import tls from 'node:tls';
import http from 'node:http';
import https from 'node:https';
export interface WebServerAccessControl {
    /** Access-Control-Allow-Headers */
    accessControlAllowHeaders?: string;
    /** Access-Control-Allow-Methods */
    accessControlAllowMethods?: string;
    /** Access-Control-Allow-Origin */
    accessControlAllowOrigin?: string;
    /** Access-Control-Expose-Headers */
    accessControlExposeHeaders?: string;
    /** Access-Control-Request-Headers */
    accessControlRequestHeaders?: string;
    /** Access-Control-Request-Method */
    accessControlRequestMethod?: string;
    /** Access-Control-Allow-Credentials */
    accessControlAllowCredentials?: boolean;
}
interface WebServerOptions {
    /** the ioBroker adapter */
    adapter: ioBroker.Adapter;
    app: http.RequestListener;
    /** if https should be used */
    secure: boolean | undefined;
    /** access control options */
    accessControl?: WebServerAccessControl;
}
interface Certificates {
    /** public certificate */
    key: string;
    /** private certificate */
    cert: string;
    /** chained certificate */
    ca?: string;
}
export declare class WebServer {
    private server;
    private readonly adapter;
    private readonly secure;
    private app;
    private originalApp;
    private readonly certManager;
    private readonly accessControl;
    constructor(options: WebServerOptions);
    private initAccessControl;
    /**
     * Initialize new https/http server, according to configuration, it will be present on `this.server`
     */
    init(): Promise<http.Server | https.Server>;
    /**
     * Build secure context from certificate collections
     *
     * @param collections the certificate collections
     */
    private buildSecureContexts;
    /**
     * Get the custom certificates as text
     */
    getCustomCertificates(): Promise<Certificates | null>;
    /**
     * Get the custom certificates context
     */
    getCustomCertificatesContext(): Promise<tls.SecureContext | null>;
}
export {};
