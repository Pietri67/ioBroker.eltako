{
  "version": 3,
  "sources": ["../../../../src/lib/common/zipFiles.ts"],
  "sourcesContent": ["import { tools } from '@iobroker/js-controller-common';\nimport JSZip from 'jszip';\nimport type { Client as ObjectsClient } from '@iobroker/db-objects-redis';\n\nfunction _getAllFilesInDir(\n    objects: ObjectsClient,\n    id: string,\n    name: string,\n    options: any,\n    callback: (errs: null | string[], res: string[]) => void,\n    result?: string[],\n): void {\n    objects.readDir(id, name, options, (err, files) => {\n        result = result || [];\n\n        let count = 0;\n        const errors: string[] = [];\n        if (files) {\n            for (const file of files) {\n                if (file.isDir) {\n                    count++;\n                    _getAllFilesInDir(\n                        objects,\n                        id,\n                        `${name}/${file.file}`,\n                        options,\n                        (errs, _result) => {\n                            errs && errors.push(...errs);\n                            if (!--count) {\n                                callback(errors.length ? errors : null, _result);\n                            }\n                        },\n                        result,\n                    );\n                } else {\n                    result.push(`${name}/${file.file}`);\n                }\n            }\n        }\n\n        if (!count) {\n            callback(null, result);\n        }\n    });\n}\n\nfunction _addFile(\n    objects: ObjectsClient,\n    id: string,\n    name: string,\n    options: any,\n    zip: JSZip,\n    callback: (err: Error | null | undefined) => void,\n): void {\n    objects.readFile(id, name, options, (err, data, _mime) => {\n        if (err) {\n            console.log(err);\n            callback(new Error(`Cannot read file \"${name}\": ${err.message}`));\n        } else {\n            // if handler installed\n            if (options.stringify) {\n                try {\n                    data = options.stringify(name, data, options ? options.settings : null);\n                } catch (e) {\n                    console.error(`Cannot stringify file \"${name}\": ${e.message}`);\n                    if (!err) {\n                        err = new Error(`Cannot stringify file \"${name}\": ${e.message}`);\n                    }\n                }\n            }\n            const parts = name.split('/');\n            if (parts.length > 1) {\n                parts.shift();\n                name = parts.join('/');\n            }\n\n            zip.file(name, data!);\n            setImmediate(() => callback(err));\n        }\n    });\n}\n\n// pack all files as zip and send it back\nexport async function readDirAsZip(\n    objects: ObjectsClient,\n    id: string,\n    name: string,\n    options: any,\n    callback: (err?: Error | null, base64?: string) => void,\n): Promise<void> {\n    if (typeof options === 'function') {\n        callback = options;\n        options = null;\n    }\n    if (name[0] === '/') {\n        name = name.substring(1);\n    }\n    options = options || {};\n    let adapter = id;\n    if (adapter.includes('.')) {\n        adapter = id.split('.')[0]!;\n    }\n\n    // try to load processor of adapter\n    try {\n        options.stringify = (await import(`${tools.appName.toLowerCase()}.${adapter}/lib/convert.js`)).stringify;\n    } catch {\n        // OK\n    }\n\n    _getAllFilesInDir(objects, id, name, options, (errs, files) => {\n        let count = 0;\n        if (files) {\n            const zip = new JSZip();\n            for (const file of files) {\n                count++;\n                _addFile(objects, id, file, options, zip, async err => {\n                    if (!--count) {\n                        try {\n                            const base64 = await zip.generateAsync({ type: 'base64' });\n                            callback(err, base64);\n                        } catch (e) {\n                            callback(e.message);\n                        }\n                    }\n                });\n            }\n        }\n\n        if (!count) {\n            callback(errs?.length ? new Error(errs.join(', ')) : null);\n        }\n    });\n}\n\ninterface CheckDirOptions {\n    objects: ObjectsClient;\n    id: string;\n    root: string;\n    parts: string[];\n    options: any;\n}\n\n/**\n * Check that directory exists recursive\n *\n * @param _options directory information and objects db\n */\nasync function _checkDir(_options: CheckDirOptions): Promise<void> {\n    const { parts, id, options, objects } = _options;\n    let { root } = _options;\n\n    if (!parts?.length) {\n        return;\n    }\n\n    root += `/${parts.shift()}`;\n\n    try {\n        await objects.readDirAsync(id, root, options);\n    } catch (e) {\n        if (e.message === tools.ERRORS.ERROR_NOT_FOUND) {\n            await objects.mkdirAsync(id, root, options);\n        }\n    }\n\n    return _checkDir({ id, objects, options, root, parts });\n}\n\nasync function _writeOneFile(\n    objects: ObjectsClient,\n    zip: JSZip,\n    id: string,\n    name: string,\n    filename: string,\n    options: any,\n): Promise<void> {\n    const zipFile = zip.files[filename];\n\n    if (!zipFile) {\n        throw new Error(`Cannot write file \"${filename}\", because JSZip instance is incomplete`);\n    }\n\n    let data = await zipFile.async('nodebuffer');\n\n    if (options.parse) {\n        data = options.parse(name, filename, data, options ? options.settings : null);\n    }\n    const fName = name + filename;\n    const parts = fName.split('/');\n    parts.pop();\n\n    await _checkDir({ objects, id, root: '', parts, options });\n    return objects.writeFileAsync(id, name + filename, data, options);\n}\n\nexport async function writeDirAsZip(\n    objects: ObjectsClient,\n    id: string,\n    name: string,\n    data: Buffer,\n    options: any,\n): Promise<void> {\n    const zip = new JSZip();\n\n    options = options || {};\n\n    let adapter = id;\n    if (adapter.includes('.')) {\n        adapter = id.split('.')[0]!;\n    }\n\n    // try to load processor of adapter\n    try {\n        options.parse = (await import(`${tools.appName.toLowerCase()}.${adapter}/lib/convert.js`)).parse;\n    } catch {\n        // OK\n    }\n\n    await zip.loadAsync(data);\n    const errors = [];\n    if (name[name.length - 1] !== '/') {\n        name += '/';\n    }\n    for (const filename of Object.keys(zip.files)) {\n        if (!filename || filename[filename.length - 1] === '/') {\n            continue;\n        }\n        try {\n            await _writeOneFile(objects, zip, id, name, filename, options);\n        } catch (e) {\n            errors.push(`Cannot write file \"${filename}\": ${e.toString()}`);\n        }\n    }\n    if (errors.length) {\n        throw new Error(errors.join(', '));\n    }\n}\n\n// pack all files as zip and send it back\nexport async function readObjectsAsZip(\n    objects: ObjectsClient,\n    rootId: string,\n    adapter: string,\n    options: any = {},\n): Promise<string> {\n    if (adapter) {\n        // try to load processor of adapter\n        try {\n            options.stringify = (await import(`${tools.appName.toLowerCase()}.${adapter}/lib/convert.js`)).stringify;\n        } catch {\n            // OK\n        }\n    }\n\n    const keys = await objects.getKeysAsync(`${rootId}.*`, options);\n    if (!keys) {\n        throw new Error('No matching keys found');\n    }\n\n    const objs = await objects.getObjectsAsync(keys, options);\n    const zip = new JSZip();\n\n    for (const obj of objs) {\n        const id = obj._id;\n\n        let data: Record<string, any> = { id, data: obj };\n\n        if (options.stringify) {\n            try {\n                data = options.stringify(data, options ? options.settings : null);\n            } catch {\n                data.id = `${id.replace(/\\./g, '/').substring(rootId.length + 1)}.json`;\n            }\n        } else {\n            data.id = `${id.replace(/\\./g, '/').substring(rootId.length + 1)}.json`;\n        }\n        if (typeof data.data === 'object') {\n            data.data = JSON.stringify(data.data, null, 2);\n        }\n\n        zip.file(data.id, data.data);\n    }\n\n    const base64 = await zip.generateAsync({ type: 'base64' });\n    return base64;\n}\n\nasync function _writeOneObject(\n    objects: ObjectsClient,\n    zip: JSZip,\n    rootId: string,\n    filename: string,\n    options: any,\n): Promise<void> {\n    const zipFile = zip.files[filename];\n\n    if (!zipFile) {\n        throw new Error(`Cannot write file \"${filename}\", because JSZip instance is incomplete`);\n    }\n\n    const bufferData = await zipFile.async('nodebuffer');\n    let data: Record<string, any> = { data: bufferData.toString(), id: filename };\n    if (options.parse) {\n        try {\n            data = options.parse(data, options ? options.settings : null);\n        } catch (e) {\n            throw new Error(`Cannot custom parse \"${data.id}\": ${e}`);\n        }\n    } else {\n        data.id = (rootId ? `${rootId}.` : '') + data.id.replace(/\\//g, '.').replace(/\\.json$/, '');\n    }\n    if (data && typeof data.data !== 'object') {\n        try {\n            data.data = JSON.parse(data.data);\n        } catch (e) {\n            throw new Error(`Cannot parse \"${data.id}\": ${e.message}`);\n        }\n    }\n    if (data && data.id && data.data) {\n        options.ts = new Date().getTime();\n        options.from = `system.host.${tools.getHostName()}.cli`;\n        await objects.setObject(data.id, data.data, options);\n        return;\n    }\n\n    if (data?.error) {\n        throw data.error;\n    }\n}\n\nexport async function writeObjectsAsZip(\n    objects: ObjectsClient,\n    rootId: string,\n    adapter: string,\n    data: Buffer,\n    options: any,\n    callback: (err?: Error | null) => void,\n): Promise<void> {\n    options = options || {};\n\n    if (adapter) {\n        // try to load processor of adapter\n        try {\n            options.parse = (await import(`${tools.appName.toLowerCase()}.${adapter}/lib/convert.js`)).parse;\n        } catch {\n            // OK\n        }\n    }\n\n    const zip = new JSZip();\n    const error: string[] = [];\n\n    try {\n        await zip.loadAsync(data);\n        for (const filename of Object.keys(zip.files)) {\n            if (filename[filename.length - 1] === '/') {\n                continue;\n            }\n\n            try {\n                await _writeOneObject(objects, zip, rootId, filename, options);\n            } catch (e) {\n                error.push(e.toString());\n            }\n        }\n    } catch (e) {\n        callback(e.toString());\n        return;\n    }\n\n    callback(error.length ? new Error(error.join(', ')) : null);\n}\n"],
  "mappings": "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",
  "names": ["JSZip"]
}
