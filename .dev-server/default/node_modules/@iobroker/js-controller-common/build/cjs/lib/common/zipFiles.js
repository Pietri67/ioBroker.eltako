"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var zipFiles_exports = {};
__export(zipFiles_exports, {
  readDirAsZip: () => readDirAsZip,
  readObjectsAsZip: () => readObjectsAsZip,
  writeDirAsZip: () => writeDirAsZip,
  writeObjectsAsZip: () => writeObjectsAsZip
});
module.exports = __toCommonJS(zipFiles_exports);
var import_js_controller_common = require("@iobroker/js-controller-common");
var import_jszip = __toESM(require("jszip"), 1);
function _getAllFilesInDir(objects, id, name, options, callback, result) {
  objects.readDir(id, name, options, (err, files) => {
    result = result || [];
    let count = 0;
    const errors = [];
    if (files) {
      for (const file of files) {
        if (file.isDir) {
          count++;
          _getAllFilesInDir(objects, id, `${name}/${file.file}`, options, (errs, _result) => {
            errs && errors.push(...errs);
            if (!--count) {
              callback(errors.length ? errors : null, _result);
            }
          }, result);
        } else {
          result.push(`${name}/${file.file}`);
        }
      }
    }
    if (!count) {
      callback(null, result);
    }
  });
}
function _addFile(objects, id, name, options, zip, callback) {
  objects.readFile(id, name, options, (err, data, _mime) => {
    if (err) {
      console.log(err);
      callback(new Error(`Cannot read file "${name}": ${err.message}`));
    } else {
      if (options.stringify) {
        try {
          data = options.stringify(name, data, options ? options.settings : null);
        } catch (e) {
          console.error(`Cannot stringify file "${name}": ${e.message}`);
          if (!err) {
            err = new Error(`Cannot stringify file "${name}": ${e.message}`);
          }
        }
      }
      const parts = name.split("/");
      if (parts.length > 1) {
        parts.shift();
        name = parts.join("/");
      }
      zip.file(name, data);
      setImmediate(() => callback(err));
    }
  });
}
async function readDirAsZip(objects, id, name, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  if (name[0] === "/") {
    name = name.substring(1);
  }
  options = options || {};
  let adapter = id;
  if (adapter.includes(".")) {
    adapter = id.split(".")[0];
  }
  try {
    options.stringify = (await import(`${import_js_controller_common.tools.appName.toLowerCase()}.${adapter}/lib/convert.js`)).stringify;
  } catch {
  }
  _getAllFilesInDir(objects, id, name, options, (errs, files) => {
    let count = 0;
    if (files) {
      const zip = new import_jszip.default();
      for (const file of files) {
        count++;
        _addFile(objects, id, file, options, zip, async (err) => {
          if (!--count) {
            try {
              const base64 = await zip.generateAsync({ type: "base64" });
              callback(err, base64);
            } catch (e) {
              callback(e.message);
            }
          }
        });
      }
    }
    if (!count) {
      callback(errs?.length ? new Error(errs.join(", ")) : null);
    }
  });
}
async function _checkDir(_options) {
  const { parts, id, options, objects } = _options;
  let { root } = _options;
  if (!parts?.length) {
    return;
  }
  root += `/${parts.shift()}`;
  try {
    await objects.readDirAsync(id, root, options);
  } catch (e) {
    if (e.message === import_js_controller_common.tools.ERRORS.ERROR_NOT_FOUND) {
      await objects.mkdirAsync(id, root, options);
    }
  }
  return _checkDir({ id, objects, options, root, parts });
}
async function _writeOneFile(objects, zip, id, name, filename, options) {
  const zipFile = zip.files[filename];
  if (!zipFile) {
    throw new Error(`Cannot write file "${filename}", because JSZip instance is incomplete`);
  }
  let data = await zipFile.async("nodebuffer");
  if (options.parse) {
    data = options.parse(name, filename, data, options ? options.settings : null);
  }
  const fName = name + filename;
  const parts = fName.split("/");
  parts.pop();
  await _checkDir({ objects, id, root: "", parts, options });
  return objects.writeFileAsync(id, name + filename, data, options);
}
async function writeDirAsZip(objects, id, name, data, options) {
  const zip = new import_jszip.default();
  options = options || {};
  let adapter = id;
  if (adapter.includes(".")) {
    adapter = id.split(".")[0];
  }
  try {
    options.parse = (await import(`${import_js_controller_common.tools.appName.toLowerCase()}.${adapter}/lib/convert.js`)).parse;
  } catch {
  }
  await zip.loadAsync(data);
  const errors = [];
  if (name[name.length - 1] !== "/") {
    name += "/";
  }
  for (const filename of Object.keys(zip.files)) {
    if (!filename || filename[filename.length - 1] === "/") {
      continue;
    }
    try {
      await _writeOneFile(objects, zip, id, name, filename, options);
    } catch (e) {
      errors.push(`Cannot write file "${filename}": ${e.toString()}`);
    }
  }
  if (errors.length) {
    throw new Error(errors.join(", "));
  }
}
async function readObjectsAsZip(objects, rootId, adapter, options = {}) {
  if (adapter) {
    try {
      options.stringify = (await import(`${import_js_controller_common.tools.appName.toLowerCase()}.${adapter}/lib/convert.js`)).stringify;
    } catch {
    }
  }
  const keys = await objects.getKeysAsync(`${rootId}.*`, options);
  if (!keys) {
    throw new Error("No matching keys found");
  }
  const objs = await objects.getObjectsAsync(keys, options);
  const zip = new import_jszip.default();
  for (const obj of objs) {
    const id = obj._id;
    let data = { id, data: obj };
    if (options.stringify) {
      try {
        data = options.stringify(data, options ? options.settings : null);
      } catch {
        data.id = `${id.replace(/\./g, "/").substring(rootId.length + 1)}.json`;
      }
    } else {
      data.id = `${id.replace(/\./g, "/").substring(rootId.length + 1)}.json`;
    }
    if (typeof data.data === "object") {
      data.data = JSON.stringify(data.data, null, 2);
    }
    zip.file(data.id, data.data);
  }
  const base64 = await zip.generateAsync({ type: "base64" });
  return base64;
}
async function _writeOneObject(objects, zip, rootId, filename, options) {
  const zipFile = zip.files[filename];
  if (!zipFile) {
    throw new Error(`Cannot write file "${filename}", because JSZip instance is incomplete`);
  }
  const bufferData = await zipFile.async("nodebuffer");
  let data = { data: bufferData.toString(), id: filename };
  if (options.parse) {
    try {
      data = options.parse(data, options ? options.settings : null);
    } catch (e) {
      throw new Error(`Cannot custom parse "${data.id}": ${e}`);
    }
  } else {
    data.id = (rootId ? `${rootId}.` : "") + data.id.replace(/\//g, ".").replace(/\.json$/, "");
  }
  if (data && typeof data.data !== "object") {
    try {
      data.data = JSON.parse(data.data);
    } catch (e) {
      throw new Error(`Cannot parse "${data.id}": ${e.message}`);
    }
  }
  if (data && data.id && data.data) {
    options.ts = (/* @__PURE__ */ new Date()).getTime();
    options.from = `system.host.${import_js_controller_common.tools.getHostName()}.cli`;
    await objects.setObject(data.id, data.data, options);
    return;
  }
  if (data?.error) {
    throw data.error;
  }
}
async function writeObjectsAsZip(objects, rootId, adapter, data, options, callback) {
  options = options || {};
  if (adapter) {
    try {
      options.parse = (await import(`${import_js_controller_common.tools.appName.toLowerCase()}.${adapter}/lib/convert.js`)).parse;
    } catch {
    }
  }
  const zip = new import_jszip.default();
  const error = [];
  try {
    await zip.loadAsync(data);
    for (const filename of Object.keys(zip.files)) {
      if (filename[filename.length - 1] === "/") {
        continue;
      }
      try {
        await _writeOneObject(objects, zip, rootId, filename, options);
      } catch (e) {
        error.push(e.toString());
      }
    }
  } catch (e) {
    callback(e.toString());
    return;
  }
  callback(error.length ? new Error(error.join(", ")) : null);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  readDirAsZip,
  readObjectsAsZip,
  writeDirAsZip,
  writeObjectsAsZip
});
//# sourceMappingURL=zipFiles.js.map
