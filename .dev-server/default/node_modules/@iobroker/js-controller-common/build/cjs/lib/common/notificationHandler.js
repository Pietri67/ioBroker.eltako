"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var notificationHandler_exports = {};
__export(notificationHandler_exports, {
  NotificationHandler: () => NotificationHandler
});
module.exports = __toCommonJS(notificationHandler_exports);
var import_fs_extra = __toESM(require("fs-extra"), 1);
var import_js_controller_common_db = require("@iobroker/js-controller-common-db");
var import_node_path = __toESM(require("node:path"), 1);
class NotificationHandler {
  states;
  objects;
  log;
  currentNotifications = {};
  // default data dir is relative to controllerDir
  dataDir = import_node_path.default.join(import_js_controller_common_db.tools.getControllerDir(), import_js_controller_common_db.tools.getDefaultDataDir());
  setup = {};
  logPrefix;
  host;
  /**
   * Creates a new instance of the notification handler class
   *
   * @param settings settings to configure the handler instance
   */
  constructor(settings) {
    this.states = settings.states;
    this.objects = settings.objects;
    this.log = settings.log;
    this.logPrefix = settings.logPrefix;
    this.host = settings.host;
    this._loadNotifications();
  }
  /**
   * Get all adapter instances on this host and store their notifications config - and clears up removed instances notifications - should be called once after init
   */
  async getSetupOfAllAdaptersFromHost() {
    let obj;
    try {
      obj = await this.objects.getObject(`system.host.${this.host}.notifications`);
    } catch {
    }
    if (!obj) {
      try {
        await this.objects.setObject(`system.host.${this.host}.notifications`, {
          type: "folder",
          common: {
            name: {
              en: "Notifications",
              de: "Benachrichtigungen",
              ru: "\u0423\u0432\u0435\u0434\u043E\u043C\u043B\u0435\u043D\u0438\u044F",
              pt: "Notifica\xE7\xF5es",
              nl: "Meldingen",
              fr: "Notifications",
              it: "Notifiche",
              es: "Notificaciones",
              pl: "Powiadomienia",
              uk: "\u0421\u043F\u043E\u0432\u0456\u0449\u0435\u043D\u043D\u044F",
              "zh-cn": "\u901A\u77E5\u4E8B\u9879"
            }
          },
          native: {}
        });
      } catch (e) {
        this.log.error(`${this.logPrefix} Could not create notifications object: ${e.message}`);
      }
    }
    const instancesOnHost = [];
    try {
      const res = await this.objects.getObjectViewAsync("system", "instance", {
        startkey: "system.adapter.",
        endkey: "system.adapter.\u9999"
      });
      for (const entry of res.rows) {
        if (entry.value.notifications) {
          await this.addConfig(entry.value.notifications);
        }
        if (entry.value.common && entry.value.common.host === this.host) {
          instancesOnHost.push(entry.id);
        }
      }
    } catch (e) {
      throw new Error(`Could not get notifications setup from instances: ${e.message}`);
    }
    for (const notificationsCategory of Object.values(this.currentNotifications)) {
      for (const instancesInfo of Object.values(notificationsCategory)) {
        for (const instance of Object.keys(instancesInfo)) {
          if (!instancesOnHost.includes(instance) && instance !== `system.host.${this.host}`) {
            this.log.info(`${this.logPrefix} Instance ${instance} removed from host, clear notifications`);
            await this.clearNotifications(null, null, instance);
          }
        }
      }
    }
    await this._updateScopeStates();
  }
  /**
   * Add a new category to the given scope with a provided optional list of regex
   *
   * @param notifications - Array with notifications
   */
  async addConfig(notifications) {
    if (Array.isArray(notifications)) {
      for (const scopeObj of notifications) {
        let obj;
        try {
          obj = await this.objects.getObject(`system.host.${this.host}.notifications.${scopeObj.scope}`);
        } catch {
        }
        if (!obj) {
          try {
            await this.objects.setObject(`system.host.${this.host}.notifications.${scopeObj.scope}`, {
              type: "state",
              common: {
                type: "object",
                role: "value",
                read: true,
                write: false,
                name: scopeObj.name,
                desc: scopeObj.description
              },
              native: {}
            });
          } catch (e) {
            this.log.error(`${this.logPrefix} Could not create notifications object for scope "${scopeObj.scope}": ${e.message}`);
          }
        }
        if (Array.isArray(scopeObj.categories) && scopeObj.categories.length) {
          const setupScope = this.setup[scopeObj.scope] || {
            name: scopeObj.name,
            description: scopeObj.description,
            categories: {}
          };
          this.setup[scopeObj.scope] = setupScope;
          for (const categoryObj of scopeObj.categories) {
            const setupCategory = setupScope.categories[categoryObj.category] || {
              regex: [],
              limit: categoryObj.limit,
              name: categoryObj.name,
              severity: categoryObj.severity,
              description: categoryObj.description
            };
            setupScope.categories[categoryObj.category] = setupCategory;
            try {
              let regex = [];
              if (Array.isArray(categoryObj.regex)) {
                for (const regexString of categoryObj.regex) {
                  regex.push(new RegExp(regexString));
                }
              } else if (typeof categoryObj.regex === "string") {
                regex = [new RegExp(categoryObj.regex)];
              }
              setupCategory.regex = regex;
            } catch (e) {
              this.log.error(`${this.logPrefix} Cannot store regex "${JSON.stringify(categoryObj.regex)}" for scope "${scopeObj.scope}", category "${categoryObj.category}": ${e.message}`);
            }
          }
        }
      }
    }
  }
  /**
   * Add a message to the scope and category
   *
   * @param options The scope, category, message, instance and contextData information
   */
  async addMessage(options) {
    const { message, scope, category, contextData } = options;
    let { instance } = options;
    if (typeof instance !== "string") {
      this.log.error(`${this.logPrefix} [addMessage] Instance has to be of type "string", got "${typeof instance}"`);
      return;
    }
    if (!instance.startsWith("system.adapter.") && !instance.startsWith("system.host.")) {
      instance = `system.adapter.${instance}`;
    }
    let stateVal = {};
    try {
      const state = await this.states.getStateAsync(`system.host.${this.host}.notifications.${scope}`);
      stateVal = state?.val ? JSON.parse(state.val) : {};
    } catch (e) {
      this.log.error(`${this.logPrefix} Could not get state for scope "${scope}": ${e.message}`);
    }
    let categories = [category];
    if (!category) {
      categories = this._parseText(scope, message);
    }
    const currentScopeObj = this.currentNotifications[scope] || {};
    this.currentNotifications[scope] = currentScopeObj;
    for (const _category of categories) {
      if (!_category) {
        continue;
      }
      const currentCategoryObj = currentScopeObj[_category] || {};
      currentScopeObj[_category] = currentCategoryObj;
      const currentInstances = currentCategoryObj[instance] || [];
      currentCategoryObj[instance] = currentInstances;
      const setupCategory = this.setup[scope]?.categories[_category];
      if (!setupCategory) {
        this.log.warn(`${this.logPrefix} No configuration found for scope "${scope}" and category "${_category}"`);
        continue;
      }
      while (setupCategory.limit < currentInstances.length + 1) {
        currentInstances.pop();
      }
      currentInstances.unshift({ message, ts: Date.now(), contextData });
    }
    if (import_js_controller_common_db.tools.isObject(this.currentNotifications[scope])) {
      for (const [categoryName, category2] of Object.entries(currentScopeObj)) {
        const categoryCounter = Object.keys(category2).length;
        stateVal[categoryName] = { count: categoryCounter };
      }
    }
    try {
      await this.states.setState(`system.host.${this.host}.notifications.${scope}`, {
        val: JSON.stringify(stateVal),
        ack: true
      });
    } catch (e) {
      this.log.error(`${this.logPrefix} Could not set notifications state for scope "${scope}": ${e.message}`);
    }
  }
  /**
   * Updates all scope states by current notifications in RAM
   */
  async _updateScopeStates() {
    for (const [scope, scopeObj] of Object.entries(this.currentNotifications)) {
      const stateVal = {};
      for (const [category, categoryObj] of Object.entries(scopeObj)) {
        const catCounter = Object.keys(categoryObj).length;
        stateVal[category] = { count: catCounter };
      }
      try {
        await this.states.setState(`system.host.${this.host}.notifications.${scope}`, {
          val: JSON.stringify(stateVal),
          ack: true
        });
      } catch (e) {
        this.log.error(`${this.logPrefix} Could not set notifications state for scope "${scope}": ${e.message}`);
      }
    }
  }
  /**
   * Check the given message against all regular expressions of the given scope
   *
   * @param scope - scope of the message
   * @param message - message to check
   */
  _parseText(scope, message) {
    const categories = [];
    const scopeObj = this.setup[scope];
    if (!scopeObj) {
      return categories;
    }
    for (const [categoryId, categoryObj] of Object.entries(scopeObj.categories)) {
      for (const regex of categoryObj.regex) {
        if (regex.test(message)) {
          categories.push(categoryId);
          break;
        }
      }
    }
    return categories;
  }
  /**
   * Load notifications from a file
   */
  _loadNotifications() {
    try {
      this.currentNotifications = import_fs_extra.default.readJSONSync(import_node_path.default.join(this.dataDir, "notifications.json"));
    } catch (e) {
      this.log.debug(`${this.logPrefix} Could not read notifications.json: ${e.message}`);
    }
  }
  /**
   * Save current notifications to file
   */
  storeNotifications() {
    try {
      import_fs_extra.default.writeJSONSync(import_node_path.default.join(this.dataDir, "notifications.json"), this.currentNotifications);
    } catch (e) {
      this.log.error(`${this.logPrefix} Could not write notifications.json: ${e.message}`);
    }
  }
  /**
   * Returns the stored notifications matching the filters with description and name
   *
   * @param scopeFilter - scope of notifications
   * @param categoryFilter - category of notifications
   * @param instanceFilter - instance of notifications
   */
  getFilteredInformation(scopeFilter, categoryFilter, instanceFilter) {
    const res = {};
    for (const [scope, currentNotification] of Object.entries(this.currentNotifications)) {
      if (scopeFilter && scopeFilter !== scope) {
        continue;
      }
      const scopeObj = this.setup[scope];
      if (!scopeObj) {
        continue;
      }
      const scopeResult = {
        categories: {},
        description: scopeObj.description,
        name: scopeObj.name
      };
      res[scope] = scopeResult;
      for (const [category, currentCategoryObj] of Object.entries(currentNotification)) {
        if (categoryFilter && categoryFilter !== category) {
          continue;
        }
        const categoryObj = scopeObj.categories[category];
        if (!categoryObj) {
          continue;
        }
        const resultCategories = {
          instances: {},
          description: categoryObj.description,
          name: categoryObj.name,
          severity: categoryObj.severity
        };
        scopeResult.categories[category] = resultCategories;
        for (const [instance, instanceObj] of Object.entries(currentCategoryObj)) {
          if (instanceFilter && instanceFilter !== instance) {
            continue;
          }
          resultCategories.instances[instance] = {
            messages: instanceObj
          };
        }
      }
    }
    return res;
  }
  /**
   * Clears the stored notifications matching the filters
   *
   * @param scopeFilter - scope of notifications
   * @param categoryFilter - category of notifications
   * @param instanceFilter - instance of notifications
   */
  async clearNotifications(scopeFilter, categoryFilter, instanceFilter) {
    for (const scope of Object.keys(this.currentNotifications)) {
      const currentNotificationScope = this.currentNotifications[scope];
      if (!currentNotificationScope) {
        delete this.currentNotifications[scope];
        continue;
      }
      if (scopeFilter && scopeFilter !== scope) {
        continue;
      }
      let stateVal = {};
      try {
        const state = await this.states.getStateAsync(`system.host.${this.host}.notifications.${scope}`);
        stateVal = state && state.val ? JSON.parse(state.val) : {};
      } catch (e) {
        this.log.error(`${this.logPrefix} Could not get state for scope "${scope}": ${e.message}`);
      }
      for (const [category, categoryObj] of Object.entries(currentNotificationScope)) {
        if (categoryFilter && categoryFilter !== category) {
          continue;
        }
        let categoryCounter = 0;
        for (const instance of Object.keys(categoryObj)) {
          if (instanceFilter && instanceFilter !== instance) {
            categoryCounter += 1;
            continue;
          }
          delete categoryObj[instance];
        }
        stateVal[category] = { count: categoryCounter };
        if (!Object.keys(categoryObj).length) {
          delete currentNotificationScope[category];
          delete stateVal[category];
        }
      }
      if (!Object.keys(currentNotificationScope).length) {
        delete this.currentNotifications[scope];
      }
      try {
        await this.states.setState(`system.host.${this.host}.notifications.${scope}`, {
          val: JSON.stringify(stateVal),
          ack: true
        });
      } catch (e) {
        this.log.error(`${this.logPrefix} Could not set notifications state for scope "${scope}": ${e.message}`);
      }
    }
  }
  /**
   * Check if given scope exists in config
   *
   * @param scope - scope to be checked for
   */
  scopeExists(scope) {
    return !!this.setup[scope];
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  NotificationHandler
});
//# sourceMappingURL=notificationHandler.js.map
