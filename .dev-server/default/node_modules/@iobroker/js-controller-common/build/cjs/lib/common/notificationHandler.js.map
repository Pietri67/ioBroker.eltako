{
  "version": 3,
  "sources": ["../../../../src/lib/common/notificationHandler.ts"],
  "sourcesContent": ["/**\n * Notification handler class\n *\n *  2021-2024 foxriver76 <moritz.heusinger@gmail.com>\n */\n\nimport fs from 'fs-extra';\nimport { tools } from '@iobroker/js-controller-common-db';\nimport path from 'node:path';\nimport type { Client as StatesInRedisClient } from '@iobroker/db-states-redis';\nimport type { Client as ObjectsInRedisClient } from '@iobroker/db-objects-redis';\nimport type Winston from 'winston';\n\ntype MultilingualObject = Exclude<ioBroker.StringOrTranslated, string>;\n\n/** Settings to configure an instance of NotificationHandler */\nexport interface NotificationHandlerSettings {\n    /** Name of the host (not id - hence, without `system.host.` prefix) */\n    host: string;\n    /** States DB instance */\n    states: StatesInRedisClient;\n    /** Objects DB instance */\n    objects: ObjectsInRedisClient;\n    /** Logger instance */\n    log: Winston.Logger | Console;\n    /** Prefix for the log messages */\n    logPrefix: string;\n}\n\n/** A notification config entry represents the top level of the notification structure */\nexport interface NotificationsConfigEntry {\n    /** e.g. system */\n    scope: string;\n    /** multilingual name */\n    name: MultilingualObject;\n    /** multilingual description */\n    description: MultilingualObject;\n    /** The notification categories inside this scope */\n    categories: CategoryConfigEntry[];\n}\n\nexport type Severity = 'info' | 'notify' | 'alert';\n\n/** A notification category entry represents one of the categories of a scope */\nexport interface CategoryConfigEntry {\n    /** Id of the category */\n    category: string;\n    /** Name of the category */\n    name: MultilingualObject;\n    /** Allows defining the severity of the notification with `info` being the lowest, `notify` representing middle priority, `alert` representing high priority and often containing critical information */\n    severity: Severity;\n    /** Description of the category */\n    description: MultilingualObject;\n    /** Regex where `console.error` output is parsed against to check if a notification of this category should be generated */\n    regex: string[];\n    /** Restrict the maximum number of messages for this category */\n    limit: number;\n}\n\ninterface NotificationMessageObject {\n    message: string;\n    ts: number;\n    contextData?: ioBroker.NotificationContextData;\n}\n\ninterface NotificationsCategory {\n    [category: string]: {\n        [instance: string]: NotificationMessageObject[];\n    };\n}\n\ninterface NotificationsObject {\n    [scope: string]: NotificationsCategory;\n}\n\ninterface FilteredNotificationCategory {\n    description: MultilingualObject;\n    name: MultilingualObject;\n    severity: Severity;\n    instances: {\n        [instance: string]: {\n            messages: NotificationMessageObject[];\n        };\n    };\n}\n\ninterface FilteredNotificationScope {\n    description: MultilingualObject;\n    name: MultilingualObject;\n    categories: {\n        [category: string]: FilteredNotificationCategory;\n    };\n}\n\n/** The filtered information as a response for `getFilteredInformation` */\nexport interface FilteredNotificationInformation {\n    [scope: string]: FilteredNotificationScope;\n}\n\ninterface NotificationSetupCategory {\n    regex: RegExp[];\n    limit: number;\n    name: MultilingualObject;\n    severity: Severity;\n    description: MultilingualObject;\n}\n\ninterface NotificationSetupObject {\n    [scope: string]: {\n        name: MultilingualObject;\n        description: MultilingualObject;\n        categories: {\n            [category: string]: NotificationSetupCategory;\n        };\n    };\n}\n\ninterface ScopeStateValue {\n    [category: string]: {\n        count: number;\n    };\n}\n\ninterface AddMessageOptions {\n    /** Scope of the message */\n    scope: string;\n    /** Category of the message, if non we check against regex of scope */\n    category?: string | null;\n    /** Message to add */\n    message: string;\n    /** Instance e.g., hm-rpc.1 or hostname, if hostname it needs to be prefixed like system.host.rpi */\n    instance: string;\n    /** Additional context for the notification which can be used by notification processing adapters */\n    contextData?: ioBroker.NotificationContextData;\n}\n\n/**\n * The Notification handler class provides an interface to manage the ioBroker notification system\n */\nexport class NotificationHandler {\n    private states: StatesInRedisClient;\n    private objects: ObjectsInRedisClient;\n    private log: Winston.Logger | Console;\n    private currentNotifications: NotificationsObject = {};\n    // default data dir is relative to controllerDir\n    private readonly dataDir = path.join(tools.getControllerDir(), tools.getDefaultDataDir());\n    private readonly setup: NotificationSetupObject = {};\n    private readonly logPrefix: string;\n    private readonly host: string;\n\n    /**\n     * Creates a new instance of the notification handler class\n     *\n     * @param settings settings to configure the handler instance\n     */\n    constructor(settings: NotificationHandlerSettings) {\n        this.states = settings.states;\n        this.objects = settings.objects;\n        this.log = settings.log;\n        this.logPrefix = settings.logPrefix;\n        this.host = settings.host;\n\n        // load notifications file\n        this._loadNotifications();\n    }\n\n    /**\n     * Get all adapter instances on this host and store their notifications config - and clears up removed instances notifications - should be called once after init\n     */\n    async getSetupOfAllAdaptersFromHost(): Promise<void> {\n        // create the initial notifications object\n        let obj;\n        try {\n            obj = await this.objects.getObject(`system.host.${this.host}.notifications`);\n        } catch {\n            // ignore\n        }\n\n        if (!obj) {\n            try {\n                await this.objects.setObject(`system.host.${this.host}.notifications`, {\n                    type: 'folder',\n                    common: {\n                        name: {\n                            en: 'Notifications',\n                            de: 'Benachrichtigungen',\n                            ru: '\u0423\u0432\u0435\u0434\u043E\u043C\u043B\u0435\u043D\u0438\u044F',\n                            pt: 'Notifica\u00E7\u00F5es',\n                            nl: 'Meldingen',\n                            fr: 'Notifications',\n                            it: 'Notifiche',\n                            es: 'Notificaciones',\n                            pl: 'Powiadomienia',\n                            uk: '\u0421\u043F\u043E\u0432\u0456\u0449\u0435\u043D\u043D\u044F',\n                            'zh-cn': '\u901A\u77E5\u4E8B\u9879',\n                        },\n                    },\n                    native: {},\n                });\n            } catch (e) {\n                this.log.error(`${this.logPrefix} Could not create notifications object: ${e.message}`);\n            }\n        }\n\n        const instancesOnHost = [];\n        // get all instances\n        try {\n            const res = await this.objects.getObjectViewAsync('system', 'instance', {\n                startkey: 'system.adapter.',\n                endkey: 'system.adapter.\\u9999',\n            });\n\n            for (const entry of res.rows) {\n                // check that instance has notification settings\n                if (entry.value.notifications) {\n                    await this.addConfig(entry.value.notifications);\n                }\n\n                if (entry.value.common && entry.value.common.host === this.host) {\n                    // if it's on our current host\n                    instancesOnHost.push(entry.id);\n                }\n            }\n        } catch (e) {\n            throw new Error(`Could not get notifications setup from instances: ${e.message}`);\n        }\n\n        // now clear up all notifications that do not belong to our host anymore\n        for (const notificationsCategory of Object.values(this.currentNotifications)) {\n            for (const instancesInfo of Object.values(notificationsCategory)) {\n                for (const instance of Object.keys(instancesInfo)) {\n                    if (!instancesOnHost.includes(instance) && instance !== `system.host.${this.host}`) {\n                        // instance no longer on host\n                        this.log.info(`${this.logPrefix} Instance ${instance} removed from host, clear notifications`);\n                        await this.clearNotifications(null, null, instance);\n                    }\n                }\n            }\n        }\n\n        // now sync RAM with state\n        await this._updateScopeStates();\n    }\n\n    /**\n     * Add a new category to the given scope with a provided optional list of regex\n     *\n     * @param notifications - Array with notifications\n     */\n    async addConfig(notifications: NotificationsConfigEntry[]): Promise<void> {\n        // if valid attributes, store it\n        if (Array.isArray(notifications)) {\n            for (const scopeObj of notifications) {\n                // create the state object for each scope if non-existing\n                let obj;\n                try {\n                    obj = await this.objects.getObject(`system.host.${this.host}.notifications.${scopeObj.scope}`);\n                } catch {\n                    // ignore\n                }\n\n                if (!obj) {\n                    try {\n                        await this.objects.setObject(`system.host.${this.host}.notifications.${scopeObj.scope}`, {\n                            type: 'state',\n                            common: {\n                                type: 'object',\n                                role: 'value',\n                                read: true,\n                                write: false,\n                                name: scopeObj.name,\n                                desc: scopeObj.description,\n                            },\n                            native: {},\n                        });\n                    } catch (e) {\n                        this.log.error(\n                            `${this.logPrefix} Could not create notifications object for scope \"${scopeObj.scope}\": ${e.message}`,\n                        );\n                    }\n                }\n\n                if (Array.isArray(scopeObj.categories) && scopeObj.categories.length) {\n                    const setupScope = this.setup[scopeObj.scope] || {\n                        name: scopeObj.name,\n                        description: scopeObj.description,\n                        categories: {},\n                    };\n\n                    // only if scope has at least one category\n                    this.setup[scopeObj.scope] = setupScope;\n\n                    for (const categoryObj of scopeObj.categories) {\n                        const setupCategory = setupScope.categories[categoryObj.category] || {\n                            regex: [],\n                            limit: categoryObj.limit,\n                            name: categoryObj.name,\n                            severity: categoryObj.severity,\n                            description: categoryObj.description,\n                        };\n                        setupScope.categories[categoryObj.category] = setupCategory;\n\n                        try {\n                            let regex: RegExp[] = [];\n                            if (Array.isArray(categoryObj.regex)) {\n                                for (const regexString of categoryObj.regex) {\n                                    regex.push(new RegExp(regexString));\n                                }\n                            } else if (typeof categoryObj.regex === 'string') {\n                                // if someone passes a string, convert to a single entry array\n                                regex = [new RegExp(categoryObj.regex)];\n                            }\n\n                            setupCategory.regex = regex;\n                        } catch (e) {\n                            this.log.error(\n                                `${this.logPrefix} Cannot store regex \"${JSON.stringify(categoryObj.regex)}\" for scope \"${\n                                    scopeObj.scope\n                                }\", category \"${categoryObj.category}\": ${e.message}`,\n                            );\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Add a message to the scope and category\n     *\n     * @param options The scope, category, message, instance and contextData information\n     */\n    async addMessage(options: AddMessageOptions): Promise<void> {\n        const { message, scope, category, contextData } = options;\n        let { instance } = options;\n\n        if (typeof instance !== 'string') {\n            this.log.error(\n                `${this.logPrefix} [addMessage] Instance has to be of type \"string\", got \"${typeof instance}\"`,\n            );\n            return;\n        }\n\n        if (!instance.startsWith('system.adapter.') && !instance.startsWith('system.host.')) {\n            instance = `system.adapter.${instance}`;\n        }\n\n        // get state of the scope\n        let stateVal: ScopeStateValue = {};\n        try {\n            const state = await this.states.getStateAsync(`system.host.${this.host}.notifications.${scope}`);\n            stateVal = state?.val ? JSON.parse(state.val as string) : {};\n        } catch (e) {\n            this.log.error(`${this.logPrefix} Could not get state for scope \"${scope}\": ${e.message}`);\n        }\n\n        let categories = [category];\n\n        if (!category) {\n            // check regex - in parse text we can have multiple matches\n            categories = this._parseText(scope, message);\n        }\n\n        const currentScopeObj = this.currentNotifications[scope] || {};\n        this.currentNotifications[scope] = currentScopeObj;\n\n        for (const _category of categories) {\n            if (!_category) {\n                continue;\n            }\n\n            const currentCategoryObj = currentScopeObj[_category] || {};\n            currentScopeObj[_category] = currentCategoryObj;\n\n            // array of all messages for instance/category\n            const currentInstances = currentCategoryObj[instance] || [];\n            currentCategoryObj[instance] = currentInstances;\n\n            const setupCategory = this.setup[scope]?.categories[_category];\n\n            if (!setupCategory) {\n                // no setup for this instance/category combination found - so we have nothing to add\n                this.log.warn(\n                    `${this.logPrefix} No configuration found for scope \"${scope}\" and category \"${_category}\"`,\n                );\n                continue;\n            }\n\n            // if limit exceeded, remove last element - use while if it somehow grew too big\n            while (setupCategory.limit < currentInstances.length + 1) {\n                currentInstances.pop();\n            }\n\n            // add a new element at the beginning\n            currentInstances.unshift({ message, ts: Date.now(), contextData });\n        }\n\n        // now count all messages of this scope - if nothing matched it can be undefined, and we can skip\n        if (tools.isObject(this.currentNotifications[scope])) {\n            for (const [categoryName, category] of Object.entries(currentScopeObj)) {\n                const categoryCounter = Object.keys(category).length;\n\n                stateVal[categoryName] = { count: categoryCounter };\n            }\n        }\n\n        // set updated scope state\n        try {\n            await this.states.setState(`system.host.${this.host}.notifications.${scope}`, {\n                val: JSON.stringify(stateVal),\n                ack: true,\n            });\n        } catch (e) {\n            this.log.error(`${this.logPrefix} Could not set notifications state for scope \"${scope}\": ${e.message}`);\n        }\n    }\n\n    /**\n     * Updates all scope states by current notifications in RAM\n     */\n    private async _updateScopeStates(): Promise<void> {\n        for (const [scope, scopeObj] of Object.entries(this.currentNotifications)) {\n            const stateVal: ScopeStateValue = {};\n\n            for (const [category, categoryObj] of Object.entries(scopeObj)) {\n                // count the number of instances with this error\n                const catCounter = Object.keys(categoryObj).length;\n                stateVal[category] = { count: catCounter };\n            }\n\n            // set updated scope state\n            try {\n                await this.states.setState(`system.host.${this.host}.notifications.${scope}`, {\n                    val: JSON.stringify(stateVal),\n                    ack: true,\n                });\n            } catch (e) {\n                this.log.error(\n                    `${this.logPrefix} Could not set notifications state for scope \"${scope}\": ${e.message}`,\n                );\n            }\n        }\n    }\n\n    /**\n     * Check the given message against all regular expressions of the given scope\n     *\n     * @param scope - scope of the message\n     * @param message - message to check\n     */\n    private _parseText(scope: string, message: string): string[] {\n        const categories: string[] = [];\n\n        const scopeObj = this.setup[scope];\n\n        if (!scopeObj) {\n            return categories;\n        }\n\n        for (const [categoryId, categoryObj] of Object.entries(scopeObj.categories)) {\n            // check all regular expressions for this category\n            for (const regex of categoryObj.regex) {\n                if (regex.test(message)) {\n                    // matching category\n                    categories.push(categoryId);\n                    // no further testing needed for this category\n                    break;\n                }\n            }\n        }\n\n        return categories;\n    }\n\n    /**\n     * Load notifications from a file\n     */\n    private _loadNotifications(): void {\n        try {\n            this.currentNotifications = fs.readJSONSync(path.join(this.dataDir, 'notifications.json'));\n        } catch (e) {\n            // at first start its normal, that we cannot read notifications, so just info\n            this.log.debug(`${this.logPrefix} Could not read notifications.json: ${e.message}`);\n        }\n    }\n\n    /**\n     * Save current notifications to file\n     */\n    storeNotifications(): void {\n        try {\n            fs.writeJSONSync(path.join(this.dataDir, 'notifications.json'), this.currentNotifications);\n        } catch (e) {\n            this.log.error(`${this.logPrefix} Could not write notifications.json: ${e.message}`);\n        }\n    }\n\n    /**\n     * Returns the stored notifications matching the filters with description and name\n     *\n     * @param scopeFilter - scope of notifications\n     * @param categoryFilter - category of notifications\n     * @param instanceFilter - instance of notifications\n     */\n    getFilteredInformation(\n        scopeFilter: string | null | undefined,\n        categoryFilter: string | null | undefined,\n        instanceFilter: string | null | undefined,\n    ): FilteredNotificationInformation {\n        const res: FilteredNotificationInformation = {};\n        for (const [scope, currentNotification] of Object.entries(this.currentNotifications)) {\n            if (scopeFilter && scopeFilter !== scope) {\n                // scope filtered out\n                continue;\n            }\n\n            const scopeObj = this.setup[scope];\n\n            if (!scopeObj) {\n                // no scope set up\n                continue;\n            }\n\n            const scopeResult: FilteredNotificationScope = {\n                categories: {},\n                description: scopeObj.description,\n                name: scopeObj.name,\n            };\n\n            res[scope] = scopeResult;\n\n            for (const [category, currentCategoryObj] of Object.entries(currentNotification)) {\n                if (categoryFilter && categoryFilter !== category) {\n                    // category filtered out\n                    continue;\n                }\n\n                const categoryObj = scopeObj.categories[category];\n\n                if (!categoryObj) {\n                    // no category set up\n                    continue;\n                }\n\n                const resultCategories: FilteredNotificationCategory = {\n                    instances: {},\n                    description: categoryObj.description,\n                    name: categoryObj.name,\n                    severity: categoryObj.severity,\n                };\n\n                scopeResult.categories[category] = resultCategories;\n\n                for (const [instance, instanceObj] of Object.entries(currentCategoryObj)) {\n                    if (instanceFilter && instanceFilter !== instance) {\n                        // instance filtered out\n                        continue;\n                    }\n\n                    resultCategories.instances[instance] = {\n                        messages: instanceObj,\n                    };\n                }\n            }\n        }\n        return res;\n    }\n\n    /**\n     * Clears the stored notifications matching the filters\n     *\n     * @param scopeFilter - scope of notifications\n     * @param categoryFilter - category of notifications\n     * @param instanceFilter - instance of notifications\n     */\n    async clearNotifications(\n        scopeFilter: string | null | undefined,\n        categoryFilter: string | null | undefined,\n        instanceFilter: string | null | undefined,\n    ): Promise<void> {\n        for (const scope of Object.keys(this.currentNotifications)) {\n            const currentNotificationScope = this.currentNotifications[scope];\n\n            if (!currentNotificationScope) {\n                delete this.currentNotifications[scope];\n                continue;\n            }\n            if (scopeFilter && scopeFilter !== scope) {\n                // skip this, because not desired to be deleted\n                continue;\n            }\n\n            let stateVal: ScopeStateValue = {};\n            try {\n                const state = await this.states.getStateAsync(`system.host.${this.host}.notifications.${scope}`);\n                stateVal = state && state.val ? JSON.parse(state.val as string) : {};\n            } catch (e) {\n                this.log.error(`${this.logPrefix} Could not get state for scope \"${scope}\": ${e.message}`);\n            }\n\n            for (const [category, categoryObj] of Object.entries(currentNotificationScope)) {\n                if (categoryFilter && categoryFilter !== category) {\n                    // category filtered out\n                    continue;\n                }\n\n                let categoryCounter = 0;\n                for (const instance of Object.keys(categoryObj)) {\n                    if (instanceFilter && instanceFilter !== instance) {\n                        // instance filtered out - message counter remains\n                        categoryCounter += 1;\n                        continue;\n                    }\n\n                    // not filtered out -> remove\n                    delete categoryObj[instance];\n                }\n\n                stateVal[category] = { count: categoryCounter };\n\n                // check if all instances of this category deleted\n                if (!Object.keys(categoryObj).length) {\n                    delete currentNotificationScope[category];\n                    delete stateVal[category];\n                }\n            }\n\n            // check if all categories of this scope deleted\n            if (!Object.keys(currentNotificationScope).length) {\n                delete this.currentNotifications[scope];\n            }\n\n            // set updated state\n            try {\n                await this.states.setState(`system.host.${this.host}.notifications.${scope}`, {\n                    val: JSON.stringify(stateVal),\n                    ack: true,\n                });\n            } catch (e) {\n                this.log.error(\n                    `${this.logPrefix} Could not set notifications state for scope \"${scope}\": ${e.message}`,\n                );\n            }\n        }\n    }\n\n    /**\n     * Check if given scope exists in config\n     *\n     * @param scope - scope to be checked for\n     */\n    scopeExists(scope: string): boolean {\n        return !!this.setup[scope];\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;AAMA,sBAAe;AACf,qCAAsB;AACtB,uBAAiB;AAmIX,MAAO,oBAAmB;EACpB;EACA;EACA;EACA,uBAA4C,CAAA;;EAEnC,UAAU,iBAAAA,QAAK,KAAK,qCAAM,iBAAgB,GAAI,qCAAM,kBAAiB,CAAE;EACvE,QAAiC,CAAA;EACjC;EACA;;;;;;EAOjB,YAAY,UAAqC;AAC7C,SAAK,SAAS,SAAS;AACvB,SAAK,UAAU,SAAS;AACxB,SAAK,MAAM,SAAS;AACpB,SAAK,YAAY,SAAS;AAC1B,SAAK,OAAO,SAAS;AAGrB,SAAK,mBAAkB;EAC3B;;;;EAKA,MAAM,gCAA6B;AAE/B,QAAI;AACJ,QAAI;AACA,YAAM,MAAM,KAAK,QAAQ,UAAU,eAAe,KAAK,IAAI,gBAAgB;IAC/E,QAAQ;IAER;AAEA,QAAI,CAAC,KAAK;AACN,UAAI;AACA,cAAM,KAAK,QAAQ,UAAU,eAAe,KAAK,IAAI,kBAAkB;UACnE,MAAM;UACN,QAAQ;YACJ,MAAM;cACF,IAAI;cACJ,IAAI;cACJ,IAAI;cACJ,IAAI;cACJ,IAAI;cACJ,IAAI;cACJ,IAAI;cACJ,IAAI;cACJ,IAAI;cACJ,IAAI;cACJ,SAAS;;;UAGjB,QAAQ,CAAA;SACX;MACL,SAAS,GAAG;AACR,aAAK,IAAI,MAAM,GAAG,KAAK,SAAS,2CAA2C,EAAE,OAAO,EAAE;MAC1F;IACJ;AAEA,UAAM,kBAAkB,CAAA;AAExB,QAAI;AACA,YAAM,MAAM,MAAM,KAAK,QAAQ,mBAAmB,UAAU,YAAY;QACpE,UAAU;QACV,QAAQ;OACX;AAED,iBAAW,SAAS,IAAI,MAAM;AAE1B,YAAI,MAAM,MAAM,eAAe;AAC3B,gBAAM,KAAK,UAAU,MAAM,MAAM,aAAa;QAClD;AAEA,YAAI,MAAM,MAAM,UAAU,MAAM,MAAM,OAAO,SAAS,KAAK,MAAM;AAE7D,0BAAgB,KAAK,MAAM,EAAE;QACjC;MACJ;IACJ,SAAS,GAAG;AACR,YAAM,IAAI,MAAM,qDAAqD,EAAE,OAAO,EAAE;IACpF;AAGA,eAAW,yBAAyB,OAAO,OAAO,KAAK,oBAAoB,GAAG;AAC1E,iBAAW,iBAAiB,OAAO,OAAO,qBAAqB,GAAG;AAC9D,mBAAW,YAAY,OAAO,KAAK,aAAa,GAAG;AAC/C,cAAI,CAAC,gBAAgB,SAAS,QAAQ,KAAK,aAAa,eAAe,KAAK,IAAI,IAAI;AAEhF,iBAAK,IAAI,KAAK,GAAG,KAAK,SAAS,aAAa,QAAQ,yCAAyC;AAC7F,kBAAM,KAAK,mBAAmB,MAAM,MAAM,QAAQ;UACtD;QACJ;MACJ;IACJ;AAGA,UAAM,KAAK,mBAAkB;EACjC;;;;;;EAOA,MAAM,UAAU,eAAyC;AAErD,QAAI,MAAM,QAAQ,aAAa,GAAG;AAC9B,iBAAW,YAAY,eAAe;AAElC,YAAI;AACJ,YAAI;AACA,gBAAM,MAAM,KAAK,QAAQ,UAAU,eAAe,KAAK,IAAI,kBAAkB,SAAS,KAAK,EAAE;QACjG,QAAQ;QAER;AAEA,YAAI,CAAC,KAAK;AACN,cAAI;AACA,kBAAM,KAAK,QAAQ,UAAU,eAAe,KAAK,IAAI,kBAAkB,SAAS,KAAK,IAAI;cACrF,MAAM;cACN,QAAQ;gBACJ,MAAM;gBACN,MAAM;gBACN,MAAM;gBACN,OAAO;gBACP,MAAM,SAAS;gBACf,MAAM,SAAS;;cAEnB,QAAQ,CAAA;aACX;UACL,SAAS,GAAG;AACR,iBAAK,IAAI,MACL,GAAG,KAAK,SAAS,qDAAqD,SAAS,KAAK,MAAM,EAAE,OAAO,EAAE;UAE7G;QACJ;AAEA,YAAI,MAAM,QAAQ,SAAS,UAAU,KAAK,SAAS,WAAW,QAAQ;AAClE,gBAAM,aAAa,KAAK,MAAM,SAAS,KAAK,KAAK;YAC7C,MAAM,SAAS;YACf,aAAa,SAAS;YACtB,YAAY,CAAA;;AAIhB,eAAK,MAAM,SAAS,KAAK,IAAI;AAE7B,qBAAW,eAAe,SAAS,YAAY;AAC3C,kBAAM,gBAAgB,WAAW,WAAW,YAAY,QAAQ,KAAK;cACjE,OAAO,CAAA;cACP,OAAO,YAAY;cACnB,MAAM,YAAY;cAClB,UAAU,YAAY;cACtB,aAAa,YAAY;;AAE7B,uBAAW,WAAW,YAAY,QAAQ,IAAI;AAE9C,gBAAI;AACA,kBAAI,QAAkB,CAAA;AACtB,kBAAI,MAAM,QAAQ,YAAY,KAAK,GAAG;AAClC,2BAAW,eAAe,YAAY,OAAO;AACzC,wBAAM,KAAK,IAAI,OAAO,WAAW,CAAC;gBACtC;cACJ,WAAW,OAAO,YAAY,UAAU,UAAU;AAE9C,wBAAQ,CAAC,IAAI,OAAO,YAAY,KAAK,CAAC;cAC1C;AAEA,4BAAc,QAAQ;YAC1B,SAAS,GAAG;AACR,mBAAK,IAAI,MACL,GAAG,KAAK,SAAS,wBAAwB,KAAK,UAAU,YAAY,KAAK,CAAC,gBACtE,SAAS,KACb,gBAAgB,YAAY,QAAQ,MAAM,EAAE,OAAO,EAAE;YAE7D;UACJ;QACJ;MACJ;IACJ;EACJ;;;;;;EAOA,MAAM,WAAW,SAA0B;AACvC,UAAM,EAAE,SAAS,OAAO,UAAU,YAAW,IAAK;AAClD,QAAI,EAAE,SAAQ,IAAK;AAEnB,QAAI,OAAO,aAAa,UAAU;AAC9B,WAAK,IAAI,MACL,GAAG,KAAK,SAAS,2DAA2D,OAAO,QAAQ,GAAG;AAElG;IACJ;AAEA,QAAI,CAAC,SAAS,WAAW,iBAAiB,KAAK,CAAC,SAAS,WAAW,cAAc,GAAG;AACjF,iBAAW,kBAAkB,QAAQ;IACzC;AAGA,QAAI,WAA4B,CAAA;AAChC,QAAI;AACA,YAAM,QAAQ,MAAM,KAAK,OAAO,cAAc,eAAe,KAAK,IAAI,kBAAkB,KAAK,EAAE;AAC/F,iBAAW,OAAO,MAAM,KAAK,MAAM,MAAM,GAAa,IAAI,CAAA;IAC9D,SAAS,GAAG;AACR,WAAK,IAAI,MAAM,GAAG,KAAK,SAAS,mCAAmC,KAAK,MAAM,EAAE,OAAO,EAAE;IAC7F;AAEA,QAAI,aAAa,CAAC,QAAQ;AAE1B,QAAI,CAAC,UAAU;AAEX,mBAAa,KAAK,WAAW,OAAO,OAAO;IAC/C;AAEA,UAAM,kBAAkB,KAAK,qBAAqB,KAAK,KAAK,CAAA;AAC5D,SAAK,qBAAqB,KAAK,IAAI;AAEnC,eAAW,aAAa,YAAY;AAChC,UAAI,CAAC,WAAW;AACZ;MACJ;AAEA,YAAM,qBAAqB,gBAAgB,SAAS,KAAK,CAAA;AACzD,sBAAgB,SAAS,IAAI;AAG7B,YAAM,mBAAmB,mBAAmB,QAAQ,KAAK,CAAA;AACzD,yBAAmB,QAAQ,IAAI;AAE/B,YAAM,gBAAgB,KAAK,MAAM,KAAK,GAAG,WAAW,SAAS;AAE7D,UAAI,CAAC,eAAe;AAEhB,aAAK,IAAI,KACL,GAAG,KAAK,SAAS,sCAAsC,KAAK,mBAAmB,SAAS,GAAG;AAE/F;MACJ;AAGA,aAAO,cAAc,QAAQ,iBAAiB,SAAS,GAAG;AACtD,yBAAiB,IAAG;MACxB;AAGA,uBAAiB,QAAQ,EAAE,SAAS,IAAI,KAAK,IAAG,GAAI,YAAW,CAAE;IACrE;AAGA,QAAI,qCAAM,SAAS,KAAK,qBAAqB,KAAK,CAAC,GAAG;AAClD,iBAAW,CAAC,cAAcC,SAAQ,KAAK,OAAO,QAAQ,eAAe,GAAG;AACpE,cAAM,kBAAkB,OAAO,KAAKA,SAAQ,EAAE;AAE9C,iBAAS,YAAY,IAAI,EAAE,OAAO,gBAAe;MACrD;IACJ;AAGA,QAAI;AACA,YAAM,KAAK,OAAO,SAAS,eAAe,KAAK,IAAI,kBAAkB,KAAK,IAAI;QAC1E,KAAK,KAAK,UAAU,QAAQ;QAC5B,KAAK;OACR;IACL,SAAS,GAAG;AACR,WAAK,IAAI,MAAM,GAAG,KAAK,SAAS,iDAAiD,KAAK,MAAM,EAAE,OAAO,EAAE;IAC3G;EACJ;;;;EAKQ,MAAM,qBAAkB;AAC5B,eAAW,CAAC,OAAO,QAAQ,KAAK,OAAO,QAAQ,KAAK,oBAAoB,GAAG;AACvE,YAAM,WAA4B,CAAA;AAElC,iBAAW,CAAC,UAAU,WAAW,KAAK,OAAO,QAAQ,QAAQ,GAAG;AAE5D,cAAM,aAAa,OAAO,KAAK,WAAW,EAAE;AAC5C,iBAAS,QAAQ,IAAI,EAAE,OAAO,WAAU;MAC5C;AAGA,UAAI;AACA,cAAM,KAAK,OAAO,SAAS,eAAe,KAAK,IAAI,kBAAkB,KAAK,IAAI;UAC1E,KAAK,KAAK,UAAU,QAAQ;UAC5B,KAAK;SACR;MACL,SAAS,GAAG;AACR,aAAK,IAAI,MACL,GAAG,KAAK,SAAS,iDAAiD,KAAK,MAAM,EAAE,OAAO,EAAE;MAEhG;IACJ;EACJ;;;;;;;EAQQ,WAAW,OAAe,SAAe;AAC7C,UAAM,aAAuB,CAAA;AAE7B,UAAM,WAAW,KAAK,MAAM,KAAK;AAEjC,QAAI,CAAC,UAAU;AACX,aAAO;IACX;AAEA,eAAW,CAAC,YAAY,WAAW,KAAK,OAAO,QAAQ,SAAS,UAAU,GAAG;AAEzE,iBAAW,SAAS,YAAY,OAAO;AACnC,YAAI,MAAM,KAAK,OAAO,GAAG;AAErB,qBAAW,KAAK,UAAU;AAE1B;QACJ;MACJ;IACJ;AAEA,WAAO;EACX;;;;EAKQ,qBAAkB;AACtB,QAAI;AACA,WAAK,uBAAuB,gBAAAC,QAAG,aAAa,iBAAAF,QAAK,KAAK,KAAK,SAAS,oBAAoB,CAAC;IAC7F,SAAS,GAAG;AAER,WAAK,IAAI,MAAM,GAAG,KAAK,SAAS,uCAAuC,EAAE,OAAO,EAAE;IACtF;EACJ;;;;EAKA,qBAAkB;AACd,QAAI;AACA,sBAAAE,QAAG,cAAc,iBAAAF,QAAK,KAAK,KAAK,SAAS,oBAAoB,GAAG,KAAK,oBAAoB;IAC7F,SAAS,GAAG;AACR,WAAK,IAAI,MAAM,GAAG,KAAK,SAAS,wCAAwC,EAAE,OAAO,EAAE;IACvF;EACJ;;;;;;;;EASA,uBACI,aACA,gBACA,gBAAyC;AAEzC,UAAM,MAAuC,CAAA;AAC7C,eAAW,CAAC,OAAO,mBAAmB,KAAK,OAAO,QAAQ,KAAK,oBAAoB,GAAG;AAClF,UAAI,eAAe,gBAAgB,OAAO;AAEtC;MACJ;AAEA,YAAM,WAAW,KAAK,MAAM,KAAK;AAEjC,UAAI,CAAC,UAAU;AAEX;MACJ;AAEA,YAAM,cAAyC;QAC3C,YAAY,CAAA;QACZ,aAAa,SAAS;QACtB,MAAM,SAAS;;AAGnB,UAAI,KAAK,IAAI;AAEb,iBAAW,CAAC,UAAU,kBAAkB,KAAK,OAAO,QAAQ,mBAAmB,GAAG;AAC9E,YAAI,kBAAkB,mBAAmB,UAAU;AAE/C;QACJ;AAEA,cAAM,cAAc,SAAS,WAAW,QAAQ;AAEhD,YAAI,CAAC,aAAa;AAEd;QACJ;AAEA,cAAM,mBAAiD;UACnD,WAAW,CAAA;UACX,aAAa,YAAY;UACzB,MAAM,YAAY;UAClB,UAAU,YAAY;;AAG1B,oBAAY,WAAW,QAAQ,IAAI;AAEnC,mBAAW,CAAC,UAAU,WAAW,KAAK,OAAO,QAAQ,kBAAkB,GAAG;AACtE,cAAI,kBAAkB,mBAAmB,UAAU;AAE/C;UACJ;AAEA,2BAAiB,UAAU,QAAQ,IAAI;YACnC,UAAU;;QAElB;MACJ;IACJ;AACA,WAAO;EACX;;;;;;;;EASA,MAAM,mBACF,aACA,gBACA,gBAAyC;AAEzC,eAAW,SAAS,OAAO,KAAK,KAAK,oBAAoB,GAAG;AACxD,YAAM,2BAA2B,KAAK,qBAAqB,KAAK;AAEhE,UAAI,CAAC,0BAA0B;AAC3B,eAAO,KAAK,qBAAqB,KAAK;AACtC;MACJ;AACA,UAAI,eAAe,gBAAgB,OAAO;AAEtC;MACJ;AAEA,UAAI,WAA4B,CAAA;AAChC,UAAI;AACA,cAAM,QAAQ,MAAM,KAAK,OAAO,cAAc,eAAe,KAAK,IAAI,kBAAkB,KAAK,EAAE;AAC/F,mBAAW,SAAS,MAAM,MAAM,KAAK,MAAM,MAAM,GAAa,IAAI,CAAA;MACtE,SAAS,GAAG;AACR,aAAK,IAAI,MAAM,GAAG,KAAK,SAAS,mCAAmC,KAAK,MAAM,EAAE,OAAO,EAAE;MAC7F;AAEA,iBAAW,CAAC,UAAU,WAAW,KAAK,OAAO,QAAQ,wBAAwB,GAAG;AAC5E,YAAI,kBAAkB,mBAAmB,UAAU;AAE/C;QACJ;AAEA,YAAI,kBAAkB;AACtB,mBAAW,YAAY,OAAO,KAAK,WAAW,GAAG;AAC7C,cAAI,kBAAkB,mBAAmB,UAAU;AAE/C,+BAAmB;AACnB;UACJ;AAGA,iBAAO,YAAY,QAAQ;QAC/B;AAEA,iBAAS,QAAQ,IAAI,EAAE,OAAO,gBAAe;AAG7C,YAAI,CAAC,OAAO,KAAK,WAAW,EAAE,QAAQ;AAClC,iBAAO,yBAAyB,QAAQ;AACxC,iBAAO,SAAS,QAAQ;QAC5B;MACJ;AAGA,UAAI,CAAC,OAAO,KAAK,wBAAwB,EAAE,QAAQ;AAC/C,eAAO,KAAK,qBAAqB,KAAK;MAC1C;AAGA,UAAI;AACA,cAAM,KAAK,OAAO,SAAS,eAAe,KAAK,IAAI,kBAAkB,KAAK,IAAI;UAC1E,KAAK,KAAK,UAAU,QAAQ;UAC5B,KAAK;SACR;MACL,SAAS,GAAG;AACR,aAAK,IAAI,MACL,GAAG,KAAK,SAAS,iDAAiD,KAAK,MAAM,EAAE,OAAO,EAAE;MAEhG;IACJ;EACJ;;;;;;EAOA,YAAY,OAAa;AACrB,WAAO,CAAC,CAAC,KAAK,MAAM,KAAK;EAC7B;;",
  "names": ["path", "category", "fs"]
}
