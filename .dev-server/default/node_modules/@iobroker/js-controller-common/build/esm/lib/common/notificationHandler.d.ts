/**
 * Notification handler class
 *
 *  2021-2024 foxriver76 <moritz.heusinger@gmail.com>
 */
import type { Client as StatesInRedisClient } from '@iobroker/db-states-redis';
import type { Client as ObjectsInRedisClient } from '@iobroker/db-objects-redis';
import type Winston from 'winston';
type MultilingualObject = Exclude<ioBroker.StringOrTranslated, string>;
/** Settings to configure an instance of NotificationHandler */
export interface NotificationHandlerSettings {
    /** Name of the host (not id - hence, without `system.host.` prefix) */
    host: string;
    /** States DB instance */
    states: StatesInRedisClient;
    /** Objects DB instance */
    objects: ObjectsInRedisClient;
    /** Logger instance */
    log: Winston.Logger | Console;
    /** Prefix for the log messages */
    logPrefix: string;
}
/** A notification config entry represents the top level of the notification structure */
export interface NotificationsConfigEntry {
    /** e.g. system */
    scope: string;
    /** multilingual name */
    name: MultilingualObject;
    /** multilingual description */
    description: MultilingualObject;
    /** The notification categories inside this scope */
    categories: CategoryConfigEntry[];
}
export type Severity = 'info' | 'notify' | 'alert';
/** A notification category entry represents one of the categories of a scope */
export interface CategoryConfigEntry {
    /** Id of the category */
    category: string;
    /** Name of the category */
    name: MultilingualObject;
    /** Allows defining the severity of the notification with `info` being the lowest, `notify` representing middle priority, `alert` representing high priority and often containing critical information */
    severity: Severity;
    /** Description of the category */
    description: MultilingualObject;
    /** Regex where `console.error` output is parsed against to check if a notification of this category should be generated */
    regex: string[];
    /** Restrict the maximum number of messages for this category */
    limit: number;
}
interface NotificationMessageObject {
    message: string;
    ts: number;
    contextData?: ioBroker.NotificationContextData;
}
interface FilteredNotificationCategory {
    description: MultilingualObject;
    name: MultilingualObject;
    severity: Severity;
    instances: {
        [instance: string]: {
            messages: NotificationMessageObject[];
        };
    };
}
interface FilteredNotificationScope {
    description: MultilingualObject;
    name: MultilingualObject;
    categories: {
        [category: string]: FilteredNotificationCategory;
    };
}
/** The filtered information as a response for `getFilteredInformation` */
export interface FilteredNotificationInformation {
    [scope: string]: FilteredNotificationScope;
}
interface AddMessageOptions {
    /** Scope of the message */
    scope: string;
    /** Category of the message, if non we check against regex of scope */
    category?: string | null;
    /** Message to add */
    message: string;
    /** Instance e.g., hm-rpc.1 or hostname, if hostname it needs to be prefixed like system.host.rpi */
    instance: string;
    /** Additional context for the notification which can be used by notification processing adapters */
    contextData?: ioBroker.NotificationContextData;
}
/**
 * The Notification handler class provides an interface to manage the ioBroker notification system
 */
export declare class NotificationHandler {
    private states;
    private objects;
    private log;
    private currentNotifications;
    private readonly dataDir;
    private readonly setup;
    private readonly logPrefix;
    private readonly host;
    /**
     * Creates a new instance of the notification handler class
     *
     * @param settings settings to configure the handler instance
     */
    constructor(settings: NotificationHandlerSettings);
    /**
     * Get all adapter instances on this host and store their notifications config - and clears up removed instances notifications - should be called once after init
     */
    getSetupOfAllAdaptersFromHost(): Promise<void>;
    /**
     * Add a new category to the given scope with a provided optional list of regex
     *
     * @param notifications - Array with notifications
     */
    addConfig(notifications: NotificationsConfigEntry[]): Promise<void>;
    /**
     * Add a message to the scope and category
     *
     * @param options The scope, category, message, instance and contextData information
     */
    addMessage(options: AddMessageOptions): Promise<void>;
    /**
     * Updates all scope states by current notifications in RAM
     */
    private _updateScopeStates;
    /**
     * Check the given message against all regular expressions of the given scope
     *
     * @param scope - scope of the message
     * @param message - message to check
     */
    private _parseText;
    /**
     * Load notifications from a file
     */
    private _loadNotifications;
    /**
     * Save current notifications to file
     */
    storeNotifications(): void;
    /**
     * Returns the stored notifications matching the filters with description and name
     *
     * @param scopeFilter - scope of notifications
     * @param categoryFilter - category of notifications
     * @param instanceFilter - instance of notifications
     */
    getFilteredInformation(scopeFilter: string | null | undefined, categoryFilter: string | null | undefined, instanceFilter: string | null | undefined): FilteredNotificationInformation;
    /**
     * Clears the stored notifications matching the filters
     *
     * @param scopeFilter - scope of notifications
     * @param categoryFilter - category of notifications
     * @param instanceFilter - instance of notifications
     */
    clearNotifications(scopeFilter: string | null | undefined, categoryFilter: string | null | undefined, instanceFilter: string | null | undefined): Promise<void>;
    /**
     * Check if given scope exists in config
     *
     * @param scope - scope to be checked for
     */
    scopeExists(scope: string): boolean;
}
export {};
//# sourceMappingURL=notificationHandler.d.ts.map