{
  "version": 3,
  "sources": ["../../../../src/lib/setup/setupInstall.ts", "../../../../../../node_modules/@alcalzone/esm2cjs/shims/import.meta.url/shim.js"],
  "sourcesContent": ["/**\n *      Install adapter\n *\n *      Copyright 2013-2024 bluefox <dogafox@gmail.com>\n *\n *      MIT License\n *\n */\n\nimport { tools, EXIT_CODES } from '@iobroker/js-controller-common';\nimport fs from 'fs-extra';\nimport path from 'node:path';\nimport semver from 'semver';\nimport child_process from 'node:child_process';\nimport axios from 'axios';\nimport { URL } from 'node:url';\nimport { Upload } from '@/lib/setup/setupUpload.js';\nimport { PacketManager } from '@/lib/setup/setupPacketManager.js';\nimport { getRepository } from '@/lib/setup/utils.js';\nimport type { Client as StatesRedisClient } from '@iobroker/db-states-redis';\nimport type { Client as ObjectsRedisClient } from '@iobroker/db-objects-redis';\nimport type { ProcessExitCallback } from '@/lib/_Types.js';\nimport { IoBrokerError } from '@/lib/setup/customError.js';\nimport type { CommandResult } from '@alcalzone/pak';\nimport { SYSTEM_ADAPTER_PREFIX } from '@iobroker/js-controller-common-db/constants';\nimport { createRequire } from 'node:module';\n\n// eslint-disable-next-line unicorn/prefer-module\nconst require = createRequire(import.meta.url || `file://${__filename}`);\n\nconst hostname = tools.getHostName();\nconst osPlatform = process.platform;\n\n/** Note: this is duplicated in preinstallCheck */\nconst RECOMMENDED_NPM_VERSION = 8;\n\ninterface NpmInstallResult {\n    installDir: string;\n    _url: string;\n}\n\ninterface NpmInstallOptions {\n    /** url of the package */\n    npmUrl: string;\n    /** Additional options*/\n    options: CLIDownloadPacketOptions;\n    /** if debug logging is desired */\n    debug: boolean;\n    /** if it is a retry, do not perform special error handling again */\n    isRetry: boolean;\n}\n\ninterface NotEmptyErrorOptions extends Omit<NpmInstallOptions, 'isRetry'> {\n    /** Result of the failed installation process */\n    result: CommandResult;\n}\n\nexport interface CLIInstallOptions {\n    params: Record<string, any>;\n    states: StatesRedisClient;\n    objects: ObjectsRedisClient;\n    processExit: ProcessExitCallback;\n}\n\ntype Dependencies = string[] | Record<string, string>[] | string | Record<string, string>;\n\ninterface DownloadPacketReturnObject {\n    stoppedList: ioBroker.InstanceObject[];\n    packetName: string;\n}\n\nexport interface CLIDownloadPacketOptions {\n    /** will stop the db before upgrade ONLY use it for controller upgrade */\n    stopDb?: boolean;\n    /** name of the packet */\n    packetName?: string;\n    /** if unsafe-perm flag is required */\n    unsafePerm?: boolean;\n}\n\ninterface CreateInstanceOptions {\n    instance?: number;\n    ignoreIfExists?: boolean;\n    enabled?: boolean;\n    host?: string;\n    port?: number;\n}\n\nexport class Install {\n    private readonly isRootOnUnix: boolean;\n    private readonly objects: ObjectsRedisClient;\n    private readonly states: StatesRedisClient;\n    private readonly processExit: ProcessExitCallback;\n    private readonly params: Record<string, any>;\n    private readonly tarballRegex: RegExp;\n    private upload: Upload;\n    private packetManager?: PacketManager;\n\n    constructor(options: CLIInstallOptions) {\n        this.isRootOnUnix = typeof process.getuid === 'function' && process.getuid() === 0;\n\n        options = options || {};\n\n        if (!options.states) {\n            throw new Error('Invalid arguments: states is missing');\n        }\n        if (!options.objects) {\n            throw new Error('Invalid arguments: objects is missing');\n        }\n        if (!options.processExit) {\n            throw new Error('Invalid arguments: processExit is missing');\n        }\n\n        this.objects = options.objects;\n        this.states = options.states;\n        this.processExit = options.processExit;\n        this.params = options.params || {};\n\n        this.tarballRegex = /\\/tarball\\/[^/]+$/;\n\n        this.upload = new Upload(options);\n    }\n\n    /**\n     * Enables or disables given instances\n     *\n     * @param instances all instance objects\n     * @param enabled if enable or disable\n     */\n    async enableInstances(instances: ioBroker.InstanceObject[], enabled: boolean): Promise<void> {\n        if (instances?.length) {\n            const ts = Date.now();\n            for (const instance of instances) {\n                const updatedObj = {\n                    common: {\n                        enabled,\n                    },\n                    from: `system.host.${hostname}.cli`,\n                    ts,\n                };\n                console.log(`host.${hostname} Adapter \"${instance._id}\" is ${enabled ? 'started' : 'stopped.'}`);\n                // @ts-expect-error should be fixed with #1917\n                await this.objects.extendObjectAsync(instance._id, updatedObj);\n            }\n        }\n    }\n\n    /**\n     * Download given packet\n     *\n     * @param repoUrlOrRepo repository url or already the repository object\n     * @param packetName name of the package to install\n     * @param options options.stopDb will stop the db before upgrade ONLY use it for controller upgrade - db is gone afterwards, does not work with stoppedList\n     * @param stoppedList list of stopped instances (as instance objects)\n     */\n    async downloadPacket(\n        repoUrlOrRepo: string | undefined | Record<string, any>,\n        packetName: string,\n        options?: CLIDownloadPacketOptions,\n        stoppedList?: ioBroker.InstanceObject[],\n    ): Promise<DownloadPacketReturnObject> {\n        if (!options || typeof options !== 'object') {\n            options = {};\n        }\n\n        stoppedList = stoppedList || [];\n        let sources: Record<string, ioBroker.RepositoryJsonAdapterContent>;\n\n        if (!repoUrlOrRepo || !tools.isObject(repoUrlOrRepo)) {\n            sources = await getRepository({ repoName: repoUrlOrRepo, objects: this.objects });\n        } else {\n            sources = repoUrlOrRepo;\n        }\n\n        if (options.stopDb && stoppedList.length) {\n            console.warn('[downloadPacket] stoppedList cannot be used if stopping of databases is requested');\n            stoppedList = [];\n        }\n\n        const debug = process.argv.includes('--debug');\n\n        let version;\n        // check if the adapter has format adapter@1.0.0\n        if (packetName.includes('@')) {\n            const parts = packetName.split('@');\n            packetName = parts[0];\n            version = parts[1];\n        } else {\n            // always take a version from repository\n            if (sources[packetName]?.version) {\n                version = sources[packetName].version;\n            } else {\n                version = '';\n            }\n        }\n\n        const source = sources[packetName];\n\n        if (!source) {\n            const errMessage = `Unknown packet name ${packetName}. Please install packages from outside the repository using \"${tools.appNameLowerCase} url <url-or-package>\"!`;\n            console.error(`host.${hostname} ${errMessage}`);\n            throw new IoBrokerError({\n                code: EXIT_CODES.UNKNOWN_PACKET_NAME,\n                message: errMessage,\n            });\n        }\n\n        options.packetName = packetName;\n        options.unsafePerm = source.unsafePerm;\n\n        // Check if flag stopBeforeUpdate is true or on windows we stop because of issue #1436\n        if ((source.stopBeforeUpdate || osPlatform === 'win32') && !stoppedList.length) {\n            stoppedList = await this._getInstancesOfAdapter(packetName);\n            await this.enableInstances(stoppedList, false);\n        }\n\n        if (options.stopDb) {\n            if (this.objects.destroy) {\n                await this.objects.destroy();\n                console.log('Stopped Objects DB');\n            }\n            if (this.states.destroy) {\n                await this.states.destroy();\n                console.log('Stopped States DB');\n            }\n        }\n\n        // vendor packages could be scoped and thus differ in the package name\n        const npmPacketName = source.packetName\n            ? `${tools.appName.toLowerCase()}.${packetName}@npm:${source.packetName}`\n            : `${tools.appName.toLowerCase()}.${packetName}`;\n\n        // Install node modules\n        await this._npmInstallWithCheck(`${npmPacketName}${version ? `@${version}` : ''}`, options, debug);\n\n        return { packetName, stoppedList };\n    }\n\n    /**\n     * Install npm module from url\n     *\n     * @param npmUrl parameter passed to `npm install <npmUrl>`\n     * @param options additional packet download options\n     * @param debug if debug output should be printed\n     */\n    private async _npmInstallWithCheck(\n        npmUrl: string,\n        options: CLIDownloadPacketOptions,\n        debug: boolean,\n    ): Promise<void | NpmInstallResult> {\n        // Get npm version\n        try {\n            let npmVersion;\n            try {\n                npmVersion = child_process.execSync('npm -v', { encoding: 'utf8' });\n                if (npmVersion) {\n                    npmVersion = semver.valid(npmVersion.trim());\n                }\n                console.log(`NPM version: ${npmVersion}`);\n            } catch (e) {\n                console.error(`Error trying to check npm version: ${e.message}`);\n            }\n\n            if (!npmVersion) {\n                console.error('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!');\n                console.error('Aborting install because the npm version could not be checked!');\n                console.error('Please check that npm is installed correctly.');\n                console.error(\n                    `Use \"npm install -g npm@${RECOMMENDED_NPM_VERSION}\" or \"npm install -g npm@latest\" to install a supported version.`,\n                );\n                console.error(\n                    'You need to make sure to repeat this step after installing an update to NodeJS and/or npm',\n                );\n                console.error('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!');\n                return this.processExit(EXIT_CODES.INVALID_NPM_VERSION);\n            } else if (semver.gte(npmVersion, '5.0.0') && semver.lt(npmVersion, '5.7.1')) {\n                console.error('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!');\n                console.error('NPM 5 is only supported starting with version 5.7.1!');\n                console.error(\n                    `Please use \"npm install -g npm@${RECOMMENDED_NPM_VERSION}\" to upgrade npm to ${RECOMMENDED_NPM_VERSION}.x or `,\n                );\n                console.error('use \"npm install -g npm@latest\" to install a supported version of npm!');\n                console.error(\n                    'You need to make sure to repeat this step after installing an update to NodeJS and/or npm',\n                );\n                console.error('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!');\n                return this.processExit(EXIT_CODES.INVALID_NPM_VERSION);\n            }\n        } catch (e) {\n            console.error(`Could not check npm version: ${e.message}`);\n            console.error('Assuming that correct version is installed.');\n        }\n\n        try {\n            return await this._npmInstall({ npmUrl, options, debug, isRetry: false });\n        } catch (e) {\n            console.error(`Could not install ${npmUrl}: ${e.message}`);\n        }\n    }\n\n    /**\n     * Extract the adapterName e.g. `hm-rpc` from url\n     *\n     * @param npmUrl url of the npm packet\n     */\n    private getAdapterNameFromUrl(npmUrl: string): string {\n        npmUrl = npmUrl\n            .replace(/\\\\/g, '/') // it could be the Windows path\n            .replace(/\\.git$/, '') // it could be https://github.com/ioBroker/ioBroker.NAME.git\n            .toLowerCase();\n\n        // If the user installed a git commit-ish, the url contains stuff that doesn't belong in a folder name\n        // e.g. iobroker/iobroker.javascript#branch-name\n        if (npmUrl.includes('#')) {\n            npmUrl = npmUrl.substring(0, npmUrl.indexOf('#'));\n        }\n        if (npmUrl.includes('/') && !npmUrl.startsWith('@')) {\n            // only scoped packages (e.g., @types/node) may have a slash in their path\n            npmUrl = npmUrl.substring(npmUrl.lastIndexOf('/') + 1);\n        }\n        if (!npmUrl.startsWith('@')) {\n            // it is a version, so cut off the version\n            npmUrl = npmUrl.split('@')[0];\n        }\n\n        return npmUrl;\n    }\n\n    /**\n     * Perform npm installation of given package\n     *\n     * @param installOptions options of package to install\n     */\n    private async _npmInstall(installOptions: NpmInstallOptions): Promise<void | NpmInstallResult> {\n        const { npmUrl, debug, isRetry } = installOptions;\n        let { options } = installOptions;\n\n        if (!tools.isObject(options)) {\n            options = {};\n        }\n\n        if (this.isRootOnUnix) {\n            // If ioBroker or the CLI is executed as root on unix platforms,\n            // not providing the --unsafe-perm options means that every pre/postinstall\n            // script fails when it uses npm commands.\n            options.unsafePerm = true;\n        }\n\n        console.log(`Installing ${npmUrl}... (System call)`);\n\n        const result = await tools.installNodeModule(npmUrl, {\n            debug: !!debug,\n            unsafePerm: !!options.unsafePerm,\n        });\n\n        // code 1 is sometimes a real error and sometimes a strange error, where everything is installed but still the error\n        const isSuccess = result.success || (result.exitCode === 1 && !result.stderr.startsWith('npm ERR!'));\n\n        if (isSuccess) {\n            // Determine where the packet would be installed if npm succeeds\n            // TODO: There's probably a better way to figure this out\n            let packetDirName: string;\n            if (options.packetName) {\n                packetDirName = `${tools.appName.toLowerCase()}.${options.packetName}`;\n            } else {\n                packetDirName = this.getAdapterNameFromUrl(npmUrl);\n            }\n            const installDir = tools.getAdapterDir(packetDirName);\n\n            // inject the installedFrom information in io-package\n            if (installDir && fs.existsSync(installDir)) {\n                const ioPackPath = path.join(installDir, 'io-package.json');\n                let ioPackContent: Record<string, any> | null;\n                try {\n                    ioPackContent = fs.readJSONSync(ioPackPath);\n                } catch {\n                    ioPackContent = null;\n                }\n                if (ioPackContent) {\n                    ioPackContent.common = ioPackContent.common || {};\n                    ioPackContent.common.installedFrom = npmUrl;\n                    try {\n                        fs.writeJsonSync(ioPackPath, ioPackContent, { encoding: 'utf8', spaces: 2 });\n                    } catch {\n                        // OK\n                    }\n                }\n            } else {\n                // npm exists with code 1 but adapter not installed\n                console.error(result.stderr);\n                console.error(`host.${hostname} Cannot install ${npmUrl}: ${result.exitCode}`);\n                return this.processExit(EXIT_CODES.CANNOT_INSTALL_NPM_PACKET);\n            }\n\n            // command succeeded\n            return { _url: npmUrl, installDir: path.dirname(installDir) };\n        }\n        if (!isRetry && result.stderr.includes('ENOTEMPTY')) {\n            return this.handleNpmNotEmptyError({ npmUrl, options, debug, result });\n        }\n\n        console.error(result.stderr);\n        console.error(`host.${hostname} Cannot install ${npmUrl}: ${result.exitCode}`);\n        return this.processExit(EXIT_CODES.CANNOT_INSTALL_NPM_PACKET);\n    }\n\n    /**\n     * Handle the NPM `ENOTEMPTY` error, by deleting different affected directories and retrying installation\n     *\n     * @param notEmptyErrorOptions options of package to install\n     */\n    private handleNpmNotEmptyError(\n        notEmptyErrorOptions: NotEmptyErrorOptions,\n    ): Promise<void | NpmInstallResult> | void {\n        const { debug, npmUrl, options, result } = notEmptyErrorOptions;\n\n        console.info('Try to solve ENOTEMPTY error automatically');\n\n        const errorFilePath = result.stderr\n            .split('\\n')\n            ?.find(line => line.startsWith('npm ERR! dest'))\n            ?.split('dest')[1]\n            .trim();\n\n        const affectedNodeModulesPath = errorFilePath ? path.join(errorFilePath, '..') : undefined;\n\n        if (affectedNodeModulesPath) {\n            const parts = affectedNodeModulesPath.replace(/\\\\/g, '/').split('/');\n            if (parts[parts.length - 1] === 'node_modules') {\n                // node modules detected, so scan it for \".*-????????\"\n                let foundNpmGarbage = false;\n                fs.readdirSync(affectedNodeModulesPath).forEach(file => {\n                    if (file.match(/^\\..*-[a-zA-Z0-9]{8}$/) && file !== '.local-chromium') {\n                        fs.rmSync(path.join(affectedNodeModulesPath, file), { recursive: true, force: true });\n                        foundNpmGarbage = true;\n                        console.warn(`host.${hostname} deleted npm temp directory: \"${file}\")`);\n                    }\n                });\n\n                if (foundNpmGarbage) {\n                    return this._npmInstall({ npmUrl, options, debug, isRetry: true });\n                }\n            }\n        }\n\n        console.error('Could not handle ENOTEMPTY, because no deletable files were found');\n        console.error(result.stderr);\n        console.error(`host.${hostname} Cannot install ${npmUrl}: ${result.exitCode}`);\n        return this.processExit(EXIT_CODES.CANNOT_INSTALL_NPM_PACKET);\n    }\n\n    private async _npmUninstall(packageName: string, debug: boolean): Promise<void> {\n        const result = await tools.uninstallNodeModule(packageName, { debug: !!debug });\n        if (!result.success) {\n            throw new Error(`host.${hostname}: Cannot uninstall ${packageName}: ${result.exitCode}`);\n        }\n    }\n\n    // this command is executed always on THIS host\n    private async _checkDependencies(\n        deps: Dependencies,\n        globalDeps: Dependencies,\n        _options: Record<string, any>,\n    ): Promise<void> {\n        if (!deps && !globalDeps) {\n            return;\n        }\n\n        deps = tools.parseDependencies(deps);\n        globalDeps = tools.parseDependencies(globalDeps);\n\n        // combine both dependencies\n        const allDeps = { ...deps, ...globalDeps };\n\n        // Get all installed adapters\n        const objs = await this.objects.getObjectViewAsync('system', 'instance', {\n            startkey: SYSTEM_ADAPTER_PREFIX,\n            endkey: `${SYSTEM_ADAPTER_PREFIX}\\u9999`,\n        });\n\n        if (objs.rows.length) {\n            for (const dName in allDeps) {\n                let isFound = false;\n\n                if (dName === 'js-controller') {\n                    const version = allDeps[dName];\n                    // Check only if version not *, else we don't have to read io-pack unnecessarily\n                    if (version !== '*') {\n                        const packJson = fs.readJSONSync(`${tools.getControllerDir()}/package.json`);\n                        if (!semver.satisfies(packJson.version, version, { includePrerelease: true })) {\n                            console.error(\n                                `host.${hostname} Invalid version of \"${dName}\". Installed \"${packJson.version}\", required \"${version}\"`,\n                            );\n                            return this.processExit(EXIT_CODES.INVALID_DEPENDENCY_VERSION);\n                        }\n                        isFound = true;\n                    } else {\n                        isFound = true;\n                    }\n                }\n\n                if (!isFound) {\n                    let gInstances: ioBroker.GetObjectViewItem<ioBroker.InstanceObject>[] = [];\n                    let locInstances: ioBroker.GetObjectViewItem<ioBroker.InstanceObject>[] = [];\n                    // if global dep get all instances of adapter\n                    if (globalDeps[dName] !== undefined) {\n                        gInstances = objs.rows.filter(obj => obj.value.common && obj.value.common.name === dName);\n                    }\n                    if (deps[dName] !== undefined) {\n                        // local dependencies: get all instances on the same host\n                        locInstances = objs.rows.filter(\n                            obj =>\n                                obj.value.common &&\n                                obj.value.common.name === dName &&\n                                obj.value.common.host === hostname,\n                        );\n                        if (locInstances.length === 0) {\n                            console.error(`host.${hostname} Required dependency \"${dName}\" not found on this host.`);\n                        }\n                    }\n\n                    // we check that all existing instances match - respect different versions for local and global deps\n                    for (const instance of locInstances) {\n                        const instanceVersion = instance.value.common.version;\n                        if (\n                            !semver.satisfies(instanceVersion, deps[dName], {\n                                includePrerelease: true,\n                            })\n                        ) {\n                            console.error(\n                                `host.${hostname} Invalid version of \"${dName}\". Installed \"${instanceVersion}\", required \"${deps[dName]}\"`,\n                            );\n                            return this.processExit(EXIT_CODES.INVALID_DEPENDENCY_VERSION);\n                        }\n                        isFound = true;\n                    }\n\n                    for (const instance of gInstances) {\n                        const instanceVersion = instance.value.common.version;\n                        if (\n                            !semver.satisfies(instanceVersion, globalDeps[dName], {\n                                includePrerelease: true,\n                            })\n                        ) {\n                            console.error(\n                                `host.${hostname} Invalid version of \"${dName}\". Installed \"${instanceVersion}\", required \"${globalDeps[dName]}\"`,\n                            );\n                            return this.processExit(EXIT_CODES.INVALID_DEPENDENCY_VERSION);\n                        }\n                        isFound = true;\n                    }\n                }\n\n                // if required dependency not found => install it\n                if (!isFound) {\n                    await this.createInstance(dName, _options);\n                }\n            }\n        }\n    }\n\n    private async _uploadStaticObjects(adapter: string, _adapterConf?: Record<string, any>): Promise<void> {\n        let adapterConf: Record<string, any>;\n        if (!_adapterConf) {\n            const adapterDir = tools.getAdapterDir(adapter);\n            if (!adapterDir || !fs.existsSync(path.join(adapterDir, 'io-package.json'))) {\n                const message = `Adapter directory \"${adapterDir}\" does not exists`;\n                console.error(`host.${hostname} ${message}`);\n                throw new Error(message);\n            }\n            try {\n                adapterConf = await fs.readJSON(path.join(adapterDir, 'io-package.json'));\n            } catch (e) {\n                const message = `error reading io-package.json: ${e.message}`;\n                console.error(`host.${hostname} ${message}`, adapter);\n                throw new Error(message);\n            }\n        } else {\n            adapterConf = _adapterConf;\n        }\n\n        let objs;\n        if (adapterConf.objects && adapterConf.objects?.length > 0) {\n            objs = adapterConf.objects;\n        } else {\n            objs = [];\n        }\n\n        // check if some dependencies are missing and install them if some found\n        await this._checkDependencies(\n            adapterConf.common.dependencies,\n            adapterConf.common.globalDependencies,\n            this.params,\n        );\n        adapterConf.common.installedVersion = adapterConf.common.version;\n\n        if (adapterConf.common.news) {\n            delete adapterConf.common.news; // remove this information as it will be taken from repo\n        }\n\n        objs.push({\n            _id: `system.adapter.${adapterConf.common.name}`,\n            type: 'adapter',\n            common: adapterConf.common,\n            native: adapterConf.native,\n        });\n\n        if (objs?.length) {\n            for (let i = 0; i < objs.length; i++) {\n                const obj = objs[i];\n                obj.from = `system.host.${hostname}.cli`;\n                obj.ts = Date.now();\n\n                try {\n                    await this.objects.extendObjectAsync(obj._id, obj);\n                } catch (err) {\n                    console.error(`host.${hostname} error setObject ${obj._id} ${err.message}`);\n                    return;\n                }\n\n                console.log(`host.${hostname} object ${obj._id} created/updated`);\n            }\n        }\n    }\n\n    /**\n     * Installs given adapter\n     *\n     * @param adapter The adapter name\n     * @param repoUrl\n     * @param _installCount\n     */\n    async installAdapter(adapter: string, repoUrl?: string, _installCount?: number): Promise<string | void> {\n        _installCount = _installCount || 0;\n        const fullName = adapter;\n        if (adapter.includes('@')) {\n            adapter = adapter.split('@')[0];\n        }\n        const adapterDir = tools.getAdapterDir(adapter);\n\n        console.log(`host.${hostname} install adapter ${fullName}`);\n\n        if (!adapterDir || !fs.existsSync(path.join(adapterDir, 'io-package.json'))) {\n            if (_installCount === 2) {\n                console.error(`host.${hostname} Cannot install ${adapter}`);\n                return this.processExit(EXIT_CODES.CANNOT_INSTALL_NPM_PACKET);\n            }\n            _installCount++;\n\n            const { stoppedList } = await this.downloadPacket(repoUrl, fullName);\n            await this.installAdapter(adapter, repoUrl, _installCount);\n            await this.enableInstances(stoppedList, true); // even if unlikely make sure to re-enable disabled instances\n            return adapter;\n        }\n        let adapterConf: ioBroker.AdapterObject;\n        try {\n            adapterConf = fs.readJSONSync(path.join(adapterDir, 'io-package.json'));\n        } catch (err) {\n            console.error(`host.${hostname} error: reading io-package.json ${err.message}`);\n            return this.processExit(EXIT_CODES.INVALID_IO_PACKAGE_JSON);\n        }\n\n        // Check if the operation system is ok\n        if (adapterConf.common && adapterConf.common.os) {\n            if (typeof adapterConf.common.os === 'string' && adapterConf.common.os !== osPlatform) {\n                console.error(\n                    `host.${hostname} Adapter does not support current os. Required ${adapterConf.common.os}. Actual platform: ${osPlatform}`,\n                );\n                return this.processExit(EXIT_CODES.INVALID_OS);\n            } else if (Array.isArray(adapterConf.common.os) && !adapterConf.common.os.includes(osPlatform as any)) {\n                console.error(\n                    `host.${hostname} Adapter does not support current os. Required one of ${adapterConf.common.os.join(\n                        ', ',\n                    )}. Actual platform: ${osPlatform}`,\n                );\n                return this.processExit(EXIT_CODES.INVALID_OS);\n            }\n        }\n\n        let engineVersion;\n        try {\n            // read directly from disk and not via require to allow \"on the fly\" updates of adapters.\n            const packJson = fs.readJSONSync(path.join(adapterDir, 'package.json'), 'utf8');\n            engineVersion = packJson?.engines?.node;\n        } catch {\n            console.error(`host.${hostname}: Cannot read and parse \"${adapterDir}/package.json\"`);\n        }\n\n        // check node.js version if defined in package.json\n        if (engineVersion) {\n            if (!semver.satisfies(process.version.replace(/^v/, ''), engineVersion)) {\n                console.error(\n                    `host.${hostname} Adapter does not support current nodejs version. Required ${engineVersion}. Actual version: ${process.version}`,\n                );\n                return this.processExit(EXIT_CODES.INVALID_NODE_VERSION);\n            }\n        }\n\n        if (adapterConf.common.osDependencies) {\n            // install linux/osx libraries\n            await this.installOSPackages(adapterConf.common.osDependencies);\n        }\n\n        await this.upload.uploadAdapter(adapter, true, true);\n        await this.upload.uploadAdapter(adapter, false, true);\n        await this.callInstallOfAdapter(adapter, adapterConf);\n        await this._uploadStaticObjects(adapter);\n        await this.upload.upgradeAdapterObjects(adapter);\n        return adapter;\n    }\n\n    async installOSPackages(osDependencies: NonNullable<ioBroker.AdapterCommon['osDependencies']>): Promise<void> {\n        if (osPlatform in osDependencies) {\n            try {\n                this.packetManager = this.packetManager || new PacketManager();\n                await this.packetManager.update();\n                // @ts-expect-error we have checked that platform is a valid key\n                await this.packetManager.install(osDependencies[osPlatform]);\n            } catch (err) {\n                console.error(`host.${hostname} Could not install required OS packages: ${err.message}`);\n            }\n        }\n    }\n\n    async callInstallOfAdapter(adapter: string, config: ioBroker.AdapterObject): Promise<string | void> {\n        if (config.common.install) {\n            // Install node modules\n            let cmd = 'node ';\n\n            let fileFullName: string;\n            try {\n                fileFullName = await tools.resolveAdapterMainFile(adapter);\n            } catch {\n                return;\n            }\n\n            return new Promise(resolve => {\n                cmd += `\"${fileFullName}\" --install`;\n                console.log(`host.${hostname} command: ${cmd}`);\n                const child = child_process.exec(cmd, { windowsHide: true });\n                if (child.stderr) {\n                    tools.pipeLinewise(child.stderr, process.stdout);\n                }\n                child.on('exit', () => resolve(adapter));\n            });\n        }\n    }\n\n    /**\n     * Create adapter instance\n     *\n     * @param adapter The adapter name\n     * @param options Additional instance creation options\n     */\n    async createInstance(adapter: string, options?: CreateInstanceOptions): Promise<void> {\n        let ignoreIfExists = false;\n        options = options || {};\n        options.host = options.host || hostname;\n\n        if (options.ignoreIfExists !== undefined) {\n            ignoreIfExists = !!options.ignoreIfExists;\n            delete options.ignoreIfExists;\n        }\n\n        let obj;\n        let err;\n        try {\n            obj = await this.objects.getObject(`system.adapter.${adapter}`);\n        } catch (_err) {\n            err = _err;\n        }\n        // Adapter is not installed - install it now\n        if (err || !obj || !obj.common.installedVersion) {\n            await this.installAdapter(adapter);\n            obj = await this.objects.getObject(`system.adapter.${adapter}`);\n        }\n\n        if (!obj) {\n            console.error('Adapter object not found, cannot create instance');\n            return void this.processExit(EXIT_CODES.ADAPTER_NOT_FOUND);\n        }\n\n        // Check if some web pages should be uploaded\n        await this.upload.uploadAdapter(adapter, true, false);\n        await this.upload.uploadAdapter(adapter, false, false);\n\n        const res = await this.objects.getObjectViewAsync('system', 'instance', {\n            startkey: `${SYSTEM_ADAPTER_PREFIX}${adapter}.`,\n            endkey: `${SYSTEM_ADAPTER_PREFIX}${adapter}.\\u9999`,\n        });\n        const systemConfig = await this.objects.getObject('system.config');\n        const defaultLogLevel = systemConfig?.common?.defaultLogLevel;\n        if (!res) {\n            console.error(`host.${hostname} error: view instanceStats`);\n            return this.processExit(EXIT_CODES.CANNOT_READ_INSTANCES);\n        }\n\n        // Count started instances\n        if (obj.common.singleton && res.rows.length) {\n            if (ignoreIfExists) {\n                return;\n            }\n            console.error(`host.${hostname} error: this adapter does not allow multiple instances`);\n            return this.processExit(EXIT_CODES.NO_MULTIPLE_INSTANCES_ALLOWED);\n        }\n\n        // check singletonHost one on host\n        if (obj.common.singletonHost) {\n            for (const row of res.rows) {\n                if (row.value?.common.host === hostname) {\n                    if (ignoreIfExists) {\n                        return;\n                    }\n                    console.error(`host.${hostname} error: this adapter does not allow multiple instances on one host`);\n                    return this.processExit(EXIT_CODES.NO_MULTIPLE_INSTANCES_ALLOWED_ON_HOST);\n                }\n            }\n        }\n\n        let instance: null | number = null;\n\n        if (options.instance !== undefined) {\n            instance = options.instance;\n            // find max instance\n            if (res.rows.find(obj => parseInt(obj.id.split('.').pop()!, 10) === instance)) {\n                console.error(`host.${hostname} error: instance yet exists`);\n                return this.processExit(EXIT_CODES.INSTANCE_ALREADY_EXISTS);\n            }\n        } else {\n            // find max instance\n            for (const row of res.rows) {\n                const iInstance = parseInt(row.id.split('.').pop()!, 10);\n                if (instance === null || iInstance > instance) {\n                    instance = iInstance;\n                }\n            }\n            if (instance === null) {\n                instance = 0;\n            } else {\n                instance++;\n            }\n        }\n\n        // We are now converting the adapter object to an instance object\n        const instanceObj: ioBroker.InstanceObject = {\n            ...obj,\n            common: { ...obj.common, host: options.host },\n            type: 'instance',\n            _id: `system.adapter.${adapter}.${instance}`,\n        };\n\n        if (instanceObj.common.news) {\n            delete instanceObj.common.news; // remove this information as it could be big, but it will be taken from repo\n        }\n\n        instanceObj.common.enabled =\n            options.enabled === true || options.enabled === false\n                ? options.enabled\n                : instanceObj.common.enabled === true || instanceObj.common.enabled === false\n                  ? instanceObj.common.enabled\n                  : false;\n\n        if (options.port) {\n            instanceObj.native = instanceObj.native || {};\n            instanceObj.native.port = options.port;\n        }\n\n        if (instanceObj.common.dataFolder && instanceObj.common.dataFolder.includes('%INSTANCE%')) {\n            instanceObj.common.dataFolder = instanceObj.common.dataFolder.replace(/%INSTANCE%/g, instance.toString());\n        }\n\n        if (defaultLogLevel) {\n            instanceObj.common.loglevel = defaultLogLevel;\n        } else if (!instanceObj.common.loglevel) {\n            instanceObj.common.loglevel = 'info';\n        }\n\n        console.log(`host.${hostname} create instance ${adapter}`);\n\n        let objs: ioBroker.StateObject[];\n        if (!instanceObj.common.onlyWWW && instanceObj.common.mode !== 'once') {\n            objs = tools.getInstanceIndicatorObjects(`${adapter}.${instance}`);\n        } else {\n            objs = [];\n        }\n\n        const adapterDir = tools.getAdapterDir(adapter);\n\n        if (!adapterDir) {\n            console.error(`host.${hostname} error: reading io-package.json ${err.message}`);\n            return this.processExit(EXIT_CODES.INVALID_IO_PACKAGE_JSON);\n        }\n\n        if (fs.existsSync(path.join(adapterDir, 'www'))) {\n            objs.push({\n                _id: `system.adapter.${adapter}.upload`,\n                type: 'state',\n                common: {\n                    name: `${adapter}.upload`,\n                    type: 'number',\n                    read: true,\n                    write: false,\n                    role: 'indicator.state',\n                    unit: '%',\n                    def: 0,\n                    desc: 'Upload process indicator',\n                },\n                native: {},\n            });\n        }\n\n        let adapterConf: Record<string, any>;\n\n        try {\n            adapterConf = fs.readJSONSync(path.join(adapterDir, 'io-package.json'));\n        } catch (err) {\n            console.error(`host.${hostname} error: reading io-package.json ${err.message}`);\n            return this.processExit(EXIT_CODES.INVALID_IO_PACKAGE_JSON);\n        }\n\n        adapterConf.instanceObjects = adapterConf.instanceObjects || [];\n        adapterConf.objects = adapterConf.objects || [];\n\n        const defStates: Map<string, ioBroker.SettableState> = new Map();\n\n        // Create only for this instance the predefined in io-package.json objects\n        // It is not necessary to write \"system.adapter.name.N.\" in the object '_id'\n        for (const instanceObject of adapterConf.instanceObjects) {\n            instanceObject._id = `${adapter}.${instance}${instanceObject._id ? `.${instanceObject._id}` : ''}`;\n\n            if (instanceObject.common) {\n                if (instanceObject.common.name) {\n                    // if name has many languages\n                    if (typeof instanceObject.common.name === 'object') {\n                        Object.keys(instanceObject.common.name).forEach(\n                            lang =>\n                                (instanceObject.common.name[lang] = instanceObject.common.name[lang].replace(\n                                    '%INSTANCE%',\n                                    instance,\n                                )),\n                        );\n                    } else {\n                        instanceObject.common.name = instanceObject.common.name.replace('%INSTANCE%', instance);\n                    }\n                }\n                if (instanceObject.common.desc) {\n                    // if name has many languages\n                    if (typeof instanceObject.common.desc === 'object') {\n                        Object.keys(instanceObject.common.desc).forEach(\n                            lang =>\n                                (instanceObject.common.desc[lang] = instanceObject.common.desc[lang].replace(\n                                    '%INSTANCE%',\n                                    instance,\n                                )),\n                        );\n                    } else {\n                        instanceObject.common.desc = instanceObject.common.desc.replace('%INSTANCE%', instance);\n                    }\n                }\n            }\n\n            objs.push(instanceObject);\n            if (instanceObject.common && instanceObject.common.def !== undefined) {\n                defStates.set(instanceObject._id, {\n                    val: instanceObject.common.def,\n                });\n            }\n        }\n\n        // upload all objects\n        for (const obj of objs) {\n            try {\n                tools.validateGeneralObjectProperties(obj);\n            } catch (e) {\n                console.warn(`host.${hostname} Object ${obj._id} is invalid: ${e.message}`);\n                continue;\n            }\n\n            obj.from = `system.host.${hostname}.cli`;\n            obj.ts = Date.now();\n            try {\n                await this.objects.setObjectAsync(obj._id, obj);\n                console.log(`host.${hostname} object ${obj._id} created`);\n            } catch (err) {\n                console.error(`host.${hostname} error: ${err.message}`);\n            }\n        }\n\n        // sets the default states if any given\n        for (const [id, defState] of defStates) {\n            defState.ack = true;\n            defState.from = `system.host.${hostname}.cli`;\n            try {\n                await this.states.setStateAsync(id, defState);\n                console.log(`host.${hostname} Set default value of ${id}: ${defState.val}`);\n            } catch (err) {\n                console.error(`host.${hostname} error: ${err.message}`);\n            }\n        }\n\n        instanceObj.from = `system.host.${hostname}.cli`;\n        instanceObj.ts = Date.now();\n\n        try {\n            await this.objects.setObjectAsync(instanceObj._id, instanceObj);\n            console.log(`host.${hostname} object ${instanceObj._id} created`);\n        } catch (err) {\n            console.error(`host.${hostname} error: ${err.message}`);\n        }\n    }\n\n    /**\n     * Enumerate all instances of an adapter\n     *\n     * @param knownObjIDs\n     * @param notDeleted\n     * @param adapter\n     * @param instance\n     */\n    private async _enumerateAdapterInstances(\n        knownObjIDs: string[],\n        notDeleted: string[],\n        adapter: string,\n        instance?: number,\n    ): Promise<void> {\n        if (!notDeleted) {\n            notDeleted = [];\n        }\n\n        // We need to filter the instances using RegExp, because the naive approach with startkey/endkey\n        //   startkey: system.adapter.mqtt\n        //   endkey: system.adapter.mqtt.\\u9999\n        // matches system.adapter.mqtt AND system.adapter.mqtt-client\n        const instanceRegex =\n            instance !== undefined\n                ? new RegExp(`^system\\\\.adapter\\\\.${adapter}\\\\.${instance}$`)\n                : new RegExp(`^system\\\\.adapter\\\\.${adapter}\\\\.\\\\d+$`);\n\n        try {\n            const doc = await this.objects.getObjectView('system', 'instance', {\n                startkey: `system.adapter.${adapter}${instance !== undefined ? `.${instance}` : ''}`,\n                endkey: `system.adapter.${adapter}${instance !== undefined ? `.${instance}` : ''}\\u9999`,\n            });\n\n            // add non-duplicates to the list (if instance not given -> only for this host)\n            const newObjIDs = doc.rows\n                // only the ones with an ID ...\n                .filter(row => !!row.value._id)\n                //  ... that matches the pattern\n                .filter(row => instanceRegex.test(row.value._id))\n                // if instance given, also delete it from foreign host else only instance on this host\n                .filter(row => {\n                    if (instance !== undefined || !row.value.common?.host || row.value.common?.host === hostname) {\n                        return true;\n                    }\n                    if (!notDeleted.includes(row.value._id)) {\n                        notDeleted.push(row.value._id);\n                    }\n                    return false;\n                })\n                .map(row => row.value._id)\n                .filter(id => !knownObjIDs.includes(id));\n\n            knownObjIDs.push(...newObjIDs);\n\n            if (newObjIDs.length > 0) {\n                console.log(\n                    `host.${hostname} Counted ${newObjIDs.length} instances of ${adapter}${\n                        instance !== undefined ? `.${instance}` : ''\n                    }`,\n                );\n            }\n        } catch (err) {\n            err !== tools.ERRORS.ERROR_NOT_FOUND &&\n                err.message !== tools.ERRORS.ERROR_NOT_FOUND &&\n                console.error(`host.${hostname} error: ${err.message}`);\n        }\n    }\n\n    /**\n     * Enumerate all meta objects of an adapter\n     *\n     * @param knownObjIDs\n     * @param adapter\n     * @param metaFilesToDelete\n     */\n    async _enumerateAdapterMeta(knownObjIDs: string[], adapter: string, metaFilesToDelete: string[]): Promise<void> {\n        try {\n            const doc = await this.objects.getObjectViewAsync('system', 'meta', {\n                startkey: `${adapter}.`,\n                endkey: `${adapter}.\\u9999`,\n            });\n\n            if (doc.rows.length) {\n                const adapterRegex = new RegExp(`^${adapter}\\\\.`);\n\n                // add non-duplicates to the list\n                const newObjs = doc.rows\n                    .filter(row => row.value._id)\n                    .map(row => row.value._id)\n                    .filter(id => adapterRegex.test(id))\n                    .filter(id => knownObjIDs.indexOf(id) === -1);\n                knownObjIDs.push(...newObjs);\n                // meta ids can also be present as files\n                metaFilesToDelete.push(...newObjs);\n\n                if (newObjs.length) {\n                    console.log(`host.${hostname} Counted ${newObjs.length} meta of ${adapter}`);\n                }\n            }\n        } catch (err) {\n            err !== tools.ERRORS.ERROR_NOT_FOUND &&\n                err.message !== tools.ERRORS.ERROR_NOT_FOUND &&\n                console.error(`host.${hostname} error: ${err.message}`);\n        }\n    }\n\n    private async _enumerateAdapters(\n        knownObjIDs: string[],\n        adapter: string,\n    ): Promise<EXIT_CODES.CANNOT_DELETE_NON_DELETABLE | EXIT_CODES.NO_ERROR | void> {\n        // This does not really enumerate the adapters, but finds the adapter object\n        // if it exists and adds it to the list\n        try {\n            const obj = await this.objects.getObjectAsync(`system.adapter.${adapter}`);\n            if (obj) {\n                if (obj.common && obj.common.nondeletable) {\n                    // If the adapter is non-deletable, mark it as not installed\n                    console.log(\n                        `host.${hostname} Adapter ${adapter} cannot be deleted completely, because it is marked non-deletable.`,\n                    );\n                    obj.common.installedVersion = '';\n                    obj.from = `system.host.${hostname}.cli`;\n                    obj.ts = Date.now();\n                    await this.objects.setObjectAsync(obj._id, obj);\n\n                    return EXIT_CODES.CANNOT_DELETE_NON_DELETABLE;\n                }\n                // The adapter is deletable, remember it for deletion\n                knownObjIDs.push(obj._id);\n                console.log(`host.${hostname} Counted 1 adapter for ${adapter}`);\n\n                return EXIT_CODES.NO_ERROR;\n            }\n        } catch (err) {\n            console.error(`host.${hostname} Cannot enumerate adapters: ${err.message}`);\n        }\n    }\n\n    /**\n     * Enumerates the devices of an adapter (or instance)\n     *\n     * @param knownObjIDs The already known object ids\n     * @param adapter The adapter to enumerate the devices for\n     * @param instance The instance to enumerate the devices for (optional)\n     */\n    private async _enumerateAdapterDevices(knownObjIDs: string[], adapter: string, instance?: number): Promise<void> {\n        const adapterRegex = new RegExp(`^${adapter}${instance !== undefined ? `\\\\.${instance}` : ''}\\\\.`);\n\n        try {\n            const doc = await this.objects.getObjectViewAsync('system', 'device', {\n                startkey: `${adapter}${instance !== undefined ? `.${instance}` : ''}`,\n                endkey: `${adapter}${instance !== undefined ? `.${instance}` : ''}\\u9999`,\n            });\n\n            if (doc.rows.length) {\n                // add non-duplicates to the list\n                const newObjs = doc.rows\n                    .filter(row => row.value._id)\n                    .map(row => row.value._id)\n                    .filter(id => adapterRegex.test(id))\n                    .filter(id => !knownObjIDs.includes(id));\n\n                knownObjIDs.push(...newObjs);\n                if (newObjs.length > 0) {\n                    console.log(\n                        `host.${hostname} Counted ${newObjs.length} devices of ${adapter}${\n                            instance !== undefined ? `.${instance}` : ''\n                        }`,\n                    );\n                }\n            }\n        } catch (err) {\n            err !== tools.ERRORS.ERROR_NOT_FOUND &&\n                err.message !== tools.ERRORS.ERROR_NOT_FOUND &&\n                console.error(`host.${hostname} error: ${err.message}`);\n        }\n    }\n\n    /**\n     * Enumerates the channels of an adapter (or instance)\n     *\n     * @param knownObjIDs The already known object ids\n     * @param adapter The adapter to enumerate the channels for\n     * @param instance The instance to enumerate the channels for (optional)\n     */\n    private async _enumerateAdapterChannels(knownObjIDs: string[], adapter: string, instance?: number): Promise<void> {\n        const adapterRegex = new RegExp(`^${adapter}${instance !== undefined ? `\\\\.${instance}` : ''}\\\\.`);\n        try {\n            const doc = await this.objects.getObjectViewAsync('system', 'channel', {\n                startkey: `${adapter}${instance !== undefined ? `.${instance}` : ''}`,\n                endkey: `${adapter}${instance !== undefined ? `.${instance}` : ''}\\u9999`,\n            });\n\n            if (doc.rows.length) {\n                // add non-duplicates to the list\n                const newObjs = doc.rows\n                    .filter(row => row.value._id)\n                    .map(row => row.value._id)\n                    .filter(id => adapterRegex.test(id))\n                    .filter(id => !knownObjIDs.includes(id));\n\n                knownObjIDs.push(...newObjs);\n                if (newObjs.length > 0) {\n                    console.log(\n                        `host.${hostname} Counted ${newObjs.length} channels of ${adapter}${\n                            instance !== undefined ? `.${instance}` : ''\n                        }`,\n                    );\n                }\n            }\n        } catch (err) {\n            err !== tools.ERRORS.ERROR_NOT_FOUND &&\n                err.message !== tools.ERRORS.ERROR_NOT_FOUND &&\n                console.error(`host.${hostname} error: ${err.message}`);\n        }\n    }\n\n    /**\n     * Enumerates the states of an adapter (or instance)\n     *\n     * @param knownObjIDs The already known object ids\n     * @param adapter The adapter to enumerate the states for\n     * @param instance The instance to enumerate the states for (optional)\n     */\n    async _enumerateAdapterStateObjects(knownObjIDs: string[], adapter: string, instance?: number): Promise<void> {\n        const adapterRegex = new RegExp(`^${adapter}${instance !== undefined ? `\\\\.${instance}` : ''}\\\\.`);\n        const sysAdapterRegex = new RegExp(\n            `^system\\\\.adapter\\\\.${adapter}${instance !== undefined ? `\\\\.${instance}` : ''}\\\\.`,\n        );\n\n        try {\n            let doc = await this.objects.getObjectViewAsync('system', 'state', {\n                startkey: `${adapter}${instance !== undefined ? `.${instance}` : ''}`,\n                endkey: `${adapter}${instance !== undefined ? `.${instance}` : ''}\\u9999`,\n            });\n\n            if (doc.rows.length) {\n                // add non-duplicates to the list\n                const newObjs = doc.rows\n                    .filter(row => row.value._id)\n                    .map(row => row.value._id)\n                    .filter(id => adapterRegex.test(id))\n                    .filter(id => !knownObjIDs.includes(id));\n\n                knownObjIDs.push(...newObjs);\n\n                if (newObjs.length > 0) {\n                    console.log(\n                        `host.${hostname} Counted ${newObjs.length} states of ${adapter}${\n                            instance !== undefined ? `.${instance}` : ''\n                        }`,\n                    );\n                }\n            }\n\n            doc = await this.objects.getObjectViewAsync('system', 'state', {\n                startkey: `system.adapter.${adapter}${instance !== undefined ? `.${instance}` : ''}`,\n                endkey: `system.adapter.${adapter}${instance !== undefined ? `.${instance}` : ''}\\u9999`,\n            });\n\n            if (doc.rows.length) {\n                // add non-duplicates to the list\n                const newObjs = doc.rows\n                    .filter(row => row.value._id)\n                    .map(row => row.value._id)\n                    .filter(id => sysAdapterRegex.test(id))\n                    .filter(id => !knownObjIDs.includes(id));\n\n                knownObjIDs.push(...newObjs);\n\n                if (newObjs.length > 0) {\n                    console.log(\n                        `host.${hostname} Counted ${newObjs.length} states of system.adapter.${adapter}${\n                            instance !== undefined ? `.${instance}` : ''\n                        }`,\n                    );\n                }\n            }\n        } catch (err) {\n            err !== tools.ERRORS.ERROR_NOT_FOUND &&\n                err.message !== tools.ERRORS.ERROR_NOT_FOUND &&\n                console.error(`host.${hostname} error: ${err.message}`);\n        }\n    }\n\n    /**\n     * Enumerates the docs of an adapter (or instance)\n     *\n     * @param knownObjIDs The already known object ids\n     * @param adapter The adapter to enumerate the states for\n     * @param instance The instance to enumerate the states for (optional)\n     */\n    private async _enumerateAdapterDocs(knownObjIDs: string[], adapter: string, instance?: number): Promise<void> {\n        const adapterRegex = new RegExp(`^${adapter}${instance !== undefined ? `\\\\.${instance}` : ''}\\\\.`);\n        const sysAdapterRegex = new RegExp(\n            `^system\\\\.adapter\\\\.${adapter}${instance !== undefined ? `\\\\.${instance}` : ''}\\\\.`,\n        );\n\n        if (instance === undefined) {\n            knownObjIDs.push(`system.host.${hostname}.adapters.${adapter}`);\n        }\n\n        try {\n            const doc = await this.objects.getObjectListAsync({ include_docs: true });\n            if (doc.rows.length) {\n                // add non-duplicates to the list\n                const newObjs = doc.rows\n                    .map(row => row.value._id)\n                    .filter(id => adapterRegex.test(id) || sysAdapterRegex.test(id))\n                    .filter(id => !knownObjIDs.includes(id));\n\n                knownObjIDs.push(...newObjs);\n                if (newObjs.length > 0) {\n                    console.log(\n                        `host.${hostname} Counted ${newObjs.length} objects of ${adapter}${\n                            instance !== undefined ? `.${instance}` : ''\n                        }`,\n                    );\n                }\n            }\n        } catch (err) {\n            err !== tools.ERRORS.ERROR_NOT_FOUND &&\n                err.message !== tools.ERRORS.ERROR_NOT_FOUND &&\n                console.error(`host.${hostname} error: ${err.message}`);\n        }\n    }\n\n    /**\n     * Enumerate all state IDs of an adapter (or instance)\n     *\n     * @param knownStateIDs\n     * @param adapter\n     * @param instance\n     */\n    async _enumerateAdapterStates(knownStateIDs: string[], adapter: string, instance?: number): Promise<void> {\n        for (const pattern of [\n            `io.${adapter}.${instance !== undefined ? `${instance}.` : ''}*`,\n            `messagebox.${adapter}.${instance !== undefined ? `${instance}.` : ''}*`,\n            `log.${adapter}.${instance !== undefined ? `${instance}.` : ''}*`,\n            `${adapter}.${instance !== undefined ? `${instance}.` : ''}*`,\n            `system.adapter.${adapter}.${instance !== undefined ? `${instance}.` : ''}*`,\n        ]) {\n            try {\n                const ids = await this.states.getKeys(pattern);\n                if (ids?.length) {\n                    // add non-duplicates to the list\n                    const newStates = ids.filter(id => !knownStateIDs.includes(id));\n\n                    knownStateIDs.push(...newStates);\n\n                    if (newStates.length) {\n                        console.log(`host.${hostname} Counted ${newStates.length} states (${pattern}) from states`);\n                    }\n                }\n            } catch (err) {\n                console.error(`host.${hostname} Cannot get keys async: ${err.message}`);\n            }\n        }\n    }\n\n    /**\n     * delete WWW pages, objects and meta files\n     *\n     * @param adapter\n     * @param metaFilesToDelete\n     */\n    private async _deleteAdapterFiles(adapter: string, metaFilesToDelete: string[]): Promise<void> {\n        // special files, which are not meta (vis widgets), combined with meta object ids\n        const filesToDelete = [\n            { id: 'vis', name: `widgets/${adapter}` },\n            { id: 'vis', name: `widgets/${adapter}.html` },\n            { id: 'vis-2', name: `widgets/${adapter}` },\n            { id: 'vis-2', name: `widgets/${adapter}.html` },\n            { id: adapter },\n            { id: `${adapter}.admin` },\n            ...metaFilesToDelete.map(id => ({ id })),\n        ];\n\n        for (const file of filesToDelete) {\n            const id = typeof file === 'object' ? file.id : file;\n            try {\n                await this.objects.unlinkAsync(id, file.name ?? '');\n                console.log(`host.${hostname} file ${id + (file.name ? `/${file.name}` : '')} deleted`);\n            } catch (err) {\n                err !== tools.ERRORS.ERROR_NOT_FOUND &&\n                    err.message !== tools.ERRORS.ERROR_NOT_FOUND &&\n                    console.error(`host.${hostname} Cannot delete ${id} files folder: ${err.message}`);\n            }\n        }\n\n        for (const objId of [adapter, `${adapter}.admin`]) {\n            try {\n                await this.objects.delObjectAsync(objId);\n                console.log(`host.${hostname} object ${objId} deleted`);\n            } catch (err) {\n                err !== tools.ERRORS.ERROR_NOT_FOUND &&\n                    err.message !== tools.ERRORS.ERROR_NOT_FOUND &&\n                    console.error(`host.${hostname} cannot delete objects: ${err.message}`);\n            }\n        }\n    }\n\n    private async _deleteAdapterStates(stateIDs: string[]): Promise<void> {\n        if (stateIDs.length > 1_000) {\n            console.log(`host.${hostname} Deleting ${stateIDs.length} state(s). Be patient...`);\n        } else if (stateIDs.length) {\n            console.log(`host.${hostname} Deleting ${stateIDs.length} state(s).`);\n        }\n\n        while (stateIDs.length > 0) {\n            if (stateIDs.length % 200 === 0) {\n                // write a progress report\n                console.log(`host.${hostname}: Only ${stateIDs.length} states left to be deleted.`);\n            }\n            // try to delete the current state\n            try {\n                await this.states.delState(stateIDs.pop()!);\n            } catch (e) {\n                // yep, that works!\n                e !== tools.ERRORS.ERROR_NOT_FOUND &&\n                    e.message !== tools.ERRORS.ERROR_NOT_FOUND &&\n                    console.error(`host.${hostname} Cannot delete states: ${e.message}`);\n            }\n        }\n    }\n\n    private async _deleteAdapterObjects(objIDs: string[]): Promise<void> {\n        if (objIDs.length > 1_000) {\n            console.log(`host.${hostname} Deleting ${objIDs.length} object(s). Be patient...`);\n        } else if (objIDs.length) {\n            console.log(`host.${hostname} Deleting ${objIDs.length} object(s).`);\n        }\n\n        let allEnums;\n\n        if (objIDs.length > 1) {\n            try {\n                // cache all enums, else it will be slow to delete many objects\n                allEnums = await tools.getAllEnums(this.objects);\n            } catch (e) {\n                console.error(`host.${hostname}: Could not retrieve all enums: ${e.message}`);\n            }\n        }\n\n        while (objIDs.length > 0) {\n            if (objIDs.length % 200 === 0) {\n                // write a progress report\n                console.log(`host.${hostname}: Only ${objIDs.length} objects left to be deleted.`);\n            }\n            // try to delete the current object\n            try {\n                const id = objIDs.pop()!;\n                await this.objects.delObjectAsync(id);\n                await tools.removeIdFromAllEnums(this.objects, id, allEnums);\n            } catch (e) {\n                if (e !== tools.ERRORS.ERROR_NOT_FOUND && e.message !== tools.ERRORS.ERROR_NOT_FOUND) {\n                    console.error(`host.${hostname} cannot delete objects: ${e.message}`);\n                }\n            }\n        }\n    }\n\n    /**\n     * Deletes given adapter from filesystem and removes all instances\n     *\n     * @param adapter adapter name\n     */\n    async deleteAdapter(adapter: string): Promise<EXIT_CODES> {\n        const knownObjectIDs: string[] = [];\n        const metaFilesToDelete: string[] = [];\n        const notDeletedObjectIDs: string[] = [];\n        const knownStateIDs: string[] = [];\n        let resultCode = EXIT_CODES.NO_ERROR;\n\n        const _uninstallNpm = async (): Promise<void> => {\n            try {\n                // find the adapter's io-package.json\n                const adapterNpm = `${tools.appName.toLowerCase()}.${adapter}`;\n                const ioPackPath = require.resolve(`${adapterNpm}/io-package.json`);\n                const ioPack = await fs.readJSON(ioPackPath);\n\n                if (!ioPack.common || !ioPack.common.nondeletable) {\n                    await this._npmUninstall(adapterNpm, false);\n                    // after uninstalling, we have to restart the defined adapters\n                    if (ioPack.common.restartAdapters) {\n                        if (!Array.isArray(ioPack.common.restartAdapters)) {\n                            // it's not an array, now it can only be a single adapter as string\n                            if (typeof ioPack.common.restartAdapters !== 'string') {\n                                return;\n                            }\n                            ioPack.common.restartAdapters = [ioPack.common.restartAdapters];\n                        }\n                        if (ioPack.common.restartAdapters.length && ioPack.common.restartAdapters[0]) {\n                            const instances = await tools.getAllInstances(ioPack.common.restartAdapters, this.objects);\n                            if (instances?.length) {\n                                for (const instance of instances) {\n                                    const obj = await this.objects.getObjectAsync(instance);\n                                    // if instance is enabled\n                                    if (obj?.common?.enabled) {\n                                        try {\n                                            obj.common.enabled = false; // disable instance\n                                            obj.from = `system.host.${hostname}.cli`;\n                                            obj.ts = Date.now();\n\n                                            await this.objects.setObjectAsync(obj._id, obj);\n\n                                            obj.common.enabled = true; // enable instance\n\n                                            obj.from = `system.host.${hostname}.cli`;\n                                            obj.ts = Date.now();\n\n                                            await this.objects.setObjectAsync(obj._id, obj);\n                                            console.log(`Adapter \"${obj._id}\" restarted.`);\n                                        } catch (err) {\n                                            console.error(`Cannot restart adapter \"${obj._id}\": ${err.message}`);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            } catch (e) {\n                console.error(`Error deleting adapter ${adapter} from disk: ${e.message}`);\n                console.error(`You might have to delete it yourself!`);\n            }\n        };\n\n        try {\n            // detect if all instances on this host, if not so the www and admin must not be deleted\n            await this._enumerateAdapterInstances(knownObjectIDs, notDeletedObjectIDs, adapter);\n\n            if (notDeletedObjectIDs.length) {\n                // just delete all instances on this host and then delete npm\n                for (const knownObjectID of knownObjectIDs) {\n                    await this.deleteInstance(adapter, parseInt(knownObjectID.split('.').pop()!));\n                }\n\n                // remove adapter from custom\n                await this._removeCustomFromObjects([adapter]);\n                await _uninstallNpm();\n            } else {\n                // we are not allowed to delete the last instance if another instance depends on us\n                const dependentInstance = await this._hasDependentInstances(adapter);\n\n                if (dependentInstance) {\n                    console.log(\n                        `Cannot remove adapter \"${adapter}\", because instance \"${dependentInstance}\" depends on it!`,\n                    );\n                    return EXIT_CODES.CANNOT_DELETE_DEPENDENCY;\n                }\n\n                const instances = knownObjectIDs.map(id => `${adapter}.${id.split('.').pop()}`);\n                await this._enumerateAdapterMeta(knownObjectIDs, adapter, metaFilesToDelete);\n                resultCode = (await this._enumerateAdapters(knownObjectIDs, adapter)) || resultCode;\n\n                await this._enumerateAdapterDevices(knownObjectIDs, adapter);\n                await this._enumerateAdapterChannels(knownObjectIDs, adapter);\n                await this._enumerateAdapterStateObjects(knownObjectIDs, adapter);\n                await this._enumerateAdapterStates(knownStateIDs, adapter);\n                await this._enumerateAdapterDocs(knownObjectIDs, adapter);\n                await this._deleteAdapterFiles(adapter, metaFilesToDelete);\n                await this._deleteAdapterObjects(knownObjectIDs);\n                await this._deleteAdapterStates(knownStateIDs);\n\n                if (this.params.custom) {\n                    // remove adapter from custom\n                    await this._removeCustomFromObjects([...instances, adapter]);\n                }\n\n                await _uninstallNpm();\n            }\n        } catch (e) {\n            console.error(`There was an error uninstalling ${adapter} on ${hostname}: ${e.message}`);\n        }\n\n        return resultCode;\n    }\n\n    /**\n     * Deletes given instance of an adapter\n     *\n     * @param adapter adapter name like hm-rpc\n     * @param instance e.g. 1, if undefined deletes all instances\n     */\n    async deleteInstance(adapter: string, instance?: number): Promise<void | EXIT_CODES.CANNOT_DELETE_DEPENDENCY> {\n        const knownObjectIDs: string[] = [];\n        const knownStateIDs: string[] = [];\n\n        // we are not allowed to delete the last instance if another instance depends on us\n        const dependentInstance = await this._hasDependentInstances(adapter, instance);\n\n        if (dependentInstance) {\n            console.log(\n                `Cannot remove instance \"${adapter}.${instance}\", because instance \"${dependentInstance}\" depends on it!`,\n            );\n            return EXIT_CODES.CANNOT_DELETE_DEPENDENCY;\n        }\n\n        await this._removeInstancesInstalledNodeModules(adapter, instance);\n\n        await this._enumerateAdapterInstances(knownObjectIDs, [], adapter, instance);\n        await this._enumerateAdapterDevices(knownObjectIDs, adapter, instance);\n        await this._enumerateAdapterChannels(knownObjectIDs, adapter, instance);\n        await this._enumerateAdapterStateObjects(knownObjectIDs, adapter, instance);\n        await this._enumerateAdapterStates(knownStateIDs, adapter, instance);\n        await this._enumerateAdapterDocs(knownObjectIDs, adapter, instance);\n\n        await this._deleteAdapterObjects(knownObjectIDs);\n        await this._deleteAdapterStates(knownStateIDs);\n        if (this.params.custom) {\n            // delete instance from custom\n            await this._removeCustomFromObjects([`${adapter}.${instance}`]);\n        }\n    }\n\n    /**\n     * Remove all node modules that has been installed by this instance\n     *\n     * @param adapter adapter name like hm-rpc\n     * @param instance e.g. 1, if undefined deletes all instances\n     */\n    private async _removeInstancesInstalledNodeModules(adapter: string, instance?: number): Promise<void> {\n        const packJson = fs.readJSONSync(path.join(tools.getRootDir(), 'package.json'));\n        const regex = new RegExp(\n            `^@${tools.appNameLowerCase}-${adapter}.${instance !== undefined ? instance : '\\\\d+'}\\\\/.*`,\n            'g',\n        );\n\n        for (const packageName of Object.keys(packJson.dependencies)) {\n            if (regex.test(packageName)) {\n                console.log(`host.${hostname} Removing package ${packageName}`);\n                await this._npmUninstall(packageName, true);\n            }\n        }\n    }\n\n    /**\n     * Removes the custom attribute of the provided adapter/instance\n     *\n     * @param ids - id of the adapter/instance to check for\n     */\n    private async _removeCustomFromObjects(ids: string[]): Promise<void> {\n        // get all objects that have a custom attribute\n        const res = await this.objects.getObjectViewAsync('system', 'custom', {\n            startkey: '',\n            endkey: '\\u9999',\n        });\n\n        if (res && res.rows) {\n            for (const row of res.rows) {\n                let obj;\n                for (const id of ids) {\n                    if (Object.prototype.hasOwnProperty.call(row.value, id)) {\n                        if (!obj) {\n                            obj = await this.objects.getObjectAsync(row.id);\n                        }\n\n                        if (obj?.common?.custom) {\n                            delete obj.common.custom[id];\n                        }\n                    }\n                }\n\n                if (obj) {\n                    // if we have removed a custom attribute, set it to db\n                    await this.objects.setObjectAsync(row.id, obj);\n                }\n            }\n        }\n    }\n\n    /**\n     * Installs an adapter from given url\n     *\n     * @param url url to install adapter from\n     * @param name package name\n     */\n    async installAdapterFromUrl(url: string, name: string): Promise<void> {\n        // If the user provided a URL, try to parse it into known ways to represent a GitHub URL\n        let parsedUrl;\n        try {\n            parsedUrl = new URL(url);\n        } catch {\n            /* ignore, not a valid URL */\n        }\n\n        const debug = process.argv.includes('--debug');\n\n        if (parsedUrl && parsedUrl.hostname === 'github.com') {\n            if (!tools.isGithubPathname(parsedUrl.pathname)) {\n                return console.error(`Cannot install from GitHub. Invalid URL ${url}`);\n            }\n\n            // This is a URL we can parse\n            // @ts-expect-error check if type check above is enough\n            const { repo, user, commit } = tools.parseGithubPathname(parsedUrl.pathname);\n\n            if (!commit) {\n                // No commit given, try to get it from the API\n                try {\n                    const result = await axios(`http://api.github.com/repos/${user}/${repo}/commits`, {\n                        headers: {\n                            'User-Agent': 'ioBroker Adapter install',\n                            // @ts-expect-error should be okay...\n                            validateStatus: status => status === 200,\n                        },\n                    });\n                    if (result.data && Array.isArray(result.data) && result.data.length >= 1 && result.data[0].sha) {\n                        url = `${user}/${repo}#${result.data[0].sha}`;\n                    } else {\n                        console.log(\n                            `Info: Can not get current GitHub commit, only remember that we installed from GitHub.`,\n                        );\n                        url = `${user}/${repo}`;\n                    }\n                } catch (err) {\n                    console.log(\n                        `Info: Can not get current GitHub commit, only remember that we installed from GitHub: ${err.message}`,\n                    );\n                    // Install using the npm GitHub URL syntax `npm i user/repo_name`:\n                    url = `${user}/${repo}`;\n                }\n            } else {\n                // We've extracted all we need from the URL\n                url = `${user}/${repo}#${commit}`;\n            }\n        }\n\n        console.log(`install ${url}`);\n\n        // Try to extract name from URL\n        if (!name) {\n            const reNpmPacket = new RegExp(`^${tools.appName}\\\\.([-_\\\\w\\\\d]+)(@.*)?$`, 'i');\n            const match = reNpmPacket.exec(url); // we have iobroker.adaptername@1.2.3\n            if (match) {\n                name = match[1];\n            } else if (url.match(/\\.(tgz|gz|zip|tar\\.gz)$/)) {\n                const parts = url.split('/');\n                const last = parts.pop()!;\n                const mm = last.match(/\\.([-_\\w]+)-[.\\d]+/);\n                if (mm) {\n                    name = mm[1];\n                }\n            } else {\n                const githubUrlParts = tools.parseShortGithubUrl(url);\n                // Try to extract the adapter name from the GitHub url if possible\n                // Otherwise fall back to the complete URL\n                if (githubUrlParts) {\n                    name = githubUrlParts.repo;\n                } else {\n                    name = url;\n                }\n                // Remove the leading `iobroker.` from the name\n                const reG = new RegExp(`${tools.appName}\\\\.([-_\\\\w\\\\d]+)$`, 'i');\n                const match = reG.exec(name);\n                if (match) {\n                    name = match[1];\n                }\n            }\n        }\n\n        if (name === 'js-controller') {\n            console.error(`Cannot install \"js-controller\" from url, use \"${tools.appName.toLowerCase()} upgrade self\"`);\n            return;\n        }\n\n        const options = {\n            packetName: name,\n        };\n\n        /** list of stopped instances for windows */\n        let stoppedList: ioBroker.InstanceObject[] = [];\n\n        if (osPlatform === 'win32') {\n            stoppedList = await this._getInstancesOfAdapter(name);\n            await this.enableInstances(stoppedList, false);\n        }\n\n        const res = await this._npmInstallWithCheck(url, options, debug);\n        // if we have no installDir, the method has called processExit itself\n        if (!res || !res.installDir) {\n            return;\n        }\n\n        await this.upload.uploadAdapter(name, true, true);\n        await this.upload.uploadAdapter(name, false, true);\n        await this.upload.upgradeAdapterObjects(name);\n\n        // re-enable stopped instances\n        await this.enableInstances(stoppedList, true);\n    }\n\n    /**\n     * Checks if other adapters depend on this adapter\n     *\n     * @param adapter adapter name\n     * @param instance instance, like 1\n     * @returns if dependent exists, returns adapter name\n     */\n    private async _hasDependentInstances(adapter: string, instance?: number): Promise<void | string> {\n        try {\n            // lets get all instances\n            const doc = await this.objects.getObjectViewAsync('system', 'instance', {\n                startkey: 'system.adapter.',\n                endkey: 'system.adapter.\\u9999',\n            });\n\n            let scopedHostname: string | undefined;\n\n            if (instance) {\n                // we need to respect host relative to the instance\n                [scopedHostname] = doc.rows\n                    .filter(row => row.id === `system.adapter.${adapter}.${instance}`)\n                    .map(row => row.value.common.host);\n            }\n\n            // fallback is this host\n            scopedHostname = scopedHostname || hostname;\n\n            for (const row of doc.rows) {\n                if (!row.value?.common) {\n                    // this object seems to be corrupted, so it will not need our adapter\n                    continue;\n                }\n\n                const localDeps = tools.parseDependencies(row.value.common.dependencies);\n\n                for (const localDep of Object.keys(localDeps)) {\n                    if (row.value.common.host === scopedHostname && localDep === adapter) {\n                        if (instance === undefined) {\n                            // this adapter needs us locally and all instances should be deleted\n                            return `${row.value.common.name}.${row.id.split('.').pop()}`;\n                        }\n                        // check if another instance of us exists on this host\n                        if (this._checkDependencyFulfilledThisHost(adapter, instance, doc.rows, scopedHostname)) {\n                            // there are other instances of our adapter - ok\n                            break;\n                        } else {\n                            return `${row.value.common.name}.${row.id.split('.').pop()}`;\n                        }\n                    }\n                }\n\n                const globalDeps = tools.parseDependencies(row.value.common.globalDependencies);\n\n                for (const globalDep of Object.keys(globalDeps)) {\n                    if (globalDep === adapter) {\n                        if (instance === undefined) {\n                            // all instances on this host should be removed, so check if there are some on other hosts\n                            if (this._checkDependencyFulfilledForeignHosts(adapter, doc.rows, scopedHostname)) {\n                                break;\n                            } else {\n                                return row.value.common.name;\n                            }\n                        } else if (\n                            this._checkDependencyFulfilledForeignHosts(adapter, doc.rows, scopedHostname) ||\n                            this._checkDependencyFulfilledThisHost(adapter, instance, doc.rows, scopedHostname)\n                        ) {\n                            // another instance of our adapter is on another host or on ours, no need to search further\n                            break;\n                        } else {\n                            return row.value.common.name;\n                        }\n                    }\n                }\n            }\n        } catch (e) {\n            console.error(`Could not check dependent instances for \"${adapter}\": ${e.message}`);\n        }\n    }\n\n    /**\n     * Checks if adapter can also be found on another host than this\n     *\n     * @param adapter adapter name\n     * @param instancesRows all instances objects view rows\n     * @param scopedHostname hostname which should be assumed as local\n     * @returns true if an instance is present on another host\n     */\n    private _checkDependencyFulfilledForeignHosts(\n        adapter: string,\n        instancesRows: ioBroker.GetObjectViewItem<ioBroker.InstanceObject>[],\n        scopedHostname: string,\n    ): boolean {\n        for (const row of instancesRows) {\n            if (row.value && row.value.common.name === adapter && row.value.common.host !== scopedHostname) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks if another instance then the given is present on this host\n     *\n     * @param adapter adapter name\n     * @param instance instance number like 1\n     * @param instancesRows all instances objects view rows\n     * @param scopedHostname hostname which should be assumed as local\n     * @returns true if another instance is present on this host\n     */\n    private _checkDependencyFulfilledThisHost(\n        adapter: string,\n        instance: number,\n        instancesRows: ioBroker.GetObjectViewItem<ioBroker.InstanceObject>[],\n        scopedHostname: string,\n    ): boolean {\n        for (const row of instancesRows) {\n            if (\n                row.value &&\n                row.value.common.name === adapter &&\n                row.value.common.host === scopedHostname &&\n                parseInt(row.value._id.split('.').pop()!) !== instance\n            ) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Get all instances of an adapter which are on the current host\n     *\n     * @param adapter adapter name\n     */\n    private async _getInstancesOfAdapter(adapter: string): Promise<ioBroker.InstanceObject[]> {\n        const instances = [];\n        const doc = await this.objects.getObjectListAsync({\n            startkey: `system.adapter.${adapter}.`,\n            endkey: `system.adapter.${adapter}.\\u9999`,\n        });\n\n        if (doc) {\n            for (const row of doc.rows) {\n                // stop only started instances on this host\n                if (row.value.common.enabled && hostname === row.value.common.host) {\n                    instances.push(row.value);\n                }\n            }\n        }\n\n        return instances as ioBroker.InstanceObject[];\n    }\n}\n", "export const __import_meta_url =\n  typeof document === 'undefined' ? new (require('url'.replace('', '')).URL)('file:' + __filename).href :\n    (document.currentScript && document.currentScript.src || new URL('main.js', document.baseURI).href)\n"],
  "mappings": "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",
  "names": ["require", "child_process", "semver", "fs", "path", "obj", "err", "axios", "match"]
}
