{
  "version": 3,
  "sources": ["../../../../src/lib/cli/cliHost.ts"],
  "sourcesContent": ["import * as CLI from './messages.js';\nimport { CLICommand, type CLICommandOptions } from './cliCommand.js';\nimport { enumHosts, enumObjects, getObjectFrom, enumInstances } from './cliTools.js';\nimport { tools, EXIT_CODES } from '@iobroker/js-controller-common';\nimport type { Client as ObjectsClient } from '@iobroker/db-objects-redis';\nimport os from 'node:os';\nimport fs from 'fs-extra';\n\n/** Command iobroker host ... */\nexport class CLIHost extends CLICommand {\n    constructor(options: CLICommandOptions) {\n        super(options);\n    }\n\n    /**\n     * Executes a command\n     *\n     * @param args\n     */\n    execute(args: any[]): void {\n        const command = args[0];\n\n        switch (command) {\n            case 'this':\n            case 'self':\n                return this.self(args);\n            case 'set':\n                return this.set(args);\n            case 'remove':\n                return this.remove(args);\n            default:\n                return this.rename(args);\n        }\n    }\n\n    /**\n     * When in single-host mode, changes the hostname of the host and all instances to the current one\n     *\n     * @param _args\n     */\n    self(_args: any[]): void {\n        this.renameHost(undefined, os.hostname());\n    }\n\n    /**\n     * Changes the current host's hostname to the given one\n     *\n     * @param args\n     */\n    set(args: any[]): void {\n        const { callback } = this.options;\n\n        const newHostname: string = args[1];\n        if (!newHostname) {\n            CLI.error.requiredArgumentMissing('newHostname', 'host set newHostname');\n            return void callback(34);\n        }\n\n        this.renameHost(tools.getHostName(), newHostname);\n    }\n\n    /**\n     * Removes the host with the given name\n     *\n     * @param args\n     */\n    remove(args: any[]): void {\n        const { callback, dbConnect } = this.options;\n\n        const hostname: string = args[1];\n        if (!hostname) {\n            CLI.error.requiredArgumentMissing('hostname', 'host remove hostname');\n            return void callback(34);\n        }\n\n        const newHostname = tools.getHostName();\n\n        if (hostname === newHostname) {\n            // avoid object deletion when target host is same host\n            CLI.error.dontRemoveCurrentHost(hostname);\n            return void callback(35);\n        }\n\n        dbConnect(async params => {\n            const { objects, isOffline } = params;\n\n            try {\n                if (!isOffline) {\n                    CLI.error.cannotChangeRunningSystem();\n                    return void callback(EXIT_CODES.CONTROLLER_RUNNING);\n                }\n\n                // Find the requested host object\n                const hosts = await enumHosts(objects);\n                const hostToDelete = hosts.find(host => host?.common.hostname === hostname);\n                if (!hostToDelete) {\n                    CLI.error.hostDoesNotExist(hostname);\n                    return void callback(30);\n                }\n\n                // Delete it\n                try {\n                    await objects.delObjectAsync(hostToDelete._id);\n                } catch (err) {\n                    CLI.error.cannotDeleteObject(hostToDelete._id, err.message);\n                    return void callback(30);\n                }\n\n                // Also delete its states\n                const hostStates = await enumObjects(objects, 'state', `system.host.${hostname}.`);\n                for (const state of hostStates) {\n                    // Therefore delete the old one because we will recreate it under a new name\n                    try {\n                        await objects.delObjectAsync(state._id);\n                        CLI.success.stateDeleted(state._id);\n                    } catch (err) {\n                        CLI.error.cannotDeleteObject(state._id, err.message);\n                    }\n                }\n\n                // Move all instances from the deleted host to the current one\n                const instances = await enumInstances(objects);\n                const instancesToRename = instances.filter(i => i?.common.host === hostname);\n                for (const instance of instancesToRename) {\n                    await changeInstanceHost(objects, instance, newHostname);\n                }\n\n                // Notify the user that we are done\n                CLI.success.hostDeleted(hostname);\n                return void callback(EXIT_CODES.NO_ERROR);\n            } catch (err) {\n                CLI.error.unknown(err.message);\n                return void callback(1);\n            }\n        });\n    }\n\n    /**\n     * Renames the host with the given name to the current one (opposite of `set()`)\n     *\n     * @param args\n     */\n    rename(args: any[]): void {\n        const { callback } = this.options;\n\n        const oldHostname: string = args[0];\n\n        if (!oldHostname) {\n            CLI.error.requiredArgumentMissing('oldHostname', 'host oldHostname');\n            return void callback(34);\n        }\n\n        this.renameHost(oldHostname, os.hostname());\n    }\n\n    /**\n     * Renames the host with the hostname `oldHostname` to the hostname `newHostname`\n     *\n     * @param oldHostname The hostname to rename from or `undefined` to rename all hosts (single-host mode only!)\n     * @param newHostname The hostname to rename to\n     */\n    renameHost(oldHostname: string | undefined, newHostname: string): void {\n        const { callback, dbConnect, showHelp } = this.options;\n        dbConnect(async params => {\n            const { isOffline, objects } = params;\n\n            try {\n                if (!isOffline) {\n                    CLI.error.cannotChangeRunningSystem();\n                    return void callback(EXIT_CODES.CONTROLLER_RUNNING);\n                }\n\n                const hosts = await enumHosts(objects);\n                if (hosts.length > 1 && oldHostname === undefined) {\n                    // iobroker host this/self in multihost is not allowed\n                    CLI.error.noHostThisInMultihost();\n                    showHelp();\n                    return void callback(30);\n                }\n\n                // Does another host with the target name exist?\n                const hostExists = !!hosts.find(obj => obj?.common.hostname === newHostname);\n                if (hostExists) {\n                    // This prevents migration of instances if host already exists, but we need it to prevent\n                    // multiple hosts with same name. Thus we only allow if no instances are on the host\n                    // Note: this is only a heuristic, if problems occur we need a `force` flag\n                    const instances = await enumInstances(objects);\n                    const hasExistingInstances = !!instances.find(instance => instance?.common.host === newHostname);\n\n                    if (hasExistingInstances) {\n                        CLI.error.hostAlreadyExists(newHostname);\n                        return void callback(EXIT_CODES.INSTANCE_ALREADY_EXISTS);\n                    }\n                }\n\n                // Remember the new hostname in the system settings\n                const configFileName = tools.getConfigFileName();\n                const configData = fs.readJSONSync(configFileName);\n                if (configData.system && configData.system.hostname !== newHostname) {\n                    configData.system.hostname = newHostname;\n                    fs.writeFileSync(configFileName, JSON.stringify(configData, null, 2), 'utf8');\n                }\n\n                // Rename the host(s)\n                for (const host of hosts) {\n                    // Remember the current hostname of this object because we need it later\n                    const prevHostname = host.common.hostname;\n\n                    // Rename only the hostname we're supposed to rename!\n                    if (oldHostname && prevHostname !== oldHostname) {\n                        continue;\n                    }\n\n                    // Rename the host object\n                    // Therefore delete the old one because we will recreate it under a new name\n                    try {\n                        await objects.delObjectAsync(host._id);\n                    } catch (err) {\n                        CLI.error.cannotDeleteObject(host._id, err.message);\n                        continue;\n                    }\n\n                    // Now update the object\n                    Object.assign(host, {\n                        _id: `system.host.${newHostname}`,\n                        from: getObjectFrom(),\n                        ts: Date.now(),\n                    });\n                    Object.assign(host.common, {\n                        name: host._id,\n                        hostname: newHostname,\n                        address: [],\n                        cmd: '',\n                        native: { process: {}, os: {}, hardware: {} },\n                    });\n                    // And save it\n                    try {\n                        await objects.setObjectAsync(host._id, host);\n                    } catch (err) {\n                        CLI.error.cannotChangeObject(host._id, err.message);\n                        continue;\n                    }\n\n                    // Rename its states\n                    const hostStateObjects = await enumObjects(objects, 'state', `system.host.${prevHostname}.`);\n                    const hostFolders = await enumObjects(objects, 'folder', `system.host.${prevHostname}.`);\n                    for (const object of [...hostStateObjects, ...hostFolders]) {\n                        // Therefore delete the old one because we will recreate it under a new name\n                        try {\n                            await objects.delObjectAsync(object._id);\n                        } catch (err) {\n                            CLI.error.cannotDeleteObject(object._id, err.message);\n                            continue;\n                        }\n\n                        // Now update the object\n                        Object.assign(object, {\n                            _id: object._id.replace(`system.host.${prevHostname}`, `system.host.${newHostname}`),\n                            from: getObjectFrom(),\n                            ts: Date.now(),\n                        });\n\n                        // And save it\n                        try {\n                            await objects.setObjectAsync(object._id, object);\n                        } catch (err) {\n                            CLI.error.cannotChangeObject(object._id, err.message);\n                        }\n                    }\n\n                    CLI.success.hostRenamed(prevHostname, newHostname);\n                }\n\n                // Also rename all instances\n                const instances = await enumInstances(objects);\n                const instancesToRename =\n                    oldHostname === undefined ? instances : instances.filter(i => i.common.host === oldHostname);\n                if (instancesToRename.length > 0) {\n                    for (const instance of instancesToRename) {\n                        // Update each instance object\n                        await changeInstanceHost(objects, instance, newHostname);\n                    }\n                } else {\n                    CLI.warn.noInstancesFoundOnHost(oldHostname);\n                }\n                return void callback(EXIT_CODES.NO_ERROR);\n            } catch (err) {\n                CLI.error.unknown(err.message);\n                return void callback(1);\n            }\n        });\n    }\n}\n\n/**\n * Changes the host an instance is running on\n *\n * @param objects The objects DB to use\n * @param instance The instance object\n * @param newHostname The new hostname the instance should be running on\n */\nasync function changeInstanceHost(\n    objects: ObjectsClient,\n    instance: ioBroker.InstanceObject,\n    newHostname: string,\n): Promise<void> {\n    const oldInstanceHost = instance.common.host;\n    instance.from = getObjectFrom();\n    instance.ts = Date.now();\n    instance.common.host = newHostname;\n    // and save it\n    try {\n        await objects.setObjectAsync(instance._id, instance);\n        CLI.success.instanceHostChanged(instance._id, oldInstanceHost, newHostname);\n    } catch (e) {\n        CLI.error.cannotChangeObject(instance._id, e.message);\n        // resolve anyways, we don't want to cause errors\n    }\n}\n"],
  "mappings": "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",
  "names": ["os", "instances", "fs"]
}
