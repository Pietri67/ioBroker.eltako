"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var utils_exports = {};
__export(utils_exports, {
  getRepository: () => getRepository,
  ignoreVersion: () => ignoreVersion,
  isVersionIgnored: () => isVersionIgnored,
  recognizeVersion: () => recognizeVersion
});
module.exports = __toCommonJS(utils_exports);
var import_js_controller_common = require("@iobroker/js-controller-common");
var import_js_controller_common2 = require("@iobroker/js-controller-common");
var import_semver = __toESM(require("semver"), 1);
var import_customError = require("../../lib/setup/customError.js");
async function getRepository(options) {
  const { objects } = options;
  const { repoName } = options;
  let repoNameOrArray = repoName;
  if (!repoName || repoName === "auto") {
    const systemConfig = await objects.getObject("system.config");
    repoNameOrArray = systemConfig.common.activeRepo;
  }
  const repoArr = !Array.isArray(repoNameOrArray) ? [repoNameOrArray] : repoNameOrArray;
  const systemRepos = await objects.getObject("system.repositories");
  const allSources = {};
  let changed = false;
  let anyFound = false;
  for (const repoUrl of repoArr) {
    const repo = systemRepos.native.repositories[repoUrl];
    if (repo) {
      if (typeof repo === "string") {
        systemRepos.native.repositories[repo] = {
          link: repo,
          json: null
        };
        changed = true;
      }
      if (!systemRepos.native.repositories[repoUrl].json) {
        console.log(`Update repository "${repoUrl}" under "${systemRepos.native.repositories[repoUrl].link}"`);
        const data = await import_js_controller_common2.tools.getRepositoryFileAsync(systemRepos.native.repositories[repoUrl].link);
        systemRepos.native.repositories[repoUrl].json = data.json;
        systemRepos.native.repositories[repoUrl].hash = data.hash;
        systemRepos.from = `system.host.${import_js_controller_common2.tools.getHostName()}.cli`;
        systemRepos.ts = (/* @__PURE__ */ new Date()).getTime();
        changed = true;
      }
      if (systemRepos.native.repositories[repoUrl].json) {
        Object.assign(allSources, systemRepos.native.repositories[repoUrl].json);
        anyFound = true;
      }
    }
    if (changed) {
      await objects.setObject("system.repositories", systemRepos);
    }
  }
  if (!anyFound) {
    let message;
    if (repoArr.length) {
      message = `ERROR: No repositories defined matching "${repoArr.join(" | ")}". Please use one of ${Object.keys(systemRepos.native.repositories).map((repo) => `"${repo}"`).join(", ")}.`;
    } else {
      message = `ERROR: No repositories defined. Please define one repository as active: "iob repo set <${Object.keys(systemRepos.native.repositories).join(" | ")}>"`;
    }
    throw new import_customError.IoBrokerError({ message, code: import_js_controller_common.EXIT_CODES.INVALID_REPO });
  } else {
    return allSources;
  }
}
async function isVersionIgnored(options) {
  const { adapterName, version, objects } = options;
  const obj = await objects.getObject(`system.host.${import_js_controller_common2.tools.getHostName()}.adapter.${adapterName}`);
  if (obj?.common.ignoreVersion === void 0) {
    return false;
  }
  return import_semver.default.satisfies(version, obj?.common.ignoreVersion);
}
async function ignoreVersion(options) {
  const { adapterName, version, objects } = options;
  const id = `system.host.${import_js_controller_common2.tools.getHostName()}.adapter.${adapterName}`;
  const obj = await objects.getObject(id);
  if (!obj) {
    throw new import_customError.IoBrokerError({ code: import_js_controller_common.EXIT_CODES.CANNOT_SET_OBJECT, message: `Object "${id}" does not exist` });
  }
  obj.common.ignoreVersion = version;
  await objects.setObject(id, obj);
}
async function recognizeVersion(options) {
  const { adapterName, objects } = options;
  const id = `system.host.${import_js_controller_common2.tools.getHostName()}.adapter.${adapterName}`;
  const obj = await objects.getObject(id);
  if (!obj) {
    throw new import_customError.IoBrokerError({ code: import_js_controller_common.EXIT_CODES.CANNOT_SET_OBJECT, message: `Object "${id}" does not exist` });
  }
  delete obj.common.ignoreVersion;
  await objects.setObject(id, obj);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getRepository,
  ignoreVersion,
  isVersionIgnored,
  recognizeVersion
});
//# sourceMappingURL=utils.js.map
