"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var setupPacketManager_exports = {};
__export(setupPacketManager_exports, {
  PacketManager: () => PacketManager
});
module.exports = __toCommonJS(setupPacketManager_exports);
var import_tools = require("@iobroker/js-controller-common-db/tools");
var LOG_LEVELS;
(function(LOG_LEVELS2) {
  LOG_LEVELS2[LOG_LEVELS2["silly"] = 5] = "silly";
  LOG_LEVELS2[LOG_LEVELS2["debug"] = 4] = "debug";
  LOG_LEVELS2[LOG_LEVELS2["log"] = 3] = "log";
  LOG_LEVELS2[LOG_LEVELS2["info"] = 2] = "info";
  LOG_LEVELS2[LOG_LEVELS2["warn"] = 1] = "warn";
  LOG_LEVELS2[LOG_LEVELS2["error"] = 0] = "error";
})(LOG_LEVELS || (LOG_LEVELS = {}));
class PacketManager {
  manager;
  logger;
  dpkg;
  sudo;
  _readyPromise;
  COMMANDS = {
    listUpgradeable: {
      apt: "list --upgradeable",
      yum: "check-update"
    }
  };
  constructor(options = { logLevel: LOG_LEVELS.info }) {
    this.manager = options?.manager || "";
    this.logger = options?.logger || {
      silly: (text) => options.logLevel >= LOG_LEVELS.silly && console.log(text),
      info: (text) => options.logLevel >= LOG_LEVELS.info && console.log(text),
      log: (text) => options.logLevel >= LOG_LEVELS.log && console.log(text),
      warn: (text) => options.logLevel >= LOG_LEVELS.warn && console.warn(text),
      error: (text) => options.logLevel >= LOG_LEVELS.error && console.error(text),
      debug: (text) => options.logLevel >= LOG_LEVELS.debug && console.log(text)
    };
    this.dpkg = false;
    this.sudo = false;
    this._readyPromise = this._init();
  }
  /** Starts the initialization process */
  async _init() {
    if (process.platform !== "win32") {
      if (!this.manager) {
        const manager = await this._detectManager();
        if (manager) {
          this.logger.debug(`Detected packet manager: ${manager}`);
          this.sudo = await this._isSudoAvailable() && await this._isSudoAvailableForManager();
        }
      }
      this.dpkg = await this._isDpkgAvailable();
      this.logger.debug(`Detected dpkg: ${this.dpkg}`);
    }
  }
  ready() {
    return this._readyPromise;
  }
  /**
   * Tests if the given command can be executed
   *
   * @param cmd The command to test
   * @returns True if the execution was successful, false otherwise
   */
  async _isCmd(cmd) {
    try {
      const { stderr } = await (0, import_tools.execAsync)(cmd);
      return !stderr;
    } catch (e) {
      if (e.stderr === "") {
        return true;
      }
      console.error(e.stderr || e.stdout || e);
      return false;
    }
  }
  async _isDpkgAvailable() {
    try {
      const { stdout, stderr } = await (0, import_tools.execAsync)("dpkg");
      return !!(stdout && stdout.includes("dpkg --help") || stderr && stderr.includes("dpkg --help"));
    } catch (err) {
      if (err.stdout && err.stdout.includes("dpkg --help") || err.stderr && err.stderr.includes("dpkg --help")) {
        return true;
      }
      this.logger.error(`Cannot detect dpkg: ${err.stderr || err.stdout || err}`);
      return false;
    }
  }
  async _isSudoAvailable() {
    try {
      const { stdout, stderr } = await (0, import_tools.execAsync)("sudo");
      return !!(stdout && stdout.includes("sudo -h") || stderr && stderr.includes("sudo -h"));
    } catch (err) {
      if (err.stdout && err.stdout.includes("sudo -h") || err.stderr && err.stderr.includes("sudo -h")) {
        return true;
      }
      this.logger.error(`Cannot detect sudo: ${err.stderr || err.stdout || err}`);
      return false;
    }
  }
  async _isSudoAvailableForManager() {
    try {
      await (0, import_tools.execAsync)(`sudo -n ${this.manager} -v`);
      return true;
    } catch (err) {
      this.logger.error(`Cannot detect \\"sudo -n ${this.manager} -v\\": ${err.stderr || err.stdout || err}`);
      return false;
    }
  }
  /**
   * Detects which package manager is installed. Throws if none can be found
   */
  async _detectManager() {
    for (const cmd of ["apt", "yum"]) {
      if (await this._isCmd(cmd)) {
        this.manager = cmd;
        return cmd;
      }
    }
    this.logger.info("No supported packet manager found");
  }
  /**
   * Updates the sources if apt is used
   */
  async update() {
    await this.ready();
    if (this.manager !== "apt") {
      return;
    }
    try {
      await (0, import_tools.execAsync)(`${(this.sudo ? "sudo " : "") + this.manager} update`);
    } catch (e) {
      this.logger.warn(`Cannot update apt sources: ${e.message}`);
    }
  }
  async _listPackages() {
    if (!this.dpkg) {
      throw new Error("No dpkg detected");
    }
    try {
      const { stdout } = await (0, import_tools.execAsync)(`${this.sudo ? "sudo " : ""}dpkg -l`);
      const res = Buffer.isBuffer(stdout) ? stdout.toString("utf-8") : stdout;
      return res || "";
    } catch {
      return "";
    }
  }
  /**
   * Checks which packages are installed and returns them
   *
   * @param packets The packets to test
   */
  async checkInstalled(packets) {
    if (!(packets instanceof Array)) {
      packets = [packets];
    }
    const installed = await this._listPackages();
    return packets.filter((p) => installed.includes(p));
  }
  /**
   * Installs a single packet using the configured manager and returns the stdout if there was any
   *
   * @param packet The packet to install
   */
  async _installPacket(packet) {
    if (!this.manager) {
      return;
    }
    await (0, import_tools.execAsync)(`${(this.sudo ? "sudo " : "") + this.manager} install ${packet} -y`);
  }
  /**
   * List all packages for which updates are available
   */
  async listUpgradeablePackages() {
    if (!this.manager) {
      return [];
    }
    const { stdout } = await (0, import_tools.execAsync)(`${(this.sudo ? "sudo " : "") + this.manager} ${this.COMMANDS.listUpgradeable[this.manager]}`);
    const res = Buffer.isBuffer(stdout) ? stdout.toString("utf-8") : stdout;
    if (!res) {
      return [];
    }
    const packagesList = res.split("\n").filter((packageInfo) => packageInfo.trim() !== "");
    packagesList.shift();
    return packagesList;
  }
  /**
   * Installs multiple packets. The returned Promise contains the list of failed packets
   *
   * @param packets list of packets to install
   */
  async _installPackets(packets) {
    const failed = [];
    if (packets?.length) {
      for (const packet of packets) {
        try {
          await this._installPacket(packet);
        } catch (err) {
          failed.push(packet);
          this.logger.error(`Cannot install "${packet}": ${err.stderr || err.stdout || err}`);
        }
      }
    }
    return failed;
  }
  /**
   * Upgrade given OS packets to given version or newest available version
   *
   * @param packets the packet names and version information
   */
  async upgrade(packets) {
    await this.ready();
    if (!this.manager) {
      return;
    }
    for (const packet of packets) {
      let upgradeCmd = `upgrade -y ${packet.name}`;
      if (packet.version) {
        if (this.manager === "apt") {
          upgradeCmd += `=${packet.version}`;
        } else {
          upgradeCmd = `install ${packet.name}-${packet.version}`;
        }
      }
      await (0, import_tools.execAsync)(`${(this.sudo ? "sudo " : "") + this.manager} ${upgradeCmd}`);
    }
  }
  /**
   * Installs all given packets
   *
   * @param packets list of packets or single packet to upgrade
   */
  async install(packets) {
    packets = packets || [];
    if (!(packets instanceof Array)) {
      packets = [packets];
    }
    await this.ready();
    packets = packets && packets.filter((p) => p && p.trim());
    if (!packets || !packets.length) {
      return;
    }
    const installed = await this.checkInstalled(packets);
    const notInstalled = packets.filter((packet) => !installed.includes(packet));
    const failed = await this._installPackets(notInstalled);
    if (this.logger) {
      if (failed.length > 0) {
        this.logger.warn(`The following ${this.manager || "OS"} packages could not be installed: ${failed.join(", ")}. Please install them manually.`);
        if (notInstalled.length) {
          this.logger.info(`Installed the following ${this.manager || "OS"} packages: ${notInstalled.join(", ")}`);
        }
        if (installed.length) {
          this.logger.info(`These ${this.manager || "OS"} packages were already installed: ${installed.join(", ")}`);
        }
      }
    }
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  PacketManager
});
//# sourceMappingURL=setupPacketManager.js.map
