"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var cliObjects_exports = {};
__export(cliObjects_exports, {
  CLIObjects: () => CLIObjects
});
module.exports = __toCommonJS(cliObjects_exports);
var import_cliCommand = require("./cliCommand.js");
var CLI = __toESM(require("./messages.js"), 1);
var import_cliTools = require("./cliTools.js");
var import_js_controller_common = require("@iobroker/js-controller-common");
class CLIObjects extends import_cliCommand.CLICommand {
  constructor(options) {
    super(options);
  }
  /**
   * Executes a command
   *
   * @param args
   */
  execute(args) {
    const { callback, showHelp } = this.options;
    const command = args[0];
    switch (command) {
      case "chmod":
        return this.chmod(args);
      case "chown":
        return this.chown(args);
      case "list":
      case "l":
        return this.list(args);
      case "get":
        return this.get(args);
      case "set":
        return this.set(args);
      case "extend":
        return this.extend(args);
      case "delete":
      case "del":
        return this.delete(args);
      case "getDBVersion":
        return this.getDBVersion();
      case "setDBVersion":
        return this.setDBVersion();
      case "activateSets":
        return this.activateSets();
      case "deactivateSets":
        return this.deactivateSets();
      default:
        CLI.error.unknownCommand("object", command);
        showHelp();
        return void callback(3);
    }
  }
  /**
   * Activates the usage of Redis Sets
   */
  activateSets() {
    const { callback, dbConnect } = this.options;
    dbConnect(async (params) => {
      const { states, objects } = params;
      const useSetsIndicator = await objects.getMeta("objects.features.useSets");
      if (!useSetsIndicator || !parseInt(useSetsIndicator)) {
        if (await import_js_controller_common.tools.isHostRunning(objects, states)) {
          console.log("Cannot activate the usage of Redis Sets while one or more hosts are running");
          return void callback(import_js_controller_common.EXIT_CODES.CONTROLLER_RUNNING);
        }
        await objects.activateSets();
        const noMigrated = await objects.migrateToSets();
        if (noMigrated) {
          console.log(`Successfully migrated ${noMigrated} objects to Redis Sets`);
        }
        console.log(`Successfully activated the usage of Redis Sets. Please make sure to only use js-controller 4.0 or higher on all hosts!`);
      } else {
        console.log("Redis Sets are already activated.");
      }
      return void callback(import_js_controller_common.EXIT_CODES.NO_ERROR);
    });
  }
  /**
   * Deactivates the usage of Redis Sets
   */
  deactivateSets() {
    const { callback, dbConnect } = this.options;
    dbConnect(async (params) => {
      const { objects } = params;
      const useSetsIndicator = await objects.getMeta("objects.features.useSets");
      if (useSetsIndicator && parseInt(useSetsIndicator)) {
        await objects.deactivateSets();
        console.log(`Successfully deactivated the usage of Redis Sets.`);
      } else {
        console.log("Redis Sets are already deactivated.");
      }
      return void callback(import_js_controller_common.EXIT_CODES.NO_ERROR);
    });
  }
  /**
   * Get the protocol version
   */
  getDBVersion() {
    const { callback, dbConnect } = this.options;
    dbConnect(async (params) => {
      const { objects } = params;
      const version = await objects.getProtocolVersion();
      console.log(`Current Objects DB protocol version: ${version}`);
      return void callback(import_js_controller_common.EXIT_CODES.NO_ERROR);
    });
  }
  /**
   * Set protocol version
   */
  setDBVersion() {
    const { callback, dbConnect } = this.options;
    dbConnect(async (params) => {
      const { objects } = params;
      const rl = await import("readline-sync");
      let answer = rl.question("Changing the protocol version will restart all hosts! Continue? [N/y]", {
        limit: /^(yes|y|n|no)$/i,
        defaultInput: "no"
      });
      answer = answer.toLowerCase();
      if (answer !== "y" && answer !== "yes") {
        console.log("Protocol version has not been changed!");
        return void callback(import_js_controller_common.EXIT_CODES.NO_ERROR);
      }
      try {
        await objects.setProtocolVersion(this.options.version);
      } catch (e) {
        console.error(`Cannot update protocol version: ${e.message}`);
        return void callback(1);
      }
      console.log(`Objects DB protocol updated to version ${this.options.version}`);
      return void callback(import_js_controller_common.EXIT_CODES.NO_ERROR);
    });
  }
  /**
   * Changes access rights for all objects matching the pattern
   *
   * @param args
   */
  chmod(args) {
    const { callback, dbConnect } = this.options;
    let [modeObject, modeState, pattern] = args.slice(1);
    if (typeof modeObject !== "number") {
      CLI.error.requiredArgumentMissing("mode", "object chmod 644 system.*");
      return void callback(1);
    }
    modeObject = parseInt(modeObject.toString(), 16);
    if (typeof modeState === "number") {
      modeState = parseInt(modeState.toString(), 16);
    } else {
      pattern = modeState;
      modeState = void 0;
    }
    if (pattern === void 0) {
      CLI.error.requiredArgumentMissing("pattern", "object chmod 644 system.*");
      return void callback(1);
    }
    dbConnect((params) => {
      const { objects, states } = params;
      objects.chmodObject(pattern, { user: "system.user.admin", object: modeObject, state: modeState }, (err, processed) => {
        this.printObjectList(objects, states, err?.message, processed);
      });
    });
  }
  /**
   * Changes owner for all objects matching the pattern
   *
   * @param args
   */
  chown(args) {
    const { callback, dbConnect } = this.options;
    let [user, group, pattern] = args.slice(1);
    if (!pattern) {
      pattern = group;
      group = void 0;
    }
    if (!user) {
      CLI.error.requiredArgumentMissing("user", "object chown user system.*");
      return void callback(1);
    } else if (!user.startsWith("system.user.")) {
      user = `system.user.${user}`;
    }
    if (group && !group.startsWith("system.group.")) {
      group = `system.group.${group}`;
    }
    if (!pattern) {
      CLI.error.requiredArgumentMissing("pattern", "object chown user system.*");
      return void callback(1);
    }
    dbConnect((params) => {
      const { objects, states } = params;
      objects.chownObject(pattern, { user: "system.user.admin", owner: user, ownerGroup: group }, (err, processed) => {
        this.printObjectList(objects, states, err?.message, processed);
      });
    });
  }
  /**
   * Lists all objects matching a pattern and their access rights
   *
   * @param args
   */
  list(args) {
    const { callback, dbConnect } = this.options;
    let pattern = args[1];
    if (typeof pattern === "string") {
      pattern = { startkey: pattern.replace("*", ""), endkey: pattern.replace("*", "\u9999") };
    }
    dbConnect((params) => {
      const { objects, states } = params;
      objects.getObjectList(pattern, { user: "system.user.admin", sorted: true }, (err, processed) => {
        this.printObjectList(objects, states, err?.message, processed && processed.rows && processed.rows.map((r) => r.value));
        return void callback(import_js_controller_common.EXIT_CODES.NO_ERROR);
      });
    });
  }
  /**
   * Retrieves an object or its property from the DB and prints it
   *
   * @param args
   */
  get(args) {
    const { callback, pretty, dbConnect } = this.options;
    const [id, propPath] = args.slice(1);
    if (!id) {
      CLI.error.requiredArgumentMissing("id", "object get id [propertypath]");
      return void callback(1);
    }
    dbConnect((params) => {
      const { objects } = params;
      objects.getObject(id, (err, res) => {
        if (err || !res) {
          CLI.error.objectNotFound(id, err?.message);
          return void callback(3);
        }
        if (typeof propPath === "string") {
          try {
            res = deepSelectProperty(res, propPath);
          } catch {
            CLI.error.objectPropertyNotFound(id, propPath);
            return void callback(3);
          }
        }
        console.log((0, import_cliTools.formatValue)(res, pretty));
        return void callback(import_js_controller_common.EXIT_CODES.NO_ERROR);
      });
    });
  }
  /**
   * Updates an object or its property with the given value
   *
   * @param args
   */
  set(args) {
    const { callback, dbConnect } = this.options;
    const id = args[1];
    if (!id) {
      CLI.error.requiredArgumentMissing("id", "object set id [propertypath=]value");
      return void callback(1);
    }
    const lastArg = args.length >= 2 ? args.slice(2).join(" ") : void 0;
    const parsedArg = parsePropPathAndAssignment(lastArg);
    if (!parsedArg) {
      CLI.error.invalidPropertyOrValue();
      return void callback(3);
    }
    const { propPath, value } = parsedArg;
    dbConnect((params) => {
      const { objects } = params;
      const doSetObject = (obj) => {
        objects.setObject(id, obj, (err) => {
          if (err) {
            CLI.error.cannotUpdateObject(id, err.message);
            return void callback(1);
          }
          CLI.success.objectUpdated(id);
          return void callback(import_js_controller_common.EXIT_CODES.NO_ERROR);
        });
      };
      if (!propPath) {
        doSetObject(value);
      } else {
        objects.getObject(id, async (err, res) => {
          if (err || !res) {
            CLI.error.objectNotFound(id, err?.message);
            return void callback(3);
          }
          try {
            deepSetProperty(res, propPath, value);
          } catch {
            CLI.error.objectPropertyNotFound(id, propPath);
            return void callback(3);
          }
          if (/^system\.adapter\.(?<adapterName>.+)\.(?<instanceNr>\d+)$/g.test(id) && "encryptedNative" in res) {
            await this._autoEncrypt(objects, res, propPath, value);
          }
          doSetObject(res);
        });
      }
    });
  }
  /**
   * Encrypts all newly set properties of encryptedNative - currently customized for propPath
   *
   * @param objects - objects db instance
   * @param res - object which will be adapted
   * @param propPath - path of the changed property
   * @param value - value which has been newly set to the property
   */
  async _autoEncrypt(objects, res, propPath, value) {
    if (/^native\..+[^.]$/g.test(propPath) && typeof value === "string") {
      const prop = propPath.split(".")[1];
      if ("encryptedNative" in res && res.encryptedNative?.includes(prop)) {
        try {
          const config = await objects.getObjectAsync("system.config");
          res.native[prop] = import_js_controller_common.tools.encrypt(config.native.secret, res.native[prop]);
        } catch (e) {
          console.error(`Could not auto-encrypt property "${prop}": ${e.message}`);
        }
      }
    } else if (propPath === "native" && import_js_controller_common.tools.isObject(value)) {
      let config;
      for (const prop in value) {
        if (typeof res.native[prop] === "string" && "encryptedNative" in res && res.encryptedNative?.includes(prop)) {
          try {
            config = config || await objects.getObjectAsync("system.config");
            res.native[prop] = import_js_controller_common.tools.encrypt(config.native.secret, res.native[prop]);
          } catch (e) {
            console.error(`Could not auto-encrypt property "${prop}": ${e.message}`);
          }
        }
      }
    }
  }
  /**
   * Extends an object with the given value
   *
   * @param args
   */
  extend(args) {
    const { callback, dbConnect } = this.options;
    const id = args[1];
    if (!id) {
      CLI.error.requiredArgumentMissing("id", "object extend id <json-value>");
      return void callback(1);
    }
    const lastArg = args.length >= 2 ? args.slice(2).join(" ") : void 0;
    const parsedArg = parsePropPathAndAssignment(lastArg);
    if (!parsedArg || parsedArg.propPath) {
      CLI.error.invalidJSONValue();
      return void callback(3);
    }
    const { value } = parsedArg;
    dbConnect((params) => {
      const { objects } = params;
      objects.extendObject(id, value, null, (err) => {
        if (err) {
          CLI.error.cannotUpdateObject(id, err.message);
          return void callback(1);
        }
        CLI.success.objectUpdated(id);
        return void callback(import_js_controller_common.EXIT_CODES.NO_ERROR);
      });
    });
  }
  /**
   * Collects all object for specific path
   *
   * @param objects class
   * @param params parameters for getObjectView
   */
  async _collectObjects(objects, params) {
    const types = [
      "state",
      "channel",
      "device",
      "enum",
      "instance",
      "host",
      "adapter",
      "meta",
      "config",
      "group",
      "user",
      "script"
    ];
    const result = [];
    for (const type of types) {
      try {
        const res = await objects.getObjectViewAsync("system", type, params);
        res.rows.forEach((item) => {
          if (item.value) {
            result.push(item.value);
          }
        });
      } catch {
      }
    }
    return result;
  }
  /**
   * Delete all object from list sequentially
   *
   * @param objects class
   * @param ids IDs
   * @param callback
   */
  async _deleteObjects(objects, ids, callback) {
    if (!ids || !ids.length) {
      return import_js_controller_common.tools.maybeCallback(callback, import_js_controller_common.EXIT_CODES.NO_ERROR);
    }
    let allEnums;
    try {
      allEnums = await import_js_controller_common.tools.getAllEnums(objects);
    } catch (e) {
      console.error(`Could not retrieve all enums: ${e.message}`);
    }
    for (const id of ids) {
      try {
        await objects.delObjectAsync(id);
        await import_js_controller_common.tools.removeIdFromAllEnums(objects, id, allEnums);
      } catch (e) {
        console.warn(`Could not delete object or remove "${id}" from enums: ${e.message}`);
      }
    }
    return import_js_controller_common.tools.maybeCallback(callback, import_js_controller_common.EXIT_CODES.NO_ERROR);
  }
  /**
   * Deletes an object
   *
   * @param args
   */
  delete(args) {
    const { callback, dbConnect } = this.options;
    const id = args[1];
    if (!id) {
      CLI.error.requiredArgumentMissing("id", "object delete id");
      return void callback(1);
    }
    dbConnect(async (params) => {
      const { objects } = params;
      if (id.endsWith("*")) {
        const params2 = {
          startkey: id.replace(/\*/g, ""),
          endkey: id.replace(/\*/g, "\u9999")
        };
        const result = await this._collectObjects(objects, params2);
        if (!result || !result.length) {
          console.log("No IDs found for this pattern.");
          return void callback(import_js_controller_common.EXIT_CODES.NO_ERROR);
        }
        const ids = result.map((item) => item._id);
        if (!this.options.f && this.options.y && !this.options.yes) {
          const rl = (await import("node:readline")).createInterface({
            input: process.stdin,
            output: process.stdout
          });
          rl.question(`${result.length} object(s) will be deleted. Are you sure? [y/N]: `, (answer) => {
            rl.close();
            if (answer === "y" || answer === "yes" || answer === "j" || answer === "ja" || answer === "\u0434\u0430" || answer === "\u0434") {
              this._deleteObjects(objects, ids, callback);
            } else {
              console.log("Aborted.");
              return void callback(3);
            }
          });
        } else {
          this._deleteObjects(objects, ids, callback);
        }
      } else {
        objects.delObject(id, async (err) => {
          if (err) {
            CLI.error.objectNotFound(id, err.message);
            callback(3);
          } else {
            try {
              await import_js_controller_common.tools.removeIdFromAllEnums(objects, id);
              CLI.success.objectDeleted(id);
              callback(import_js_controller_common.EXIT_CODES.NO_ERROR);
            } catch (e) {
              CLI.error.cannotDeleteObjectFromEnums(id, e.message);
              callback(3);
            }
          }
        });
      }
    });
  }
  /**
   * Prints a list of objects and its access properties
   *
   * @param objects objects db
   * @param states states db
   * @param err An error (if one occurred)
   * @param objList The object list to print
   */
  async printObjectList(objects, states, err, objList) {
    const { callback } = this.options;
    if (err) {
      console.error(err);
      return void callback(33);
    }
    if (objList !== null && objList !== void 0) {
      const { List } = await import("../setup/setupList.js");
      const list = new List({
        states,
        objects,
        processExit: callback
      });
      list.showObjectHeader();
      objList.forEach(list.showObject);
    }
    setTimeout(callback, 1e3);
  }
}
function reverseString(str) {
  return Array.from(str).reverse().join("");
}
function normalizePropertyPath(path) {
  const arrayIndexRegex = /(]\d+\[)(?!\.)/g;
  let ret = reverseString(path);
  ret = ret.replace(arrayIndexRegex, "$1.");
  return reverseString(ret);
}
function deepSelectProperty(object, path) {
  function _deepSelectProperty(obj, pathArr) {
    if (!pathArr.length) {
      return obj;
    }
    let propName = pathArr.shift();
    if (/\[\d+]/.test(propName)) {
      propName = parseInt(propName.slice(1, -1));
    }
    return _deepSelectProperty(obj[propName], pathArr);
  }
  path = normalizePropertyPath(path);
  return _deepSelectProperty(object, path.split("."));
}
function deepSetProperty(object, path, value) {
  function _deepSetProperty(obj, pathArr) {
    if (pathArr.length === 1) {
      obj[pathArr[0]] = value;
      return;
    }
    let propName = pathArr.shift();
    if (/\[\d+]/.test(propName)) {
      propName = parseInt(propName.slice(1, -1));
    }
    _deepSetProperty(obj[propName], pathArr);
  }
  path = normalizePropertyPath(path);
  _deepSetProperty(object, path.split("."));
}
function parseCLIValue(arg) {
  try {
    return JSON.parse(arg);
  } catch {
    return arg;
  }
}
function parsePropPathAndAssignment(arg) {
  const equalsIndex = arg.indexOf("=");
  if (equalsIndex > -1) {
    const propPath = arg.substr(0, equalsIndex);
    const valueString = arg.substr(equalsIndex + 1);
    const value = parseCLIValue(valueString);
    return { propPath, value };
  }
  try {
    const value = JSON.parse(arg);
    if (!import_js_controller_common.tools.isObject(value)) {
      return void 0;
    }
    return { value };
  } catch {
    return void 0;
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CLIObjects
});
//# sourceMappingURL=cliObjects.js.map
