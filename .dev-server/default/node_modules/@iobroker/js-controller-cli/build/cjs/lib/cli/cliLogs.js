"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var cliLogs_exports = {};
__export(cliLogs_exports, {
  CLILogs: () => CLILogs
});
module.exports = __toCommonJS(cliLogs_exports);
var __import_meta_url = typeof document === "undefined" ? new (require("url".replace("", ""))).URL("file:" + __filename).href : document.currentScript && document.currentScript.src || new URL("main.js", document.baseURI).href;
var import_cliCommand = require("./cliCommand.js");
var import_js_controller_common = require("@iobroker/js-controller-common");
var import_chokidar = __toESM(require("chokidar"), 1);
var import_fs_extra = __toESM(require("fs-extra"), 1);
var import_node_os = __toESM(require("node:os"), 1);
var import_event_stream = __toESM(require("event-stream"), 1);
var import_node_module = require("node:module");
const require2 = (0, import_node_module.createRequire)(__import_meta_url || `file://${__filename}`);
const { getConfigFileName } = import_js_controller_common.tools;
class CLILogs extends import_cliCommand.CLICommand {
  fileSizes = /* @__PURE__ */ new Map();
  isReady = false;
  constructor(options) {
    super(options);
  }
  /**
   * Executes a command
   *
   * @param args
   * @param params additional parsed CLI parameters
   */
  execute(args, params) {
    const adapterName = args[0];
    const watch = params.watch || params.w;
    const count = params.lines || 1e3;
    const options = {
      complete: this.options.all
    };
    const config = import_fs_extra.default.readJSONSync(require2.resolve(getConfigFileName()));
    const logger = (0, import_js_controller_common.logger)(config.log);
    let fileName = logger.getFileName();
    if (fileName) {
      let lines = import_fs_extra.default.readFileSync(fileName).toString("utf-8").split("\n");
      lines = lines.filter((line) => line);
      if (lines.length > count) {
        lines.splice(0, lines.length - count);
      }
      let regex;
      if (adapterName) {
        regex = new RegExp(`: ${adapterName}\\.`);
        options.regex = regex;
      }
      lines.forEach((line) => {
        if (regex && !regex.test(line)) {
          return;
        }
        console.log(line);
      });
      if (watch) {
        fileName = fileName.replace(/\\/g, "/");
        const parts = fileName.split("/");
        parts.pop();
        import_chokidar.default.watch(`${parts.join("/")}/iobroker*`, {
          awaitWriteFinish: { stabilityThreshold: 500 },
          followSymlinks: false
        }).on("all", this.watchHandler.bind(this, options)).on("ready", () => this.isReady = true);
      }
    } else {
      console.log("No log file found");
    }
  }
  /**
   * Called by chokidar when watched files change
   *
   * @param options some options
   * @param event The type of change
   * @param path Which path has changed
   * @param stats Information about the file
   */
  watchHandler(options, event, path, stats) {
    if (event === "add" || !this.fileSizes.has(path)) {
      this.fileSizes.set(path, stats.size);
      if (stats.size > 0 && (this.isReady || options.complete && this.isTodaysLogfile(path))) {
        this.streamChange(path, 0, options);
      }
    } else if (event === "change") {
      const oldFileSize = this.fileSizes.get(path);
      this.fileSizes.set(path, stats.size);
      if (this.isReady && stats.size > oldFileSize) {
        this.streamChange(path, oldFileSize, options);
      }
    } else if (event === "unlink") {
      this.fileSizes.delete(path);
    }
  }
  /**
   * If the log file belongs to today
   *
   * @param path The log file path
   */
  isTodaysLogfile(path) {
    const YYYYMMDDDate = (/* @__PURE__ */ new Date()).toJSON().slice(0, 10);
    return path.includes(YYYYMMDDDate);
  }
  /**
   * Streams a portion of a file to the console
   *
   * @param path The file to stream
   * @param start The offset in bytes where to start
   * @param options some options
   */
  streamChange(path, start, options) {
    const input = import_fs_extra.default.createReadStream(path, {
      encoding: "utf8",
      start,
      autoClose: true
    });
    if (options.regex) {
      input.pipe(import_event_stream.default.split()).pipe(import_event_stream.default.filterSync((line) => options.regex.test(line))).pipe(import_event_stream.default.mapSync((line) => line + import_node_os.default.EOL)).pipe(process.stdout);
    } else {
      import_js_controller_common.tools.pipeLinewise(input, process.stdout);
    }
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CLILogs
});
//# sourceMappingURL=cliLogs.js.map
