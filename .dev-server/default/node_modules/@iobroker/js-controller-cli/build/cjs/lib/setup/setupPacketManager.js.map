{
  "version": 3,
  "sources": ["../../../../src/lib/setup/setupPacketManager.ts"],
  "sourcesContent": ["import { execAsync, type InternalLogger } from '@iobroker/js-controller-common-db/tools';\n\nenum LOG_LEVELS {\n    silly = 5,\n    debug = 4,\n    log = 3,\n    info = 2,\n    warn = 1,\n    error = 0,\n}\n\ninterface Logger extends InternalLogger {\n    log(message: string): void;\n}\n\ntype Manager = 'apt' | 'yum' | '';\n\ninterface PacketManagerOptions {\n    logLevel: LOG_LEVELS;\n    manager?: Manager;\n    logger?: Logger;\n}\n\nexport interface UpgradePacket {\n    /** Name of the packet which should be upgraded */\n    name: string;\n    /** Optional version */\n    version?: string;\n}\n\nexport class PacketManager {\n    private manager: Manager;\n    private readonly logger: Logger;\n    private dpkg: boolean;\n    private sudo: boolean;\n    private readonly _readyPromise: Promise<void>;\n    private readonly COMMANDS = {\n        listUpgradeable: {\n            apt: 'list --upgradeable',\n            yum: 'check-update',\n        },\n    } as const;\n\n    constructor(options: PacketManagerOptions = { logLevel: LOG_LEVELS.info }) {\n        // detect apt or yum\n        this.manager = options?.manager || '';\n        this.logger = options?.logger || {\n            silly: text => options.logLevel >= LOG_LEVELS.silly && console.log(text),\n            info: text => options.logLevel >= LOG_LEVELS.info && console.log(text),\n            log: text => options.logLevel >= LOG_LEVELS.log && console.log(text),\n            warn: text => options.logLevel >= LOG_LEVELS.warn && console.warn(text),\n            error: text => options.logLevel >= LOG_LEVELS.error && console.error(text),\n            debug: text => options.logLevel >= LOG_LEVELS.debug && console.log(text),\n        };\n        this.dpkg = false;\n        this.sudo = false;\n        this._readyPromise = this._init();\n    }\n\n    /** Starts the initialization process */\n    private async _init(): Promise<void> {\n        if (process.platform !== 'win32') {\n            if (!this.manager) {\n                const manager = await this._detectManager();\n                if (manager) {\n                    this.logger.debug(`Detected packet manager: ${manager}`);\n                    // Check if sudo is available for packet manager and store information\n                    this.sudo = (await this._isSudoAvailable()) && (await this._isSudoAvailableForManager());\n                }\n            }\n\n            // Check if dpkg is available\n            this.dpkg = await this._isDpkgAvailable();\n            this.logger.debug(`Detected dpkg: ${this.dpkg}`);\n        }\n    }\n\n    ready(): Promise<void> {\n        return this._readyPromise;\n    }\n\n    /**\n     * Tests if the given command can be executed\n     *\n     * @param cmd The command to test\n     * @returns True if the execution was successful, false otherwise\n     */\n    private async _isCmd(cmd: string): Promise<boolean> {\n        try {\n            const { stderr } = await execAsync(cmd);\n            return !stderr;\n        } catch (e) {\n            // non zero exit code, however lets check if ok\n            if (e.stderr === '') {\n                return true;\n            }\n            console.error(e.stderr || e.stdout || e);\n            return false;\n        }\n    }\n\n    private async _isDpkgAvailable(): Promise<boolean> {\n        try {\n            const { stdout, stderr } = await execAsync('dpkg');\n            return !!((stdout && stdout.includes('dpkg --help')) || (stderr && stderr.includes('dpkg --help')));\n        } catch (err) {\n            // non zero exit code, however lets check if ok\n            if (\n                (err.stdout && err.stdout.includes('dpkg --help')) ||\n                (err.stderr && err.stderr.includes('dpkg --help'))\n            ) {\n                return true;\n            }\n            this.logger.error(`Cannot detect dpkg: ${err.stderr || err.stdout || err}`);\n            return false;\n        }\n    }\n\n    private async _isSudoAvailable(): Promise<boolean> {\n        try {\n            const { stdout, stderr } = await execAsync('sudo');\n            return !!((stdout && stdout.includes('sudo -h')) || (stderr && stderr.includes('sudo -h')));\n        } catch (err) {\n            // non zero exit code, however lets check if ok\n            if ((err.stdout && err.stdout.includes('sudo -h')) || (err.stderr && err.stderr.includes('sudo -h'))) {\n                return true;\n            }\n            this.logger.error(`Cannot detect sudo: ${err.stderr || err.stdout || err}`);\n            return false;\n        }\n    }\n\n    private async _isSudoAvailableForManager(): Promise<boolean> {\n        try {\n            await execAsync(`sudo -n ${this.manager} -v`);\n            return true;\n        } catch (err) {\n            this.logger.error(`Cannot detect \\\\\"sudo -n ${this.manager} -v\\\\\": ${err.stderr || err.stdout || err}`);\n            return false;\n        }\n    }\n\n    /**\n     * Detects which package manager is installed. Throws if none can be found\n     */\n    private async _detectManager(): Promise<Manager | void> {\n        for (const cmd of ['apt', 'yum'] as const) {\n            if (await this._isCmd(cmd)) {\n                this.manager = cmd;\n                return cmd;\n            }\n        }\n        this.logger.info('No supported packet manager found');\n    }\n\n    /**\n     * Updates the sources if apt is used\n     */\n    async update(): Promise<void> {\n        await this.ready();\n\n        if (this.manager !== 'apt') {\n            // ignore\n            return;\n        }\n\n        try {\n            await execAsync(`${(this.sudo ? 'sudo ' : '') + this.manager} update`);\n        } catch (e) {\n            this.logger.warn(`Cannot update apt sources: ${e.message}`);\n        }\n    }\n\n    private async _listPackages(): Promise<string> {\n        if (!this.dpkg) {\n            throw new Error('No dpkg detected');\n        }\n\n        try {\n            const { stdout } = await execAsync(`${this.sudo ? 'sudo ' : ''}dpkg -l`);\n            const res = Buffer.isBuffer(stdout) ? stdout.toString('utf-8') : stdout;\n            return res || '';\n        } catch {\n            // Ignore error\n            return '';\n        }\n    }\n\n    /**\n     * Checks which packages are installed and returns them\n     *\n     * @param packets The packets to test\n     */\n    async checkInstalled(packets: string[] | string): Promise<string[]> {\n        if (!(packets instanceof Array)) {\n            packets = [packets];\n        }\n\n        const installed = await this._listPackages();\n        return packets.filter(p => installed.includes(p));\n    }\n\n    /**\n     * Installs a single packet using the configured manager and returns the stdout if there was any\n     *\n     * @param packet The packet to install\n     */\n    private async _installPacket(packet: string): Promise<void> {\n        if (!this.manager) {\n            // ignore\n            return;\n        }\n\n        // if it fails, let it throw and get caught by _installPackets\n        await execAsync(`${(this.sudo ? 'sudo ' : '') + this.manager} install ${packet} -y`);\n    }\n\n    /**\n     * List all packages for which updates are available\n     */\n    async listUpgradeablePackages(): Promise<string[]> {\n        if (!this.manager) {\n            return [];\n        }\n\n        const { stdout } = await execAsync(\n            `${(this.sudo ? 'sudo ' : '') + this.manager} ${this.COMMANDS.listUpgradeable[this.manager]}`,\n        );\n\n        const res = Buffer.isBuffer(stdout) ? stdout.toString('utf-8') : stdout;\n\n        if (!res) {\n            return [];\n        }\n\n        const packagesList = res.split('\\n').filter(packageInfo => packageInfo.trim() !== '');\n        // first line is no package, just Listing...\n        packagesList.shift();\n\n        return packagesList;\n    }\n\n    /**\n     * Installs multiple packets. The returned Promise contains the list of failed packets\n     *\n     * @param packets list of packets to install\n     */\n    private async _installPackets(packets: string[]): Promise<string[]> {\n        const failed: string[] = [];\n\n        if (packets?.length) {\n            // Install all packets\n            for (const packet of packets) {\n                try {\n                    await this._installPacket(packet);\n                } catch (err) {\n                    failed.push(packet);\n                    this.logger.error(`Cannot install \"${packet}\": ${err.stderr || err.stdout || err}`);\n                    // Continue with the next packet\n                }\n            }\n        }\n        return failed;\n    }\n\n    /**\n     * Upgrade given OS packets to given version or newest available version\n     *\n     * @param packets the packet names and version information\n     */\n    async upgrade(packets: UpgradePacket[]): Promise<void> {\n        await this.ready();\n\n        if (!this.manager) {\n            return;\n        }\n\n        for (const packet of packets) {\n            let upgradeCmd = `upgrade -y ${packet.name}`;\n\n            if (packet.version) {\n                if (this.manager === 'apt') {\n                    upgradeCmd += `=${packet.version}`;\n                } else {\n                    upgradeCmd = `install ${packet.name}-${packet.version}`;\n                }\n            }\n\n            await execAsync(`${(this.sudo ? 'sudo ' : '') + this.manager} ${upgradeCmd}`);\n        }\n    }\n\n    /**\n     * Installs all given packets\n     *\n     * @param packets list of packets or single packet to upgrade\n     */\n    async install(packets: string[] | string): Promise<void> {\n        packets = packets || [];\n        if (!(packets instanceof Array)) {\n            packets = [packets];\n        }\n\n        await this.ready();\n\n        // Filter empty packets out\n        packets = packets && packets.filter(p => p && p.trim());\n\n        if (!packets || !packets.length) {\n            // nothing must be installed\n            return;\n        }\n        const installed = await this.checkInstalled(packets);\n        const notInstalled = packets.filter(packet => !installed.includes(packet));\n        // Install all non-installed packets\n        const failed = await this._installPackets(notInstalled);\n        if (this.logger) {\n            if (failed.length > 0) {\n                this.logger.warn(\n                    `The following ${this.manager || 'OS'} packages could not be installed: ${failed.join(\n                        ', ',\n                    )}. Please install them manually.`,\n                );\n\n                if (notInstalled.length) {\n                    this.logger.info(\n                        `Installed the following ${this.manager || 'OS'} packages: ${notInstalled.join(', ')}`,\n                    );\n                }\n\n                if (installed.length) {\n                    this.logger.info(\n                        `These ${this.manager || 'OS'} packages were already installed: ${installed.join(', ')}`,\n                    );\n                }\n            }\n        }\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;;;;;AAAA,mBAA+C;AAE/C,IAAK;CAAL,SAAKA,aAAU;AACX,EAAAA,YAAAA,YAAA,OAAA,IAAA,CAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,OAAA,IAAA,CAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,KAAA,IAAA,CAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,MAAA,IAAA,CAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,MAAA,IAAA,CAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,OAAA,IAAA,CAAA,IAAA;AACJ,GAPK,eAAA,aAAU,CAAA,EAAA;AA4BT,MAAO,cAAa;EACd;EACS;EACT;EACA;EACS;EACA,WAAW;IACxB,iBAAiB;MACb,KAAK;MACL,KAAK;;;EAIb,YAAY,UAAgC,EAAE,UAAU,WAAW,KAAI,GAAE;AAErE,SAAK,UAAU,SAAS,WAAW;AACnC,SAAK,SAAS,SAAS,UAAU;MAC7B,OAAO,UAAQ,QAAQ,YAAY,WAAW,SAAS,QAAQ,IAAI,IAAI;MACvE,MAAM,UAAQ,QAAQ,YAAY,WAAW,QAAQ,QAAQ,IAAI,IAAI;MACrE,KAAK,UAAQ,QAAQ,YAAY,WAAW,OAAO,QAAQ,IAAI,IAAI;MACnE,MAAM,UAAQ,QAAQ,YAAY,WAAW,QAAQ,QAAQ,KAAK,IAAI;MACtE,OAAO,UAAQ,QAAQ,YAAY,WAAW,SAAS,QAAQ,MAAM,IAAI;MACzE,OAAO,UAAQ,QAAQ,YAAY,WAAW,SAAS,QAAQ,IAAI,IAAI;;AAE3E,SAAK,OAAO;AACZ,SAAK,OAAO;AACZ,SAAK,gBAAgB,KAAK,MAAK;EACnC;;EAGQ,MAAM,QAAK;AACf,QAAI,QAAQ,aAAa,SAAS;AAC9B,UAAI,CAAC,KAAK,SAAS;AACf,cAAM,UAAU,MAAM,KAAK,eAAc;AACzC,YAAI,SAAS;AACT,eAAK,OAAO,MAAM,4BAA4B,OAAO,EAAE;AAEvD,eAAK,OAAQ,MAAM,KAAK,iBAAgB,KAAQ,MAAM,KAAK,2BAA0B;QACzF;MACJ;AAGA,WAAK,OAAO,MAAM,KAAK,iBAAgB;AACvC,WAAK,OAAO,MAAM,kBAAkB,KAAK,IAAI,EAAE;IACnD;EACJ;EAEA,QAAK;AACD,WAAO,KAAK;EAChB;;;;;;;EAQQ,MAAM,OAAO,KAAW;AAC5B,QAAI;AACA,YAAM,EAAE,OAAM,IAAK,UAAM,wBAAU,GAAG;AACtC,aAAO,CAAC;IACZ,SAAS,GAAG;AAER,UAAI,EAAE,WAAW,IAAI;AACjB,eAAO;MACX;AACA,cAAQ,MAAM,EAAE,UAAU,EAAE,UAAU,CAAC;AACvC,aAAO;IACX;EACJ;EAEQ,MAAM,mBAAgB;AAC1B,QAAI;AACA,YAAM,EAAE,QAAQ,OAAM,IAAK,UAAM,wBAAU,MAAM;AACjD,aAAO,CAAC,EAAG,UAAU,OAAO,SAAS,aAAa,KAAO,UAAU,OAAO,SAAS,aAAa;IACpG,SAAS,KAAK;AAEV,UACK,IAAI,UAAU,IAAI,OAAO,SAAS,aAAa,KAC/C,IAAI,UAAU,IAAI,OAAO,SAAS,aAAa,GAClD;AACE,eAAO;MACX;AACA,WAAK,OAAO,MAAM,uBAAuB,IAAI,UAAU,IAAI,UAAU,GAAG,EAAE;AAC1E,aAAO;IACX;EACJ;EAEQ,MAAM,mBAAgB;AAC1B,QAAI;AACA,YAAM,EAAE,QAAQ,OAAM,IAAK,UAAM,wBAAU,MAAM;AACjD,aAAO,CAAC,EAAG,UAAU,OAAO,SAAS,SAAS,KAAO,UAAU,OAAO,SAAS,SAAS;IAC5F,SAAS,KAAK;AAEV,UAAK,IAAI,UAAU,IAAI,OAAO,SAAS,SAAS,KAAO,IAAI,UAAU,IAAI,OAAO,SAAS,SAAS,GAAI;AAClG,eAAO;MACX;AACA,WAAK,OAAO,MAAM,uBAAuB,IAAI,UAAU,IAAI,UAAU,GAAG,EAAE;AAC1E,aAAO;IACX;EACJ;EAEQ,MAAM,6BAA0B;AACpC,QAAI;AACA,gBAAM,wBAAU,WAAW,KAAK,OAAO,KAAK;AAC5C,aAAO;IACX,SAAS,KAAK;AACV,WAAK,OAAO,MAAM,4BAA4B,KAAK,OAAO,WAAW,IAAI,UAAU,IAAI,UAAU,GAAG,EAAE;AACtG,aAAO;IACX;EACJ;;;;EAKQ,MAAM,iBAAc;AACxB,eAAW,OAAO,CAAC,OAAO,KAAK,GAAY;AACvC,UAAI,MAAM,KAAK,OAAO,GAAG,GAAG;AACxB,aAAK,UAAU;AACf,eAAO;MACX;IACJ;AACA,SAAK,OAAO,KAAK,mCAAmC;EACxD;;;;EAKA,MAAM,SAAM;AACR,UAAM,KAAK,MAAK;AAEhB,QAAI,KAAK,YAAY,OAAO;AAExB;IACJ;AAEA,QAAI;AACA,gBAAM,wBAAU,IAAI,KAAK,OAAO,UAAU,MAAM,KAAK,OAAO,SAAS;IACzE,SAAS,GAAG;AACR,WAAK,OAAO,KAAK,8BAA8B,EAAE,OAAO,EAAE;IAC9D;EACJ;EAEQ,MAAM,gBAAa;AACvB,QAAI,CAAC,KAAK,MAAM;AACZ,YAAM,IAAI,MAAM,kBAAkB;IACtC;AAEA,QAAI;AACA,YAAM,EAAE,OAAM,IAAK,UAAM,wBAAU,GAAG,KAAK,OAAO,UAAU,EAAE,SAAS;AACvE,YAAM,MAAM,OAAO,SAAS,MAAM,IAAI,OAAO,SAAS,OAAO,IAAI;AACjE,aAAO,OAAO;IAClB,QAAQ;AAEJ,aAAO;IACX;EACJ;;;;;;EAOA,MAAM,eAAe,SAA0B;AAC3C,QAAI,EAAE,mBAAmB,QAAQ;AAC7B,gBAAU,CAAC,OAAO;IACtB;AAEA,UAAM,YAAY,MAAM,KAAK,cAAa;AAC1C,WAAO,QAAQ,OAAO,OAAK,UAAU,SAAS,CAAC,CAAC;EACpD;;;;;;EAOQ,MAAM,eAAe,QAAc;AACvC,QAAI,CAAC,KAAK,SAAS;AAEf;IACJ;AAGA,cAAM,wBAAU,IAAI,KAAK,OAAO,UAAU,MAAM,KAAK,OAAO,YAAY,MAAM,KAAK;EACvF;;;;EAKA,MAAM,0BAAuB;AACzB,QAAI,CAAC,KAAK,SAAS;AACf,aAAO,CAAA;IACX;AAEA,UAAM,EAAE,OAAM,IAAK,UAAM,wBACrB,IAAI,KAAK,OAAO,UAAU,MAAM,KAAK,OAAO,IAAI,KAAK,SAAS,gBAAgB,KAAK,OAAO,CAAC,EAAE;AAGjG,UAAM,MAAM,OAAO,SAAS,MAAM,IAAI,OAAO,SAAS,OAAO,IAAI;AAEjE,QAAI,CAAC,KAAK;AACN,aAAO,CAAA;IACX;AAEA,UAAM,eAAe,IAAI,MAAM,IAAI,EAAE,OAAO,iBAAe,YAAY,KAAI,MAAO,EAAE;AAEpF,iBAAa,MAAK;AAElB,WAAO;EACX;;;;;;EAOQ,MAAM,gBAAgB,SAAiB;AAC3C,UAAM,SAAmB,CAAA;AAEzB,QAAI,SAAS,QAAQ;AAEjB,iBAAW,UAAU,SAAS;AAC1B,YAAI;AACA,gBAAM,KAAK,eAAe,MAAM;QACpC,SAAS,KAAK;AACV,iBAAO,KAAK,MAAM;AAClB,eAAK,OAAO,MAAM,mBAAmB,MAAM,MAAM,IAAI,UAAU,IAAI,UAAU,GAAG,EAAE;QAEtF;MACJ;IACJ;AACA,WAAO;EACX;;;;;;EAOA,MAAM,QAAQ,SAAwB;AAClC,UAAM,KAAK,MAAK;AAEhB,QAAI,CAAC,KAAK,SAAS;AACf;IACJ;AAEA,eAAW,UAAU,SAAS;AAC1B,UAAI,aAAa,cAAc,OAAO,IAAI;AAE1C,UAAI,OAAO,SAAS;AAChB,YAAI,KAAK,YAAY,OAAO;AACxB,wBAAc,IAAI,OAAO,OAAO;QACpC,OAAO;AACH,uBAAa,WAAW,OAAO,IAAI,IAAI,OAAO,OAAO;QACzD;MACJ;AAEA,gBAAM,wBAAU,IAAI,KAAK,OAAO,UAAU,MAAM,KAAK,OAAO,IAAI,UAAU,EAAE;IAChF;EACJ;;;;;;EAOA,MAAM,QAAQ,SAA0B;AACpC,cAAU,WAAW,CAAA;AACrB,QAAI,EAAE,mBAAmB,QAAQ;AAC7B,gBAAU,CAAC,OAAO;IACtB;AAEA,UAAM,KAAK,MAAK;AAGhB,cAAU,WAAW,QAAQ,OAAO,OAAK,KAAK,EAAE,KAAI,CAAE;AAEtD,QAAI,CAAC,WAAW,CAAC,QAAQ,QAAQ;AAE7B;IACJ;AACA,UAAM,YAAY,MAAM,KAAK,eAAe,OAAO;AACnD,UAAM,eAAe,QAAQ,OAAO,YAAU,CAAC,UAAU,SAAS,MAAM,CAAC;AAEzE,UAAM,SAAS,MAAM,KAAK,gBAAgB,YAAY;AACtD,QAAI,KAAK,QAAQ;AACb,UAAI,OAAO,SAAS,GAAG;AACnB,aAAK,OAAO,KACR,iBAAiB,KAAK,WAAW,IAAI,qCAAqC,OAAO,KAC7E,IAAI,CACP,iCAAiC;AAGtC,YAAI,aAAa,QAAQ;AACrB,eAAK,OAAO,KACR,2BAA2B,KAAK,WAAW,IAAI,cAAc,aAAa,KAAK,IAAI,CAAC,EAAE;QAE9F;AAEA,YAAI,UAAU,QAAQ;AAClB,eAAK,OAAO,KACR,SAAS,KAAK,WAAW,IAAI,qCAAqC,UAAU,KAAK,IAAI,CAAC,EAAE;QAEhG;MACJ;IACJ;EACJ;;",
  "names": ["LOG_LEVELS"]
}
