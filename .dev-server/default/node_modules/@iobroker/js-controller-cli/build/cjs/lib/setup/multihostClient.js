"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var multihostClient_exports = {};
__export(multihostClient_exports, {
  MHClient: () => MHClient
});
module.exports = __toCommonJS(multihostClient_exports);
var import_node_dgram = __toESM(require("node:dgram"), 1);
var import_js_controller_common = require("@iobroker/js-controller-common");
var import_node_crypto = __toESM(require("node:crypto"), 1);
const PORT = 50005;
const MULTICAST_ADDR = "239.255.255.250";
class MHClient {
  id = 1;
  timer = null;
  server;
  /**
   * Stops the MH server
   */
  stopServer() {
    if (this.server) {
      try {
        this.server.close();
      } catch {
      }
      this.server = void 0;
    }
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = null;
    }
  }
  /**
   * Calculate the SHA
   *
   * @param secret the MH secret
   * @param salt the MH salt
   * @param callback
   */
  sha(secret, salt, callback) {
    const hash = import_node_crypto.default.createHash("sha256");
    hash.on("readable", function() {
      const data = hash.read();
      if (data) {
        callback(data.toString("hex"));
      }
    });
    hash.write(secret + salt);
    hash.end();
  }
  /**
   * Starts the MH server
   *
   * @param isBroadcast if server should receive broadcast
   * @param timeout timeout after which MH server will be closed
   * @param onReady ready handler
   * @param onMessage message handler, if return true here, server will be stopped
   * @param onFinished finished handler
   */
  startServer(isBroadcast, timeout, onReady, onMessage, onFinished) {
    if (this.server) {
      onFinished(new Error("Some operation still active"));
      return;
    }
    this.server = import_node_dgram.default.createSocket("udp4");
    timeout = timeout || 2e3;
    this.timer = setTimeout(() => {
      if (this.server) {
        this.stopServer();
        onFinished();
      }
    }, timeout);
    this.server.on("error", (err) => {
      if (this.server) {
        this.stopServer();
        onFinished(err);
      }
    });
    this.server.on("message", (msg, rinfo) => {
      try {
        const message = JSON.parse(msg.toString());
        if (this.server) {
          if (onMessage(message, rinfo)) {
            this.stopServer();
          }
        }
      } catch {
        console.error(`Multihost discovery client: Invalid answer: ${msg.toString()}`);
      }
    });
    this.server.on("listening", () => {
      if (isBroadcast) {
        this.server.setBroadcast(true);
      }
      onReady();
    });
    this.server.bind();
  }
  /**
   * Start MH browsing for server
   *
   * @param timeout timeout to stop browsing
   * @param isDebug debug will also show local addresses
   */
  browse(timeout, isDebug) {
    const result = [];
    const ownIps = import_js_controller_common.tools.findIPs();
    return new Promise((resolve, reject) => {
      this.startServer(true, timeout, () => {
        const text = JSON.stringify({
          cmd: "browse",
          id: ++this.id
        });
        this.server.send(text, 0, text.length, PORT, MULTICAST_ADDR);
      }, (msg, rinfo) => {
        if (isDebug || !import_js_controller_common.tools.isLocalAddress(rinfo.address) && !ownIps.includes(rinfo.address)) {
          if (msg.result === "not authenticated") {
            result.push({
              ip: rinfo.address,
              hostname: rinfo.address,
              info: "authentication required",
              auth: msg.auth
            });
          } else if (msg.result === "ok") {
            result.push(msg);
          } else {
            console.log(`Multihost discovery client: Unknown answer: ${JSON.stringify(msg)}`);
          }
        }
        if (isDebug) {
          console.log(JSON.stringify(msg));
        }
        return false;
      }, (err) => {
        if (err) {
          reject(err);
          return;
        }
        resolve(result);
      });
    });
  }
  /**
   * Connect to server
   *
   * @param ip ip address of server
   * @param password password for authentication
   * @param callback
   */
  connect(ip, password, callback) {
    let callCb = true;
    this.startServer(false, 2e3, () => {
      const text = JSON.stringify({
        cmd: "browse",
        id: ++this.id
      });
      this.server.send(text, 0, text.length, PORT, ip);
    }, (msg, rinfo) => {
      if (msg.cmd === "browse" && msg.id === this.id) {
        if (msg.result === "ok") {
          if (callCb) {
            if (!msg.objects) {
              callback(new Error(`Invalid configuration received: ${JSON.stringify(msg)}`));
              callCb = false;
            } else if (!msg.states) {
              callback(new Error(`Invalid configuration received: ${JSON.stringify(msg)}`));
              callCb = false;
            } else {
              if (typeof callback === "function") {
                callback(void 0, msg.objects, msg.states, rinfo.address);
              }
            }
          }
        } else if (msg.result === "not authenticated") {
          if (!password) {
            if (callCb) {
              callback(new Error(`not authenticated: ${JSON.stringify(msg)}`));
              callCb = false;
            }
          } else {
            this.sha(password, msg.salt, (shaText) => {
              const text = JSON.stringify({
                cmd: "browse",
                id: ++this.id,
                password: shaText
              });
              this.server.send(text, 0, text.length, PORT, ip);
            });
            return false;
          }
        } else if (msg.result === "invalid password") {
          if (callCb) {
            callback(new Error("invalid password"));
            callCb = false;
          }
        } else {
          console.log(msg.result);
        }
        return true;
      }
      console.warn(`Multihost discovery client: Unexpected message: ${JSON.stringify(msg)}`);
      return false;
    }, function onFinished(err) {
      if (callCb) {
        callback(err);
        callCb = false;
      }
    });
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  MHClient
});
//# sourceMappingURL=multihostClient.js.map
