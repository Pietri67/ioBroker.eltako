"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var setupMultihost_exports = {};
__export(setupMultihost_exports, {
  Multihost: () => Multihost
});
module.exports = __toCommonJS(setupMultihost_exports);
var import_fs_extra = __toESM(require("fs-extra"), 1);
var import_node_path = __toESM(require("node:path"), 1);
var import_node_readline = __toESM(require("node:readline"), 1);
var import_js_controller_common = require("@iobroker/js-controller-common");
var import_js_controller_common2 = require("@iobroker/js-controller-common");
var import_multihostClient = require("./multihostClient.js");
var import_readline_sync = __toESM(require("readline-sync"), 1);
var import_prompt = __toESM(require("prompt"), 1);
class Multihost {
  configName;
  params;
  objects;
  constructor(options) {
    this.configName = import_js_controller_common.tools.getConfigFileName();
    this.params = options.params || {};
    this.objects = options.objects;
  }
  /**
   * Retrieve config (iobroker.json content)
   */
  getConfig() {
    let config;
    try {
      if (import_fs_extra.default.existsSync(this.configName)) {
        config = import_fs_extra.default.readJsonSync(this.configName);
      } else {
        config = import_fs_extra.default.readJsonSync(import_node_path.default.join(import_js_controller_common.tools.getControllerDir(), "conf", `${import_js_controller_common.tools.appName.toLowerCase()}-dist.json`));
      }
    } catch {
      config = import_fs_extra.default.readJsonSync(import_node_path.default.join(import_js_controller_common.tools.getControllerDir(), "conf", `${import_js_controller_common.tools.appName.toLowerCase()}-dist.json`));
    }
    return config;
  }
  /**
   * Show hosts on CLI
   *
   * @param list list of hosts
   */
  showHosts(list) {
    if (!list || !list.length) {
      console.info("No Multihost server found. Make sure iobroker is running on the host where you enabled multihost discovery (and it is not this host)!");
    } else {
      for (let i = 0; i < list.length; i++) {
        console.log(`${i + 1} | ${list[i].hostname.padStart(20)} | ${list[i].slave ? "slave" : " host"} | ${list[i].ip.padStart(20)} | ${JSON.stringify(list[i].info)}`);
      }
    }
  }
  /**
   * Start MH browsing
   */
  async browse() {
    const mhClient = new import_multihostClient.MHClient();
    try {
      const res = await mhClient.browse(2e3, !!this.params.debug);
      return res;
    } catch (e) {
      throw new Error(`Multihost discovery client: Cannot browse: ${e.message}`);
    }
  }
  /**
   * Show MH state on CLI
   *
   * @param config iob config
   * @param changed if config has changed
   */
  async showMHState(config, changed) {
    if (config.multihostService.enabled) {
      let warningShown = false;
      const hasLocalObjectsServer = await (0, import_js_controller_common2.isLocalObjectsDbServer)(config.objects.type, config.objects.host, true);
      if (hasLocalObjectsServer) {
        console.log("Changing objects server to accept connections on all IP addresses.");
        config.objects.host = import_js_controller_common.tools.getListenAllAddress();
        changed = true;
      } else if (config.objects.type === "redis") {
        warningShown = true;
        console.log(`Please check the binding of redis service. By default it is only local: http://download.redis.io/redis-stable/redis.conf
Change "bind 127.0.0.1" to "bind ${import_js_controller_common.tools.getListenAllAddress()}" or to others.`);
      } else {
        warningShown = true;
        console.log(`Please check the binding of the configured ${config.objects.type} server to allow remote connections.`);
      }
      const hasLocalStatesServer = await (0, import_js_controller_common2.isLocalStatesDbServer)(config.states.type, config.states.host, true);
      if (hasLocalStatesServer) {
        console.log("Changing states server to accept connections on all IP addresses.");
        config.states.host = import_js_controller_common.tools.getListenAllAddress();
        changed = true;
      } else if (config.states.type === "redis") {
        !warningShown && console.log(`Please check the binding of redis service. By default it is only local: http://download.redis.io/redis-stable/redis.conf
Change "bind 127.0.0.1" to "bind ${import_js_controller_common.tools.getListenAllAddress()}" or to others.`);
      } else {
        !warningShown && console.log(`Please check the binding of the configured ${config.states.type} server to allow remote connections.`);
      }
    }
    if (!changed) {
      console.log("No configuration change needed.");
    } else {
      import_fs_extra.default.writeFileSync(this.configName, JSON.stringify(config, null, 2));
      console.log('Please restart ioBroker for the changes to take effect: "iobroker restart"');
    }
    console.log("\n");
    console.log(`Multihost discovery server: ${config.multihostService.enabled ? "enabled" : "disabled"}`);
    console.log(`Discovery authentication:   ${config.multihostService.secure ? "enabled" : "disabled"}`);
    console.log(`Persistent activation:      ${config.multihostService.enabled && config.multihostService.persist ? "enabled" : "disabled"}`);
    console.log(`Objects:                    ${config.objects.type} on ${config.objects.host}`);
    console.log(`States:                     ${config.states.type} on ${config.states.host}`);
  }
  /**
   * Enables or disables the multihost discovery server in the config json
   *
   * @param isEnable - if the server should be activated or deactivated
   * @param callback - callback function to be executed
   */
  enable(isEnable, callback) {
    let changed = false;
    const config = this.getConfig();
    config.multihostService = config.multihostService || { enabled: false, secure: true };
    if (isEnable && !config.multihostService.enabled) {
      changed = true;
      config.multihostService.enabled = true;
      config.multihostService.password = "";
      console.log("Multihost discovery server activated on this host. If iobroker is currently not running please start befeore trying to discover this host.");
      console.log("Important: Multihost discovery works with UDP packets. Make sure they are routed correctly in your network. If you use Docker you also need to configure this correctly.");
      if (!this.params.persist) {
        console.log("Multihost discovery will be automatically deactivated after 15 minutes. If you want to activate it permanently use the --persist flag");
      }
    } else if (!isEnable && config.multihostService.enabled) {
      changed = true;
      config.multihostService.enabled = false;
      config.multihostService.password = "";
      console.log("Multihost discovery server deactivated on this host.");
    }
    if (this.params.secure === void 0) {
      this.params.secure = true;
    }
    this.params.persist = !!this.params.persist;
    if (isEnable && (config.multihostService.secure !== this.params.secure || config.multihostService.secure && !config.multihostService.password || config.multihostService.persist !== this.params.persist)) {
      changed = true;
      config.multihostService.secure = this.params.secure;
      config.multihostService.persist = this.params.persist;
      console.log(`Discovery authentication ${this.params.secure ? "activated" : "deactivated"}.`);
      if (config.multihostService.secure) {
        import_prompt.default.message = "";
        import_prompt.default.delimiter = "";
        const schema = {
          properties: {
            password: {
              description: "Enter secret phrase for connection:",
              pattern: /^[^'"]+$/,
              message: 'No " are allowed',
              hidden: true
            },
            passwordRepeat: {
              description: "Repeat secret phrase for connection:",
              pattern: /^[^'"]+$/,
              message: 'No " are allowed',
              hidden: true
            }
          }
        };
        import_prompt.default.start();
        import_prompt.default.get(schema, (err, password) => {
          if (password?.password) {
            if (password.password !== password.passwordRepeat) {
              callback(new Error("Secret phrases are not equal!"));
            } else {
              this.objects.getObject("system.config", (err2, obj) => {
                config.multihostService.password = import_js_controller_common.tools.encrypt(obj.native.secret, password.password);
                this.showMHState(config, changed);
                callback();
              });
            }
          } else {
            callback(new Error("No secret phrase entered!"));
          }
        });
      } else {
        this.showMHState(config, changed);
        callback();
      }
    } else {
      this.showMHState(config, changed);
      callback();
    }
  }
  /**
   * Show the MH status
   */
  status() {
    const config = this.getConfig();
    config.multihostService = config.multihostService || { enabled: false, secure: true };
    this.showMHState(config, false);
  }
  /**
   * Read password from cli
   */
  readPassword() {
    return import_readline_sync.default.question("Enter secret phrase for connection: ", { hideEchoBack: true });
  }
  /**
   * Connect to given MH server
   *
   * @param mhClient mhclient used for connection
   * @param ip ip address of server
   * @param pass password
   * @param callback
   */
  connectHelper(mhClient, ip, pass, callback) {
    mhClient.connect(ip, pass, async (err, oObjects, oStates, ipHost) => {
      if (err) {
        callback(new Error(`Cannot connect to "${ip}": ${err.message}`));
      } else if (oObjects && oStates) {
        const config = this.getConfig();
        config.objects = oObjects;
        config.states = oStates;
        const hasLocalObjectsServer = await (0, import_js_controller_common2.isLocalObjectsDbServer)(config.objects.type, config.objects.host, true);
        const hasLocalStatesServer = await (0, import_js_controller_common2.isLocalStatesDbServer)(config.states.type, config.states.host, true);
        if (hasLocalObjectsServer || hasLocalStatesServer) {
          callback(new Error(`IP Address of the remote host is ${import_js_controller_common.tools.getLocalAddress()}. Connections from this host will not be accepted. Please change the configuration of this host to accept remote connections.`));
        } else {
          if (import_js_controller_common.tools.isListenAllAddress(config.states.host)) {
            config.states.host = ipHost ?? "";
          }
          if (import_js_controller_common.tools.isListenAllAddress(config.objects.host)) {
            config.objects.host = ipHost ?? "";
          }
          import_fs_extra.default.writeFileSync(this.configName, JSON.stringify(config, null, 2));
          console.log('Config ok. Please restart ioBroker: "iobroker restart"');
          callback();
        }
      } else {
        callback(new Error("No configuration received!"));
      }
    });
  }
  /**
   * Connect to MH Server
   *
   * @param index index of host to connect to
   * @param pass password
   * @param callback
   */
  async connect(index, pass, callback) {
    if (typeof pass === "function") {
      callback = pass;
      pass = null;
    }
    if (typeof index === "function") {
      callback = index;
      index = null;
    }
    const mhClient = new import_multihostClient.MHClient();
    let list;
    try {
      list = await mhClient.browse(2e3, !!this.params.debug);
    } catch (e) {
      callback(new Error(`Cannot browse: ${e.message}`));
      return;
    }
    this.showHosts(list);
    if (index !== null && index !== void 0 && index > 0) {
      if (list && index < list.length + 1) {
        if (!pass) {
          callback(new Error('No password defined: please use "multihost connect <NUMBER> <PASSWORD>"'));
        } else {
          this.connectHelper(mhClient, list[index - 1].ip, pass, callback);
        }
      } else {
        callback(new Error(`Invalid index: ${index}`));
      }
    } else if (list && list.length) {
      const rl = import_node_readline.default.createInterface({
        input: process.stdin,
        output: process.stdout
      });
      rl.question("Please select host [1]: ", (answer) => {
        if (answer === "" || answer === null || answer === void 0) {
          index = 1;
        }
        index = parseInt(answer, 10) - 1;
        const listEntry = list[index];
        if (!listEntry) {
          rl.close();
          callback(new Error(`Invalid index: ${answer}`));
        } else {
          if (listEntry.auth) {
            const password = this.readPassword();
            if (password) {
              this.connectHelper(mhClient, listEntry.ip, password, callback);
            } else {
              callback(new Error("No password entered!"));
            }
          } else {
            this.connectHelper(mhClient, listEntry.ip, "", callback);
          }
        }
      });
    } else {
      callback(void 0, list);
    }
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Multihost
});
//# sourceMappingURL=setupMultihost.js.map
