{
  "version": 3,
  "sources": ["../../../../src/lib/setup/dbConnection.ts"],
  "sourcesContent": ["import type { DbConnectAsyncReturn, DbConnectCallback } from '../_Types.js';\nimport fs from 'fs-extra';\nimport {\n    getObjectsConstructor,\n    getStatesConstructor,\n    objectsDbHasServer,\n    statesDbHasServer,\n} from '@iobroker/js-controller-common';\nimport { EXIT_CODES } from '@iobroker/js-controller-common';\nimport { tools } from '@iobroker/js-controller-common';\nimport { setTimeout as wait } from 'node:timers/promises';\nimport type { Client as StatesRedisClient } from '@iobroker/db-states-redis';\nimport type { Client as ObjectsInRedisClient } from '@iobroker/db-objects-redis';\nimport path from 'node:path';\nimport type { PluginHandlerSettings } from '@iobroker/plugin-base/types';\nimport { PluginHandler } from '@iobroker/plugin-base';\n\nlet pluginHandler: InstanceType<typeof PluginHandler>;\nlet Objects: typeof ObjectsInRedisClient | null; // constructor\nlet objects: ObjectsInRedisClient | null; // instance\nlet States: typeof StatesRedisClient | null; // constructor\nlet states: StatesRedisClient | null; // instance\n\ninterface DbConnectParams {\n    /** DB connect timeout, default is 10_000 */\n    timeout?: number;\n}\n\nexport function dbConnect(callback: DbConnectCallback): void;\nexport function dbConnect(params: Record<string, any>, callback: DbConnectCallback): void;\nexport function dbConnect(onlyCheck: boolean, params: Record<string, any>, callback: DbConnectCallback): void;\n/**\n * Connects to the DB or tests the connection.\n *\n * @param onlyCheck\n * @param params\n * @param callback\n */\nexport async function dbConnect(\n    onlyCheck: boolean | Record<string, any> | DbConnectCallback,\n    params?: DbConnectParams | DbConnectCallback,\n    callback?: DbConnectCallback,\n): Promise<void> {\n    if (typeof onlyCheck === 'object') {\n        callback = params as DbConnectCallback;\n        params = onlyCheck;\n        onlyCheck = false;\n    }\n    if (typeof onlyCheck === 'function') {\n        callback = onlyCheck;\n        onlyCheck = false;\n    }\n    if (typeof params === 'function') {\n        callback = params;\n        params = {};\n    }\n\n    if (!callback) {\n        throw new Error('No callback for dbConnect');\n    }\n\n    params = params || {};\n\n    const config: ioBroker.IoBrokerJson = fs.readJSONSync(tools.getConfigFileName());\n\n    if (objects && states) {\n        return void callback({ objects, states, isOffline: false, objectsDBType: config.objects.type, config });\n    }\n\n    config.states = config.states || { type: 'jsonl' };\n    config.objects = config.objects || { type: 'jsonl' };\n    // Make sure the DB has enough time (5s). JsonL can take a bit longer if the process just crashed before\n    // because the lockfile might not have been freed.\n    config.states.connectTimeout = Math.max(config.states.connectTimeout || 0, 5_000);\n    config.objects.connectTimeout = Math.max(config.objects.connectTimeout || 0, 5_000);\n\n    Objects = await getObjectsConstructor(); // Objects DB Client object\n    States = await getStatesConstructor(); // States DB Client object\n\n    let isObjectConnected = false;\n    let isStatesConnected = false;\n\n    // Detect timeout or try to open file itself\n    setTimeout(\n        async () => {\n            if (isObjectConnected && isStatesConnected) {\n                return;\n            }\n\n            if (!isObjectConnected) {\n                if (objects) {\n                    // Destroy Client we tried to connect with\n                    await objects.destroy();\n                    objects = null;\n                }\n\n                const hasObjectsServer = await objectsDbHasServer(config.objects.type);\n\n                if (hasObjectsServer) {\n                    // Just open in memory DB itself\n                    Objects = (await import(`@iobroker/db-objects-${config.objects.type}`)).Server;\n                    objects = new Objects!({\n                        connection: config.objects,\n                        logger: {\n                            silly: (_msg: string) => {\n                                /** do not log on this level */\n                            },\n                            debug: (_msg: string) => {\n                                /** do not log on this level */\n                            },\n                            info: (_msg: string) => {\n                                /** do not log on this level */\n                            },\n                            warn: (msg: string) => console.log(msg),\n                            error: (msg: string) => console.log(msg),\n                        },\n                        connected: async () => {\n                            isObjectConnected = true;\n                            if (isStatesConnected && typeof callback === 'function') {\n                                try {\n                                    await initializePlugins(config);\n                                } catch {\n                                    // ignore in silence\n                                }\n                                return void callback({\n                                    objects: objects!,\n                                    states: states!,\n                                    isOffline: true,\n                                    objectsDBType: config.objects.type,\n                                    config,\n                                });\n                            }\n                        },\n                    });\n                } else {\n                    console.log(\n                        `No connection to objects ${config.objects.host}:${config.objects.port}[${config.objects.type}]`,\n                    );\n                    if (onlyCheck) {\n                        callback &&\n                            callback({\n                                objects: objects!,\n                                states: states!,\n                                isOffline: true,\n                                objectsDBType: config.objects.type,\n                                config,\n                            });\n                        callback = undefined;\n                    } else {\n                        return void exitApplicationSave(EXIT_CODES.NO_CONNECTION_TO_OBJ_DB);\n                    }\n                }\n            }\n\n            if (!isStatesConnected) {\n                if (states) {\n                    // Destroy Client we tried to connect with\n                    await states.destroy();\n                    states = null;\n                }\n\n                const hasStatesServer = await statesDbHasServer(config.states.type);\n\n                if (hasStatesServer) {\n                    // Just open in memory DB itself\n                    States = (await import(`@iobroker/db-states-${config.states.type}`)).Server;\n\n                    states = new States!({\n                        connection: config.states,\n                        logger: {\n                            silly: (_msg: string) => {\n                                /** do not log on this level */\n                            },\n                            debug: (_msg: string) => {\n                                /** do not log on this level */\n                            },\n                            info: (_msg: string) => {\n                                /** do not log on this level */\n                            },\n                            warn: (msg: string) => console.log(msg),\n                            error: (msg: string) => console.log(msg),\n                        },\n                        connected: async () => {\n                            isStatesConnected = true;\n                            if (isObjectConnected && typeof callback === 'function') {\n                                try {\n                                    await initializePlugins(config);\n                                } catch {\n                                    // ignore in silence\n                                }\n                                return void callback({\n                                    objects: objects!,\n                                    states: states!,\n                                    isOffline: true,\n                                    objectsDBType: config.objects.type,\n                                    config,\n                                });\n                            }\n                        },\n                        // react on change\n                        // @ts-expect-error todo according to types and first look states.onchange does not exist\n                        change: (id, msg) => states?.onChange(id, msg),\n                    });\n                    // @ts-expect-error todo according to types and first look states.onchange does not exist\n                    states.onChange = null; // here the custom onChange handler could be installed\n                } else {\n                    if (states) {\n                        // Destroy Client we tried to connect with\n                        await (states as StatesRedisClient).destroy();\n                        states = null;\n                    }\n                    if (objects) {\n                        // Destroy Client we tried to connect with\n                        await objects.destroy();\n                        objects = null;\n                    }\n                    console.log(\n                        `No connection to states ${config.states.host}:${config.states.port}[${config.states.type}]`,\n                    );\n                    if (onlyCheck) {\n                        callback &&\n                            callback({\n                                objects: objects!,\n                                states: states!,\n                                isOffline: true,\n                                objectsDBType: config.objects.type,\n                                config,\n                            });\n                        callback = undefined;\n                    } else {\n                        return void exitApplicationSave(EXIT_CODES.NO_CONNECTION_TO_OBJ_DB);\n                    }\n                }\n            }\n\n            await wait((params.timeout || 10_000) + config.objects.connectTimeout);\n\n            // Failsafe\n            if (isObjectConnected && isStatesConnected) {\n                return;\n            }\n\n            console.log('No connection to databases possible ...');\n            if (onlyCheck) {\n                callback &&\n                    callback({\n                        // TODO types: allow null if onlyCheck is true\n                        objects: null as any,\n                        states: null as any,\n                        isOffline: true,\n                        objectsDBType: config.objects.type,\n                        config,\n                    });\n                callback = undefined;\n            } else {\n                return void exitApplicationSave(EXIT_CODES.NO_CONNECTION_TO_OBJ_DB);\n            }\n        },\n        params.timeout || config.objects.connectTimeout * 2,\n    );\n\n    // try to connect as client\n    objects = new Objects({\n        connection: config.objects,\n        logger: {\n            silly: (_msg: string) => {\n                /** do not log on this level */\n            },\n            debug: (_msg: string) => {\n                /** do not log on this level */\n            },\n            info: (_msg: string) => {\n                /** do not log on this level */\n            },\n            warn: (msg: string) => console.log(msg),\n            error: (msg: string) => console.log(msg),\n        },\n        connected: async () => {\n            if (isObjectConnected) {\n                return;\n            }\n            isObjectConnected = true;\n\n            if (isStatesConnected && typeof callback === 'function') {\n                const isOffline = await checkSystemOffline(onlyCheck);\n                try {\n                    await initializePlugins(config);\n                } catch {\n                    // ignore in silence\n                }\n                callback({ objects: objects!, states: states!, isOffline, objectsDBType: config.objects.type, config });\n            }\n        },\n    });\n\n    states = new States({\n        connection: config.states,\n        logger: {\n            silly: (_msg: string) => {\n                /** do not log on this level */\n            },\n            debug: (_msg: string) => {\n                /** do not log on this level */\n            },\n            info: (_msg: string) => {\n                /** do not log on this level */\n            },\n            warn: (msg: string) => console.log(msg),\n            error: (msg: string) => console.log(msg),\n        },\n        connected: async () => {\n            if (isStatesConnected) {\n                return;\n            }\n            isStatesConnected = true;\n\n            if (isObjectConnected && typeof callback === 'function') {\n                const isOffline = await checkSystemOffline(onlyCheck);\n                try {\n                    await initializePlugins(config);\n                } catch {\n                    // ignore in silence\n                }\n                callback({ objects: objects!, states: states!, isOffline, objectsDBType: config.objects.type, config });\n            }\n        },\n        // @ts-expect-error todo according to types and first look states.onchange does not exist\n        change: (id, state) => states?.onChange(id, state),\n    });\n}\n\n/**\n * Connects to the DB or tests the connection.\n *\n * @param onlyCheck if only connection check should be performed\n * @param params options used by dbConnect\n */\nexport function dbConnectAsync(onlyCheck: boolean, params?: DbConnectParams): Promise<DbConnectAsyncReturn> {\n    return new Promise(resolve => dbConnect(onlyCheck, params || {}, params => resolve(params)));\n}\n\n/**\n * Disconnect the database\n */\nexport async function resetDbConnect(): Promise<void> {\n    if (objects) {\n        await objects.destroy();\n        objects = null;\n    }\n    if (states) {\n        await states.destroy();\n        states = null;\n    }\n    if (Objects) {\n        Objects = null;\n    }\n    if (States) {\n        States = null;\n    }\n\n    if (pluginHandler) {\n        pluginHandler.destroyAll();\n    }\n}\n\n/**\n * Exits the process and saves objects before exit - never resolves\n *\n * @param  exitCode code passed to process.exit\n */\nexport async function exitApplicationSave(exitCode?: number): Promise<never> {\n    await resetDbConnect();\n    await wait(1_000);\n    process.exit(exitCode);\n}\n\n/**\n * Initialize plugins from io-pack and config json\n *\n * @param config - parsed content of iobroker.json\n */\nfunction initializePlugins(config: Record<string, any>): Promise<void> {\n    const ioPackage = fs.readJsonSync(path.join(tools.getControllerDir(), 'io-package.json'));\n    const packageJson = fs.readJsonSync(path.join(tools.getControllerDir(), 'package.json'));\n    const hostname = tools.getHostName();\n\n    const pluginSettings: PluginHandlerSettings = {\n        namespace: `system.host.${hostname}`,\n        logNamespace: `host.${hostname}`,\n        scope: 'controller',\n        log: {\n            // cli should be clean, only log warn/error\n            silly: (_msg: string) => {\n                /** do not log on this level */\n            },\n            debug: (_msg: string) => {\n                /** do not log on this level */\n            },\n            info: (_msg: string) => {\n                /** do not log on this level */\n            },\n            warn: (msg: string) => console.log(msg),\n            error: (msg: string) => console.log(msg),\n            level: 'warn',\n        },\n        iobrokerConfig: config,\n        parentPackage: packageJson,\n        controllerVersion: ioPackage.common.version,\n    };\n\n    pluginHandler = new PluginHandler(pluginSettings);\n    pluginHandler.addPlugins(ioPackage.common.plugins, tools.getControllerDir()); // Plugins from io-package have priority over ...\n    pluginHandler.addPlugins(config.plugins, tools.getControllerDir()); // ... plugins from iobroker.json\n    pluginHandler.setDatabaseForPlugins(objects, states);\n\n    return pluginHandler.initPlugins(ioPackage);\n}\n\n/**\n * Checks if system is offline\n *\n * @param onlyCheck - returns true then\n */\nasync function checkSystemOffline(onlyCheck: boolean): Promise<boolean> {\n    if (!objects || !states) {\n        // should never happen\n        return true;\n    }\n    if (onlyCheck) {\n        return true;\n    }\n\n    const offlineStatus = !(await tools.isHostRunning(objects, states));\n\n    return offlineStatus;\n}\n"],
  "mappings": "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",
  "names": ["import_js_controller_common", "fs", "wait", "params", "path"]
}
