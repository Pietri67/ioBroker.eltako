"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var dbConnection_exports = {};
__export(dbConnection_exports, {
  dbConnect: () => dbConnect,
  dbConnectAsync: () => dbConnectAsync,
  exitApplicationSave: () => exitApplicationSave,
  resetDbConnect: () => resetDbConnect
});
module.exports = __toCommonJS(dbConnection_exports);
var import_fs_extra = __toESM(require("fs-extra"), 1);
var import_js_controller_common = require("@iobroker/js-controller-common");
var import_js_controller_common2 = require("@iobroker/js-controller-common");
var import_js_controller_common3 = require("@iobroker/js-controller-common");
var import_promises = require("node:timers/promises");
var import_node_path = __toESM(require("node:path"), 1);
var import_plugin_base = require("@iobroker/plugin-base");
let pluginHandler;
let Objects;
let objects;
let States;
let states;
async function dbConnect(onlyCheck, params, callback) {
  if (typeof onlyCheck === "object") {
    callback = params;
    params = onlyCheck;
    onlyCheck = false;
  }
  if (typeof onlyCheck === "function") {
    callback = onlyCheck;
    onlyCheck = false;
  }
  if (typeof params === "function") {
    callback = params;
    params = {};
  }
  if (!callback) {
    throw new Error("No callback for dbConnect");
  }
  params = params || {};
  const config = import_fs_extra.default.readJSONSync(import_js_controller_common3.tools.getConfigFileName());
  if (objects && states) {
    return void callback({ objects, states, isOffline: false, objectsDBType: config.objects.type, config });
  }
  config.states = config.states || { type: "jsonl" };
  config.objects = config.objects || { type: "jsonl" };
  config.states.connectTimeout = Math.max(config.states.connectTimeout || 0, 5e3);
  config.objects.connectTimeout = Math.max(config.objects.connectTimeout || 0, 5e3);
  Objects = await (0, import_js_controller_common.getObjectsConstructor)();
  States = await (0, import_js_controller_common.getStatesConstructor)();
  let isObjectConnected = false;
  let isStatesConnected = false;
  setTimeout(async () => {
    if (isObjectConnected && isStatesConnected) {
      return;
    }
    if (!isObjectConnected) {
      if (objects) {
        await objects.destroy();
        objects = null;
      }
      const hasObjectsServer = await (0, import_js_controller_common.objectsDbHasServer)(config.objects.type);
      if (hasObjectsServer) {
        Objects = (await import(`@iobroker/db-objects-${config.objects.type}`)).Server;
        objects = new Objects({
          connection: config.objects,
          logger: {
            silly: (_msg) => {
            },
            debug: (_msg) => {
            },
            info: (_msg) => {
            },
            warn: (msg) => console.log(msg),
            error: (msg) => console.log(msg)
          },
          connected: async () => {
            isObjectConnected = true;
            if (isStatesConnected && typeof callback === "function") {
              try {
                await initializePlugins(config);
              } catch {
              }
              return void callback({
                objects,
                states,
                isOffline: true,
                objectsDBType: config.objects.type,
                config
              });
            }
          }
        });
      } else {
        console.log(`No connection to objects ${config.objects.host}:${config.objects.port}[${config.objects.type}]`);
        if (onlyCheck) {
          callback && callback({
            objects,
            states,
            isOffline: true,
            objectsDBType: config.objects.type,
            config
          });
          callback = void 0;
        } else {
          return void exitApplicationSave(import_js_controller_common2.EXIT_CODES.NO_CONNECTION_TO_OBJ_DB);
        }
      }
    }
    if (!isStatesConnected) {
      if (states) {
        await states.destroy();
        states = null;
      }
      const hasStatesServer = await (0, import_js_controller_common.statesDbHasServer)(config.states.type);
      if (hasStatesServer) {
        States = (await import(`@iobroker/db-states-${config.states.type}`)).Server;
        states = new States({
          connection: config.states,
          logger: {
            silly: (_msg) => {
            },
            debug: (_msg) => {
            },
            info: (_msg) => {
            },
            warn: (msg) => console.log(msg),
            error: (msg) => console.log(msg)
          },
          connected: async () => {
            isStatesConnected = true;
            if (isObjectConnected && typeof callback === "function") {
              try {
                await initializePlugins(config);
              } catch {
              }
              return void callback({
                objects,
                states,
                isOffline: true,
                objectsDBType: config.objects.type,
                config
              });
            }
          },
          // react on change
          // @ts-expect-error todo according to types and first look states.onchange does not exist
          change: (id, msg) => states?.onChange(id, msg)
        });
        states.onChange = null;
      } else {
        if (states) {
          await states.destroy();
          states = null;
        }
        if (objects) {
          await objects.destroy();
          objects = null;
        }
        console.log(`No connection to states ${config.states.host}:${config.states.port}[${config.states.type}]`);
        if (onlyCheck) {
          callback && callback({
            objects,
            states,
            isOffline: true,
            objectsDBType: config.objects.type,
            config
          });
          callback = void 0;
        } else {
          return void exitApplicationSave(import_js_controller_common2.EXIT_CODES.NO_CONNECTION_TO_OBJ_DB);
        }
      }
    }
    await (0, import_promises.setTimeout)((params.timeout || 1e4) + config.objects.connectTimeout);
    if (isObjectConnected && isStatesConnected) {
      return;
    }
    console.log("No connection to databases possible ...");
    if (onlyCheck) {
      callback && callback({
        // TODO types: allow null if onlyCheck is true
        objects: null,
        states: null,
        isOffline: true,
        objectsDBType: config.objects.type,
        config
      });
      callback = void 0;
    } else {
      return void exitApplicationSave(import_js_controller_common2.EXIT_CODES.NO_CONNECTION_TO_OBJ_DB);
    }
  }, params.timeout || config.objects.connectTimeout * 2);
  objects = new Objects({
    connection: config.objects,
    logger: {
      silly: (_msg) => {
      },
      debug: (_msg) => {
      },
      info: (_msg) => {
      },
      warn: (msg) => console.log(msg),
      error: (msg) => console.log(msg)
    },
    connected: async () => {
      if (isObjectConnected) {
        return;
      }
      isObjectConnected = true;
      if (isStatesConnected && typeof callback === "function") {
        const isOffline = await checkSystemOffline(onlyCheck);
        try {
          await initializePlugins(config);
        } catch {
        }
        callback({ objects, states, isOffline, objectsDBType: config.objects.type, config });
      }
    }
  });
  states = new States({
    connection: config.states,
    logger: {
      silly: (_msg) => {
      },
      debug: (_msg) => {
      },
      info: (_msg) => {
      },
      warn: (msg) => console.log(msg),
      error: (msg) => console.log(msg)
    },
    connected: async () => {
      if (isStatesConnected) {
        return;
      }
      isStatesConnected = true;
      if (isObjectConnected && typeof callback === "function") {
        const isOffline = await checkSystemOffline(onlyCheck);
        try {
          await initializePlugins(config);
        } catch {
        }
        callback({ objects, states, isOffline, objectsDBType: config.objects.type, config });
      }
    },
    // @ts-expect-error todo according to types and first look states.onchange does not exist
    change: (id, state) => states?.onChange(id, state)
  });
}
function dbConnectAsync(onlyCheck, params) {
  return new Promise((resolve) => dbConnect(onlyCheck, params || {}, (params2) => resolve(params2)));
}
async function resetDbConnect() {
  if (objects) {
    await objects.destroy();
    objects = null;
  }
  if (states) {
    await states.destroy();
    states = null;
  }
  if (Objects) {
    Objects = null;
  }
  if (States) {
    States = null;
  }
  if (pluginHandler) {
    pluginHandler.destroyAll();
  }
}
async function exitApplicationSave(exitCode) {
  await resetDbConnect();
  await (0, import_promises.setTimeout)(1e3);
  process.exit(exitCode);
}
function initializePlugins(config) {
  const ioPackage = import_fs_extra.default.readJsonSync(import_node_path.default.join(import_js_controller_common3.tools.getControllerDir(), "io-package.json"));
  const packageJson = import_fs_extra.default.readJsonSync(import_node_path.default.join(import_js_controller_common3.tools.getControllerDir(), "package.json"));
  const hostname = import_js_controller_common3.tools.getHostName();
  const pluginSettings = {
    namespace: `system.host.${hostname}`,
    logNamespace: `host.${hostname}`,
    scope: "controller",
    log: {
      // cli should be clean, only log warn/error
      silly: (_msg) => {
      },
      debug: (_msg) => {
      },
      info: (_msg) => {
      },
      warn: (msg) => console.log(msg),
      error: (msg) => console.log(msg),
      level: "warn"
    },
    iobrokerConfig: config,
    parentPackage: packageJson,
    controllerVersion: ioPackage.common.version
  };
  pluginHandler = new import_plugin_base.PluginHandler(pluginSettings);
  pluginHandler.addPlugins(ioPackage.common.plugins, import_js_controller_common3.tools.getControllerDir());
  pluginHandler.addPlugins(config.plugins, import_js_controller_common3.tools.getControllerDir());
  pluginHandler.setDatabaseForPlugins(objects, states);
  return pluginHandler.initPlugins(ioPackage);
}
async function checkSystemOffline(onlyCheck) {
  if (!objects || !states) {
    return true;
  }
  if (onlyCheck) {
    return true;
  }
  const offlineStatus = !await import_js_controller_common3.tools.isHostRunning(objects, states);
  return offlineStatus;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  dbConnect,
  dbConnectAsync,
  exitApplicationSave,
  resetDbConnect
});
//# sourceMappingURL=dbConnection.js.map
