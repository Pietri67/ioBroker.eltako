"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var cliPlugin_exports = {};
__export(cliPlugin_exports, {
  CLIPlugin: () => CLIPlugin
});
module.exports = __toCommonJS(cliPlugin_exports);
var __import_meta_url = typeof document === "undefined" ? new (require("url".replace("", ""))).URL("file:" + __filename).href : document.currentScript && document.currentScript.src || new URL("main.js", document.baseURI).href;
var CLI = __toESM(require("./messages.js"), 1);
var import_cliCommand = require("./cliCommand.js");
var import_cliTools = require("./cliTools.js");
var import_js_controller_common = require("@iobroker/js-controller-common");
var import_fs_extra = __toESM(require("fs-extra"), 1);
var import_node_path = __toESM(require("node:path"), 1);
var import_node_module = require("node:module");
const require2 = (0, import_node_module.createRequire)(__import_meta_url || `file://${__filename}`);
const controllerIoPackPath = require2.resolve("iobroker.js-controller/io-package.json");
class CLIPlugin extends import_cliCommand.CLICommand {
  /** @param options the cli command options */
  constructor(options) {
    super(options);
  }
  /**
   * Executes a command
   *
   * @param args parsed cli args
   */
  execute(args) {
    const { callback, showHelp } = this.options;
    const command = args[0];
    switch (command) {
      case "on":
      case "enable":
        return this.set(args, true);
      case "off":
      case "disable":
        return this.set(args, false);
      case "status":
        return this.status(args);
      default:
        CLI.error.unknownCommand("plugin", command);
        showHelp();
        return void callback(3);
    }
  }
  /**
   * Enables or disables the given plugin
   *
   * @param args the parsed CLI args
   * @param enabled if plugin should be enabled
   */
  set(args, enabled) {
    const { callback, dbConnect } = this.options;
    const pluginName = args[1];
    if (!pluginName) {
      CLI.error.requiredArgumentMissing("pluginName", "plugin enable <pluginname>");
      return void callback(34);
    }
    let hostname;
    let instance;
    if (this.options.adapter || this.options.instance) {
      instance = this.options.adapter || this.options.instance;
      if (!/\.\d+$/.test(instance)) {
        instance += ".0";
      }
    } else {
      hostname = this.options.host;
      if (!hostname || hostname === "this") {
        hostname = import_js_controller_common.tools.getHostName();
      }
    }
    dbConnect(async (params) => {
      const { states, objects, config: iobrokerJson } = params;
      try {
        let objectNamespace;
        if (hostname) {
          objectNamespace = `system.host.${hostname}`;
          const hostObject = await objects.getObject(objectNamespace);
          if (!hostObject) {
            CLI.error.hostDoesNotExist(hostname);
            return void callback(30);
          }
        } else {
          objectNamespace = `system.adapter.${instance}`;
          const instanceObject = await objects.getObject(objectNamespace);
          if (!instanceObject) {
            CLI.error.invalidInstance(instance);
            return void callback(30);
          }
        }
        if (!pluginExists(pluginName, iobrokerJson, instance)) {
          CLI.error.pluginNotDefined(pluginName, hostname, instance);
          return void callback(30);
        }
        const pluginsFolderId = `${objectNamespace}.plugins`;
        if (!await objects.getObjectAsync(pluginsFolderId)) {
          await objects.setObject(pluginsFolderId, {
            type: "folder",
            common: {
              name: `${hostname ? "host" : "instance"}: plugin states`
            },
            native: {}
          });
        }
        const pluginFolderId = `${objectNamespace}.plugins.${pluginName}`;
        if (!await objects.getObjectAsync(pluginFolderId)) {
          await objects.setObject(pluginFolderId, {
            type: "folder",
            common: {
              name: `${pluginName}: plugin states`
            },
            native: {}
          });
        }
        const pluginEnabledId = `${pluginFolderId}.enabled`;
        if (!await objects.getObjectAsync(pluginEnabledId)) {
          await objects.setObject(pluginEnabledId, {
            type: "state",
            common: {
              name: "Plugin enabled",
              type: "boolean",
              read: true,
              write: true,
              role: "value"
            },
            native: {}
          });
        }
        await states.setStateAsync(pluginEnabledId, {
          val: enabled,
          from: (0, import_cliTools.getObjectFrom)()
        });
        CLI.success.pluginEnabledOrDisabled(pluginName, hostname, instance, enabled);
        return void callback();
      } catch (err) {
        CLI.error.unknown(err.message);
        return void callback(1);
      }
    });
  }
  /**
   * Prints the status of the given plugin
   *
   * @param args the parsed CLI arguments
   */
  status(args) {
    const { callback, dbConnect } = this.options;
    const pluginName = args[1];
    if (!pluginName) {
      CLI.error.requiredArgumentMissing("pluginName", "plugin status <pluginname>");
      return void callback(34);
    }
    let hostname;
    let instance;
    if (this.options.adapter || this.options.instance) {
      instance = this.options.adapter || this.options.instance;
      if (!/\.\d+$/.test(instance)) {
        instance += ".0";
      }
    } else {
      hostname = this.options.host;
      if (!hostname || hostname === "this") {
        hostname = import_js_controller_common.tools.getHostName();
      }
    }
    dbConnect(async (params) => {
      const { states, objects, config: iobrokerJson } = params;
      try {
        let objectNamespace;
        if (hostname) {
          objectNamespace = `system.host.${hostname}`;
          const hostObject = await objects.getObject(objectNamespace);
          if (!hostObject) {
            CLI.error.hostDoesNotExist(hostname);
            return void callback(30);
          }
        } else {
          objectNamespace = `system.adapter.${instance}`;
          const instanceObject = await objects.getObject(objectNamespace);
          if (!instanceObject) {
            CLI.error.invalidInstance(instance);
            return void callback(30);
          }
        }
        if (!pluginExists(pluginName, iobrokerJson, instance)) {
          CLI.error.pluginNotDefined(pluginName, hostname, instance);
          return void callback(30);
        }
        const pluginEnabledId = `${objectNamespace}.plugins.${pluginName}.enabled`;
        try {
          const val = (await states.getStateAsync(pluginEnabledId))?.val;
          if (typeof val === "boolean") {
            CLI.success.pluginStatus(pluginName, hostname, instance, val);
            return void callback();
          }
        } catch {
        }
        const enabled = pluginEnabled(pluginName, instance, await objects.getObjectAsync("system.config"), iobrokerJson);
        CLI.success.pluginStatus(pluginName, hostname, instance, enabled);
        return void callback();
      } catch (err) {
        CLI.error.unknown(err.message);
        return void callback(1);
      }
    });
  }
}
function pluginExists(pluginName, iobrokerJson, adapter) {
  try {
    const ioPackPath = adapter ? import_node_path.default.join(import_js_controller_common.tools.getAdapterDir(adapter), "io-package.json") : controllerIoPackPath;
    const ioPack = import_fs_extra.default.readJSONSync(ioPackPath, { encoding: "utf8" });
    if (ioPack?.common?.plugins && pluginName in ioPack.common.plugins) {
      return true;
    }
  } catch {
  }
  return !!(iobrokerJson?.plugins && pluginName in iobrokerJson.plugins);
}
function pluginEnabled(pluginName, adapter, systemConfig, iobrokerJson) {
  if (systemConfig?.common?.diag === "none") {
    return false;
  }
  try {
    const ioPackPath = adapter ? import_node_path.default.join(import_js_controller_common.tools.getAdapterDir(adapter), "io-package.json") : controllerIoPackPath;
    const ioPack = import_fs_extra.default.readJSONSync(ioPackPath, { encoding: "utf8" });
    if (ioPack?.common?.plugins && pluginName in ioPack.common.plugins && ioPack.common.plugins[pluginName].enabled === false) {
      return false;
    }
  } catch {
  }
  if (iobrokerJson?.plugins && pluginName in iobrokerJson.plugins && iobrokerJson.plugins[pluginName].enabled === false) {
    return false;
  }
  return true;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CLIPlugin
});
//# sourceMappingURL=cliPlugin.js.map
