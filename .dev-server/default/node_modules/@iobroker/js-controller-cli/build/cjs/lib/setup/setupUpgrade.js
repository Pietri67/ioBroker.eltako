"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var setupUpgrade_exports = {};
__export(setupUpgrade_exports, {
  Upgrade: () => Upgrade
});
module.exports = __toCommonJS(setupUpgrade_exports);
var import_debug = __toESM(require("debug"), 1);
var import_fs_extra = __toESM(require("fs-extra"), 1);
var import_js_controller_common = require("@iobroker/js-controller-common");
var import_semver = __toESM(require("semver"), 1);
var import_setupUpload = require("../../lib/setup/setupUpload.js");
var import_setupInstall = require("../../lib/setup/setupInstall.js");
var import_readline_sync = __toESM(require("readline-sync"), 1);
var import_node_tty = __toESM(require("node:tty"), 1);
var import_node_path = __toESM(require("node:path"), 1);
var import_utils = require("../../lib/setup/utils.js");
var import_customError = require("../../lib/setup/customError.js");
const debug = (0, import_debug.default)("iobroker:cli");
class Upgrade {
  hostname = import_js_controller_common.tools.getHostName();
  upload;
  install;
  objects;
  processExit;
  constructor(options) {
    options = options || {};
    if (!options.processExit) {
      throw new Error("Invalid arguments: processExit is missing");
    }
    this.processExit = options.processExit;
    this.objects = options.objects;
    this.upload = new import_setupUpload.Upload(options);
    this.install = new import_setupInstall.Install(options);
  }
  /**
   * Sorts the adapters by their dependencies and then upgrades multiple adapters from the given repository url
   *
   * @param repo the repository content
   * @param list list of adapters to upgrade
   * @param forceDowngrade flag to force downgrade
   * @param autoConfirm automatically confirm the tty questions (bypass)
   */
  async upgradeAdapterHelper(repo, list, forceDowngrade, autoConfirm) {
    const relevantAdapters = [];
    for (const adapter of list) {
      if (repo[adapter].controller) {
        continue;
      }
      const adapterDir = import_js_controller_common.tools.getAdapterDir(adapter);
      if (adapterDir && import_fs_extra.default.existsSync(import_node_path.default.join(adapterDir, "io-package.json"))) {
        const ioInstalled = import_fs_extra.default.readJsonSync(import_node_path.default.join(adapterDir, "io-package.json"));
        if (!import_js_controller_common.tools.upToDate(repo[adapter].version, ioInstalled.common.version)) {
          relevantAdapters.push(adapter);
        }
      }
    }
    if (relevantAdapters.length) {
      const sortedAdapters = [];
      while (relevantAdapters.length) {
        let oneAdapterAdded = false;
        for (let i = relevantAdapters.length - 1; i >= 0; i--) {
          const relAdapter = relevantAdapters[i];
          if (!repo[relAdapter].dependencies && !repo[relAdapter].globalDependencies) {
            sortedAdapters.push(relAdapter);
            relevantAdapters.splice(relevantAdapters.indexOf(relAdapter), 1);
            oneAdapterAdded = true;
          } else {
            const allDeps = {
              ...import_js_controller_common.tools.parseDependencies(repo[relAdapter].dependencies),
              ...import_js_controller_common.tools.parseDependencies(repo[relAdapter].globalDependencies)
            };
            let conflict = false;
            for (const [depName, version] of Object.entries(allDeps)) {
              debug(`adapter "${relAdapter}" has dependency "${depName}": "${version}"`);
              if (version !== "*") {
                if (relevantAdapters.includes(depName)) {
                  debug(`conflict for dependency "${depName}" at adapter "${relAdapter}"`);
                  conflict = true;
                  break;
                }
              }
            }
            if (!conflict) {
              sortedAdapters.push(relAdapter);
              relevantAdapters.splice(relevantAdapters.indexOf(relAdapter), 1);
              oneAdapterAdded = true;
            }
          }
        }
        if (!oneAdapterAdded) {
          console.warn(`Circular dependency detected between adapters "${relevantAdapters.join(", ")}"`);
          sortedAdapters.concat(relevantAdapters);
          break;
        }
      }
      debug(`upgrade order is "${sortedAdapters.join(", ")}"`);
      for (const sortedAdapter of sortedAdapters) {
        if (repo[sortedAdapter]?.controller) {
          continue;
        }
        await this.upgradeAdapter(repo, sortedAdapter, forceDowngrade, autoConfirm, true);
      }
    } else {
      console.log("All adapters are up to date");
    }
  }
  /**
   * Checks that local and global deps are fulfilled else rejects promise
   *
   * @param deps local dependencies - required on this host
   * @param globalDeps global dependencies - required on one of the hosts
   */
  async _checkDependencies(deps, globalDeps) {
    if (!deps && !globalDeps) {
      return Promise.resolve();
    }
    deps = import_js_controller_common.tools.parseDependencies(deps);
    globalDeps = import_js_controller_common.tools.parseDependencies(globalDeps);
    const allDeps = { ...deps, ...globalDeps };
    const objs = await this.objects.getObjectViewAsync("system", "instance", {
      startkey: "system.adapter.",
      endkey: "system.adapter.\u9999"
    }, void 0);
    if (objs?.rows?.length) {
      for (const dName in allDeps) {
        if (dName === "js-controller") {
          const version = allDeps[dName];
          if (version !== "*") {
            const iopkg_ = import_fs_extra.default.readJSONSync(`${import_js_controller_common.tools.getControllerDir()}/package.json`);
            try {
              if (!import_semver.default.satisfies(iopkg_.version, version, { includePrerelease: true })) {
                return Promise.reject(new Error(`Invalid version of "${dName}". Installed "${iopkg_.version}", required "${version}`));
              }
            } catch (e) {
              console.log(`Can not check js-controller dependency requirement: ${e.message}`);
              return Promise.reject(new Error(`Invalid version of "${dName}". Installed "${iopkg_.version}", required "${version}`));
            }
          }
        } else {
          let gInstances = [];
          let locInstances = [];
          if (globalDeps[dName] !== void 0) {
            gInstances = objs.rows.filter((obj) => obj.value.common && obj.value.common.name === dName);
          }
          if (deps[dName] !== void 0) {
            locInstances = objs.rows.filter((obj) => obj.value.common && obj.value.common.name === dName && obj.value.common.host === this.hostname);
            if (locInstances.length === 0) {
              return Promise.reject(new Error(`Required dependency "${dName}" not found on this host.`));
            }
          }
          let isFound = false;
          for (const instance of locInstances) {
            const instanceVersion = instance.value.common.version;
            try {
              if (!import_semver.default.satisfies(instanceVersion, deps[dName], {
                includePrerelease: true
              })) {
                return Promise.reject(new Error(`Invalid version of "${dName}". Installed "${instanceVersion}", required "${deps[dName]}`));
              }
            } catch (e) {
              console.log(`Can not check dependency requirement: ${e.message}`);
              return Promise.reject(new Error(`Invalid version of "${dName}". Installed "${instanceVersion}", required "${deps[dName]}`));
            }
            isFound = true;
          }
          for (const instance of gInstances) {
            const instanceVersion = instance.value.common.version;
            try {
              if (!import_semver.default.satisfies(instanceVersion, globalDeps[dName], {
                includePrerelease: true
              })) {
                return Promise.reject(new Error(`Invalid version of "${dName}". Installed "${instanceVersion}", required "${globalDeps[dName]}`));
              }
            } catch (e) {
              console.log(`Can not check dependency requirement: ${e.message}`);
              return Promise.reject(new Error(`Invalid version of "${dName}". Installed "${instanceVersion}", required "${globalDeps[dName]}`));
            }
            isFound = true;
          }
          if (isFound === false) {
            return Promise.reject(new Error(`Required dependency "${dName}" not found.`));
          }
        }
      }
    }
  }
  /**
   * Try to async upgrade adapter from a given source with some checks
   *
   * @param repoUrlOrObject url of the selected repository or parsed repo, if undefined, use current active repository
   * @param adapter name of the adapter (can also include version like web@3.0.0)
   * @param forceDowngrade flag to force downgrade
   * @param autoConfirm automatically confirm the tty questions (bypass)
   * @param upgradeAll if true, this is an upgrade all call, we don't do major upgrades if no tty
   */
  async upgradeAdapter(repoUrlOrObject, adapter, forceDowngrade, autoConfirm, upgradeAll) {
    let sources;
    if (!repoUrlOrObject || !import_js_controller_common.tools.isObject(repoUrlOrObject)) {
      try {
        sources = await (0, import_utils.getRepository)({ repoName: repoUrlOrObject, objects: this.objects });
      } catch (e) {
        console.error(e.message);
        return this.processExit(e instanceof import_customError.IoBrokerError ? e.code : e);
      }
    } else {
      sources = repoUrlOrObject;
    }
    let version;
    if (adapter.includes("@")) {
      const parts = adapter.split("@");
      adapter = parts[0];
      version = parts[1];
    } else {
      version = "";
    }
    if (version) {
      forceDowngrade = true;
    }
    const repoAdapter = sources[adapter];
    const finishUpgrade = async (name, ioPack) => {
      if (!ioPack) {
        const adapterDir2 = import_js_controller_common.tools.getAdapterDir(name);
        if (!adapterDir2) {
          console.error(`Cannot find io-package.json in ${adapterDir2}`);
          return this.processExit(import_js_controller_common.EXIT_CODES.MISSING_ADAPTER_FILES);
        }
        try {
          ioPack = import_fs_extra.default.readJSONSync(import_node_path.default.join(adapterDir2, "io-package.json"));
        } catch {
          console.error(`Cannot find io-package.json in ${adapterDir2}`);
          return this.processExit(import_js_controller_common.EXIT_CODES.MISSING_ADAPTER_FILES);
        }
      }
      if (ioPack.common.osDependencies) {
        await this.install.installOSPackages(ioPack.common.osDependencies);
      }
      await this.upload.uploadAdapter(name, false, true);
      await this.upload.upgradeAdapterObjects(name, ioPack);
      await this.upload.uploadAdapter(name, true, true);
    };
    const adapterDir = import_js_controller_common.tools.getAdapterDir(adapter);
    if (!adapterDir || !version && !import_fs_extra.default.existsSync(import_node_path.default.join(adapterDir, "io-package.json"))) {
      return console.log(`Adapter "${adapter}"${adapter.length < 15 ? new Array(15 - adapter.length).join(" ") : ""} is not installed.`);
    }
    if (!repoAdapter) {
      console.log(`Adapter "${adapter}" is not in the repository and cannot be updated.`);
      return this.processExit(import_js_controller_common.EXIT_CODES.ADAPTER_NOT_FOUND);
    }
    if (repoAdapter.controller) {
      return console.log(`Cannot update ${adapter} using this command. Please use "iobroker upgrade self" instead!`);
    }
    let ioInstalled;
    if (adapterDir && import_fs_extra.default.existsSync(import_node_path.default.join(adapterDir, "io-package.json"))) {
      ioInstalled = import_fs_extra.default.readJsonSync(`${adapterDir}/io-package.json`);
    } else {
      ioInstalled = { common: { version: "0.0.0" } };
    }
    const installedVersion = ioInstalled.common.version;
    const showUpgradeDialog = (installedVersion2, targetVersion, adapterName) => {
      const isMajor = import_semver.default.major(installedVersion2) !== import_semver.default.major(targetVersion);
      if (autoConfirm || !import_node_tty.default.isatty(process.stdout.fd) && (!isMajor || !upgradeAll)) {
        return true;
      }
      if (!import_node_tty.default.isatty(process.stdout.fd) && isMajor && upgradeAll) {
        console.log(`Skip major upgrade of ${adapterName} from ${installedVersion2} to ${targetVersion}`);
        return false;
      }
      const isUpgrade = import_semver.default.gt(targetVersion, installedVersion2);
      const isDowngrade = import_semver.default.lt(targetVersion, installedVersion2);
      if (repoAdapter?.news) {
        const news = repoAdapter.news;
        let first = true;
        if (isUpgrade) {
          for (const version2 in news) {
            try {
              if (import_semver.default.lte(version2, targetVersion) && import_semver.default.gt(version2, installedVersion2)) {
                if (first === true) {
                  const noMissingNews = news[targetVersion] && news[installedVersion2];
                  console.log(`
This upgrade of "${adapter}" will ${noMissingNews ? "" : "at least "}introduce the following changes:`);
                  console.log("==========================================================================");
                  first = false;
                } else if (first === false) {
                  console.log();
                }
                console.log(`-> ${version2}:`);
                console.log(news[version2].en);
              }
            } catch {
            }
          }
        } else if (isDowngrade) {
          for (const version2 in news) {
            try {
              if (import_semver.default.gt(version2, targetVersion) && import_semver.default.lte(version2, installedVersion2)) {
                if (first === true) {
                  const noMissingNews = news[targetVersion] && news[installedVersion2];
                  console.log(`
This downgrade of "${adapter}" will ${noMissingNews ? "" : "at least "}remove the following changes:`);
                  console.log("==========================================================================");
                  first = false;
                } else if (first === false) {
                  console.log();
                }
                console.log(`-> ${version2}`);
                console.log(news[version2].en);
              }
            } catch {
            }
          }
        }
        if (first === false) {
          console.log("==========================================================================\n");
        }
      }
      let answer;
      do {
        if (isUpgrade || isDowngrade) {
          if (isMajor) {
            console.log(`BE CAREFUL: THIS IS A MAJOR ${isUpgrade ? "UPGRADE" : "DOWNGRADE"}, WHICH WILL MOST LIKELY INTRODUCE BREAKING CHANGES!`);
          }
          answer = import_readline_sync.default.question(`Would you like to ${isUpgrade ? "upgrade" : "downgrade"} ${adapter} from @${installedVersion2} to @${version || repoAdapter.version} now? [(y)es, (n)o]: `, {
            defaultInput: "n"
          });
        } else {
          answer = import_readline_sync.default.question(`Would you like to reinstall version ${version || repoAdapter.version} of ${adapter} now? [(y)es, (n)o]: `, {
            defaultInput: "n"
          });
        }
        answer = answer.toLowerCase();
        if (answer === "n" || answer === "no") {
          return false;
        }
      } while (answer !== "y" && answer !== "yes");
      return true;
    };
    if (repoAdapter.version) {
      if (!forceDowngrade) {
        try {
          await this._checkDependencies(repoAdapter.dependencies, repoAdapter.globalDependencies);
        } catch (e) {
          return console.error(`Cannot check dependencies: ${e.message}`);
        }
      }
      if (!forceDowngrade && (repoAdapter.version === installedVersion || import_js_controller_common.tools.upToDate(repoAdapter.version, installedVersion))) {
        return console.log(`Adapter "${adapter}"${adapter.length < 15 ? new Array(15 - adapter.length).join(" ") : ""} is up to date.`);
      }
      const targetVersion = version || repoAdapter.version;
      const isIgnored = await (0, import_utils.isVersionIgnored)({
        adapterName: adapter,
        version: targetVersion,
        objects: this.objects
      });
      if (isIgnored) {
        console.log(`No upgrade of "${adapter}" desired, because version "${targetVersion}" is configured to be ignored by the user. Run "${import_js_controller_common.tools.appNameLowerCase} version ${adapter} --recognize" to allow this upgrade!`);
        return;
      }
      try {
        if (!showUpgradeDialog(installedVersion, targetVersion, adapter)) {
          console.log(`No upgrade of "${adapter}" desired.`);
          return;
        }
      } catch (e) {
        console.log(`Can not check version information to display upgrade infos: ${e.message}`);
      }
      console.log(`Update ${adapter} from @${installedVersion} to @${targetVersion}`);
      const npmPacketName = `${import_js_controller_common.tools.appNameLowerCase}.${adapter}`;
      try {
        if (!import_semver.default.diff(installedVersion, targetVersion)) {
          console.log(`Uninstall npm packet "${npmPacketName}" for a clean re-installation`);
          await import_js_controller_common.tools.uninstallNodeModule(npmPacketName, { debug: process.argv.includes("--debug") });
        }
      } catch (e) {
        console.warn(`Could not uninstall npm packet "${npmPacketName}": ${e.message}`);
      }
      const { packetName, stoppedList } = await this.install.downloadPacket(sources, `${adapter}@${targetVersion}`);
      await finishUpgrade(packetName);
      await this.install.enableInstances(stoppedList, true);
    } else if (repoAdapter.meta) {
      const ioPack = await import_js_controller_common.tools.getJsonAsync(repoAdapter.meta);
      if (!ioPack) {
        console.error(`Cannot parse file${repoAdapter.meta}`);
        return;
      }
      if (!forceDowngrade) {
        try {
          await this._checkDependencies(ioPack.common.dependencies, ioPack.common.globalDependencies);
        } catch (e) {
          console.error(`Cannot check dependencies: ${e.message}`);
          return;
        }
      }
      if (!version && (ioPack.common.version === installedVersion || !forceDowngrade && import_js_controller_common.tools.upToDate(ioPack.common.version, installedVersion))) {
        console.log(`Adapter "${adapter}"${adapter.length < 15 ? new Array(15 - adapter.length).join(" ") : ""} is up to date.`);
      } else {
        const targetVersion = version || ioPack.common.version;
        const isIgnored = await (0, import_utils.isVersionIgnored)({
          adapterName: adapter,
          version: targetVersion,
          objects: this.objects
        });
        if (isIgnored) {
          console.log(`No upgrade of "${adapter}" desired, because version "${targetVersion}" is configured to be ignored by the user. Run "${import_js_controller_common.tools.appNameLowerCase} version ${adapter} --recognize" to allow this upgrade!`);
          return;
        }
        try {
          if (!showUpgradeDialog(installedVersion, targetVersion, adapter)) {
            console.log(`No upgrade of "${adapter}" desired.`);
            return;
          }
        } catch (e) {
          console.log(`Can not check version information to display upgrade infos: ${e.message}`);
        }
        console.log(`Update ${adapter} from @${installedVersion} to @${targetVersion}`);
        const { packetName, stoppedList } = await this.install.downloadPacket(sources, `${adapter}@${targetVersion}`);
        await finishUpgrade(packetName, ioPack);
        await this.install.enableInstances(stoppedList, true);
      }
    } else if (forceDowngrade) {
      try {
        if (!showUpgradeDialog(installedVersion, version, adapter)) {
          return console.log(`No upgrade of "${adapter}" desired.`);
        }
      } catch (e) {
        console.log(`Can not check version information to display upgrade infos: ${e.message}`);
      }
      console.warn(`Unable to get version for "${adapter}". Update anyway.`);
      console.log(`Update ${adapter} from @${installedVersion} to @${version}`);
      const { packetName, stoppedList } = await this.install.downloadPacket(sources, `${adapter}@${version}`);
      await finishUpgrade(packetName);
      await this.install.enableInstances(stoppedList, true);
    } else {
      return console.error(`Unable to get version for "${adapter}".`);
    }
  }
  /**
   * Upgrade the js-controller
   *
   * @param repoUrl the repo or url
   * @param forceDowngrade if downgrades are allowed
   * @param controllerRunning if controller is currently running
   */
  async upgradeController(repoUrl, forceDowngrade, controllerRunning) {
    let sources;
    try {
      const result = await (0, import_utils.getRepository)({ repoName: repoUrl, objects: this.objects });
      if (!result) {
        return console.warn(`Cannot get repository under "${repoUrl}"`);
      }
      sources = result;
    } catch (e) {
      console.error(e.message);
      return this.processExit(e instanceof import_customError.IoBrokerError ? e.code : e);
    }
    const installed = import_fs_extra.default.readJSONSync(`${import_js_controller_common.tools.getControllerDir()}/io-package.json`);
    if (!installed || !installed.common || !installed.common.version) {
      return console.error(`Host "${this.hostname}"${this.hostname.length < 15 ? "".padStart(15 - this.hostname.length) : ""} is not installed.`);
    }
    const controllerName = installed.common.name;
    const repoController = sources[controllerName];
    if (!repoController) {
      return console.error(`Cannot find this controller "${controllerName}" in repository.`);
    }
    if (repoController.version) {
      if (!forceDowngrade && (repoController.version === installed.common.version || import_js_controller_common.tools.upToDate(repoController.version, installed.common.version))) {
        console.log(`Host    "${this.hostname}"${this.hostname.length < 15 ? new Array(15 - this.hostname.length).join(" ") : ""} is up to date.`);
      } else if (controllerRunning) {
        console.warn(`Controller is running. Please stop ioBroker first.`);
      } else {
        console.log(`Update ${controllerName} from @${installed.common.version} to @${repoController.version}`);
        await this.install.downloadPacket(sources, `${controllerName}@${repoController.version}`, {
          stopDb: true
        });
      }
    } else {
      const ioPack = await import_js_controller_common.tools.getJsonAsync(repoController.meta);
      if ((!ioPack || !ioPack.common) && !forceDowngrade) {
        return console.warn(`Cannot read version. Write "${import_js_controller_common.tools.appName} upgrade self --force" to upgrade controller anyway.`);
      }
      let version = ioPack?.common ? ioPack.common.version : "";
      if (version) {
        version = `@${version}`;
      }
      if (ioPack?.common && ioPack.common.version === installed.common.version || !forceDowngrade && ioPack?.common && import_js_controller_common.tools.upToDate(ioPack.common.version, installed.common.version)) {
        console.log(`Host    "${this.hostname}"${this.hostname.length < 15 ? new Array(15 - this.hostname.length).join(" ") : ""} is up to date.`);
      } else if (controllerRunning) {
        console.warn(`Controller is running. Please stop ioBroker first.`);
      } else {
        const name = ioPack?.common?.name || controllerName;
        console.log(`Update ${name} from @${installed.common.version} to ${version}`);
        await this.install.downloadPacket(sources, name + version, { stopDb: true });
      }
    }
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Upgrade
});
//# sourceMappingURL=setupUpgrade.js.map
