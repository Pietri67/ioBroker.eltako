"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var setupVendor_exports = {};
__export(setupVendor_exports, {
  Vendor: () => Vendor
});
module.exports = __toCommonJS(setupVendor_exports);
var import_js_controller_common = require("@iobroker/js-controller-common");
var import_fs_extra = __toESM(require("fs-extra"), 1);
var import_deep_clone = __toESM(require("deep-clone"), 1);
var import_node_util = require("node:util");
const VENDOR_FILE = "/etc/iob-vendor.json";
class Vendor {
  objects;
  constructor(options) {
    this.objects = options.objects;
  }
  /**
   * Deep merge of source into target object
   *
   * @param target target obj
   * @param source source obj
   */
  deepMerge(target, source) {
    Object.keys(source).forEach((attr) => {
      if (typeof source[attr] === "object" && !(source[attr] instanceof Array)) {
        if (target[attr] && typeof target[attr] !== "object") {
          target[attr] = {};
        }
        target[attr] = target[attr] || {};
        this.deepMerge(target[attr], source[attr]);
      } else {
        target[attr] = source[attr];
      }
    });
  }
  /**
   * Read info from  '/etc/iob_vendor.json' and executes instructions stored there
   *
   * @param file file path if not given, default path is used
   * @param password vendor password
   * @param logger
   */
  async checkVendor(file, password, logger) {
    logger = logger || {
      debug: (text) => console.log(text),
      info: (text) => console.log(text),
      error: (text) => console.error(text),
      warn: (text) => console.warn(text)
    };
    file = file || VENDOR_FILE;
    let data;
    if (import_fs_extra.default.existsSync(file)) {
      try {
        data = import_fs_extra.default.readJSONSync(file);
      } catch (err) {
        logger.error(`cannot read or parse "${file}": ${err.message}`);
        throw new Error(`cannot read or parse "${file}": ${err.message}`);
      }
    } else {
      logger.error(`"${file}" does not exist`);
      throw new Error(`"${file}" does not exist`);
    }
    if (data.uuid) {
      const uuid = data.uuid;
      data.uuid = null;
      const obj = await this.objects.getObject("system.meta.uuid");
      if (obj?.native) {
        if (obj.native.uuid !== uuid) {
          obj.native.uuid = uuid;
          logger.info(`Update "system.meta.uuid:native.uuid" = "${obj.native.uuid}"`);
          obj.nonEdit = obj.nonEdit || {};
          obj.nonEdit.password = password;
          try {
            await this.objects.setObjectAsync("system.meta.uuid", obj);
            logger.info(`object system.meta.uuid updated: ${uuid}`);
          } catch (e) {
            logger.error(`Cannot update system.meta.uuid: ${e.message}`);
          }
        }
      } else {
        try {
          await this.objects.setObjectAsync("system.meta.uuid", {
            type: "meta",
            common: {
              name: "uuid",
              type: "uuid"
            },
            ts: (/* @__PURE__ */ new Date()).getTime(),
            from: `system.host.${import_js_controller_common.tools.getHostName()}.tools`,
            native: {
              uuid
            }
          });
          logger.info(`object system.meta.uuid created: ${uuid}`);
        } catch (e) {
          logger.error(`Cannot create system.meta.uuid: ${e.message}`);
        }
      }
    }
    if (data.iobroker) {
      const settings = import_fs_extra.default.readJSONSync(import_js_controller_common.tools.getConfigFileName());
      logger.info("Update iobroker.json file");
      this.deepMerge(settings, data.iobroker);
      import_fs_extra.default.writeFileSync(import_js_controller_common.tools.getConfigFileName(), JSON.stringify(settings, null, 2));
    }
    if (data.vendor) {
      const vendor = (0, import_deep_clone.default)(data.vendor);
      data._vendor = (0, import_deep_clone.default)(vendor);
      data.vendor = null;
      try {
        const obj = await this.objects.getObject("system.config");
        if (obj && obj.native) {
          if (!(0, import_node_util.isDeepStrictEqual)(obj.native.vendor, vendor)) {
            obj.native.vendor = vendor;
            obj.nonEdit = obj.nonEdit || {};
            obj.nonEdit.password = password;
            await this.objects.setObjectAsync(obj._id, obj);
            logger.info("object system.config updated");
          }
        }
      } catch (e) {
        logger.error(`Cannot update system.config: ${e.message}`);
      }
    }
    if (data.objects) {
      for (let id of Object.keys(data.objects)) {
        if (!id.includes("*")) {
          const _newObj = data.objects[id];
          const obj = await this.objects.getObject(id);
          if (obj) {
            obj.nonEdit = obj.nonEdit || {};
            const originalObj = (0, import_deep_clone.default)(obj);
            _newObj.nonEdit = _newObj.nonEdit || {};
            _newObj.nonEdit.passHash = obj.nonEdit.passHash;
            import_js_controller_common.tools.copyAttributes(_newObj, obj);
            if (!(0, import_node_util.isDeepStrictEqual)(originalObj, obj)) {
              delete obj.nonEdit.passHash;
              obj.nonEdit.password = password;
              logger.info(`Update "${obj._id}"`);
              try {
                await this.objects.setObjectAsync(obj._id, obj);
                logger.info(`object "${obj._id}" updated`);
              } catch (e) {
                logger.error(`Cannot update "${obj._id}": ${e.message}`);
              }
            }
          } else {
            try {
              await this.objects.setObjectAsync(id, _newObj);
              logger.info(`object "${_newObj._id}" updated`);
            } catch (e) {
              logger.error(`Cannot update ${id} "${JSON.stringify(_newObj)}": ${e.message}`);
            }
          }
        } else {
          id = id.replace(/\*/g, "");
          const _obj = data.objects[id];
          const arr = await this.objects.getObjectListAsync({
            startkey: id,
            endkey: `${id}\u9999`
          }, { checked: true });
          if (arr && arr.rows && arr.rows.length) {
            for (const row of arr.rows) {
              const obj = row.value;
              if (obj) {
                obj.nonEdit = obj.nonEdit || {};
                const originalObj = (0, import_deep_clone.default)(obj);
                _obj.nonEdit = _obj.nonEdit || {};
                _obj.nonEdit.passHash = obj.nonEdit.passHash;
                import_js_controller_common.tools.copyAttributes(_obj, obj);
                if (!(0, import_node_util.isDeepStrictEqual)(originalObj, obj)) {
                  delete obj.nonEdit.passHash;
                  obj.nonEdit.password = password;
                  logger.info(`Update "${obj._id}"`);
                  try {
                    await this.objects.setObjectAsync(obj._id, obj);
                    logger.info(`object "${obj._id}" updated`);
                  } catch (e) {
                    logger.error(`Cannot update "${obj._id}": ${e.message}`);
                  }
                }
              }
            }
          }
        }
      }
    }
    if (data.model) {
      const model = data.model;
      data.model = null;
      const hostname = import_js_controller_common.tools.getHostName();
      const obj = await this.objects.getObject(`system.host.${hostname}`);
      if (obj && obj.common) {
        if (model.name && model.name !== "JS controller" && obj.common.title === "JS controller" || model.icon && !obj.common.icon || model.color && !obj.common.color) {
          if (model.name) {
            obj.common.title = model.name;
          }
          if (model.icon) {
            obj.common.icon = model.icon;
          }
          if (model.color) {
            obj.common.color = model.color;
          }
          obj.nonEdit = obj.nonEdit || {};
          obj.nonEdit.password = password;
          obj.common.title && logger.info(`Update "system.host.${hostname}:common.title" = "${obj.common.title}"`);
          obj.common.icon && logger.info(`Update "system.host.${hostname}:common.icon"  = "${!!obj.common.icon}"`);
          obj.common.color && logger.info(`Update "system.host.${hostname}:common.color" = "${obj.common.color}"`);
          try {
            await this.objects.setObjectAsync(obj._id, obj);
            logger.info(`object "system.host.${hostname}" updated`);
          } catch (e) {
            logger.error(`Cannot update "system.host.${hostname}": ${e.message}`);
          }
        }
      }
    }
    setTimeout(() => {
      logger.warn("RESTART!");
      process.exit(-1);
    }, 2e3);
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Vendor
});
//# sourceMappingURL=setupVendor.js.map
