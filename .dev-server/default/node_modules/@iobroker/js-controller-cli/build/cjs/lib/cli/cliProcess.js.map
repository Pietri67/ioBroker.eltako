{
  "version": 3,
  "sources": ["../../../../src/lib/cli/cliProcess.ts"],
  "sourcesContent": ["import fs from 'fs-extra';\nimport path from 'node:path';\nimport os from 'node:os';\nimport { spawn } from 'node:child_process';\nimport deepClone from 'deep-clone';\nimport { setTimeout as wait } from 'node:timers/promises';\n\nimport {\n    isLocalStatesDbServer,\n    isLocalObjectsDbServer,\n    getInstancesOrderedByStartPrio,\n} from '@iobroker/js-controller-common';\nimport { tools, EXIT_CODES } from '@iobroker/js-controller-common';\nimport * as CLI from '@/lib/cli/messages.js';\nimport { CLICommand } from '@/lib/cli/cliCommand.js';\nimport { getObjectFrom, getInstanceName, normalizeAdapterName, enumInstances } from '@/lib/cli/cliTools.js';\nimport type { Client as ObjectsClient } from '@iobroker/db-objects-redis';\nimport type { Client as StatesClient } from '@iobroker/db-states-redis';\nimport type { CLICommandOptions } from '@/lib/cli/cliCommand.js';\n\n/** Time to wait after killing pid until process is assumed as stopped */\nconst TRY_KILL_WAIT_MS = 5_000;\n\n// The root of this project. Change this when moving code to another directory\nconst rootDir = tools.getControllerDir();\nconst killAllScriptPath = path.join(rootDir, 'killall.sh');\n\nexport class CLIProcess extends CLICommand {\n    constructor(options: CLICommandOptions) {\n        super(options);\n    }\n\n    // These CLI commands have no subcommands, but belong together thematically\n    // (start/stop/restart/status)\n\n    /**\n     * Starts one or more adapters or the js-controller\n     *\n     * @param args parsed cli arguments\n     */\n    async start(args: any[]): Promise<void> {\n        const adapterName = normalizeAdapterName(args[0]);\n        if (!adapterName) {\n            await this.startJSController();\n            this.options.callback();\n        } else if (adapterName === 'all') {\n            this.setAllAdaptersEnabled(true);\n        } else if (/\\.\\d+$/.test(adapterName)) {\n            this.setAdapterInstanceEnabled(adapterName, true);\n        } else {\n            this.setAdapterEnabled(adapterName, true);\n        }\n    }\n\n    /**\n     * Restarts one or more instances or the js-controller\n     *\n     * @param args parsed cli arguments\n     */\n    async restart(args: any[]): Promise<void> {\n        const adapterName = normalizeAdapterName(args[0]);\n        if (!adapterName) {\n            await this.restartJSController();\n            this.options.callback();\n        } else if (/\\.\\d+$/.test(adapterName)) {\n            this.setAdapterInstanceEnabled(adapterName, true, /* restartIfRunning */ true);\n        } else {\n            this.setAdapterEnabled(adapterName, true, /* restartIfRunning */ true);\n        }\n    }\n\n    /**\n     * Stops one or more adapters or the js-controller\n     *\n     * @param args parsed cli arguments\n     */\n    async stop(args: any[]): Promise<void> {\n        const adapterName = normalizeAdapterName(args[0]);\n        if (adapterName === undefined) {\n            await CLIProcess.stopJSController();\n            this.options.callback();\n        } else if (adapterName === 'all') {\n            this.setAllAdaptersEnabled(false);\n        } else if (/\\.\\d+$/.test(adapterName)) {\n            this.setAdapterInstanceEnabled(adapterName, false);\n        } else {\n            this.setAdapterEnabled(adapterName, false);\n        }\n    }\n\n    /**\n     * Starts or stops all adapters\n     *\n     * @param enabled if adapters should be started or stopped\n     */\n    setAllAdaptersEnabled(enabled: boolean): void {\n        const { callback, dbConnect } = this.options;\n        dbConnect(async params => {\n            const { objects } = params;\n            // Enumerate all adapter instances\n            const instances = await getInstancesOrderedByStartPrio(objects, console);\n            // Create a promise for each. setInstanceEnabled only starts/stops when necessary\n            const instancePromises = instances\n                .filter(obj => obj.common.enabled !== enabled)\n                .map(obj => setInstanceEnabled(objects, obj, enabled));\n            // wait for all instances to be started/stopped\n            await Promise.all(instancePromises);\n            callback();\n        });\n    }\n\n    /**\n     * Starts or stops a single or all instances of adapter.\n     * If there are multiple instances, all will be started/stopped/restarted\n     *\n     * @param adapter The adapter to start\n     * @param enabled If adapter should be started or stopped\n     * @param [restartIfRunning] Whether running instances should be restarted\n     */\n    setAdapterEnabled(adapter: string, enabled: boolean, restartIfRunning?: boolean): void {\n        const { callback, dbConnect } = this.options;\n        dbConnect(async params => {\n            const { objects } = params;\n\n            try {\n                // Enumerate all adapter instances\n                const adapterInstances = await enumInstances(objects, adapter);\n                if (adapterInstances.length === 0) {\n                    CLI.error.noInstancesFound(adapter);\n                    return void callback(EXIT_CODES.UNKNOWN_ERROR);\n                }\n                for (const instance of adapterInstances) {\n                    await setInstanceEnabled(objects, instance, enabled, restartIfRunning);\n                }\n                return void callback();\n            } catch (e) {\n                CLI.error.unknown(e.message);\n                return void callback(EXIT_CODES.UNKNOWN_ERROR);\n            }\n        });\n    }\n\n    /**\n     * Starts or stops a specific adapter instance\n     *\n     * @param instance The instance to start, e.g. \"adaptername.0\"\n     * @param enabled If the instance should be started or stopped\n     * @param [restartIfRunning] Whether running instances should be restarted\n     */\n    setAdapterInstanceEnabled(instance: string, enabled: boolean, restartIfRunning?: boolean): void {\n        const { callback, dbConnect } = this.options;\n        dbConnect(async params => {\n            const { objects } = params;\n\n            const obj = (await objects.getObject(`system.adapter.${instance}`)) as\n                | ioBroker.InstanceObject\n                | ioBroker.AdapterObject;\n\n            if (!obj || obj.type !== 'instance') {\n                CLI.error.invalidInstance(instance);\n                return void callback();\n            }\n\n            try {\n                await setInstanceEnabled(objects, obj, enabled, restartIfRunning);\n                return void callback();\n            } catch (e) {\n                CLI.error.unknown(e.message);\n                return void callback(EXIT_CODES.UNKNOWN_ERROR);\n            }\n        });\n    }\n\n    /**\n     * Starts the JS controller\n     */\n    async startJSController(): Promise<void> {\n        let memoryLimitMB = 0;\n        try {\n            const config: ioBroker.IoBrokerJson = fs.readJSONSync(tools.getConfigFileName(), { encoding: 'utf-8' });\n            if (config?.system?.memoryLimitMB) {\n                memoryLimitMB = Math.round(config.system.memoryLimitMB);\n            }\n        } catch {\n            console.warn('Cannot read memoryLimitMB');\n            console.warn(\n                `May be config file does not exist.\\nPlease call \"${tools.appName} setup first\" to initialize the settings.`,\n            );\n        }\n\n        let pid: number | undefined;\n        try {\n            pid = await tools.getControllerPid();\n        } catch (e) {\n            console.error(`Could not read pid file: ${e.message}`);\n        }\n\n        if (pid) {\n            console.log(`Controller is already running with pid ${pid}`);\n            return;\n        }\n\n        const args = [path.join(rootDir, 'controller.js')];\n        if (memoryLimitMB) {\n            args.push(`--max-old-space-size=${memoryLimitMB}`);\n        }\n\n        const child = spawn(process.execPath, args, {\n            env: process.env,\n            detached: true,\n            stdio: ['ignore', 'ignore', 'ignore', 'ipc'],\n            windowsHide: true,\n            cwd: rootDir,\n        });\n\n        child.unref();\n    }\n\n    /**\n     * Stops the JS controller\n     */\n    static async stopJSController(): Promise<void> {\n        let pid: number | undefined;\n        try {\n            pid = await tools.getControllerPid();\n        } catch (e) {\n            console.error(`Could not read pid file: ${e.message}`);\n        }\n\n        if (!pid) {\n            return;\n        }\n\n        await tryKill(pid);\n\n        // On non-Windows OSes start a KILLALL script\n        // to make sure nothing keeps running\n        if (os.platform() !== 'win32') {\n            let data = '';\n            if (fs.existsSync(killAllScriptPath)) {\n                fs.chmodSync(killAllScriptPath, '777');\n                const child = spawn(killAllScriptPath, [], { windowsHide: true });\n                child.stdout.on('data', _data => (data += _data.toString().replace(/\\n/g, '')));\n                child.stderr.on('data', _data => (data += _data.toString().replace(/\\n/g, '')));\n                return new Promise(resolve => {\n                    child.on('exit', exitCode => {\n                        console.log(`Exit code for \"killall.sh\": ${exitCode}`);\n                        resolve();\n                    });\n                });\n            }\n            console.log('No \"killall.sh\" script found. Just stop.');\n        }\n\n        try {\n            // delete pids.txt file\n            fs.unlinkSync(tools.getPidsFileName());\n        } catch {\n            // ignore\n        }\n    }\n\n    /** Restarts the JS controller */\n    async restartJSController(): Promise<void> {\n        await CLIProcess.stopJSController();\n        await this.startJSController();\n    }\n\n    /**\n     * Checks if ioBroker is running or not\n     *\n     * @param args parsed cli arguments\n     */\n    status(args: any[]): void {\n        const { callback, dbConnect } = this.options;\n        const adapterName = normalizeAdapterName(args[0]);\n        const showEntireConfig = adapterName === 'all';\n\n        dbConnect(async params => {\n            const { objects, states, config, isOffline } = params;\n\n            if (!adapterName || showEntireConfig) {\n                // we want host info or/and whole config\n                const hostAlive = await states.getState(`system.host.${tools.getHostName()}.alive`);\n\n                const alive = hostAlive ? (hostAlive.val as boolean) : false;\n                CLI.success.controllerStatus(alive);\n                console.log();\n\n                const hasLocalStatesServer = await isLocalStatesDbServer(config.states.type, config.states.host);\n                const hasLocalObjectsServer = await isLocalObjectsDbServer(config.objects.type, config.objects.host);\n\n                if (!hasLocalStatesServer && !hasLocalObjectsServer) {\n                    CLI.success.systemStatus(!isOffline);\n                }\n\n                console.log();\n                if (showEntireConfig) {\n                    await showAllInstancesStatus(states, objects);\n                    console.log();\n                    showConfig(config);\n                } else {\n                    console.log(`Objects type: ${config.objects.type}`);\n                    console.log(`States  type: ${config.states.type}`);\n                }\n                return void callback(isOffline ? EXIT_CODES.CONTROLLER_NOT_RUNNING : undefined);\n            }\n            // we want to know the status of an adapter\n            if (/\\.\\d+$/.test(adapterName)) {\n                // instance specified\n                await showInstanceStatus(states, adapterName);\n                return void callback();\n            }\n            const adapterInstances = await enumInstances(objects, adapterName);\n            // If there are multiple instances of this adapter, ask the user to specify which one\n            if (adapterInstances.length > 1) {\n                CLI.error.specifyInstance(\n                    adapterName,\n                    adapterInstances.map(obj => obj._id.substring('system.adapter.'.length)),\n                );\n                return void callback(EXIT_CODES.INVALID_ADAPTER_ID);\n            } else if (adapterInstances.length === 0) {\n                CLI.error.noInstancesFound(adapterName);\n                return void callback(EXIT_CODES.UNKNOWN_ERROR);\n            }\n\n            const instanceId = adapterInstances[0]._id.split('.').pop();\n            await showInstanceStatus(states, `${adapterName}.${instanceId}`);\n            return void callback();\n        });\n    }\n}\n\n/**\n * Outputs the status of all existing adapter instances\n *\n * @param states The States DB\n * @param objects The Objects DB\n */\nasync function showAllInstancesStatus(states: StatesClient, objects: ObjectsClient): Promise<void> {\n    const allInstances = await enumInstances(objects);\n    for (const instance of allInstances) {\n        const instanceId = instance._id.split('.').pop();\n        await showInstanceStatus(states, `${instance.common.name}.${instanceId}`);\n    }\n    return Promise.resolve();\n}\n\n/**\n * Outputs the status of an adapter instance\n *\n * @param states the states object\n * @param adapterInstance <adapterName>.<instanceId>\n */\nasync function showInstanceStatus(states: StatesClient, adapterInstance: string): Promise<void> {\n    const state = await states.getState(`system.adapter.${adapterInstance}.alive`);\n    if (state?.val === true) {\n        console.log(`Instance \"${adapterInstance}\" is running`);\n    } else {\n        console.log(`Instance \"${adapterInstance}\" is not running`);\n    }\n}\n\n/**\n * Prints the config file to the console\n *\n * @param config the ioBroker json file content\n * @param root\n */\nfunction showConfig(config: ioBroker.IoBrokerJson, root?: string[]): void {\n    if (!tools.isObject(config)) {\n        return;\n    }\n    root = root || [];\n    const prefix = root.join('/').toUpperCase();\n    for (const attr of Object.keys(config)) {\n        if (attr.match(/comment$/i)) {\n            continue;\n        }\n        if (typeof (config as Record<string, any>)[attr] === 'object') {\n            const nextRoot = deepClone(root);\n            nextRoot.push(attr);\n            showConfig((config as Record<string, any>)[attr], nextRoot);\n        } else {\n            console.log(`${prefix}${(prefix ? '/' : '') + attr}: ${(config as Record<string, any>)[attr]}`);\n        }\n    }\n}\n\n/**\n * Sets the enabled state of an instance to the given value\n *\n * @param objects The objects DB\n * @param instanceObj The instance object to change\n * @param enabled Whether the instance should be enabled or not\n * @param force Whether the object should be updated always\n */\nasync function setInstanceEnabled(\n    objects: ObjectsClient,\n    instanceObj: ioBroker.InstanceObject,\n    enabled: boolean,\n    force?: boolean,\n): Promise<void> {\n    if (!force && instanceObj.common.enabled === enabled) {\n        return;\n    }\n\n    instanceObj.common.enabled = enabled;\n    instanceObj.from = getObjectFrom();\n    instanceObj.ts = Date.now();\n    await objects.setObject(instanceObj._id, instanceObj);\n    const instanceName = getInstanceName(instanceObj._id);\n    if (enabled) {\n        CLI.success.adapterStarted(instanceName);\n    } else {\n        CLI.success.adapterStopped(instanceName);\n    }\n}\n\n/**\n * Kills a process by its PID\n *\n * @param pid The PID of the process to kill\n */\nasync function tryKill(pid: number): Promise<void> {\n    try {\n        process.kill(pid, 'SIGTERM');\n    } catch (e) {\n        console.warn(`Could not send \"SIGTERM\" to process ${pid}: ${e.message}`);\n    }\n\n    await wait(TRY_KILL_WAIT_MS);\n}\n"],
  "mappings": "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",
  "names": ["import_js_controller_common", "path", "fs", "os", "deepClone", "wait"]
}
