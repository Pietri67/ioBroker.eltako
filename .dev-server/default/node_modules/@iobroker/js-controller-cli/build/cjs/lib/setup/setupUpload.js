"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var setupUpload_exports = {};
__export(setupUpload_exports, {
  Upload: () => Upload
});
module.exports = __toCommonJS(setupUpload_exports);
var import_fs_extra = __toESM(require("fs-extra"), 1);
var import_js_controller_common = require("@iobroker/js-controller-common");
var import_deep_clone = __toESM(require("deep-clone"), 1);
var import_node_util = require("node:util");
var import_axios = __toESM(require("axios"), 1);
var import_mime_types = __toESM(require("mime-types"), 1);
var import_node_path = require("node:path");
const hostname = import_js_controller_common.tools.getHostName();
class Upload {
  states;
  objects;
  regApp = new RegExp(`/${import_js_controller_common.tools.appName.replace(/\./g, "\\.")}\\.`, "i");
  callbackId = 1;
  sendToHostFromCliAsync;
  callbacks = {};
  lastProgressUpdate = Date.now();
  constructor(_options) {
    const options = _options || {};
    if (!options.states) {
      throw new Error("Invalid arguments: states is missing");
    }
    if (!options.objects) {
      throw new Error("Invalid arguments: objects is missing");
    }
    this.states = options.states;
    this.objects = options.objects;
    this.sendToHostFromCliAsync = import_js_controller_common.tools.promisifyNoError(this.sendToHostFromCli);
  }
  async checkHostsIfAlive(hosts) {
    const result = [];
    if (hosts) {
      for (const host of hosts) {
        const state = await this.states.getStateAsync(`${host}.alive`);
        if (state?.val) {
          result.push(host);
        }
      }
    }
    return result;
  }
  async getHosts(onlyAlive) {
    const hosts = [];
    try {
      const arr = await this.objects.getObjectListAsync({
        startkey: "system.host.",
        endkey: "system.host.\u9999"
      });
      if (arr?.rows) {
        for (const row of arr.rows) {
          if (row.value.type !== "host") {
            continue;
          }
          hosts.push(row.value._id);
        }
      }
    } catch (e) {
      console.warn(`Cannot read hosts: ${e.message}`);
    }
    if (onlyAlive) {
      return this.checkHostsIfAlive(hosts);
    }
    return hosts;
  }
  // Check if some adapters must be restarted and restart them
  async checkRestartOther(adapter) {
    const adapterDir = import_js_controller_common.tools.getAdapterDir(adapter);
    if (!adapterDir) {
      console.error(`Adapter directory of adapter "${adapter}" not found`);
      return;
    }
    try {
      const adapterConf = await import_fs_extra.default.readJSON((0, import_node_path.join)(adapterDir, "io-package.json"));
      if (adapterConf.common.restartAdapters) {
        if (!Array.isArray(adapterConf.common.restartAdapters)) {
          if (typeof adapterConf.common.restartAdapters !== "string") {
            return;
          }
          adapterConf.common.restartAdapters = [adapterConf.common.restartAdapters];
        }
        if (adapterConf.common.restartAdapters.length && adapterConf.common.restartAdapters[0]) {
          const instances = await import_js_controller_common.tools.getAllInstances(adapterConf.common.restartAdapters, this.objects);
          if (instances?.length) {
            for (const instance of instances) {
              try {
                const obj = await this.objects.getObjectAsync(instance);
                if (obj?.common?.enabled) {
                  obj.common.enabled = false;
                  obj.from = `system.host.${import_js_controller_common.tools.getHostName()}.cli`;
                  obj.ts = Date.now();
                  await this.objects.setObjectAsync(obj._id, obj);
                  obj.common.enabled = true;
                  obj.ts = Date.now();
                  await this.objects.setObjectAsync(obj._id, obj);
                  console.log(`Adapter "${obj._id}" restarted.`);
                }
              } catch (e) {
                console.error(`Cannot restart adapter "${instance}": ${e.message}`);
              }
            }
          }
        }
      }
    } catch (e) {
      console.error(`Cannot parse ${adapterDir}/io-package.json: ${e.message}`);
    }
  }
  sendToHostFromCli(host, command, message, callback) {
    const time = Date.now();
    const from = `system.host.${hostname}_cli_${time}`;
    const timeout = setTimeout(() => {
      if (callback) {
        callback();
      }
      callback = null;
      this.states.unsubscribeMessage(from);
      this.states.onChange = null;
    }, 6e4);
    this.states.onChange = (id, msg) => {
      if (id.endsWith(from)) {
        if (msg.command === "log" || msg.command === "error" || msg.command === "warn") {
          console[msg.command](`${host} -> ${msg.text}`);
        } else if (callback) {
          callback(msg && msg.message);
          callback = null;
          clearTimeout(timeout);
          this.states.unsubscribeMessage(from);
          this.states.onChange = null;
        }
      }
    };
    this.states.subscribeMessage(from, () => {
      const obj = {
        command,
        message,
        from: `system.host.${hostname}_cli_${time}`,
        callback: {
          message,
          id: this.callbackId++,
          ack: false,
          time
        }
      };
      if (this.callbackId > 4294967295) {
        this.callbackId = 1;
      }
      this.callbacks[`_${obj.callback.id}`] = { cb: callback };
      this.states.pushMessage(host, obj);
    });
  }
  async uploadAdapterFullAsync(adapters) {
    if (adapters?.length) {
      const liveHosts = await this.getHosts(true);
      for (const adapter of adapters) {
        const instances = await import_js_controller_common.tools.getInstances(adapter, this.objects, true);
        let instance = instances.find((obj) => obj?.common?.host === hostname);
        instance = instance || instances.find((obj) => obj?.common?.enabled && liveHosts.includes(obj.common.host));
        instance = instance || instances.find((obj) => obj?.common && liveHosts.includes(obj.common.host));
        if (instance && instance.common.host !== hostname) {
          console.log(`Send upload command to host "${instance.common.host}"... `);
          const response = await this.sendToHostFromCliAsync(instance.common.host, "upload", adapter);
          if (response) {
            console.log(`Upload result: ${response.result}`);
          } else {
            console.error(`No answer from ${instance.common.host}`);
          }
        } else {
          if (!instance) {
            const adapterDir = import_js_controller_common.tools.getAdapterDir(adapter);
            if (!adapterDir || !import_fs_extra.default.existsSync(adapterDir)) {
              console.warn(`No alive host found which has the adapter ${adapter} installed! No upload possible. Skipped.`);
              continue;
            }
          }
          await this.uploadAdapter(adapter, true, true);
          await this.upgradeAdapterObjects(adapter);
          await this.uploadAdapter(adapter, false, true);
        }
      }
    }
  }
  /**
   * Uploads a file
   *
   * @param source source path
   * @param target target path
   */
  async uploadFile(source, target) {
    target = target.replace(/\\/g, "/");
    source = source.replace(/\\/g, "/");
    if (target[0] === "/") {
      target = target.substring(1);
    }
    if (target[target.length - 1] === "/") {
      let name = source.split("/").pop();
      name = name.split("?")[0];
      if (!name.includes(".")) {
        name = "index.html";
      }
      target += name;
    }
    const parts = target.split("/");
    const adapter = parts[0];
    parts.splice(0, 1);
    target = parts.join("/");
    if (source.match(/^http:\/\/|^https:\/\//)) {
      try {
        const result = await (0, import_axios.default)(source, {
          responseType: "arraybuffer",
          validateStatus: (status) => status === 200
        });
        if (result?.data) {
          await this.objects.writeFileAsync(adapter, target, result.data);
        } else {
          console.error(`Empty response from URL "${source}"`);
          throw new Error(`Empty response from URL "${source}"`);
        }
      } catch (e) {
        let result;
        if (e.response) {
          result = e.response.data || e.response.status;
        } else if (e.request) {
          result = e.request;
        } else {
          result = e.message;
        }
        console.error(`Cannot get URL "${source}": ${result}`);
        throw new Error(result);
      }
    } else {
      try {
        await this.objects.writeFileAsync(adapter, target, import_fs_extra.default.readFileSync(source));
      } catch (e) {
        console.error(`Cannot read file "${source}": ${e.message}`);
        throw e;
      }
    }
    return `${adapter}/${target}`;
  }
  async eraseFiles(files, logger) {
    if (files && files.length) {
      for (const file of files) {
        try {
          await this.objects.unlinkAsync(file.adapter, file.path);
        } catch (e) {
          logger.error(`Cannot delete file "${file.path}": ${e}`);
        }
      }
    }
  }
  /**
   * Collect Files of an adapter specific directory from the ioBroker storage
   *
   * @param adapter Adapter name
   * @param path path in the adapter specific storage space
   * @param logger Logger instance
   */
  async collectExistingFilesToDelete(adapter, path, logger) {
    let _files = [];
    let _dirs = [];
    let files;
    try {
      files = await this.objects.readDirAsync(adapter, path);
    } catch {
      files = [];
    }
    if (files?.length) {
      for (const file of files) {
        if (file.file === "." || file.file === "..") {
          continue;
        }
        const newPath = path + file.file;
        if (file.isDir) {
          if (!_dirs.find((e) => e.path === newPath)) {
            _dirs.push({ adapter, path: newPath });
          }
          try {
            const result = await this.collectExistingFilesToDelete(adapter, `${newPath}/`, logger);
            if (result.filesToDelete) {
              _files = _files.concat(result.filesToDelete);
            }
            _dirs = _dirs.concat(result.dirs);
          } catch (e) {
            logger.warn(`Cannot delete folder "${adapter}${newPath}/": ${e.message}`);
          }
        } else if (!_files.find((e) => e.path === newPath)) {
          _files.push({ adapter, path: newPath });
        }
      }
    }
    return { filesToDelete: _files, dirs: _dirs };
  }
  async upload(adapter, isAdmin, files, id, logger) {
    const uploadID = `system.adapter.${adapter}.upload`;
    await this.states.setState(uploadID, { val: 0, ack: true });
    for (let f = 0; f < files.length; f++) {
      const file = files[f];
      if (file === ".gitignore") {
        continue;
      }
      const mimeType = import_mime_types.default.lookup(file);
      let attNameArr = file.split(this.regApp);
      if (attNameArr.length === 1 && file.toLowerCase().includes(import_js_controller_common.tools.appName.toLowerCase())) {
        attNameArr = ["", file.substring(import_js_controller_common.tools.appName.length + 2)];
      }
      let attName = attNameArr.pop();
      attName = attName.split("/").slice(2).join("/");
      const remainingFiles = files.length - f - 1;
      if (remainingFiles >= 100) {
        (!f || !(remainingFiles % 50)) && logger.log(`upload [${remainingFiles}] ${id} ${file} ${attName} ${mimeType}`);
      } else if (remainingFiles > 20) {
        if (!f || !(remainingFiles % 10)) {
          logger.log(`upload [${remainingFiles}] ${id} ${file} ${attName} ${mimeType}`);
        }
      } else {
        logger.log(`upload [${remainingFiles}] ${id} ${file} ${attName} ${mimeType}`);
      }
      if (!isAdmin) {
        const now = Date.now();
        if (now - this.lastProgressUpdate > 1e3) {
          this.lastProgressUpdate = now;
          await this.states.setState(uploadID, {
            val: Math.round(1e3 * (files.length - f) / files.length) / 10,
            ack: true
          });
        }
      }
      try {
        const content = await import_fs_extra.default.readFile(file);
        await this.objects.writeFileAsync(id, attName, content, { mimeType: mimeType || void 0 });
      } catch (e) {
        console.error(`Error: Cannot upload ${file}: ${e.message}`);
      }
    }
    if (!isAdmin && files.length) {
      await this.states.setState(uploadID, { val: 0, ack: true });
    }
    return adapter;
  }
  // Read synchronous all files recursively from local directory
  walk(dir, _results) {
    const results = _results || [];
    try {
      if (import_fs_extra.default.existsSync(dir)) {
        const list = import_fs_extra.default.readdirSync(dir);
        list.map((file) => {
          const stat = import_fs_extra.default.statSync(`${dir}/${file}`);
          if (stat.isDirectory()) {
            this.walk(`${dir}/${file}`, results);
          } else {
            if (!file.endsWith(".npmignore") && !file.endsWith(".gitignore")) {
              results.push(`${dir}/${file}`);
            }
          }
        });
      }
    } catch (e) {
      console.error(e);
    }
    return results;
  }
  /**
   * Upload given adapter
   *
   * @param adapter adapter name
   * @param isAdmin if admin folder should be uploaded too
   * @param forceUpload if upload should be forced
   * @param subTree subtree path to upload
   * @param _logger logger instance
   */
  async uploadAdapter(adapter, isAdmin, forceUpload, subTree, _logger) {
    const id = adapter + (isAdmin ? ".admin" : "");
    const adapterDir = import_js_controller_common.tools.getAdapterDir(adapter);
    let dir = adapterDir ? adapterDir + (isAdmin ? "/admin" : "/www") : "";
    const logger = _logger || console;
    if (subTree && dir) {
      dir += `/${subTree}`;
    }
    if (adapterDir === null || !import_fs_extra.default.existsSync(adapterDir)) {
      console.log(`INFO: Directory "${adapterDir || `for ${adapter}${isAdmin ? ".admin" : ""}`}" does not exist. Nothing was uploaded or deleted.`);
      return adapter;
    }
    let cfg;
    try {
      cfg = await import_fs_extra.default.readJSON(`${adapterDir}/io-package.json`);
    } catch (e) {
      console.error(`Could not read io-package.json: ${e.message}`);
    }
    if (!import_fs_extra.default.existsSync(dir)) {
      (isAdmin || cfg?.common?.onlyWWW && !cfg.common.visWidgets) && console.log(`INFO: Directory "${dir || `for ${adapter}${isAdmin ? ".admin" : ""}`}" was not found! Nothing was uploaded or deleted.`);
      if (isAdmin) {
        return adapter;
      }
      await this.checkRestartOther(adapter);
      return adapter;
    }
    if (!isAdmin && cfg?.common?.wwwDontUpload) {
      return adapter;
    }
    if (!isAdmin) {
      let obj;
      const uploadID = `system.adapter.${adapter}.upload`;
      try {
        obj = await this.objects.getObject(uploadID);
      } catch {
      }
      if (!obj) {
        await this.objects.setObject(uploadID, {
          _id: uploadID,
          type: "state",
          common: {
            name: `${adapter}.upload`,
            type: "number",
            role: "indicator.state",
            unit: "%",
            min: 0,
            max: 100,
            def: 0,
            desc: "Upload process indicator",
            read: true,
            write: false
          },
          from: `system.host.${import_js_controller_common.tools.getHostName()}.cli`,
          ts: Date.now(),
          native: {}
        });
      }
      await this.states.setState(uploadID, { val: 0, ack: true });
    }
    let result;
    try {
      result = await this.objects.getObjectAsync(id);
    } catch {
    }
    const files = this.walk(dir);
    if (!result) {
      await this.objects.setObjectAsync(id, {
        type: "meta",
        common: {
          name: id.split(".").pop(),
          type: isAdmin ? "admin" : "www"
        },
        from: `system.host.${import_js_controller_common.tools.getHostName()}.cli`,
        ts: Date.now(),
        native: {}
      });
      forceUpload = true;
    }
    if (forceUpload) {
      if (cfg?.common?.eraseOnUpload !== false && !(cfg?.common?.eraseOnUpload === void 0 && cfg?.common?.type === "visualization")) {
        const { filesToDelete } = await this.collectExistingFilesToDelete(isAdmin ? `${adapter}.admin` : adapter, "/", logger);
        await this.eraseFiles(filesToDelete, logger);
      }
      if (!isAdmin) {
        await this.checkRestartOther(adapter);
        await new Promise((resolve) => setTimeout(() => resolve(), 25));
        await this.upload(adapter, isAdmin, files, id, logger);
      } else {
        await this.upload(adapter, isAdmin, files, id, logger);
      }
    }
    return adapter;
  }
  extendNative(target, additional) {
    if (import_js_controller_common.tools.isObject(additional)) {
      for (const [attr, attrData] of Object.entries(additional)) {
        if (target[attr] === void 0) {
          target[attr] = attrData;
        } else if (import_js_controller_common.tools.isObject(attrData)) {
          try {
            target[attr] = target[attr] || {};
          } catch {
            console.warn(`Cannot update attribute ${attr} of native`);
          }
          if (typeof target[attr] === "object" && target[attr] !== null) {
            this.extendNative(target[attr], attrData);
          }
        }
      }
    }
    return target;
  }
  extendCommon(target, additional, instance) {
    if (import_js_controller_common.tools.isObject(additional)) {
      const preserveAttributes = [
        "title",
        "schedule",
        "restartSchedule",
        "mode",
        "loglevel",
        "enabled",
        "custom",
        "tier"
      ];
      for (const [attr, attrData] of Object.entries(additional)) {
        if (preserveAttributes.includes(attr) || attr === "titleLang" && typeof target[attr] === "string") {
          if (target[attr] === void 0) {
            target[attr] = attrData;
          }
        } else if (typeof attrData !== "object" || attrData instanceof Array) {
          try {
            target[attr] = attrData;
            if (attr === "dataFolder" && target.dataFolder && target.dataFolder.includes("%INSTANCE%")) {
              target.dataFolder = target.dataFolder.replace(/%INSTANCE%/g, instance);
            }
          } catch {
            console.warn(`Cannot update attribute ${attr} of common`);
          }
        } else {
          target[attr] = target[attr] || {};
          if (typeof target[attr] !== "object") {
            target[attr] = {};
          }
          this.extendCommon(target[attr], attrData, instance);
        }
      }
    }
    return target;
  }
  /**
   * Extends the `system.instance.adapter.<instanceNumber>` objects with the native properties from adapters io-package.json
   *
   * @param name name of the adapter
   * @param ioPack parsed io-package content
   * @param hostname name of the host where the adapter is installed on
   * @param logger instance of logger
   */
  async _upgradeAdapterObjectsHelper(name, ioPack, hostname2, logger) {
    const res = await this.objects.getObjectViewAsync("system", "instance", {
      startkey: `system.adapter.${name}.`,
      endkey: `system.adapter.${name}.\u9999`
    });
    if (res) {
      for (const row of res.rows) {
        if (row.value?.common.host === hostname2) {
          const _obj = await this.objects.getObject(row.id);
          const newObject = (0, import_deep_clone.default)(_obj);
          newObject.common = this.extendCommon(newObject.common, ioPack.common, newObject._id.split(".").pop());
          newObject.native = this.extendNative(newObject.native, ioPack.native);
          newObject.protectedNative = ioPack.protectedNative || [];
          newObject.encryptedNative = ioPack.encryptedNative || [];
          newObject.notifications = ioPack.notifications || [];
          newObject.instanceObjects = ioPack.instanceObjects || [];
          newObject.objects = ioPack.objects || [];
          newObject.common.version = ioPack.common.version;
          newObject.common.installedVersion = ioPack.common.version;
          newObject.common.installedFrom = ioPack.common.installedFrom;
          if (ioPack.common.visWidgets) {
            newObject.common.visWidgets = ioPack.common.visWidgets;
          } else {
            delete newObject.common.visWidgets;
          }
          if (ioPack.common.localLinks) {
            newObject.common.localLinks = ioPack.common.localLinks;
          } else {
            delete newObject.common.localLinks;
          }
          if (!ioPack.common.compact && newObject.common.compact) {
            newObject.common.compact = ioPack.common.compact;
          }
          if (!(0, import_node_util.isDeepStrictEqual)(newObject, _obj)) {
            logger.log(`Update "${newObject._id}"`);
            newObject.from = `system.host.${import_js_controller_common.tools.getHostName()}.cli`;
            newObject.ts = Date.now();
            await this.objects.setObjectAsync(newObject._id, newObject);
          }
        }
      }
    }
    if (Array.isArray(ioPack.objects)) {
      for (const obj of ioPack.objects) {
        if (name === "js-controller" && !obj._id.startsWith("_design/")) {
          continue;
        }
        obj.from = `system.host.${hostname2}.cli`;
        obj.ts = Date.now();
        try {
          await this.objects.setObjectAsync(obj._id, obj);
        } catch (e) {
          logger.error(`Cannot update object: ${e}`);
        }
      }
    }
    return name;
  }
  /**
   * Create object from io-package json
   *
   * @param name adapter name
   * @param ioPack IoPack content
   * @param logger logger instance
   */
  async upgradeAdapterObjects(name, ioPack, logger = console) {
    const adapterDir = import_js_controller_common.tools.getAdapterDir(name);
    let ioPackFile;
    try {
      ioPackFile = import_fs_extra.default.readJSONSync(`${adapterDir}/io-package.json`);
    } catch {
      if (adapterDir) {
        logger.error(`Cannot find io-package.json in ${adapterDir}`);
      } else {
        logger.error(`Cannot find io-package.json for "${name}"`);
      }
      ioPackFile = null;
    }
    ioPack = ioPack || ioPackFile;
    if (ioPack) {
      logger.log(`Updating objects from io-package.json for adapter "${name}" with version "${ioPack.common.version}"`);
      if (ioPackFile?.common?.installedFrom) {
        ioPack.common = ioPack.common || {};
        ioPack.common.installedFrom = ioPackFile.common.installedFrom;
      }
      let _obj;
      try {
        _obj = await this.objects.getObject(`system.adapter.${name}`);
      } catch {
      }
      const obj = _obj || {
        common: ioPack.common,
        native: ioPack.native,
        type: "adapter",
        instanceObjects: [],
        objects: []
      };
      obj.common = ioPack.common || {};
      obj.native = ioPack.native || {};
      obj.protectedNative = ioPack.protectedNative || [];
      obj.encryptedNative = ioPack.encryptedNative || [];
      obj.notifications = ioPack.notifications || [];
      obj.instanceObjects = ioPack.instanceObjects || [];
      obj.objects = ioPack.objects || [];
      obj.type = "adapter";
      obj.common.installedVersion = ioPack.common.version;
      if (obj.common.news) {
        delete obj.common.news;
      }
      const hostname2 = import_js_controller_common.tools.getHostName();
      obj.from = `system.host.${hostname2}.cli`;
      obj.ts = Date.now();
      try {
        await this.objects.setObject(`system.adapter.${name}`, obj);
        await this.objects.setObject(`system.host.${hostname2}.adapter.${name}`, obj);
      } catch (e) {
        logger.error(`Cannot set "system.adapter.${name}" and "system.host.${hostname2}.adapters.${name}": ${e.message}`);
      }
      await this._upgradeAdapterObjectsHelper(name, ioPack, hostname2, logger);
    }
    return name;
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Upload
});
//# sourceMappingURL=setupUpload.js.map
