"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var cliCompact_exports = {};
__export(cliCompact_exports, {
  CLICompact: () => CLICompact
});
module.exports = __toCommonJS(cliCompact_exports);
var CLI = __toESM(require("./messages.js"), 1);
var import_cliCommand = require("./cliCommand.js");
var import_js_controller_common = require("@iobroker/js-controller-common");
var import_fs_extra = __toESM(require("fs-extra"), 1);
class CLICompact extends import_cliCommand.CLICommand {
  config = import_fs_extra.default.readJSONSync(import_js_controller_common.tools.getConfigFileName());
  constructor(options) {
    super(options);
  }
  /**
   * Executes a command
   *
   * @param args
   */
  execute(args) {
    const { callback, showHelp } = this.options;
    const command = args[0];
    switch (command) {
      case "status":
        return this.statusCompactModeHost();
      case "enable":
      case "on":
        return this.setCompactModeHost(true);
      case "disable":
      case "off":
        return this.setCompactModeHost(false);
      default:
        if (command && command.includes(".")) {
          if (args[1]) {
            switch (args[1]) {
              case "status":
                return this.statusCompactModeInstance(command);
              case "enable":
              case "on":
                return this.setCompactModeInstance(command, true, args[2]);
              case "disable":
              case "off":
                return this.setCompactModeInstance(command, false);
              case "group":
                return this.setCompactModeInstance(command, void 0, args[2]);
            }
          }
        }
        CLI.error.unknownCommand("compact", command);
        showHelp();
        return void callback(3);
    }
  }
  /**
   * Output status of compact mode for host
   */
  statusCompactModeHost() {
    const { callback } = this.options;
    const compactMode = !!this.config?.system?.compact;
    console.log(`Compact mode for this host is currently ${compactMode ? "enabled" : "disabled"}`);
    return void callback();
  }
  /**
   * Set compact mode for this host
   *
   * @param targetState enable or disable compact mode for host
   */
  setCompactModeHost(targetState) {
    const { callback, dbConnect } = this.options;
    dbConnect((params) => {
      const { isOffline } = params;
      const currentState = !!this.config?.system?.compact;
      if (targetState === currentState) {
        console.log(`Compact mode for this host is already ${currentState ? "enabled" : "disabled"}`);
        return void callback();
      }
      this.config.system = this.config.system || {};
      this.config.system.compact = targetState;
      const configFileName = import_js_controller_common.tools.getConfigFileName();
      import_fs_extra.default.writeFileSync(configFileName, JSON.stringify(this.config, null, 4), "utf8");
      console.log();
      console.log(`Compact mode for this host is now ${targetState ? "enabled" : "disabled"}`);
      if (!isOffline) {
        console.log();
        console.log("Please restart ioBroker for this change to take effect!");
      }
      return void callback();
    });
  }
  /**
   * Output the compact mode status for a defined adapter instance
   *
   * @param instance instance to output status for
   */
  statusCompactModeInstance(instance) {
    const { callback, dbConnect } = this.options;
    dbConnect((params) => {
      const { objects } = params;
      if (!this.config.system?.compact) {
        console.log("Compact mode is disabled for this host. All compact mode settings will have no effect!");
        console.log();
      }
      objects.getObject(`system.adapter.${instance}`, (err, obj) => {
        if (!err && obj) {
          if (!obj.common.compact) {
            console.log("This adapter does not support compact mode. The below settings will have no effect!");
            console.log();
          } else {
            console.log(`Adapter supports compact mode:     ${!!obj.common.compact}`);
          }
          console.log(`Compact mode enabled for instance: ${!!obj.common.runAsCompactMode}`);
          console.log(`Compact group:                     ${obj.common.compactGroup !== void 0 ? obj.common.compactGroup : 1}`);
          return void callback();
        }
        CLI.error.invalidInstance(instance);
        return void callback(24);
      });
    });
  }
  /**
   * Put given instance in compact mode group
   *
   * @param instance instance to put in group
   * @param targetState if compact mode should be enabled for instance, if undefined `instance.common.runAsCompact` will not be updated
   * @param groupId the compact group id, if not given, it will be put in controller group
   */
  setCompactModeInstance(instance, targetState, groupId) {
    const { callback, dbConnect } = this.options;
    dbConnect(async (params) => {
      const { objects } = params;
      if (!this.config.system?.compact) {
        console.log("Compact mode is disabled on this host. This setting will have no effect!");
        console.log();
      }
      let obj;
      try {
        obj = await objects.getObject(`system.adapter.${instance}`);
      } catch {
      }
      if (!obj) {
        CLI.error.invalidInstance(instance);
        return void callback(24);
      }
      if (!obj.common.compact) {
        console.log("This adapter does not support compact mode. The below settings will have no effect!");
        console.log();
      } else {
        console.log(`Adapter supports compact mode :    ${!!obj.common.compact}`);
      }
      let newRunAsCompactMode;
      if (targetState !== void 0 && targetState !== !!obj.common.runAsCompactMode) {
        newRunAsCompactMode = targetState;
      }
      let newCompactGroup;
      if (obj.common.compactGroup === void 0) {
        obj.common.compactGroup = 1;
        newCompactGroup = obj.common.compactGroup;
      }
      if (groupId !== void 0) {
        groupId = typeof groupId === "string" ? parseInt(groupId, 10) : groupId;
        if (groupId !== obj.common.compactGroup) {
          newCompactGroup = groupId;
        }
      }
      console.log(`Compact mode enabled for instance: ${newRunAsCompactMode !== void 0 ? `--> ${newRunAsCompactMode}` : !!obj.common.runAsCompactMode}`);
      console.log(`Compact group:                     ${newCompactGroup !== void 0 && obj.common.compactGroup !== newCompactGroup ? `--> ${newCompactGroup}` : obj.common.compactGroup}`);
      if (newRunAsCompactMode !== void 0 || newCompactGroup !== void 0) {
        if (newCompactGroup !== void 0) {
          obj.common.compactGroup = newCompactGroup;
        }
        if (newRunAsCompactMode !== void 0) {
          obj.common.runAsCompactMode = newRunAsCompactMode;
        }
        obj.from = `system.host.${import_js_controller_common.tools.getHostName()}.cli`;
        obj.ts = (/* @__PURE__ */ new Date()).getTime();
        objects.setObject(`system.adapter.${instance}`, obj, (err) => {
          if (err) {
            console.log(err);
          }
          console.log(`Instance settings for "${instance}" are changed.`);
          callback();
        });
      } else {
        console.log("No settings changed.");
        return void callback();
      }
    });
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CLICompact
});
//# sourceMappingURL=cliCompact.js.map
