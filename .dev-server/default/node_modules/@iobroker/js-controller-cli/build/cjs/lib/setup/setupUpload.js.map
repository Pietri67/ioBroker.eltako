{
  "version": 3,
  "sources": ["../../../../src/lib/setup/setupUpload.ts"],
  "sourcesContent": ["/**\n *      Upload adapter files into DB\n *\n *      Copyright 2013-2024 bluefox <dogafox@gmail.com>\n *\n *      MIT License\n *\n */\n\nimport fs from 'fs-extra';\nimport { tools } from '@iobroker/js-controller-common';\nimport deepClone from 'deep-clone';\nimport { isDeepStrictEqual } from 'node:util';\nimport axios from 'axios';\nimport mime from 'mime-types';\nimport { join } from 'node:path';\nimport type { Client as StatesRedisClient } from '@iobroker/db-states-redis';\nimport type { Client as ObjectsRedisClient } from '@iobroker/db-objects-redis';\nimport type { InternalLogger } from '@iobroker/js-controller-common-db/tools';\n\nconst hostname = tools.getHostName();\n\nexport interface CLIUploadOptions {\n    states: StatesRedisClient;\n    objects: ObjectsRedisClient;\n}\n\ninterface File {\n    adapter: string;\n    path: string;\n}\n\ninterface Logger extends InternalLogger {\n    log(message: string): void;\n}\n\n/** Logger without noisy levels */\ntype MinimalLogger = Omit<Logger, 'info' | 'silly' | 'debug'>;\n\nexport class Upload {\n    private readonly states: StatesRedisClient;\n    private readonly objects: ObjectsRedisClient;\n    private readonly regApp = new RegExp(`/${tools.appName.replace(/\\./g, '\\\\.')}\\\\.`, 'i');\n    private callbackId = 1;\n    private readonly sendToHostFromCliAsync: (...args: any[]) => Promise<any>;\n    private callbacks: Record<string, any> = {};\n    private lastProgressUpdate = Date.now();\n\n    constructor(_options: CLIUploadOptions) {\n        const options = _options || {};\n\n        if (!options.states) {\n            throw new Error('Invalid arguments: states is missing');\n        }\n        if (!options.objects) {\n            throw new Error('Invalid arguments: objects is missing');\n        }\n\n        this.states = options.states;\n        this.objects = options.objects;\n        this.sendToHostFromCliAsync = tools.promisifyNoError(this.sendToHostFromCli);\n    }\n\n    async checkHostsIfAlive(hosts: string[]): Promise<string[]> {\n        const result = [];\n        if (hosts) {\n            for (const host of hosts) {\n                const state = await this.states.getStateAsync(`${host}.alive`);\n                if (state?.val) {\n                    result.push(host);\n                }\n            }\n        }\n        return result;\n    }\n\n    async getHosts(onlyAlive: boolean): Promise<string[]> {\n        const hosts = [];\n        try {\n            const arr = await this.objects.getObjectListAsync({\n                startkey: 'system.host.',\n                endkey: 'system.host.\\u9999',\n            });\n            if (arr?.rows) {\n                for (const row of arr.rows) {\n                    if (row.value.type !== 'host') {\n                        continue;\n                    }\n                    hosts.push(row.value._id);\n                }\n            }\n        } catch (e) {\n            // ignore\n            console.warn(`Cannot read hosts: ${e.message}`);\n        }\n\n        if (onlyAlive) {\n            return this.checkHostsIfAlive(hosts);\n        }\n        return hosts;\n    }\n\n    // Check if some adapters must be restarted and restart them\n    async checkRestartOther(adapter: string): Promise<void> {\n        const adapterDir = tools.getAdapterDir(adapter);\n\n        if (!adapterDir) {\n            console.error(`Adapter directory of adapter \"${adapter}\" not found`);\n            return;\n        }\n\n        try {\n            const adapterConf = await fs.readJSON(join(adapterDir, 'io-package.json'));\n            if (adapterConf.common.restartAdapters) {\n                if (!Array.isArray(adapterConf.common.restartAdapters)) {\n                    // it's not an array, now it can only be a single adapter as string\n                    if (typeof adapterConf.common.restartAdapters !== 'string') {\n                        return;\n                    }\n                    adapterConf.common.restartAdapters = [adapterConf.common.restartAdapters];\n                }\n\n                if (adapterConf.common.restartAdapters.length && adapterConf.common.restartAdapters[0]) {\n                    const instances = await tools.getAllInstances(adapterConf.common.restartAdapters, this.objects);\n                    if (instances?.length) {\n                        for (const instance of instances) {\n                            try {\n                                const obj = await this.objects.getObjectAsync(instance);\n                                // if instance is enabled\n                                if (obj?.common?.enabled) {\n                                    obj.common.enabled = false; // disable instance\n\n                                    obj.from = `system.host.${tools.getHostName()}.cli`;\n                                    obj.ts = Date.now();\n\n                                    await this.objects.setObjectAsync(obj._id, obj);\n\n                                    obj.common.enabled = true; // enable instance\n                                    obj.ts = Date.now();\n\n                                    await this.objects.setObjectAsync(obj._id, obj);\n                                    console.log(`Adapter \"${obj._id}\" restarted.`);\n                                }\n                            } catch (e) {\n                                console.error(`Cannot restart adapter \"${instance}\": ${e.message}`);\n                            }\n                        }\n                    }\n                }\n            }\n        } catch (e) {\n            console.error(`Cannot parse ${adapterDir}/io-package.json: ${e.message}`);\n        }\n    }\n\n    sendToHostFromCli(\n        host: string,\n        command: string,\n        message: ioBroker.MessagePayload,\n        callback: ioBroker.MessageCallback | null,\n    ): void {\n        const time = Date.now();\n        const from = `system.host.${hostname}_cli_${time}`;\n\n        const timeout = setTimeout(() => {\n            if (callback) {\n                callback();\n            }\n            callback = null;\n            this.states.unsubscribeMessage(from);\n            // @ts-expect-error todo: I don't think this works\n            this.states.onChange = null;\n        }, 60_000);\n\n        // @ts-expect-error todo: I don't think this works\n        this.states.onChange = (id, msg) => {\n            if (id.endsWith(from)) {\n                if (msg.command === 'log' || msg.command === 'error' || msg.command === 'warn') {\n                    // @ts-expect-error\n                    console[msg.command](`${host} -> ${msg.text}`);\n                } else if (callback) {\n                    callback(msg && msg.message);\n                    callback = null;\n                    clearTimeout(timeout);\n                    this.states.unsubscribeMessage(from);\n                    // @ts-expect-error\n                    this.states.onChange = null;\n                }\n            }\n        };\n\n        this.states.subscribeMessage(from, () => {\n            const obj = {\n                command,\n                message: message,\n                from: `system.host.${hostname}_cli_${time}`,\n                callback: {\n                    message,\n                    id: this.callbackId++,\n                    ack: false,\n                    time,\n                },\n            } as const;\n\n            if (this.callbackId > 0xffffffff) {\n                this.callbackId = 1;\n            }\n\n            this.callbacks[`_${obj.callback.id}`] = { cb: callback };\n\n            // we cannot receive answers from hosts in CLI, so this command is \"fire and forget\"\n            this.states.pushMessage(host, obj);\n        });\n    }\n\n    async uploadAdapterFullAsync(adapters: string[]): Promise<void> {\n        if (adapters?.length) {\n            const liveHosts = await this.getHosts(true);\n            for (const adapter of adapters) {\n                // Find the host which has this adapter\n                const instances = await tools.getInstances(adapter, this.objects, true);\n                // try to find instance on this host\n                let instance = instances.find(obj => obj?.common?.host === hostname);\n\n                // try to find enabled instance on live host\n                instance =\n                    instance || instances.find(obj => obj?.common?.enabled && liveHosts.includes(obj.common.host));\n\n                // try to find any instance\n                instance = instance || instances.find(obj => obj?.common && liveHosts.includes(obj.common.host));\n\n                if (instance && instance.common.host !== hostname) {\n                    console.log(`Send upload command to host \"${instance.common.host}\"... `);\n                    // send upload message to the host\n                    const response = await this.sendToHostFromCliAsync(instance.common.host, 'upload', adapter);\n                    if (response) {\n                        console.log(`Upload result: ${response.result}`);\n                    } else {\n                        console.error(`No answer from ${instance.common.host}`);\n                    }\n                } else {\n                    if (!instance) {\n                        // no one alive instance found\n                        const adapterDir = tools.getAdapterDir(adapter);\n                        if (!adapterDir || !fs.existsSync(adapterDir)) {\n                            console.warn(\n                                `No alive host found which has the adapter ${adapter} installed! No upload possible. Skipped.`,\n                            );\n                            continue;\n                        }\n                    }\n\n                    // try to upload on this host. It will print an error if the adapter directory not found\n                    await this.uploadAdapter(adapter, true, true);\n                    await this.upgradeAdapterObjects(adapter);\n                    await this.uploadAdapter(adapter, false, true);\n                }\n            }\n        }\n    }\n\n    /**\n     * Uploads a file\n     *\n     * @param source source path\n     * @param target target path\n     */\n    async uploadFile(source: string, target: string): Promise<string> {\n        target = target.replace(/\\\\/g, '/');\n        source = source.replace(/\\\\/g, '/');\n        if (target[0] === '/') {\n            target = target.substring(1);\n        }\n        if (target[target.length - 1] === '/') {\n            let name = source.split('/').pop()!;\n            name = name.split('?')[0];\n            if (!name.includes('.')) {\n                name = 'index.html';\n            }\n            target += name;\n        }\n        const parts = target.split('/');\n        const adapter = parts[0];\n        parts.splice(0, 1);\n        target = parts.join('/');\n\n        if (source.match(/^http:\\/\\/|^https:\\/\\//)) {\n            try {\n                const result = await axios(source, {\n                    responseType: 'arraybuffer',\n                    validateStatus: status => status === 200,\n                });\n                if (result?.data) {\n                    await this.objects.writeFileAsync(adapter, target, result.data);\n                } else {\n                    console.error(`Empty response from URL \"${source}\"`);\n                    throw new Error(`Empty response from URL \"${source}\"`);\n                }\n            } catch (e) {\n                let result;\n                if (e.response) {\n                    // The request was made and the server responded with a status code\n                    // that falls out of the range of 2xx\n                    result = e.response.data || e.response.status;\n                } else if (e.request) {\n                    // The request was made but no response was received\n                    // `err.request` is an instance of XMLHttpRequest in the browser and an instance of\n                    // http.ClientRequest in node.js\n                    result = e.request;\n                } else {\n                    // Something happened in setting up the request that triggered an Error\n                    result = e.message;\n                }\n                console.error(`Cannot get URL \"${source}\": ${result}`);\n                throw new Error(result);\n            }\n        } else {\n            try {\n                await this.objects.writeFileAsync(adapter, target, fs.readFileSync(source));\n            } catch (e) {\n                console.error(`Cannot read file \"${source}\": ${e.message}`);\n                throw e;\n            }\n        }\n\n        return `${adapter}/${target}`;\n    }\n\n    async eraseFiles(files: any[], logger: MinimalLogger | typeof console): Promise<void> {\n        if (files && files.length) {\n            for (const file of files) {\n                try {\n                    await this.objects.unlinkAsync(file.adapter, file.path);\n                } catch (e) {\n                    logger.error(`Cannot delete file \"${file.path}\": ${e}`);\n                }\n            }\n        }\n    }\n\n    /**\n     * Collect Files of an adapter specific directory from the ioBroker storage\n     *\n     * @param adapter Adapter name\n     * @param path path in the adapter specific storage space\n     * @param logger Logger instance\n     */\n    async collectExistingFilesToDelete(\n        adapter: string,\n        path: string,\n        logger: MinimalLogger | typeof console,\n    ): Promise<{\n        filesToDelete: File[];\n        dirs: File[];\n    }> {\n        let _files: File[] = [];\n        let _dirs: File[] = [];\n        let files: ioBroker.ReadDirResult[];\n        try {\n            files = await this.objects.readDirAsync(adapter, path);\n        } catch {\n            // ignore err\n            files = [];\n        }\n\n        if (files?.length) {\n            for (const file of files) {\n                if (file.file === '.' || file.file === '..') {\n                    continue;\n                }\n                const newPath = path + file.file;\n                if (file.isDir) {\n                    if (!_dirs.find(e => e.path === newPath)) {\n                        _dirs.push({ adapter, path: newPath });\n                    }\n                    try {\n                        const result = await this.collectExistingFilesToDelete(adapter, `${newPath}/`, logger);\n                        if (result.filesToDelete) {\n                            _files = _files.concat(result.filesToDelete);\n                        }\n\n                        _dirs = _dirs.concat(result.dirs);\n                    } catch (e) {\n                        logger.warn(`Cannot delete folder \"${adapter}${newPath}/\": ${e.message}`);\n                    }\n                } else if (!_files.find(e => e.path === newPath)) {\n                    _files.push({ adapter, path: newPath });\n                }\n            }\n        }\n\n        return { filesToDelete: _files, dirs: _dirs };\n    }\n\n    async upload(\n        adapter: string,\n        isAdmin: boolean,\n        files: string[],\n        id: string,\n        logger: MinimalLogger | typeof console,\n    ): Promise<string> {\n        const uploadID = `system.adapter.${adapter}.upload`;\n\n        await this.states.setState(uploadID, { val: 0, ack: true });\n\n        for (let f = 0; f < files.length; f++) {\n            const file = files[f];\n            // do not upload '.gitignore' files. Todo: add other exceptions\n            if (file === '.gitignore') {\n                continue;\n            }\n\n            const mimeType = mime.lookup(file);\n            let attNameArr = file.split(this.regApp);\n            // try to find anyway if adapter is not lower case\n            if (attNameArr.length === 1 && file.toLowerCase().includes(tools.appName.toLowerCase())) {\n                attNameArr = ['', file.substring(tools.appName.length + 2)];\n            }\n\n            let attName = attNameArr.pop()!;\n            attName = attName.split('/').slice(2).join('/');\n\n            const remainingFiles = files.length - f - 1;\n\n            if (remainingFiles >= 100) {\n                (!f || !(remainingFiles % 50)) &&\n                    logger.log(`upload [${remainingFiles}] ${id} ${file} ${attName} ${mimeType}`);\n            } else if (remainingFiles > 20) {\n                if (!f || !(remainingFiles % 10)) {\n                    logger.log(`upload [${remainingFiles}] ${id} ${file} ${attName} ${mimeType}`);\n                }\n            } else {\n                logger.log(`upload [${remainingFiles}] ${id} ${file} ${attName} ${mimeType}`);\n            }\n\n            // Update upload indicator\n            if (!isAdmin) {\n                const now = Date.now();\n                if (now - this.lastProgressUpdate > 1_000) {\n                    this.lastProgressUpdate = now;\n                    await this.states.setState(uploadID, {\n                        val: Math.round((1_000 * (files.length - f)) / files.length) / 10,\n                        ack: true,\n                    });\n                }\n            }\n\n            try {\n                const content = await fs.readFile(file);\n                await this.objects.writeFileAsync(id, attName, content, { mimeType: mimeType || undefined });\n            } catch (e) {\n                console.error(`Error: Cannot upload ${file}: ${e.message}`);\n            }\n        }\n\n        // Set upload progress to 0;\n        if (!isAdmin && files.length) {\n            await this.states.setState(uploadID, { val: 0, ack: true });\n        }\n\n        return adapter;\n    }\n\n    // Read synchronous all files recursively from local directory\n    walk(dir: string, _results?: string[]): string[] {\n        const results = _results || [];\n        try {\n            if (fs.existsSync(dir)) {\n                const list = fs.readdirSync(dir);\n                list.map(file => {\n                    const stat = fs.statSync(`${dir}/${file}`);\n                    if (stat.isDirectory()) {\n                        this.walk(`${dir}/${file}`, results);\n                    } else {\n                        if (!file.endsWith('.npmignore') && !file.endsWith('.gitignore')) {\n                            results.push(`${dir}/${file}`);\n                        }\n                    }\n                });\n            }\n        } catch (e) {\n            console.error(e);\n        }\n\n        return results;\n    }\n\n    /**\n     * Upload given adapter\n     *\n     * @param adapter adapter name\n     * @param isAdmin if admin folder should be uploaded too\n     * @param forceUpload if upload should be forced\n     * @param subTree subtree path to upload\n     * @param _logger logger instance\n     */\n    async uploadAdapter(\n        adapter: string,\n        isAdmin: boolean,\n        forceUpload: boolean,\n        subTree?: string,\n        _logger?: MinimalLogger,\n    ): Promise<string> {\n        const id = adapter + (isAdmin ? '.admin' : '');\n        const adapterDir = tools.getAdapterDir(adapter);\n        let dir = adapterDir ? adapterDir + (isAdmin ? '/admin' : '/www') : '';\n\n        const logger = _logger || console;\n\n        if (subTree && dir) {\n            dir += `/${subTree}`;\n        }\n        if (adapterDir === null || !fs.existsSync(adapterDir)) {\n            console.log(\n                `INFO: Directory \"${\n                    adapterDir || `for ${adapter}${isAdmin ? '.admin' : ''}`\n                }\" does not exist. Nothing was uploaded or deleted.`,\n            );\n            return adapter;\n        }\n\n        let cfg;\n        try {\n            cfg = await fs.readJSON(`${adapterDir}/io-package.json`);\n        } catch (e) {\n            // file not parsable or does not exist\n            console.error(`Could not read io-package.json: ${e.message}`);\n        }\n\n        if (!fs.existsSync(dir)) {\n            // www folder have not all adapters. So show warning only for admin folder\n            // widgets do not have www folder, but they have onlyWWW flag\n            (isAdmin || (cfg?.common?.onlyWWW && !cfg.common.visWidgets)) &&\n                console.log(\n                    `INFO: Directory \"${\n                        dir || `for ${adapter}${isAdmin ? '.admin' : ''}`\n                    }\" was not found! Nothing was uploaded or deleted.`,\n                );\n\n            if (isAdmin) {\n                return adapter;\n            }\n            await this.checkRestartOther(adapter);\n            return adapter;\n        }\n\n        // check for common.wwwDontUpload (required for legacy adapters and admin)\n        if (!isAdmin && cfg?.common?.wwwDontUpload) {\n            return adapter;\n        }\n\n        // Create \"upload progress\" object if not exists\n        if (!isAdmin) {\n            let obj;\n            const uploadID = `system.adapter.${adapter}.upload`;\n            try {\n                obj = await this.objects.getObject(uploadID);\n            } catch {\n                // ignore\n            }\n            if (!obj) {\n                await this.objects.setObject(uploadID, {\n                    _id: uploadID,\n                    type: 'state',\n                    common: {\n                        name: `${adapter}.upload`,\n                        type: 'number',\n                        role: 'indicator.state',\n                        unit: '%',\n                        min: 0,\n                        max: 100,\n                        def: 0,\n                        desc: 'Upload process indicator',\n                        read: true,\n                        write: false,\n                    },\n                    from: `system.host.${tools.getHostName()}.cli`,\n                    ts: Date.now(),\n                    native: {},\n                });\n            }\n            // Set indicator to 0\n            await this.states.setState(uploadID, { val: 0, ack: true });\n        }\n\n        let result;\n        try {\n            result = await this.objects.getObjectAsync(id);\n        } catch {\n            // ignore\n        }\n        // Read all names with subtrees from local directory\n        const files = this.walk(dir);\n        if (!result) {\n            // @ts-expect-error types needed admin is not allowed for meta, but it should be allowed\n            await this.objects.setObjectAsync(id, {\n                type: 'meta',\n                common: {\n                    name: id.split('.').pop()!,\n                    type: isAdmin ? 'admin' : 'www',\n                },\n                from: `system.host.${tools.getHostName()}.cli`,\n                ts: Date.now(),\n                native: {},\n            });\n            forceUpload = true;\n        }\n\n        if (forceUpload) {\n            // only skip if explicitly opted out\n            // The visualization check is needed as user of legacy systems often stored files inside adapter directories like `vis`\n            // in the long term, such adapters should explicitly opt out, so we can hopefully remove this line in 2-3 versions (current 5.0)\n            if (\n                cfg?.common?.eraseOnUpload !== false &&\n                !(cfg?.common?.eraseOnUpload === undefined && cfg?.common?.type === 'visualization')\n            ) {\n                const { filesToDelete } = await this.collectExistingFilesToDelete(\n                    isAdmin ? `${adapter}.admin` : adapter,\n                    '/',\n                    logger,\n                );\n                // delete old files, before upload of new\n                await this.eraseFiles(filesToDelete, logger);\n            }\n            if (!isAdmin) {\n                await this.checkRestartOther(adapter);\n                await new Promise<void>(resolve => setTimeout(() => resolve(), 25));\n                await this.upload(adapter, isAdmin, files, id, logger);\n            } else {\n                await this.upload(adapter, isAdmin, files, id, logger);\n            }\n        }\n        return adapter;\n    }\n\n    extendNative(target: Record<string, any>, additional: Record<string, unknown>): Record<string, any> {\n        if (tools.isObject(additional)) {\n            for (const [attr, attrData] of Object.entries(additional)) {\n                if (target[attr] === undefined) {\n                    target[attr] = attrData;\n                } else if (tools.isObject(attrData)) {\n                    try {\n                        target[attr] = target[attr] || {};\n                    } catch {\n                        console.warn(`Cannot update attribute ${attr} of native`);\n                    }\n                    if (typeof target[attr] === 'object' && target[attr] !== null) {\n                        this.extendNative(target[attr], attrData);\n                    }\n                }\n            }\n        }\n        return target;\n    }\n\n    extendCommon(\n        target: Record<string, any>,\n        additional: Record<string, any>,\n        instance: string,\n    ): ioBroker.InstanceCommon {\n        if (tools.isObject(additional)) {\n            const preserveAttributes = [\n                'title',\n                'schedule',\n                'restartSchedule',\n                'mode',\n                'loglevel',\n                'enabled',\n                'custom',\n                'tier',\n            ];\n\n            for (const [attr, attrData] of Object.entries(additional)) {\n                // preserve these attributes, except, they were undefined before and preserve titleLang if current titleLang is of type string (changed by user)\n                if (preserveAttributes.includes(attr) || (attr === 'titleLang' && typeof target[attr] === 'string')) {\n                    if (target[attr] === undefined) {\n                        target[attr] = attrData;\n                    }\n                } else if (typeof attrData !== 'object' || attrData instanceof Array) {\n                    try {\n                        target[attr] = attrData;\n\n                        // dataFolder can have wildcards\n                        if (attr === 'dataFolder' && target.dataFolder && target.dataFolder.includes('%INSTANCE%')) {\n                            target.dataFolder = target.dataFolder.replace(/%INSTANCE%/g, instance);\n                        }\n                    } catch {\n                        console.warn(`Cannot update attribute ${attr} of common`);\n                    }\n                } else {\n                    target[attr] = target[attr] || {};\n                    if (typeof target[attr] !== 'object') {\n                        target[attr] = {}; // here we clean the simple value with object\n                    }\n\n                    this.extendCommon(target[attr], attrData, instance);\n                }\n            }\n        }\n        return target as ioBroker.InstanceCommon;\n    }\n\n    /**\n     * Extends the `system.instance.adapter.<instanceNumber>` objects with the native properties from adapters io-package.json\n     *\n     * @param name name of the adapter\n     * @param ioPack parsed io-package content\n     * @param hostname name of the host where the adapter is installed on\n     * @param logger instance of logger\n     */\n    async _upgradeAdapterObjectsHelper(\n        name: string,\n        ioPack: ioBroker.AdapterObject,\n        hostname: string,\n        logger: MinimalLogger | typeof console,\n    ): Promise<string> {\n        // Update all instances of this host\n        const res = await this.objects.getObjectViewAsync('system', 'instance', {\n            startkey: `system.adapter.${name}.`,\n            endkey: `system.adapter.${name}.\\u9999`,\n        });\n\n        if (res) {\n            for (const row of res.rows) {\n                if (row.value?.common.host === hostname) {\n                    const _obj = await this.objects.getObject(row.id);\n                    const newObject = deepClone(_obj) as ioBroker.InstanceObject;\n\n                    // TODO: refactor the following assignments into a method, where we can define which attributes need a real override and their defaults\n\n                    // all common settings should be taken from new one\n                    newObject.common = this.extendCommon(\n                        newObject.common,\n                        ioPack.common,\n                        newObject._id.split('.').pop()!,\n                    );\n                    newObject.native = this.extendNative(newObject.native, ioPack.native);\n\n                    // protected/encryptedNative and notifications also need to be updated\n                    newObject.protectedNative = ioPack.protectedNative || [];\n                    newObject.encryptedNative = ioPack.encryptedNative || [];\n                    newObject.notifications = ioPack.notifications || [];\n                    // update instanceObjects and objects\n                    newObject.instanceObjects = ioPack.instanceObjects || [];\n                    newObject.objects = ioPack.objects || [];\n\n                    newObject.common.version = ioPack.common.version;\n                    newObject.common.installedVersion = ioPack.common.version;\n                    newObject.common.installedFrom = ioPack.common.installedFrom;\n\n                    // do not merge visWidgets and localLinks\n                    if (ioPack.common.visWidgets) {\n                        newObject.common.visWidgets = ioPack.common.visWidgets;\n                    } else {\n                        delete newObject.common.visWidgets;\n                    }\n\n                    if (ioPack.common.localLinks) {\n                        newObject.common.localLinks = ioPack.common.localLinks;\n                    } else {\n                        delete newObject.common.localLinks;\n                    }\n\n                    if (!ioPack.common.compact && newObject.common.compact) {\n                        newObject.common.compact = ioPack.common.compact;\n                    }\n\n                    // Compare objects to reduce restarts of instances\n                    if (!isDeepStrictEqual(newObject, _obj)) {\n                        logger.log(`Update \"${newObject._id}\"`);\n\n                        newObject.from = `system.host.${tools.getHostName()}.cli`;\n                        newObject.ts = Date.now();\n\n                        await this.objects.setObjectAsync(newObject._id, newObject);\n                    }\n                }\n            }\n        }\n\n        // updates only \"_design/system\" and co \"_design/*\"\n        if (Array.isArray(ioPack.objects)) {\n            for (const obj of ioPack.objects) {\n                if (name === 'js-controller' && !obj._id.startsWith('_design/')) {\n                    continue;\n                }\n\n                obj.from = `system.host.${hostname}.cli`;\n                obj.ts = Date.now();\n\n                try {\n                    await this.objects.setObjectAsync(obj._id, obj);\n                } catch (e) {\n                    logger.error(`Cannot update object: ${e}`);\n                }\n            }\n        }\n\n        return name;\n    }\n\n    /**\n     * Create object from io-package json\n     *\n     * @param name adapter name\n     * @param ioPack IoPack content\n     * @param logger logger instance\n     */\n    async upgradeAdapterObjects(\n        name: string,\n        ioPack?: ioBroker.AdapterObject,\n        logger: MinimalLogger | typeof console = console,\n    ): Promise<string> {\n        const adapterDir = tools.getAdapterDir(name);\n        let ioPackFile;\n        try {\n            ioPackFile = fs.readJSONSync(`${adapterDir}/io-package.json`);\n        } catch {\n            if (adapterDir) {\n                logger.error(`Cannot find io-package.json in ${adapterDir}`);\n            } else {\n                logger.error(`Cannot find io-package.json for \"${name}\"`);\n            }\n            ioPackFile = null;\n        }\n\n        ioPack = ioPack || ioPackFile;\n\n        if (ioPack) {\n            logger.log(\n                `Updating objects from io-package.json for adapter \"${name}\" with version \"${ioPack.common.version}\"`,\n            );\n            // Always update installedFrom from File on disk if exists and set\n            if (ioPackFile?.common?.installedFrom) {\n                ioPack.common = ioPack.common || {};\n                ioPack.common.installedFrom = ioPackFile.common.installedFrom;\n            }\n            // Not existing? Why ever ... we recreate\n            let _obj;\n            try {\n                _obj = await this.objects.getObject(`system.adapter.${name}`);\n            } catch {\n                // ignore err\n            }\n            const obj: Omit<ioBroker.AdapterObject, '_id'> = _obj || {\n                common: ioPack.common,\n                native: ioPack.native,\n                type: 'adapter',\n                instanceObjects: [],\n                objects: [],\n            };\n\n            obj.common = ioPack.common || {};\n            obj.native = ioPack.native || {};\n            // protected/encryptedNative and notifications also need to be updated\n            obj.protectedNative = ioPack.protectedNative || [];\n            obj.encryptedNative = ioPack.encryptedNative || [];\n            obj.notifications = ioPack.notifications || [];\n            // update instanceObjects and objects\n            obj.instanceObjects = ioPack.instanceObjects || [];\n            obj.objects = ioPack.objects || [];\n\n            obj.type = 'adapter';\n\n            obj.common.installedVersion = ioPack.common.version;\n\n            if (obj.common.news) {\n                delete obj.common.news; // remove this information as it could be big, but it will be taken from repo\n            }\n\n            const hostname = tools.getHostName();\n\n            obj.from = `system.host.${hostname}.cli`;\n            obj.ts = Date.now();\n\n            try {\n                await this.objects.setObject(`system.adapter.${name}`, obj);\n                await this.objects.setObject(`system.host.${hostname}.adapter.${name}`, obj);\n            } catch (e) {\n                logger.error(\n                    `Cannot set \"system.adapter.${name}\" and \"system.host.${hostname}.adapters.${name}\": ${e.message}`,\n                );\n            }\n\n            await this._upgradeAdapterObjectsHelper(name, ioPack, hostname, logger);\n        }\n\n        return name;\n    }\n}\n"],
  "mappings": "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",
  "names": ["fs", "axios", "mime", "hostname", "deepClone"]
}
