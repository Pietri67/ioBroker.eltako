"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var objectsInRedisClient_exports = {};
__export(objectsInRedisClient_exports, {
  ObjectsInRedisClient: () => ObjectsInRedisClient
});
module.exports = __toCommonJS(objectsInRedisClient_exports);
var __import_meta_url = typeof document === "undefined" ? new (require("url".replace("", ""))).URL("file:" + __filename).href : document.currentScript && document.currentScript.src || new URL("main.js", document.baseURI).href;
var import_node = __toESM(require("node.extend"), 1);
var import_ioredis = __toESM(require("ioredis"), 1);
var import_db_base = require("@iobroker/db-base");
var import_node_fs = __toESM(require("node:fs"), 1);
var import_node_path = __toESM(require("node:path"), 1);
var import_node_crypto = __toESM(require("node:crypto"), 1);
var import_node_util = require("node:util");
var import_deep_clone = __toESM(require("deep-clone"), 1);
var utils = __toESM(require("../../lib/objects/objectsUtils.js"), 1);
var import_semver = __toESM(require("semver"), 1);
var CONSTS = __toESM(require("../../lib/objects/constants.js"), 1);
var url = __toESM(require("node:url"), 1);
const thisDir = url.fileURLToPath(new URL(".", __import_meta_url || `file://${__filename}`));
const ERRORS = CONSTS.ERRORS;
class ObjectsInRedisClient {
  client;
  fileNamespace;
  redisNamespace;
  fileNamespaceL;
  objNamespace;
  setNamespace;
  metaNamespace;
  objNamespaceL;
  supportedProtocolVersions;
  stop;
  sub;
  subSystem;
  settings;
  preserveSettings;
  defaultNewAcl;
  namespace;
  hostname;
  scripts;
  existingMetaObjects;
  log;
  activeProtocolVersion;
  useSets;
  noLegacyMultihost;
  userSubscriptions;
  systemSubscriptions;
  constructor(settings) {
    this.settings = settings || {};
    this.redisNamespace = `${this.settings.redisNamespace || this.settings.connection && this.settings.connection.redisNamespace || "cfg"}.`;
    this.fileNamespace = `${this.redisNamespace}f.`;
    this.fileNamespaceL = this.fileNamespace.length;
    this.objNamespace = `${this.redisNamespace}o.`;
    this.setNamespace = `${this.redisNamespace}s.`;
    this.metaNamespace = `${this.settings.metaNamespace || "meta"}.`;
    this.objNamespaceL = this.objNamespace.length;
    this.supportedProtocolVersions = ["4"];
    this.stop = false;
    this.client = null;
    this.sub = null;
    this.subSystem = null;
    this.preserveSettings = ["custom", "smartName", "material", "habpanel", "mobile"];
    this.defaultNewAcl = this.settings.defaultNewAcl || null;
    this.namespace = this.settings.namespace || this.settings.hostname || "";
    this.hostname = this.settings.hostname || import_db_base.tools.getHostName();
    this.scripts = {};
    this.userSubscriptions = {};
    this.systemSubscriptions = {};
    this.existingMetaObjects = {};
    this.log = import_db_base.tools.getLogger(this.settings.logger);
    if (this.settings.autoConnect !== false) {
      this.connectDb();
    }
  }
  /**
   * Checks if we are allowed to start and sets the protocol version accordingly
   */
  async _determineProtocolVersion() {
    if (!this.client) {
      throw new Error(ERRORS.ERROR_DB_CLOSED);
    }
    let protoVersion;
    try {
      protoVersion = await this.client.get(`${this.metaNamespace}objects.protocolVersion`);
    } catch (e) {
      if (e.message.includes("GET-UNSUPPORTED")) {
        return;
      }
    }
    if (!protoVersion) {
      const highestVersion = Math.max(...this.supportedProtocolVersions.map((value) => parseInt(value)));
      await this.setProtocolVersion(highestVersion);
      this.activeProtocolVersion = highestVersion.toString();
      return;
    }
    if (this.supportedProtocolVersions.includes(protoVersion)) {
      this.activeProtocolVersion = protoVersion;
    } else {
      throw new Error(`This host does not support protocol version "${protoVersion}"`);
    }
  }
  connectDb() {
    this.settings.connection = this.settings.connection || {};
    const onChange = this.settings.change;
    const onChangeUser = this.settings.changeUser;
    const onChangeFileUser = this.settings.changeFileUser;
    this.settings.connection.maxQueue = this.settings.connection.maxQueue || 1e3;
    this.settings.connection.options = this.settings.connection.options || {};
    const retry_max_delay = this.settings.connection.options.retry_max_delay || 5e3;
    const retry_max_count = this.settings.connection.options.retry_max_count || 19;
    let ready = false;
    let initError = false;
    let connected = false;
    let reconnectCounter = 0;
    let errorLogged = false;
    this.settings.connection.options.retryStrategy = (reconnectCount) => {
      if (!ready && initError) {
        return new Error("No more tries");
      }
      if (this.stop) {
        return new Error("Client has stopped ... no retries anymore");
      }
      if (ready && reconnectCount >= retry_max_count) {
        return new Error("Stop trying to reconnect");
      }
      if (!ready) {
        return 300;
      }
      return retry_max_delay;
    };
    delete this.settings.connection.options.retry_max_delay;
    this.settings.connection.options.enableReadyCheck = true;
    if (this.settings.connection.port === 0) {
      this.settings.connection.options.path = this.settings.connection.host;
      this.log.debug(`${this.namespace} Redis Objects: Use File Socket for connection: ${this.settings.connection.options.path}`);
    } else if (Array.isArray(this.settings.connection.host)) {
      const configuredPort = this.settings.connection.port;
      const defaultPort = Array.isArray(configuredPort) ? null : configuredPort;
      this.settings.connection.options.sentinels = this.settings.connection.host.map((redisNode, idx) => ({
        host: redisNode,
        // @ts-expect-error ts does not get that if defPort is null we have an array
        port: defaultPort === null ? configuredPort[idx] : defaultPort
      }));
      this.settings.connection.options.name = this.settings.connection.sentinelName ? this.settings.connection.sentinelName : "mymaster";
      this.log.debug(`${this.namespace} Redis Objects: Use Sentinel for connection: ${this.settings.connection.options.name}, ${JSON.stringify(this.settings.connection.options.sentinels)}`);
    } else {
      this.settings.connection.options.host = this.settings.connection.host;
      this.settings.connection.options.port = this.settings.connection.port;
      this.log.debug(`${this.namespace} Redis Objects: Use Redis connection: ${this.settings.connection.options.host}:${this.settings.connection.options.port}`);
    }
    this.settings.connection.options.db = this.settings.connection.options.db || 0;
    this.settings.connection.options.family = this.settings.connection.options.family || 0;
    this.settings.connection.options.password = this.settings.connection.options.auth_pass || this.settings.connection.pass || null;
    this.settings.connection.options.autoResubscribe = false;
    this.settings.connection.options.connectionName = this.namespace.replace(/\s/g, "");
    this.client = new import_ioredis.default(this.settings.connection.options);
    this.client.on("error", (error) => {
      this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} Redis ERROR Objects: (${this.stop}) ${error.message} / ${error.stack}`);
      if (this.stop) {
        return;
      }
      if (!ready) {
        initError = true;
        if (error.message.startsWith('Protocol error, got "H" as reply type byte.')) {
          this.log.error(`${this.namespace} Could not connect to objects database at ${this.settings.connection.options.host}:${this.settings.connection.options.port} (invalid protocol). Please make sure the configured IP and port points to a host running JS-Controller >= 2.0. and that the port is not occupied by other software!`);
        }
        return;
      }
      this.log.error(`${this.namespace} Objects database error: ${error.message}`);
      errorLogged = true;
    });
    this.client.on("end", () => {
      this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} Objects-Redis Event end (stop=${this.stop})`);
      ready && typeof this.settings.disconnected === "function" && this.settings.disconnected();
    });
    this.client.on("connect", () => {
      this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} Objects-Redis Event connect (stop=${this.stop})`);
      connected = true;
      if (errorLogged) {
        this.log.info(`${this.namespace} Objects database successfully reconnected`);
        errorLogged = false;
      }
    });
    this.client.on("close", () => {
      this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} Objects-Redis Event close (stop=${this.stop})`);
    });
    this.client.on("reconnecting", () => {
      if (connected && !ready && !initError) {
        reconnectCounter++;
      }
      this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} Objects-Redis Event reconnect (reconnectCounter=${reconnectCounter}, stop=${this.stop})`);
      if (reconnectCounter > 2) {
        this.log.error(`${this.namespace} The DB port  ${this.settings.connection.options.port} is occupied by something that is not a Redis protocol server. Please check other software running on this port or, if you use iobroker, make sure to update to js-controller 2.0 or higher!`);
        return;
      }
      connected = false;
      initError = false;
    });
    this.client.on("ready", async () => {
      if (this.stop || !this.client) {
        return;
      }
      initError = false;
      this.log.debug(`${this.namespace} Objects client ready ... initialize now`);
      try {
        await this.client.config("SET", "lua-time-limit", 1e4);
      } catch (e) {
        this.log.warn(`${this.namespace} Unable to increase LUA script timeout: ${e.message}`);
      }
      let initCounter = 0;
      if (!this.subSystem && typeof onChange === "function") {
        initCounter++;
        this.log.debug(`${this.namespace} Objects create System PubSub Client`);
        this.subSystem = new import_ioredis.default(this.settings.connection.options);
        if (typeof this.settings.primaryHostLost === "function") {
          try {
            await this.client.config("SET", "notify-keyspace-events", "Exe");
          } catch (e) {
            this.log.warn(`${this.namespace} Unable to enable Expiry Keyspace events from Redis Server: ${e.message}`);
          }
          this.subSystem.on("message", (channel, message) => {
            if (channel === `__keyevent@${this.settings.connection.options.db}__:expired` || channel === `__keyevent@${this.settings.connection.options.db}__:evicted`) {
              this.log.silly(`${this.namespace} redis message expired/evicted ${channel}:${message}`);
              if (message === `${this.metaNamespace}objects.primaryHost` && typeof this.settings.primaryHostLost === "function") {
                this.settings.primaryHostLost();
              }
            }
          });
        }
        if (typeof onChange === "function") {
          this.subSystem.on("pmessage", (pattern, channel, message) => setImmediate(() => {
            this.log.silly(`${this.namespace} Objects system redis pmessage ${pattern}/${channel}:${message}`);
            if (channel.startsWith(this.metaNamespace)) {
              if (channel === `${this.metaNamespace}objects.protocolVersion` && message !== this.activeProtocolVersion) {
                if (typeof this.settings.disconnected === "function") {
                  this.log.info(`${this.namespace} Objects protocol version has changed, disconnecting!`);
                  this.settings.disconnected();
                }
              } else if (channel === `${this.metaNamespace}objects.features.useSets`) {
                const newUseSets = !!parseInt(message);
                if (newUseSets !== this.useSets) {
                  this.log.info(`${this.namespace} Sets ${newUseSets ? "activated" : "deactivated"}: restarting ...`);
                  this.useSets = newUseSets;
                  if (typeof this.settings.disconnected === "function") {
                    this.settings.disconnected();
                  }
                }
              }
              return;
            }
            try {
              if (channel.startsWith(this.objNamespace) && channel.length > this.objNamespaceL) {
                const id = channel.substring(this.objNamespaceL);
                try {
                  const obj2 = message ? JSON.parse(message) : null;
                  if (id === "system.config" && obj2 && obj2.common && obj2.common.defaultNewAcl && !(0, import_node_util.isDeepStrictEqual)(obj2.common.defaultNewAcl, this.defaultNewAcl)) {
                    this.defaultNewAcl = (0, import_deep_clone.default)(obj2.common.defaultNewAcl);
                    this.settings.controller && this.setDefaultAcl(this.defaultNewAcl);
                  }
                  onChange(id, obj2);
                } catch (e) {
                  this.log.warn(`${this.namespace} Objects Cannot process system pmessage ${id} - ${message}: ${e.message}`);
                  this.log.warn(`${this.namespace} ${e.stack}`);
                }
              } else {
                this.log.warn(`${this.namespace} Objects Received unexpected system pmessage: ${channel}`);
              }
            } catch (e) {
              this.log.warn(`${this.namespace} Objects system pmessage ${channel} ${JSON.stringify(message)} ${e.message}`);
              this.log.warn(`${this.namespace} ${e.stack}`);
            }
          }));
        }
        this.subSystem.on("end", () => {
          this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} Objects-Redis System Event end sub (stop=${this.stop})`);
          ready && typeof this.settings.disconnected === "function" && this.settings.disconnected();
        });
        this.subSystem.on("error", (error) => {
          if (this.stop) {
            return;
          }
          this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} PubSub System client Objects No redis connection: ${JSON.stringify(error)}`);
        });
        if (this.settings.connection.enhancedLogging) {
          this.subSystem.on("connect", () => this.log.silly(`${this.namespace} PubSub System client Objects-Redis Event connect (stop=${this.stop})`));
          this.subSystem.on("close", () => this.log.silly(`${this.namespace} PubSub System client Objects-Redis Event close (stop=${this.stop})`));
          this.subSystem.on("reconnecting", (reconnectCounter2) => this.log.silly(`${this.namespace} PubSub System client Objects-Redis Event reconnect (reconnectCounter=${reconnectCounter2}, stop=${this.stop})`));
        }
        this.subSystem.on("ready", async () => {
          if (--initCounter < 1) {
            if (this.settings.connection.port === 0) {
              this.log.debug(`${this.namespace} Objects ${ready ? "system re" : ""}connected to redis: ${import_db_base.tools.maybeArrayToString(this.settings.connection.host)}`);
            } else {
              this.log.debug(`${this.namespace} Objects ${ready ? "system re" : ""}connected to redis: ${import_db_base.tools.maybeArrayToString(this.settings.connection.host)}:${import_db_base.tools.maybeArrayToString(this.settings.connection.port)}`);
            }
            !ready && typeof this.settings.connected === "function" && this.settings.connected();
            ready = true;
          }
          try {
            this.subSystem && await this.subSystem.psubscribe(`${this.objNamespace}system.config`);
          } catch {
          }
          try {
            this.subSystem && await this.subSystem.psubscribe(`${this.metaNamespace}*`);
          } catch (e) {
            this.log.warn(`${this.namespace} Unable to subscribe to meta namespace "${this.metaNamespace}" changes: ${e.message}`);
          }
          if (this.subSystem) {
            for (const sub of Object.keys(this.systemSubscriptions)) {
              try {
                await this.subSystem.psubscribe(sub);
              } catch {
              }
            }
          }
        });
      }
      if (!this.sub && (typeof onChangeUser === "function" || typeof onChangeFileUser === "function")) {
        initCounter++;
        this.log.debug(`${this.namespace} Objects create User PubSub Client`);
        this.sub = new import_ioredis.default(this.settings.connection.options);
        this.sub.on("pmessage", (pattern, channel, message) => {
          setImmediate(() => {
            this.log.silly(`${this.namespace} Objects user redis pmessage ${pattern}/${channel}:${message}`);
            try {
              if (channel.startsWith(this.objNamespace) && channel.length > this.objNamespaceL) {
                if (onChangeUser) {
                  const id = channel.substring(this.objNamespaceL);
                  try {
                    const obj2 = message ? JSON.parse(message) : null;
                    onChangeUser(id, obj2);
                  } catch (e) {
                    this.log.warn(`${this.namespace} Objects user cannot process pmessage ${id} - ${message}: ${e.message}`);
                    this.log.warn(`${this.namespace} ${e.stack}`);
                  }
                }
              } else if (channel.startsWith(this.fileNamespace) && channel.length > this.fileNamespaceL) {
                if (onChangeFileUser) {
                  const [id, fileName] = channel.substring(this.fileNamespaceL).split("$%$");
                  try {
                    const obj2 = message ? JSON.parse(message) : null;
                    onChangeFileUser(id, fileName, obj2);
                  } catch (e) {
                    this.log.warn(`${this.namespace} Objects user cannot process pmessage ${id}/${fileName} - ${message}: ${e.message}`);
                    this.log.warn(`${this.namespace} ${e.stack}`);
                  }
                }
              } else {
                this.log.warn(`${this.namespace} Objects user received unexpected pmessage: ${channel}`);
              }
            } catch (e) {
              this.log.warn(`${this.namespace} Objects user pmessage ${channel} ${JSON.stringify(message)} ${e.message}`);
              this.log.warn(`${this.namespace} ${e.stack}`);
            }
          });
        });
        this.sub.on("end", () => {
          this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} Objects-Redis Event end user sub (stop=${this.stop})`);
          ready && typeof this.settings.disconnected === "function" && this.settings.disconnected();
        });
        this.sub.on("error", (error) => {
          if (this.stop) {
            return;
          }
          this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} PubSub user client Objects No redis connection: ${JSON.stringify(error)}`);
        });
        if (this.settings.connection.enhancedLogging) {
          this.sub.on("connect", () => this.log.silly(`${this.namespace} PubSub user client Objects-Redis Event connect (stop=${this.stop})`));
          this.sub.on("close", () => this.log.silly(`${this.namespace} PubSub user client Objects-Redis Event close (stop=${this.stop})`));
          this.sub.on("reconnecting", (reconnectCounter2) => this.log.silly(`${this.namespace} PubSub user client Objects-Redis Event reconnect (reconnectCounter=${reconnectCounter2}, stop=${this.stop})`));
        }
        this.sub.on("ready", async () => {
          if (!this.sub) {
            return;
          }
          if (--initCounter < 1) {
            if (this.settings.connection.port === 0) {
              this.log.debug(`${this.namespace} Objects ${ready ? "user re" : ""}connected to redis: ${import_db_base.tools.maybeArrayToString(this.settings.connection.host)}`);
            } else {
              this.log.debug(`${this.namespace} Objects ${ready ? "user re" : ""}connected to redis: ${import_db_base.tools.maybeArrayToString(this.settings.connection.host)}:${import_db_base.tools.maybeArrayToString(this.settings.connection.port)}`);
            }
            !ready && typeof this.settings.connected === "function" && this.settings.connected();
            ready = true;
          }
          for (const sub of Object.keys(this.userSubscriptions)) {
            try {
              await this.sub.psubscribe(sub);
            } catch {
            }
          }
        });
      }
      if (!this.client) {
        return;
      }
      initCounter++;
      try {
        this.useSets = !!parseInt(await this.client.get(`${this.metaNamespace}objects.features.useSets`) || "0");
      } catch (e) {
        if (!e.message.includes("UNSUPPORTED")) {
          this.log.error(`${this.namespace} Cannot determine Set feature status: ${e.message}`);
          return;
        }
        this.useSets = false;
      }
      try {
        await this._determineProtocolVersion();
      } catch (e) {
        this.log.error(`${this.namespace} ${e.message}`);
        throw new Error("Objects DB is not allowed to start in the current Multihost environment");
      }
      let keys2 = await this._getKeysViaScan(`${this.objNamespace}system.host.*`);
      const hostRegex = new RegExp(`^${this.objNamespace.replace(/\./g, "\\.")}system\\.host\\.[^.]+$`);
      keys2 = keys2.filter((id) => hostRegex.test(id));
      this.noLegacyMultihost = true;
      try {
        if (keys2.length) {
          const objs2 = await this.client.mget(keys2);
          for (const strObj of objs2) {
            const obj2 = strObj !== null ? JSON.parse(strObj) : strObj;
            if (obj2 && obj2.type === "host" && obj2._id !== `system.host.${this.hostname}` && obj2.common && obj2.common.installedVersion && import_semver.default.lt(obj2.common.installedVersion, "4.0.0")) {
              this.noLegacyMultihost = false;
              this.log.info(`${this.namespace} Sets unsupported`);
            }
          }
        }
      } catch (e) {
        this.log.error(`${this.namespace} Cannot determine Lua scripts strategy: ${e.message} ${JSON.stringify(keys2)}`);
        return;
      }
      this.log.debug(`${this.namespace} Objects client initialize lua scripts`);
      try {
        await this.loadLuaScripts();
      } catch (err) {
        this.log.error(`${this.namespace} Cannot initialize database scripts: ${err.message}`);
        return;
      }
      let obj;
      try {
        obj = await this.client.get(`${this.objNamespace}system.config`);
      } catch {
      }
      if (obj) {
        try {
          obj = JSON.parse(obj);
        } catch {
          this.log.error(`${this.namespace} Cannot parse JSON system.config: ${obj}`);
          obj = null;
        }
        if (obj && obj.common && obj.common.defaultNewAcl) {
          this.defaultNewAcl = obj.common.defaultNewAcl;
        }
      } else {
        this.log.error(`${this.namespace} Cannot read system.config: ${obj} (OK when migrating or restoring)`);
      }
      if (--initCounter < 1) {
        if (this.settings.connection.port === 0) {
          this.log.debug(`${this.namespace} Objects ${ready ? "client re" : ""}connected to redis: ${import_db_base.tools.maybeArrayToString(this.settings.connection.host)}`);
        } else {
          this.log.debug(`${this.namespace} Objects ${ready ? "client re" : ""}connected to redis: ${import_db_base.tools.maybeArrayToString(this.settings.connection.host)}:${import_db_base.tools.maybeArrayToString(this.settings.connection.port)}`);
        }
        !ready && typeof this.settings.connected === "function" && this.settings.connected();
        ready = true;
      }
    });
  }
  getStatus() {
    return { type: "redis", server: false };
  }
  /**
   * Checks if given ID is a meta-object, else throws error
   *
   * @param id to check
   * @throws Error if id is invalid
   */
  async validateMetaObject(id) {
    if (this.existingMetaObjects[id] === void 0) {
      const obj = await this.getObjectAsync(id);
      if (obj && obj.type === "meta") {
        this.existingMetaObjects[id] = true;
      } else {
        this.existingMetaObjects[id] = false;
        return Promise.reject(new Error(`${id} is not an object of type "meta"`));
      }
    } else if (this.existingMetaObjects[id] === false) {
      return Promise.reject(new Error(`${id} is not an object of type "meta"`));
    }
  }
  normalizeFilename(name) {
    return name ? name.replace(/[/\\]+/g, "/") : name;
  }
  // -------------- FILE FUNCTIONS -------------------------------------------
  /**
   * Sets a buffer to the Redis DB
   *
   * @param id id of the file
   * @param data content, if string is passed it will be converted to a Buffer
   */
  async _setBinaryState(id, data) {
    if (!this.client) {
      throw new Error(ERRORS.ERROR_DB_CLOSED);
    }
    if (!Buffer.isBuffer(data)) {
      data = Buffer.from(data);
    }
    await this.client.set(id, data);
    await this.client.publish(id, data.byteLength.toString(10));
  }
  /**
   * get buffer of given id from redis
   *
   * @param id - id of the data with namespace prefix
   */
  _getBinaryState(id) {
    if (!this.client) {
      throw new Error(ERRORS.ERROR_DB_CLOSED);
    }
    return this.client.getBuffer(id);
  }
  /**
   * deletes binary state of given id from redis db
   *
   * @param id - id to delete, with namespace prefix
   */
  async _delBinaryState(id) {
    if (!this.client) {
      throw new Error(ERRORS.ERROR_DB_CLOSED);
    } else {
      await this.client.del(id);
      await this.client.publish(id, "null");
    }
  }
  getFileId(id, name, isMeta) {
    name = this.normalizeFilename(name);
    if (id.endsWith(".admin")) {
      if (name.startsWith("admin/")) {
        name = name.replace(/^admin\//, "");
      } else if (name.match(/^iobroker.[-\d\w]\/admin\//i)) {
        name = name.replace(/^iobroker.[-\d\w]\/admin\//i, "");
      }
    }
    let normalized;
    try {
      normalized = utils.sanitizePath(id, name);
    } catch {
      this.log.debug(`${this.namespace} Invalid file path ${id}/${name}`);
      return "";
    }
    if (id !== "*") {
      id = normalized.id;
    }
    name = normalized.name;
    return `${this.fileNamespace + id}$%$${name}${isMeta !== void 0 ? isMeta ? "$%$meta" : "$%$data" : ""}`;
  }
  async checkFile(id, name, options2, flag, callback) {
    const fileId = this.getFileId(id, name, true);
    if (!fileId) {
      const fileOptions2 = { notExists: true };
      if (utils.checkFile(fileOptions2, options2, flag, this.defaultNewAcl)) {
        return import_db_base.tools.maybeCallback(callback, false, options2, fileOptions2);
      }
      return import_db_base.tools.maybeCallback(callback, true, options2);
    }
    if (!this.client) {
      return import_db_base.tools.maybeCallbackWithRedisError(callback, ERRORS.ERROR_DB_CLOSED, options2);
    }
    let fileOptions;
    try {
      fileOptions = await this.client.get(fileId);
    } catch {
    }
    fileOptions = fileOptions || '{"notExists": true}';
    try {
      fileOptions = JSON.parse(fileOptions);
    } catch {
      this.log.error(`${this.namespace} Cannot parse JSON ${id}: ${fileOptions}`);
      fileOptions = { notExists: true };
    }
    if (utils.checkFile(fileOptions, options2, flag, this.defaultNewAcl)) {
      return import_db_base.tools.maybeCallback(callback, false, options2, fileOptions);
    }
    return import_db_base.tools.maybeCallback(callback, true, options2);
  }
  checkFileRights(id, name, options2, flag, callback) {
    return utils.checkFileRights(this, id, name, options2, flag, callback);
  }
  async _setDefaultAcl(ids, defaultAcl) {
    for (const id of ids) {
      try {
        const obj = await this.getObject(id);
        if (obj && !obj.acl) {
          obj.acl = defaultAcl;
          await this.setObjectAsync(id, obj, null);
        }
      } catch (e) {
        this.log.error(`${this.namespace} _setDefaultAcl error on id "${id}" with acl "${JSON.stringify(defaultAcl)}": ${e.message}`);
      }
    }
  }
  async setDefaultAcl(defaultNewAcl) {
    this.defaultNewAcl = defaultNewAcl || {
      owner: CONSTS.SYSTEM_ADMIN_USER,
      ownerGroup: CONSTS.SYSTEM_ADMIN_GROUP,
      object: 1636,
      state: 1636,
      file: 1636
    };
    try {
      const ids = await this.getKeysAsync("*");
      if (ids) {
        await this._setDefaultAcl(ids, this.defaultNewAcl);
      }
    } catch (e) {
      this.log.error(`${this.namespace} Could not update default acl: ${e.message}`);
    }
  }
  getUserGroup(user, callback) {
    return utils.getUserGroup(this, user, (error, user2, userGroups, userAcl) => {
      if (error) {
        this.log.error(`${this.namespace} ${error.stack}`);
      }
      return import_db_base.tools.maybeCallback(callback, user2, userGroups, userAcl);
    });
  }
  async _writeFile(id, name, data, options2, callback, meta) {
    const matchedExtension = name.match(/\.[^.]+$/);
    const ext = matchedExtension ? matchedExtension[0] : "";
    const isTextData = typeof data === "string";
    const { mimeType, isBinary } = utils.getMimeType(ext, isTextData);
    const metaID = this.getFileId(id, name, true);
    if (!this.client) {
      return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);
    }
    if (options2.virtualFile) {
      meta = {
        notExists: true,
        virtualFile: true
      };
      try {
        await this.client.set(metaID, JSON.stringify(meta));
        return import_db_base.tools.maybeCallback(callback);
      } catch (e) {
        return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
      }
    } else {
      if (!meta) {
        meta = { createdAt: Date.now() };
      }
      if (!meta.acl) {
        meta.acl = {
          owner: options2.user || this.defaultNewAcl && this.defaultNewAcl.owner || CONSTS.SYSTEM_ADMIN_USER,
          ownerGroup: options2.group || this.defaultNewAcl && this.defaultNewAcl.ownerGroup || CONSTS.SYSTEM_ADMIN_GROUP,
          permissions: options2.mode || this.defaultNewAcl && this.defaultNewAcl.file || 1604
        };
      }
      meta.stats = {
        size: data ? data.length : 0
      };
      if (Object.prototype.hasOwnProperty.call(meta, "notExists")) {
        delete meta.notExists;
      }
      meta.mimeType = options2.mimeType || mimeType;
      meta.binary = isBinary;
      meta.acl.ownerGroup = meta.acl.ownerGroup || this.defaultNewAcl && this.defaultNewAcl.ownerGroup || CONSTS.SYSTEM_ADMIN_GROUP;
      meta.modifiedAt = Date.now();
      try {
        await this._setBinaryState(this.getFileId(id, name, false), data);
        await this.client.set(metaID, JSON.stringify(meta));
        return import_db_base.tools.maybeCallback(callback);
      } catch (e) {
        return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
      }
    }
  }
  async writeFile(id, name, data, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = null;
    }
    if (typeof options2 === "string") {
      options2 = { mimeType: options2 };
    }
    if (options2?.acl) {
      options2.acl = null;
    }
    if (!callback) {
      return this.writeFileAsync(id, name, data, options2);
    }
    try {
      await this.validateMetaObject(id);
    } catch (e) {
      this.log.error(`${this.namespace} Cannot write file ${name}: ${e.message}`);
      return import_db_base.tools.maybeCallbackWithError(callback, e);
    }
    if (typeof name !== "string" || !name.length || name === "/") {
      return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_NOT_FOUND);
    }
    if (name.startsWith("/")) {
      name = name.substring(1);
    }
    if (data === void 0) {
      data = null;
    }
    return this.checkFileRights(id, name, options2, CONSTS.ACCESS_WRITE, (err, options3, meta) => {
      if (err) {
        return import_db_base.tools.maybeCallbackWithError(callback, err);
      }
      return this._writeFile(id, name, data, options3, callback, meta);
    });
  }
  writeFileAsync(id, name, data, options2) {
    return new Promise((resolve, reject) => this.writeFile(id, name, data, options2, (err) => err ? reject(err) : resolve()));
  }
  async _readFile(id, name, meta) {
    if (meta.notExists) {
      throw new Error(ERRORS.ERROR_NOT_FOUND);
    }
    if (!this.client) {
      throw new Error(ERRORS.ERROR_DB_CLOSED);
    }
    let buffer;
    buffer = await this._getBinaryState(this.getFileId(id, name, false));
    const mimeType = meta && meta.mimeType;
    if (meta && !meta.binary && buffer) {
      buffer = buffer.toString();
    }
    return { file: buffer, mimeType };
  }
  readFile(id, name, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = null;
    }
    if (options2 && options2.acl) {
      options2.acl = null;
    }
    if (!callback) {
      return new Promise((resolve, reject) => this.readFile(id, name, options2, (err, res, mimeType) => err ? reject(err) : resolve({ file: res, mimeType })));
    }
    if (typeof name !== "string" || !name.length || name === "/") {
      return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_NOT_FOUND);
    }
    if (name.startsWith("/")) {
      name = name.substring(1);
    }
    options2 = options2 || {};
    this.checkFileRights(id, name, options2, CONSTS.ACCESS_READ, async (err, options3, meta) => {
      if (err) {
        return import_db_base.tools.maybeCallbackWithError(callback, err);
      }
      try {
        const { file, mimeType } = await this._readFile(id, name, meta);
        return import_db_base.tools.maybeCallbackWithError(callback, null, file, mimeType);
      } catch (e) {
        return import_db_base.tools.maybeCallbackWithError(callback, e);
      }
    });
  }
  /**
   * Check if given object exists
   *
   * @param id id of the object
   * @param options optional user context
   */
  async objectExists(id, options2) {
    if (!this.client) {
      throw new Error(ERRORS.ERROR_DB_CLOSED);
    }
    if (!id || typeof id !== "string") {
      throw new Error(`invalid id ${JSON.stringify(id)}`);
    }
    try {
      await new Promise((resolve, reject) => {
        utils.checkObjectRights(this, null, null, options2, CONSTS.ACCESS_LIST, (err) => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
      const exists = await this.client.exists(this.objNamespace + id);
      return !!exists;
    } catch (e) {
      this.log.error(`${this.namespace} Cannot check object existence of "${id}": ${e.message}`);
      return Promise.reject(new Error(`Cannot check object existence of "${id}": ${e.message}`));
    }
  }
  /**
   * Check if given file exists
   *
   * @param id id of the namespace
   * @param name name of the file
   * @param options optional user context
   */
  async fileExists(id, name, options2) {
    if (typeof name !== "string") {
      name = "";
    }
    if (name.startsWith("/")) {
      name = name.substring(1);
    }
    try {
      await new Promise((resolve, reject) => {
        this.checkFileRights(id, name, options2, CONSTS.ACCESS_READ, (err) => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
      if (!this.client) {
        throw new Error(ERRORS.ERROR_DB_CLOSED);
      }
      id = this.getFileId(id, name, false);
      const exists = await this.client.exists(id);
      return !!exists;
    } catch (e) {
      this.log.error(`${this.namespace} Cannot check file existence of "${id}": ${e.message}`);
      throw new Error(`Cannot check file existence of "${id}": ${e.message}`);
    }
  }
  async _unlink(id, name, options2, meta) {
    if (!this.client) {
      throw new Error(ERRORS.ERROR_DB_CLOSED);
    }
    if (meta && meta.notExists) {
      return this._rm(id, name, options2);
    }
    const metaID = this.getFileId(id, name, true);
    const dataID = this.getFileId(id, name, false);
    await this._delBinaryState(dataID);
    await this.client.del(metaID);
  }
  unlink(id, name, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = null;
    }
    if (options2 && options2.acl) {
      options2.acl = null;
    }
    if (typeof name !== "string") {
      name = "";
    }
    if (name.startsWith("/")) {
      name = name.substring(1);
    }
    this.checkFileRights(id, name, options2, CONSTS.ACCESS_DELETE, async (err, options3, meta) => {
      if (err) {
        return import_db_base.tools.maybeCallbackWithError(callback, err);
      }
      if (!options3.acl.file.delete) {
        return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_PERMISSION);
      }
      try {
        const files = await this._unlink(id, name, options3, meta);
        return import_db_base.tools.maybeCallbackWithError(callback, null, files);
      } catch (e) {
        return import_db_base.tools.maybeCallbackWithError(callback, e);
      }
    });
  }
  unlinkAsync(id, name, options2) {
    return new Promise((resolve, reject) => this.unlink(id, name, options2, (err) => err ? reject(err) : resolve()));
  }
  delFile(id, name, options2, callback) {
    return this.unlink(id, name, options2, callback);
  }
  delFileAsync(id, name, options2) {
    return this.unlinkAsync(id, name, options2);
  }
  async _readDir(id, name, options2, callback) {
    name = this.normalizeFilename(name);
    if (!this.client) {
      return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);
    }
    if (id === "") {
      const dirID2 = this.getFileId("*", "*");
      let keys3;
      try {
        keys3 = await this._getKeysViaScan(dirID2);
      } catch (e) {
        return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
      }
      if (!this.client) {
        return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);
      }
      const result3 = [];
      if (!keys3 || !keys3.length) {
        return import_db_base.tools.maybeCallbackWithError(callback, null, result3);
      }
      let lastDir;
      keys3.sort().forEach((dir) => {
        dir = dir.substring(this.fileNamespaceL, dir.indexOf("$%$"));
        if (dir !== lastDir) {
          result3.push({
            file: dir,
            stats: {},
            isDir: true
          });
        }
        lastDir = dir;
      });
      return import_db_base.tools.maybeCallbackWithError(callback, null, result3);
    }
    const dirID = this.getFileId(id, `${name}${name.length ? "/" : ""}*`);
    let keys2;
    try {
      keys2 = await this._getKeysViaScan(dirID);
    } catch (e) {
      return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
    }
    if (!this.client) {
      return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);
    }
    const start = dirID.indexOf("$%$") + 3;
    const end = "$%$meta".length;
    const baseName = name + (name.length ? "/" : "");
    const dirs = [];
    const deepLevel = baseName.split("/").length;
    if (!keys2 || !keys2.length) {
      return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_NOT_FOUND, []);
    }
    keys2 = keys2.sort().filter((key) => {
      if (key.endsWith("$%$meta")) {
        const parts = key.substr(start, key.length - end).split("/");
        if (parts.length === deepLevel) {
          return !key.includes("/_data.json$%$") && key !== "_data.json";
        }
        const dir = parts[deepLevel - 1];
        if (dirs.indexOf(dir) === -1) {
          dirs.push(dir);
        }
      }
    });
    if (!keys2.length) {
      const result3 = dirs.map((file) => ({
        file,
        stats: {},
        isDir: true
      }));
      return import_db_base.tools.maybeCallbackWithError(callback, null, result3);
    }
    let strObjs;
    try {
      strObjs = await this.client.mget(keys2);
    } catch (e) {
      return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
    }
    const result2 = [];
    const dontCheck = options2.user === CONSTS.SYSTEM_ADMIN_USER || options2.group !== CONSTS.SYSTEM_ADMIN_GROUP || options2.groups && options2.groups.indexOf(CONSTS.SYSTEM_ADMIN_GROUP) !== -1;
    for (let i = 0; i < keys2.length; i++) {
      const file = keys2[i].substring(start + baseName.length, keys2[i].length - end);
      while (dirs.length && dirs[0] < file) {
        result2.push({
          file: dirs.shift(),
          stats: {},
          isDir: true
        });
      }
      const strObj = strObjs[i];
      let obj;
      try {
        obj = strObj ? JSON.parse(strObj) : null;
      } catch {
        this.log.error(`${this.namespace} Cannot parse JSON ${keys2[i]}: ${strObj}`);
        continue;
      }
      if (dontCheck || utils.checkObject(obj, options2, CONSTS.ACCESS_READ)) {
        if (!obj || obj.virtualFile) {
          continue;
        }
        obj.acl = obj.acl || {};
        if (options2.user !== CONSTS.SYSTEM_ADMIN_USER && options2.groups && options2.groups.indexOf(CONSTS.SYSTEM_ADMIN_GROUP) === -1) {
          obj.acl.read = !!(obj.acl.permissions & CONSTS.ACCESS_EVERY_READ);
          obj.acl.write = !!(obj.acl.permissions & CONSTS.ACCESS_EVERY_WRITE);
        } else {
          obj.acl.read = true;
          obj.acl.write = true;
        }
        result2.push({
          file,
          stats: obj.stats,
          isDir: false,
          acl: obj.acl,
          modifiedAt: obj.modifiedAt,
          createdAt: obj.createdAt
        });
      }
    }
    while (dirs.length) {
      result2.push({
        file: dirs.shift(),
        stats: {},
        isDir: true
      });
    }
    return import_db_base.tools.maybeCallbackWithError(callback, null, result2);
  }
  readDir(id, name, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = null;
    }
    if (options2 && options2.acl) {
      options2.acl = null;
    }
    if (typeof name !== "string") {
      name = "";
    }
    if (name.startsWith("/")) {
      name = name.substring(1);
    }
    if (name.endsWith("/")) {
      name = name.substring(0, name.length - 1);
    }
    this.checkFileRights(id, name, options2, CONSTS.ACCESS_READ, (err, options3) => {
      if (err) {
        return import_db_base.tools.maybeCallbackWithError(callback, err);
      }
      if (!options3.acl.file.list) {
        return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_PERMISSION);
      }
      this._readDir(id, name, options3, callback);
    });
  }
  readDirAsync(id, name, options2) {
    return new Promise((resolve, reject) => this.readDir(id, name, options2, (err, res) => err ? reject(err) : resolve(res)));
  }
  async _renameHelper(keys2, oldBase, newBase, callback) {
    if (!keys2 || !keys2.length) {
      return import_db_base.tools.maybeCallback(callback);
    }
    if (!this.client) {
      return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);
    }
    for (const id of keys2) {
      try {
        try {
          await this.client.rename(id.replace(/\$%\$meta$/, "$%$data"), id.replace(oldBase, newBase).replace(/\$%\$meta$/, "$%$data"));
        } catch (e) {
          if (!(id.endsWith("/_data.json$%$meta") && e.message.includes("no such key"))) {
            throw e;
          }
        }
        await this.client.rename(id, id.replace(oldBase, newBase));
      } catch (e) {
        return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
      }
    }
    return import_db_base.tools.maybeCallback(callback);
  }
  async _rename(id, oldName, newName, options2, callback, meta) {
    const oldMetaID = this.getFileId(id, oldName, true);
    const oldDataID = this.getFileId(id, oldName, false);
    const newMetaID = this.getFileId(id, newName, true);
    const newDataID = this.getFileId(id, newName, false);
    if (!meta || !this.client) {
      return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);
    } else if (meta.notExists) {
      oldName = this.normalizeFilename(oldName);
      newName = this.normalizeFilename(newName);
      if (!oldName.endsWith("/*")) {
        oldName += "/*";
      } else if (oldName.endsWith("/")) {
        oldName += "*";
      }
      if (!newName.endsWith("/*")) {
        newName += "/*";
      } else if (newName.endsWith("/")) {
        newName += "*";
      }
      const oldBase = oldName.substring(0, oldName.length - 1);
      const newBase = newName.substring(0, newName.length - 1);
      const dirID = this.getFileId(id, oldName);
      let keys2;
      try {
        keys2 = await this._getKeysViaScan(dirID);
      } catch (e) {
        return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
      }
      if (!this.client) {
        return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);
      }
      if (!keys2) {
        return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_NOT_FOUND);
      }
      keys2 = keys2.sort().filter((key) => key.endsWith("$%$meta"));
      if (!keys2.length) {
        return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_NOT_FOUND);
      }
      let strObjs;
      try {
        strObjs = await this.client.mget(keys2);
      } catch (e) {
        return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
      }
      let result2;
      const dontCheck = options2.user === CONSTS.SYSTEM_ADMIN_USER || options2.group !== CONSTS.SYSTEM_ADMIN_GROUP || options2.groups && options2.groups.indexOf(CONSTS.SYSTEM_ADMIN_GROUP) !== -1;
      if (!dontCheck) {
        result2 = [];
        for (let i = 0; i < keys2.length; i++) {
          const strObj = strObjs[i];
          let obj;
          try {
            obj = strObj ? JSON.parse(strObj) : null;
          } catch {
            this.log.error(`${this.namespace} Cannot parse JSON ${keys2[i]}: ${strObj}`);
            continue;
          }
          if (utils.checkObject(obj, options2, CONSTS.ACCESS_READ)) {
            result2.push(keys2[i]);
          }
        }
      } else {
        result2 = keys2;
      }
      return this._renameHelper(result2, oldBase, newBase, callback);
    }
    try {
      await this.client.rename(oldDataID, newDataID);
      await this.client.rename(oldMetaID, newMetaID);
      return import_db_base.tools.maybeCallback(callback);
    } catch (e) {
      return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
    }
  }
  rename(id, oldName, newName, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = null;
    }
    if (options2 && options2.acl) {
      options2.acl = null;
    }
    if (typeof oldName !== "string" || !oldName.length || oldName === "/" || oldName === "//" || typeof newName !== "string" || !newName.length || newName === "/" || newName === "//") {
      return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_NOT_FOUND);
    }
    if (oldName.startsWith("/")) {
      oldName = oldName.substring(1);
    }
    if (newName.startsWith("/")) {
      newName = newName.substring(1);
    }
    if (oldName.endsWith("/")) {
      oldName = oldName.substring(0, oldName.length - 1);
    }
    if (newName.endsWith("/")) {
      newName = newName.substring(0, newName.length - 1);
    }
    this.checkFileRights(id, oldName, options2, CONSTS.ACCESS_WRITE, (err, options3, meta) => {
      if (err) {
        return import_db_base.tools.maybeCallbackWithError(callback, err);
      }
      if (!options3.acl.file.write) {
        return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_PERMISSION);
      }
      this._rename(id, oldName, newName, options3, callback, meta);
    });
  }
  renameAsync(id, oldName, newName, options2) {
    return new Promise((resolve, reject) => this.rename(id, oldName, newName, options2, (err) => err ? reject(err) : resolve()));
  }
  async _touch(id, name, callback, meta) {
    const metaID = this.getFileId(id, name, true);
    if (!this.client) {
      return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);
    }
    if (!meta || meta.notExists) {
      return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_NOT_FOUND);
    }
    meta.modifiedAt = Date.now();
    try {
      await this.client.set(metaID, JSON.stringify(meta));
      return import_db_base.tools.maybeCallback(callback);
    } catch (e) {
      return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
    }
  }
  touch(id, name, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = null;
    }
    if (options2 && options2.acl) {
      options2.acl = null;
    }
    if (typeof name !== "string" || !name.length || name === "/") {
      return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_NOT_FOUND);
    }
    if (name.startsWith("/")) {
      name = name.substring(1);
    }
    this.checkFileRights(id, name, options2, CONSTS.ACCESS_WRITE, (err, options3, meta) => {
      if (err) {
        return import_db_base.tools.maybeCallbackWithError(callback, err);
      }
      return this._touch(id, name, callback, meta);
    });
  }
  touchAsync(id, name, options2) {
    return new Promise((resolve, reject) => this.touch(id, name, options2, (err) => err ? reject(err) : resolve()));
  }
  async _rmHelper(keys2) {
    if (!keys2.length) {
      return;
    }
    if (!this.client) {
      throw new Error(ERRORS.ERROR_DB_CLOSED);
    }
    for (const id of keys2) {
      await this._delBinaryState(id.replace(/\$%\$meta$/, "$%$data"));
      await this.client.del(id);
    }
  }
  async _rm(id, name, options2, meta) {
    if (meta && !meta.isDir) {
      const metaID = this.getFileId(id, name, true);
      const dataID = this.getFileId(id, name, false);
      await this.delObjectAsync(dataID);
      await this.delObjectAsync(metaID);
    } else {
      if (!this.client) {
        throw new Error(ERRORS.ERROR_DB_CLOSED);
      }
      name = this.normalizeFilename(name);
      if (!name.endsWith("/*")) {
        name += "/*";
      } else if (name.endsWith("/")) {
        name += "*";
      }
      const dirID = this.getFileId(id, name);
      let keys2 = await this._getKeysViaScan(dirID);
      if (!this.client) {
        throw new Error(ERRORS.ERROR_DB_CLOSED);
      }
      if (!keys2) {
        throw new Error(ERRORS.ERROR_NOT_FOUND);
      }
      keys2 = keys2.sort().filter((key) => key.endsWith("$%$meta"));
      if (!keys2.length) {
        throw new Error(ERRORS.ERROR_NOT_FOUND);
      }
      let objs2;
      try {
        objs2 = await this.client.mget(keys2);
      } catch {
      }
      let result2;
      const dontCheck = options2.user === CONSTS.SYSTEM_ADMIN_USER || options2.group !== CONSTS.SYSTEM_ADMIN_GROUP || options2.groups && options2.groups.indexOf(CONSTS.SYSTEM_ADMIN_GROUP) !== -1;
      objs2 = objs2 || [];
      if (!dontCheck) {
        result2 = [];
        for (let i = 0; i < keys2.length; i++) {
          try {
            const strObj = objs2[i];
            const obj = strObj ? JSON.parse(strObj) : null;
            if (utils.checkObject(obj, options2, CONSTS.ACCESS_READ)) {
              result2.push(keys2[i]);
            }
          } catch {
            this.log.error(`${this.namespace} Cannot parse JSON ${keys2[i]}: ${objs2[i]}`);
          }
        }
      } else {
        result2 = keys2;
      }
      const files = result2.map((key) => {
        const name2 = key.substring(this.fileNamespaceL + id.length + 3, key.length - 7);
        const pos = name2.lastIndexOf("/");
        if (pos !== -1) {
          return { file: name2.substring(pos + 1), path: name2.substring(0, pos) };
        }
        return { file: id, path: "" };
      });
      try {
        await this._rmHelper(result2);
      } catch (e) {
        this.log.error(`${this.namespace} Could not remove files: ${e.message}`);
      }
      return files;
    }
  }
  rm(id, name, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = null;
    }
    if (options2 && options2.acl) {
      options2.acl = null;
    }
    if (typeof name !== "string") {
      name = "";
    }
    this.checkFileRights(id, null, options2, CONSTS.ACCESS_DELETE, async (err, options3, meta) => {
      if (err) {
        return import_db_base.tools.maybeCallbackWithError(callback, err);
      }
      if (!options3.acl.file.delete) {
        return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_PERMISSION);
      }
      try {
        const files = await this._rm(id, name, options3, meta && meta.notExists ? null : meta);
        return import_db_base.tools.maybeCallbackWithError(callback, null, files);
      } catch (e) {
        return import_db_base.tools.maybeCallbackWithError(callback, e);
      }
    });
  }
  rmAsync(id, name, options2) {
    return new Promise((resolve, reject) => this.rm(id, name, options2, (err, files) => err ? reject(err) : resolve(files)));
  }
  // simulate. redis has no dirs
  mkdir(id, dirName, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = null;
    }
    if (typeof dirName !== "string") {
      dirName = "";
    }
    dirName = this.normalizeFilename(dirName);
    if (dirName.startsWith("/")) {
      dirName = dirName.substring(1);
    }
    this.checkFileRights(id, dirName, options2, CONSTS.ACCESS_WRITE, (err, options3) => {
      if (err) {
        return import_db_base.tools.maybeCallbackWithError(callback, err);
      }
      if (!options3.acl.file.write) {
        return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_PERMISSION);
      }
      options3 = { ...options3, virtualFile: true };
      const realName = dirName + (dirName.endsWith("/") ? "" : "/");
      this.writeFile(id, `${realName}_data.json`, "", options3, callback);
    });
  }
  mkdirAsync(id, dirName, options2) {
    return new Promise((resolve, reject) => this.mkdir(id, dirName, options2, (err) => err ? reject(err) : resolve()));
  }
  async _chownFileHelper(keys2, metas, options2, callback) {
    if (!keys2.length) {
      return import_db_base.tools.maybeCallback(callback);
    }
    if (!this.client) {
      return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);
    }
    for (const id of keys2) {
      const meta = metas.shift();
      meta.acl.owner = options2.owner;
      meta.acl.ownerGroup = options2.ownerGroup;
      try {
        await this.client.set(id, JSON.stringify(meta));
      } catch (e) {
        return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
      }
    }
    return import_db_base.tools.maybeCallback(callback);
  }
  async _chownFile(id, name, options2, callback, meta) {
    if (!meta) {
      return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_NOT_FOUND);
    }
    name = this.normalizeFilename(name);
    if (!this.client) {
      return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);
    }
    if (!meta.isDir && !meta.notExists) {
      const metaID = this.getFileId(id, name, true);
      meta.acl.owner = options2.owner;
      meta.acl.ownerGroup = options2.ownerGroup;
      try {
        await this.client.set(metaID, JSON.stringify(meta));
      } catch (e) {
        return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
      }
      const nameArr = name.split("/");
      const file = nameArr.pop();
      const res = [
        {
          path: nameArr.join("/"),
          file,
          stats: meta.stats,
          isDir: false,
          acl: meta.acl || {},
          modifiedAt: meta.modifiedAt,
          createdAt: meta.createdAt
        }
      ];
      return import_db_base.tools.maybeCallbackWithError(callback, null, res);
    }
    if (!name.endsWith("/*")) {
      name += "/*";
    } else if (name.endsWith("/")) {
      name += "*";
    }
    const dirID = this.getFileId(id, name);
    let keys2;
    try {
      keys2 = await this._getKeysViaScan(dirID);
    } catch (e) {
      return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
    }
    if (!this.client) {
      return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);
    }
    if (!keys2) {
      return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_NOT_FOUND);
    }
    keys2 = keys2.sort().filter((key) => key.endsWith("$%$meta"));
    let metasStr;
    try {
      metasStr = await this.client.mget(keys2);
    } catch (e) {
      return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
    }
    const dontCheck = options2.user === CONSTS.SYSTEM_ADMIN_USER || options2.group !== CONSTS.SYSTEM_ADMIN_GROUP || options2.groups && options2.groups.indexOf(CONSTS.SYSTEM_ADMIN_GROUP) !== -1;
    const keysFiltered = [];
    const objsFiltered = [];
    const processed = [];
    const start = dirID.indexOf("$%$") + 3;
    const end = "$%$meta".length;
    for (let i = 0; i < keys2.length; i++) {
      const metaStr = metasStr[i];
      let meta2;
      try {
        meta2 = metaStr ? JSON.parse(metaStr) : null;
      } catch {
        this.log.error(`${this.namespace} Cannot parse JSON ${keys2[i]}: ${metaStr}`);
        continue;
      }
      if (dontCheck || utils.checkObject(meta2, options2, CONSTS.ACCESS_WRITE)) {
        if (!meta2 || meta2.virtualFile) {
          continue;
        }
        keysFiltered.push(keys2[i]);
        objsFiltered.push(meta2);
        const name2 = keys2[i].substring(start, keys2[i].length - end);
        const nameArr = name2.split("/");
        const file = nameArr.pop();
        processed.push({
          path: nameArr.join("/"),
          file,
          stats: meta2.stats || {},
          isDir: false,
          acl: meta2.acl || {},
          modifiedAt: meta2.modifiedAt,
          createdAt: meta2.createdAt
        });
      }
    }
    this._chownFileHelper(keysFiltered, objsFiltered, options2, (err) => {
      return import_db_base.tools.maybeCallbackWithError(callback, err, processed);
    });
  }
  chownFile(id, name, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = {};
    }
    options2 = options2 || {};
    if (typeof options2 !== "object") {
      options2 = { owner: options2 };
    }
    if (typeof name !== "string" || !name.length || name === "/") {
      return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_NOT_FOUND);
    }
    if (name.startsWith("/")) {
      name = name.substring(1);
    }
    if (!options2.ownerGroup && options2.group) {
      options2.ownerGroup = options2.group;
    }
    if (!options2.owner && options2.user) {
      options2.owner = options2.user;
    }
    if (!options2.owner) {
      this.log.error(`${this.namespace} user is not defined`);
      return import_db_base.tools.maybeCallbackWithError(callback, "invalid parameter");
    }
    if (!options2.ownerGroup) {
      this.getUserGroup(options2.owner, (user, groups) => {
        if (!groups || !groups[0]) {
          return import_db_base.tools.maybeCallbackWithError(callback, `user "${options2.owner}" belongs to no group`);
        }
        options2.ownerGroup = groups[0];
        this.chownFile(id, name, options2, callback);
      });
      return;
    }
    this.checkFileRights(id, name, options2, CONSTS.ACCESS_WRITE, (err, options3, meta) => {
      if (err) {
        return import_db_base.tools.maybeCallbackWithError(callback, err);
      }
      if (!options3.acl.file.write) {
        return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_PERMISSION);
      }
      return this._chownFile(id, name, options3, callback, meta);
    });
  }
  chownFileAsync(id, name, options2) {
    return new Promise((resolve, reject) => this.chownFile(id, name, options2, (err, processed) => err ? reject(err) : resolve(processed)));
  }
  /**
   *
   * @param keys Key names to handle
   * @param metas Objects for the keys to handle
   * @param options options
   * @param callback callback function
   */
  async _chmodFileHelper(keys2, metas, options2, callback) {
    if (!keys2 || !keys2.length) {
      return import_db_base.tools.maybeCallback(callback);
    }
    if (!this.client) {
      return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);
    }
    for (const i in keys2) {
      const id = keys2[i];
      const meta = metas[i];
      meta.acl.permissions = options2.mode;
      try {
        await this.client.set(id, JSON.stringify(meta));
      } catch (e) {
        return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
      }
    }
    return import_db_base.tools.maybeCallback(callback);
  }
  async _chmodFile(id, name, options2, callback, meta) {
    if (!meta) {
      return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_NOT_FOUND);
    }
    name = this.normalizeFilename(name);
    if (!this.client) {
      return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);
    }
    if (!meta.isDir && !meta.notExists) {
      const metaID = this.getFileId(id, name, true);
      meta.acl.permissions = options2.mode;
      try {
        await this.client.set(metaID, JSON.stringify(meta));
      } catch (e) {
        return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
      }
      const nameArr = name.split("/");
      const file = nameArr.pop();
      const res = [
        {
          path: nameArr.join("/"),
          file,
          stats: meta.stats,
          isDir: false,
          acl: meta.acl || {},
          modifiedAt: meta.modifiedAt,
          createdAt: meta.createdAt
        }
      ];
      return import_db_base.tools.maybeCallbackWithError(callback, null, res);
    }
    if (!name.endsWith("/*")) {
      name += "/*";
    } else if (name.endsWith("/")) {
      name += "*";
    }
    const dirID = this.getFileId(id, name);
    let keys2;
    try {
      keys2 = await this._getKeysViaScan(dirID);
    } catch (e) {
      return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
    }
    if (!this.client) {
      return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);
    }
    if (!keys2) {
      return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_NOT_FOUND);
    }
    keys2 = keys2.sort().filter((key) => key.endsWith("$%$meta"));
    let strObjs;
    try {
      strObjs = await this.client.mget(keys2);
    } catch (e) {
      return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
    }
    const dontCheck = options2.user === CONSTS.SYSTEM_ADMIN_USER || options2.group !== CONSTS.SYSTEM_ADMIN_GROUP || options2.groups && options2.groups.indexOf(CONSTS.SYSTEM_ADMIN_GROUP) !== -1;
    const keysFiltered = [];
    const objsFiltered = [];
    const processed = [];
    const start = dirID.indexOf("$%$") + 3;
    const end = "$%$meta".length;
    for (let i = 0; i < keys2.length; i++) {
      const strObj = strObjs[i];
      let obj;
      try {
        obj = strObj ? JSON.parse(strObj) : null;
      } catch {
        this.log.error(`${this.namespace} Cannot parse JSON ${keys2[i]}: ${strObj}`);
        continue;
      }
      if (dontCheck || utils.checkObject(obj, options2, CONSTS.ACCESS_WRITE)) {
        if (!obj || obj.virtualFile) {
          continue;
        }
        keysFiltered.push(keys2[i]);
        objsFiltered.push(obj);
        const name2 = keys2[i].substring(start, keys2[i].length - end);
        const nameArr = name2.split("/");
        const file = nameArr.pop();
        processed.push({
          path: nameArr.join("/"),
          file,
          stats: obj.stats,
          isDir: false,
          acl: obj.acl || {},
          modifiedAt: obj.modifiedAt,
          createdAt: obj.createdAt
        });
      }
    }
    this._chmodFileHelper(keysFiltered, objsFiltered, options2, (err) => import_db_base.tools.maybeCallbackWithError(callback, err, processed));
  }
  chmodFile(id, name, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = null;
    }
    options2 = options2 || {};
    if (typeof name !== "string" || !name.length || name === "/") {
      return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_NOT_FOUND);
    }
    if (name[0].startsWith("/")) {
      name = name.substring(1);
    }
    if (typeof options2 !== "object") {
      options2 = { mode: options2 };
    }
    if (options2.mode === void 0) {
      this.log.error(`${this.namespace} mode is not defined`);
      return import_db_base.tools.maybeCallbackWithError(callback, "invalid parameter");
    } else if (typeof options2.mode === "string") {
      options2.mode = parseInt(options2.mode, 16);
    }
    this.checkFileRights(id, name, options2, CONSTS.ACCESS_WRITE, (err, options3, meta) => {
      if (err) {
        return import_db_base.tools.maybeCallbackWithError(callback, err);
      }
      if (!options3.acl.file.write) {
        return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_PERMISSION);
      }
      return this._chmodFile(id, name, options3, callback, meta);
    });
  }
  chmodFileAsync(id, name, options2) {
    return new Promise((resolve, reject) => this.chmodFile(id, name, options2, (err, processed) => err ? reject(err) : resolve(processed)));
  }
  enableFileCache(enabled, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = null;
    }
    if (options2 && options2.acl) {
      options2.acl = null;
    }
    utils.checkObjectRights(this, null, null, options2, CONSTS.ACCESS_WRITE, (err, _options) => {
      if (err) {
        return import_db_base.tools.maybeCallbackWithError(callback, err);
      }
      return import_db_base.tools.maybeCallbackWithError(callback, null, false);
    });
  }
  enableFileCacheAsync(enabled, options2) {
    return new Promise((resolve, reject) => this.enableFileCache(enabled, options2, (err, res) => err ? reject(err) : resolve(res)));
  }
  async _subscribeFile(id, pattern) {
    if (!this.sub) {
      throw new Error(ERRORS.ERROR_DB_CLOSED);
    }
    if (Array.isArray(pattern)) {
      for (const _pattern of pattern) {
        const fileId = this.getFileId(id, _pattern, false);
        this.log.silly(`${this.namespace} redis psubscribe ${fileId}`);
        if (this.sub) {
          await this.sub.psubscribe(fileId);
          this.userSubscriptions[fileId] = true;
        }
      }
    } else {
      const fileId = this.getFileId(id, pattern, false);
      this.log.silly(`${this.namespace} redis psubscribe ${fileId}`);
      await this.sub.psubscribe(fileId);
      this.userSubscriptions[fileId] = true;
    }
  }
  async _unsubscribeFile(id, pattern) {
    if (!this.sub) {
      throw new Error(ERRORS.ERROR_DB_CLOSED);
    }
    if (Array.isArray(pattern)) {
      for (const _pattern of pattern) {
        const fileId = this.getFileId(id, _pattern, false);
        this.log.silly(`${this.namespace} redis punsubscribe ${fileId}`);
        if (this.sub) {
          await this.sub.punsubscribe(fileId);
          if (this.userSubscriptions[fileId] !== void 0) {
            delete this.userSubscriptions[fileId];
          }
        }
      }
    } else {
      this.log.silly(`${this.namespace} redis punsubscribe ${this.objNamespace}${pattern}`);
      const fileId = this.getFileId(id, pattern, false);
      await this.sub.punsubscribe(fileId);
      if (this.userSubscriptions[fileId] !== void 0) {
        delete this.userSubscriptions[fileId];
      }
    }
  }
  subscribeUserFile(id, pattern, options2) {
    return new Promise((resolve, reject) => {
      utils.checkObjectRights(this, null, null, options2, "list", (err) => {
        if (err) {
          reject(err);
        } else {
          return this._subscribeFile(id, pattern).then(() => resolve()).catch((err2) => reject(err2));
        }
      });
    });
  }
  unsubscribeUserFile(id, pattern, options2) {
    return new Promise((resolve, reject) => {
      utils.checkObjectRights(this, null, null, options2, "list", (err) => {
        if (err) {
          reject(err);
        } else {
          return this._unsubscribeFile(id, pattern).then(() => resolve()).catch((err2) => reject(err2));
        }
      });
    });
  }
  _subscribe(pattern, asUser, callback) {
    const subClient = asUser ? this.sub : this.subSystem;
    if (!subClient) {
      return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);
    }
    if (Array.isArray(pattern)) {
      let count = pattern.length;
      pattern.forEach((pattern2) => {
        this.log.silly(`${this.namespace} redis psubscribe ${this.objNamespace}${pattern2}`);
        subClient.psubscribe(this.objNamespace + pattern2, (err) => {
          if (!err) {
            const subscriptions = asUser ? this.userSubscriptions : this.systemSubscriptions;
            subscriptions[this.objNamespace + pattern2] = true;
          }
          if (!--count) {
            return import_db_base.tools.maybeCallbackWithError(callback, err);
          }
        });
      });
    } else {
      this.log.silly(`${this.namespace} redis psubscribe ${this.objNamespace}${pattern}`);
      subClient.psubscribe(this.objNamespace + pattern, (err) => {
        if (!err) {
          const subscriptions = asUser ? this.userSubscriptions : this.systemSubscriptions;
          subscriptions[this.objNamespace + pattern] = true;
        }
        return import_db_base.tools.maybeCallbackWithError(callback, err);
      });
    }
  }
  subscribeConfig(pattern, options2, callback) {
    utils.checkObjectRights(this, null, null, options2, "list", (err) => {
      if (err) {
        return import_db_base.tools.maybeCallbackWithRedisError(callback, err);
      }
      return this._subscribe(pattern, false, callback);
    });
  }
  subscribe(pattern, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = null;
    }
    return this.subscribeConfig(pattern, options2, callback);
  }
  subscribeAsync(pattern, options2) {
    return new Promise((resolve, reject) => this.subscribe(pattern, options2, (err) => err ? reject(err) : resolve()));
  }
  subscribeUser(pattern, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = null;
    }
    utils.checkObjectRights(this, null, null, options2, "list", (err) => {
      if (err) {
        return import_db_base.tools.maybeCallbackWithRedisError(callback, err);
      }
      return this._subscribe(pattern, true, callback);
    });
  }
  subscribeUserAsync(pattern, options2) {
    return new Promise((resolve, reject) => this.subscribeUser(pattern, options2, (err) => err ? reject(err) : resolve()));
  }
  async _unsubscribe(pattern, asUser) {
    const subClient = asUser ? this.sub : this.subSystem;
    if (!subClient) {
      throw new Error(ERRORS.ERROR_DB_CLOSED);
    }
    if (Array.isArray(pattern)) {
      for (const _pattern of pattern) {
        this.log.silly(`${this.namespace} redis punsubscribe ${this.objNamespace}${_pattern}`);
        await subClient.punsubscribe(this.objNamespace + _pattern);
        const subscriptions = asUser ? this.userSubscriptions : this.systemSubscriptions;
        if (subscriptions[this.objNamespace + _pattern] !== void 0) {
          delete subscriptions[this.objNamespace + _pattern];
        }
      }
    } else {
      this.log.silly(`${this.namespace} redis punsubscribe ${this.objNamespace}${pattern}`);
      await subClient.punsubscribe(this.objNamespace + pattern);
      const subscriptions = asUser ? this.userSubscriptions : this.systemSubscriptions;
      if (subscriptions[this.objNamespace + pattern] !== void 0) {
        delete subscriptions[this.objNamespace + pattern];
      }
    }
  }
  unsubscribeConfig(pattern, options2, callback) {
    utils.checkObjectRights(this, null, null, options2, "list", async (err) => {
      if (err) {
        return import_db_base.tools.maybeCallbackWithRedisError(callback, err);
      }
      try {
        await this._unsubscribe(pattern, false);
        return import_db_base.tools.maybeCallback(callback);
      } catch (e) {
        return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
      }
    });
  }
  unsubscribe(pattern, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = null;
    }
    return this.unsubscribeConfig(pattern, options2, callback);
  }
  unsubscribeAsync(pattern, options2) {
    return new Promise((resolve, reject) => this.unsubscribe(pattern, options2, (err) => err ? reject(err) : resolve()));
  }
  unsubscribeUser(pattern, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = null;
    }
    utils.checkObjectRights(this, null, null, options2, "list", async (err) => {
      if (err) {
        return import_db_base.tools.maybeCallbackWithError(callback, err);
      }
      try {
        await this._unsubscribe(pattern, true);
        return import_db_base.tools.maybeCallback(callback);
      } catch (e) {
        return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
      }
    });
  }
  unsubscribeUserAsync(pattern, options2) {
    return new Promise((resolve, reject) => this.unsubscribeUser(pattern, options2, (err) => err ? reject(err) : resolve()));
  }
  async _objectHelper(keys2, objs2) {
    if (!keys2.length) {
      return;
    }
    if (!this.client) {
      throw new Error(ERRORS.ERROR_DB_CLOSED);
    }
    for (const id of keys2) {
      const obj = objs2.shift();
      const message = JSON.stringify(obj);
      const commands = [];
      if (this.useSets) {
        if (obj.type) {
          commands.push(["sadd", `${this.setNamespace}object.type.${obj.type}`, id]);
        }
        if (obj.common?.custom) {
          commands.push(["sadd", `${this.setNamespace}object.common.custom`, id]);
        }
      }
      if (!commands.length) {
        await this.client.set(id, message);
      } else {
        commands.push(["set", id, message]);
        await this.client.multi(commands).exec();
      }
      await this.client.publish(id, message);
    }
  }
  _chownObject(pattern, options2, callback) {
    this.getKeys(pattern, options2, async (err, keys2) => {
      if (err) {
        return import_db_base.tools.maybeCallbackWithError(callback, err);
      }
      if (!this.client) {
        return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);
      }
      if (!keys2) {
        return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_NOT_FOUND);
      }
      let strObjects;
      try {
        strObjects = await this.client.mget(keys2);
      } catch (e) {
        return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
      }
      const filteredKeys = [];
      const filteredObjs = [];
      for (let i = 0; i < keys2.length; i++) {
        const strObj = strObjects[i];
        let obj;
        try {
          obj = strObj ? JSON.parse(strObj) : null;
        } catch {
          this.log.error(`${this.namespace} Cannot parse JSON ${keys2[i]}: ${strObj}`);
          continue;
        }
        if (!obj || !utils.checkObject(obj, options2, CONSTS.ACCESS_WRITE)) {
          continue;
        }
        if (!obj.acl) {
          obj.acl = {
            owner: this.defaultNewAcl && this.defaultNewAcl.owner || CONSTS.SYSTEM_ADMIN_USER,
            ownerGroup: this.defaultNewAcl && this.defaultNewAcl.ownerGroup || CONSTS.SYSTEM_ADMIN_GROUP,
            object: this.defaultNewAcl && this.defaultNewAcl.object || CONSTS.ACCESS_USER_RW | CONSTS.ACCESS_GROUP_READ | CONSTS.ACCESS_EVERY_READ
            // '0644'
          };
          if (obj.type === "state") {
            obj.acl.state = this.defaultNewAcl && this.defaultNewAcl.state || CONSTS.ACCESS_USER_RW | CONSTS.ACCESS_GROUP_READ | CONSTS.ACCESS_EVERY_READ;
          }
        }
        obj.acl.owner = options2.owner || obj.acl.owner;
        obj.acl.ownerGroup = options2.ownerGroup || obj.acl.ownerGroup;
        filteredKeys.push(keys2[i]);
        filteredObjs.push(obj);
      }
      try {
        await this._objectHelper(filteredKeys, filteredObjs);
      } catch (e) {
        this.log.error(`${this.namespace} _chownObject error: ${e.message}`);
      }
      return import_db_base.tools.maybeCallbackWithError(callback, null, filteredObjs);
    }, true);
  }
  chownObject(pattern, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = {};
    }
    options2 = options2 || {};
    options2.acl = null;
    if (typeof options2 !== "object") {
      options2 = { owner: options2 };
    }
    if (!options2.ownerGroup && options2.group) {
      options2.ownerGroup = options2.group;
    }
    if (!options2.owner && options2.user) {
      options2.owner = options2.user;
    }
    if (!options2.owner) {
      this.log.error(`${this.namespace} user is not defined`);
      return import_db_base.tools.maybeCallbackWithError(callback, "invalid parameter");
    }
    if (!options2.ownerGroup) {
      this.getUserGroup(options2.owner, (user, groups) => {
        if (!groups || !groups[0]) {
          return import_db_base.tools.maybeCallbackWithError(callback, `user "${options2.owner}" belongs to no group`);
        }
        options2.ownerGroup = groups[0];
        this.chownObject(pattern, options2, callback);
      });
      return;
    }
    utils.checkObjectRights(this, null, null, options2, CONSTS.ACCESS_WRITE, (err, options3) => {
      if (err) {
        return import_db_base.tools.maybeCallbackWithRedisError(callback, err);
      }
      if (!options3.acl.object || !options3.acl.object.write) {
        return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_PERMISSION);
      }
      return this._chownObject(pattern, options3, callback);
    });
  }
  chownObjectAsync(pattern, options2) {
    return new Promise((resolve, reject) => this.chownObject(pattern, options2, (err, list) => err ? reject(err) : resolve(list)));
  }
  _chmodObject(pattern, options2, callback) {
    this.getKeys(pattern, options2, async (err, keys2) => {
      if (err) {
        return import_db_base.tools.maybeCallbackWithRedisError(callback, err);
      }
      if (!this.client) {
        return import_db_base.tools.maybeCallbackWithRedisError(callback, ERRORS.ERROR_DB_CLOSED);
      }
      if (!keys2) {
        return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_NOT_FOUND);
      }
      let strObjs;
      try {
        strObjs = await this.client.mget(keys2);
      } catch (e) {
        return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
      }
      const filteredKeys = [];
      const filteredObjs = [];
      for (let i = 0; i < keys2.length; i++) {
        const strObj = strObjs[i];
        let obj;
        try {
          obj = strObj ? JSON.parse(strObj) : null;
        } catch {
          this.log.error(`${this.namespace} Cannot parse JSON ${keys2[i]}: ${strObj}`);
          continue;
        }
        if (!utils.checkObject(obj, options2, CONSTS.ACCESS_WRITE) || !obj) {
          continue;
        }
        if (!obj.acl) {
          obj.acl = {
            owner: this.defaultNewAcl && this.defaultNewAcl.owner || CONSTS.SYSTEM_ADMIN_USER,
            ownerGroup: this.defaultNewAcl && this.defaultNewAcl.ownerGroup || CONSTS.SYSTEM_ADMIN_GROUP,
            object: this.defaultNewAcl && this.defaultNewAcl.object || CONSTS.ACCESS_USER_RW | CONSTS.ACCESS_GROUP_READ | CONSTS.ACCESS_EVERY_READ
            // '0644'
          };
          if (obj.type === "state") {
            obj.acl.state = this.defaultNewAcl && this.defaultNewAcl.state || CONSTS.ACCESS_USER_RW | CONSTS.ACCESS_GROUP_READ | CONSTS.ACCESS_EVERY_READ;
          }
        }
        if (options2.object !== void 0) {
          obj.acl.object = options2.object;
        }
        if (options2.state !== void 0 && "state" in obj.acl) {
          obj.acl.state = options2.state;
        }
        filteredKeys.push(keys2[i]);
        filteredObjs.push(obj);
      }
      try {
        await this._objectHelper(filteredKeys, filteredObjs);
      } catch (e) {
        this.log.error(`${this.namespace} _chmodObject error: ${e.message}`);
      }
    }, true);
  }
  chmodObject(pattern, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = null;
    }
    options2 = options2 || {};
    options2.acl = null;
    if (typeof options2 !== "object") {
      options2 = { object: options2 };
    }
    if (options2.mode && !options2.object) {
      options2.object = options2.mode;
    }
    if (options2.object === void 0) {
      this.log.error(`${this.namespace} mode is not defined`);
      return import_db_base.tools.maybeCallbackWithError(callback, "invalid parameter");
    } else if (typeof options2.mode === "string") {
      options2.mode = parseInt(options2.mode, 16);
    }
    utils.checkObjectRights(this, null, null, options2, CONSTS.ACCESS_WRITE, (err, options3) => {
      if (err) {
        return import_db_base.tools.maybeCallbackWithRedisError(callback, err);
      }
      if (!options3.acl.file.write) {
        return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_PERMISSION);
      }
      return this._chmodObject(pattern, options3, callback);
    });
  }
  chmodObjectAsync(pattern, options2) {
    return new Promise((resolve, reject) => this.chmodObject(pattern, options2, (err, list) => err ? reject(err) : resolve(list)));
  }
  async _getObject(id, options2, callback) {
    if (!this.client) {
      return import_db_base.tools.maybeCallbackWithRedisError(callback, ERRORS.ERROR_DB_CLOSED);
    }
    if (!id || typeof id !== "string") {
      return import_db_base.tools.maybeCallbackWithError(callback, `invalid id ${JSON.stringify(id)}`);
    }
    let obj, err;
    try {
      obj = await this.client.get(this.objNamespace + id);
    } catch (e) {
      this.log.debug(`${this.namespace} redis get ${id}, error - ${e.message}`);
      err = e;
    }
    try {
      obj = obj ? JSON.parse(obj) : null;
    } catch (e) {
      this.log.warn(`${this.namespace} Cannot parse ${id} - ${obj}: ${e.message}`);
      obj = null;
      if (!err) {
        err = e;
      }
    }
    if (obj) {
      if (utils.checkObject(obj, options2, CONSTS.ACCESS_READ)) {
        return import_db_base.tools.maybeCallbackWithError(callback, null, obj);
      }
      return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_PERMISSION);
    }
    return import_db_base.tools.maybeCallbackWithRedisError(callback, err, obj);
  }
  getObject(id, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = null;
    }
    if (!callback) {
      return new Promise((resolve, reject) => this.getObject(id, options2, (err, obj) => err ? reject(err) : resolve(obj)));
    }
    if (typeof callback === "function") {
      if (options2?.acl) {
        options2.acl = null;
      }
      utils.checkObjectRights(this, null, null, options2, CONSTS.ACCESS_READ, (err, options3) => {
        if (err) {
          return import_db_base.tools.maybeCallbackWithError(callback, err);
        }
        return this._getObject(id, options3, callback);
      });
    }
  }
  /**
   *
   * @param id
   * @param options
   * @deprecated use `getObject` without callback instead
   */
  getObjectAsync(id, options2) {
    return new Promise((resolve, reject) => this.getObject(id, options2, (err, obj) => err ? reject(err) : resolve(obj)));
  }
  async _getKeys(pattern, options2, callback, dontModify) {
    if (!this.client) {
      return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);
    }
    if (!pattern || typeof pattern !== "string") {
      return import_db_base.tools.maybeCallbackWithError(callback, `invalid pattern ${JSON.stringify(pattern)}`);
    }
    const r = new RegExp(import_db_base.tools.pattern2RegEx(pattern));
    let keys2;
    try {
      keys2 = await this._getKeysViaScan(this.objNamespace + pattern);
    } catch (e) {
      return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
    }
    if (!this.client) {
      return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);
    }
    const result2 = [];
    if (keys2) {
      keys2.sort();
      const result3 = [];
      const dontCheck = options2.user === CONSTS.SYSTEM_ADMIN_USER || options2.group !== CONSTS.SYSTEM_ADMIN_GROUP || options2.groups && options2.groups.indexOf(CONSTS.SYSTEM_ADMIN_GROUP) !== -1;
      if (dontCheck) {
        for (let i = 0; i < keys2.length; i++) {
          const id = keys2[i].substring(this.objNamespaceL);
          if (r.test(id)) {
            if (!dontModify) {
              result3.push(id);
            } else {
              result3.push(keys2[i]);
            }
          }
        }
        return import_db_base.tools.maybeCallbackWithError(callback, null, result3);
      }
      let metas;
      try {
        metas = await this.client.mget(keys2);
      } catch (e) {
        return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
      }
      metas = metas || [];
      for (let i = 0; i < keys2.length; i++) {
        const metaStr = metas[i];
        let meta;
        try {
          meta = metaStr ? JSON.parse(metaStr) : null;
        } catch {
          this.log.error(`${this.namespace} Cannot parse JSON ${keys2[i]}: ${metaStr}`);
          continue;
        }
        if (r.test(keys2[i]) && utils.checkObject(meta, options2, CONSTS.ACCESS_READ)) {
          if (!dontModify) {
            result3.push(keys2[i].substring(this.objNamespaceL));
          } else {
            result3.push(keys2[i]);
          }
        }
      }
      return import_db_base.tools.maybeCallbackWithError(callback, null, result3);
    }
    return import_db_base.tools.maybeCallbackWithError(callback, null, result2);
  }
  getKeys(pattern, options2, callback, dontModify) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = null;
    }
    if (!callback) {
      return new Promise((resolve, reject) => this.getKeys(pattern, options2, (err, obj) => err ? reject(err) : resolve(obj), dontModify));
    }
    if (typeof callback === "function") {
      utils.checkObjectRights(this, null, null, options2, "list", (err, options3) => {
        if (err) {
          return import_db_base.tools.maybeCallbackWithRedisError(callback, err);
        }
        return this._getKeys(pattern, options3, callback, dontModify);
      });
    }
  }
  getKeysAsync(id, options2) {
    return this.getKeys(id, options2);
  }
  async _getObjects(keys2, options2, callback, dontModify) {
    if (!keys2) {
      return import_db_base.tools.maybeCallbackWithError(callback, "no keys");
    }
    if (!keys2.length) {
      return import_db_base.tools.maybeCallbackWithError(callback, null, []);
    }
    let _keys;
    if (!dontModify) {
      _keys = [];
      for (let i = 0; i < keys2.length; i++) {
        _keys[i] = this.objNamespace + keys2[i];
      }
    } else {
      _keys = keys2;
    }
    if (!this.client) {
      return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);
    }
    let objs2;
    try {
      objs2 = await this.client.mget(_keys);
      this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} redis mget ${!objs2 ? 0 : objs2.length} ${_keys.length}`);
    } catch (e) {
      this.log.warn(`${this.namespace} redis mget ${!objs2 ? 0 : objs2.length} ${_keys.length}, err: ${e.message}`);
    }
    let result2 = [];
    if (objs2) {
      const dontCheck = options2 && (options2.user === CONSTS.SYSTEM_ADMIN_USER || options2.group !== CONSTS.SYSTEM_ADMIN_GROUP || options2.groups && options2.groups.indexOf(CONSTS.SYSTEM_ADMIN_GROUP) !== -1);
      if (!dontCheck) {
        for (let i = 0; i < objs2.length; i++) {
          const strObj = objs2[i];
          let obj;
          try {
            obj = strObj ? JSON.parse(strObj) : null;
          } catch {
            this.log.error(`${this.namespace} Cannot parse JSON ${_keys[i]}: ${objs2[i]}`);
            result2.push({ error: ERRORS.ERROR_PERMISSION });
            continue;
          }
          if (utils.checkObject(obj, options2, CONSTS.ACCESS_READ)) {
            result2.push(obj);
          } else {
            result2.push({ error: ERRORS.ERROR_PERMISSION });
          }
        }
      } else {
        result2 = objs2.map((obj, i) => {
          try {
            return obj !== null ? JSON.parse(obj) : obj;
          } catch {
            this.log.error(`${this.namespace} Cannot parse JSON ${_keys[i]}: ${obj}`);
            return null;
          }
        });
      }
    }
    return import_db_base.tools.maybeCallbackWithError(callback, null, result2);
  }
  getObjects(keys2, options2, callback, dontModify) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = null;
    }
    if (!callback) {
      return new Promise((resolve, reject) => (
        // @ts-expect-error need to clarify, that objs is not undefined if no error is provided
        this.getObjects(keys2, options2, (err, objs2) => err ? reject(err) : resolve(objs2), dontModify)
      ));
    }
    if (options2?.acl) {
      options2.acl = null;
    }
    if (typeof callback === "function") {
      utils.checkObjectRights(this, null, null, options2, CONSTS.ACCESS_READ, (err, options3) => {
        if (err) {
          return import_db_base.tools.maybeCallbackWithRedisError(callback, err);
        }
        return this._getObjects(keys2, options3, callback, dontModify);
      });
    }
  }
  getObjectsAsync(keys2, options2) {
    return this.getObjects(keys2, options2);
  }
  async _getObjectsByPattern(pattern, options2, callback) {
    if (!pattern || typeof pattern !== "string") {
      return import_db_base.tools.maybeCallbackWithError(callback, `invalid pattern ${JSON.stringify(pattern)}`);
    }
    if (!this.client) {
      return import_db_base.tools.maybeCallbackWithRedisError(callback, ERRORS.ERROR_DB_CLOSED);
    }
    let keys2;
    try {
      keys2 = await this._getKeysViaScan(this.objNamespace + pattern);
    } catch (e) {
      return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
    }
    if (!this.client) {
      return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);
    }
    this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} redis keys ${keys2.length} ${pattern}`);
    this._getObjects(keys2, options2, callback, true);
  }
  getObjectsByPattern(pattern, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = null;
    }
    if (!callback) {
      return new Promise((resolve, reject) => this.getObjectsByPattern(pattern, options2, (err, obj) => err ? reject(err) : resolve(obj)));
    }
    if (options2 && options2.acl) {
      options2.acl = null;
    }
    if (typeof callback === "function") {
      utils.checkObjectRights(this, null, null, options2, CONSTS.ACCESS_READ, (err, options3) => {
        if (err) {
          return import_db_base.tools.maybeCallbackWithRedisError(callback, err);
        }
        return this._getObjectsByPattern(pattern, options3, callback);
      });
    }
  }
  getObjectsByPatternAsync(pattern, options2) {
    return new Promise((resolve, reject) => this.getObjectsByPattern(pattern, options2, (err, objs2) => err ? reject(err) : resolve(objs2)));
  }
  async _setObject(id, obj, options2) {
    if (!id || typeof id !== "string" || utils.REG_CHECK_ID.test(id)) {
      throw new Error(`Invalid ID: ${id}`);
    }
    if (!obj) {
      this.log.warn(`${this.namespace} setObject: Argument object is null`);
      throw new Error("obj is null");
    }
    if (!import_db_base.tools.isObject(obj)) {
      this.log.warn(`${this.namespace} setObject: Argument object is no object: ${obj}`);
      throw new Error("obj is no object");
    }
    if (!this.client) {
      throw new Error(ERRORS.ERROR_DB_CLOSED);
    }
    obj = (0, import_deep_clone.default)(obj);
    obj._id = id;
    const oldObjStr = await this.client.get(this.objNamespace + id);
    let oldObj;
    try {
      oldObj = oldObjStr ? JSON.parse(oldObjStr) : null;
    } catch (e) {
      this.log.error(`${this.namespace} Cannot parse ${id} - ${oldObjStr}: ${e.message}`);
      throw new Error(`Cannot parse ${id} - ${oldObjStr}: ${e.message}`);
    }
    if (!import_db_base.tools.checkNonEditable(oldObj, obj)) {
      throw new Error("Invalid password for update of vendor information");
    }
    const oldObjHasCustom = oldObj?.common?.custom;
    if (oldObj?.common) {
      for (const commonSetting of this.preserveSettings) {
        if (commonSetting === "custom") {
          if (oldObj.common.custom !== void 0 && oldObj.common.custom !== null && !import_db_base.tools.isObject(oldObj.common.custom)) {
            delete oldObj.common.custom;
          }
          if (obj.common && obj.common.custom !== void 0 && obj.common.custom !== null && !import_db_base.tools.isObject(obj.common.custom)) {
            delete obj.common.custom;
          }
          if ((!obj.common || !obj.common.custom) && oldObj.common.custom && obj.type === "state") {
            obj.common = obj.common || {};
            obj.common.custom = oldObj.common.custom;
          } else if (obj.common?.custom && oldObj.common.custom) {
            for (const attr of Object.keys(oldObj.common.custom)) {
              if (obj.common.custom[attr] === null) {
                delete obj.common.custom[attr];
              } else if (obj.common.custom[attr] === void 0) {
                obj.common.custom[attr] = oldObj.common.custom[attr];
              }
            }
          }
          if (obj.common?.custom) {
            for (const attr of Object.keys(obj.common.custom)) {
              if (obj.common.custom[attr] === null) {
                delete obj.common.custom[attr];
              }
            }
            if (!Object.keys(obj.common.custom).length) {
              delete obj.common.custom;
            }
          }
        } else {
          let objCommon = obj.common;
          if (objCommon && objCommon[commonSetting] === null) {
            delete objCommon[commonSetting];
          } else if (
            // if old setting present and new setting is absent
            // @ts-expect-error https://github.com/ioBroker/adapter-core/issues/455
            oldObj.common[commonSetting] !== void 0 && (!objCommon || objCommon[commonSetting] === void 0)
          ) {
            objCommon = objCommon || {};
            objCommon[commonSetting] = oldObj.common[commonSetting];
          }
        }
      }
    }
    if (obj.common && "alias" in obj.common && obj.common.alias.id) {
      if (typeof obj.common.alias.id === "object") {
        if (typeof obj.common.alias.id.write !== "string" || typeof obj.common.alias.id.read !== "string") {
          throw new Error("Invalid alias ID");
        }
        if (obj.common.alias.id.write.startsWith("alias.") || obj.common.alias.id.read.startsWith("alias.")) {
          throw new Error("Cannot make alias on alias");
        }
      } else {
        if (typeof obj.common.alias.id !== "string") {
          throw new Error("Invalid alias ID");
        }
        if (obj.common.alias.id.startsWith("alias.")) {
          throw new Error("Cannot make alias on alias");
        }
      }
    }
    if (oldObj?.acl && !obj.acl) {
      obj.acl = oldObj.acl;
    }
    if (this.defaultNewAcl && !obj.acl) {
      obj.acl = (0, import_deep_clone.default)(this.defaultNewAcl);
      delete obj.acl.file;
      if (obj.type !== "state") {
        delete obj.acl.state;
      }
      if (options2.user && options2.user !== CONSTS.SYSTEM_ADMIN_USER) {
        obj.acl.owner = options2.user;
      }
      if (options2.group && options2.group !== CONSTS.SYSTEM_ADMIN_GROUP) {
        obj.acl.ownerGroup = options2.group;
      }
    }
    if (this.defaultNewAcl && obj.acl && !obj.acl.ownerGroup && options2.group) {
      obj.acl.ownerGroup = options2.group;
    }
    const message = JSON.stringify(obj);
    const commands = [];
    if (this.useSets) {
      if (obj.type && !oldObj?.type) {
        commands.push(["sadd", `${this.setNamespace}object.type.${obj.type}`, this.objNamespace + id]);
      } else if (obj.type && oldObj && oldObj.type && oldObj.type !== obj.type) {
        commands.push(["sadd", `${this.setNamespace}object.type.${obj.type}`, this.objNamespace + id], ["srem", `${this.setNamespace}object.type.${oldObj.type}`, this.objNamespace + id]);
      } else if (oldObj?.type && !obj.type) {
        commands.push(["srem", `${this.setNamespace}object.type.${obj.type}`, this.objNamespace + id]);
      }
      if (obj.common?.custom && !oldObjHasCustom) {
        commands.push(["sadd", `${this.setNamespace}object.common.custom`, this.objNamespace + id]);
      } else if (oldObjHasCustom && !obj.common?.custom) {
        commands.push(["srem", `${this.setNamespace}object.common.custom`, this.objNamespace + id]);
      }
    }
    if (!commands.length) {
      await this.client.set(this.objNamespace + id, message);
    } else {
      commands.push(["set", this.objNamespace + id, message]);
      await this.client.multi(commands).exec();
    }
    if (oldObj?.type === "meta" && this.existingMetaObjects[id] === false) {
      this.existingMetaObjects[id] = true;
    }
    await this.client.publish(this.objNamespace + id, message);
    return { id };
  }
  /**
   * set anew or update object
   *
   * This function writes the object into DB
   *
   * @param id ID of the object
   * @param obj
   * @param options options for access control are optional
   * @param callback return function
   */
  setObject(id, obj, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = {};
    }
    if (!callback) {
      return new Promise((resolve, reject) => this.setObject(id, obj, options2, (err, res) => err ? reject(err) : resolve(res)));
    }
    if (options2 && options2.acl) {
      options2.acl = null;
    }
    utils.checkObjectRights(this, null, null, options2, CONSTS.ACCESS_WRITE, async (err) => {
      if (err) {
        return import_db_base.tools.maybeCallbackWithRedisError(callback, err);
      }
      try {
        const res = await this._setObject(id, obj, options2 || {});
        return import_db_base.tools.maybeCallbackWithError(callback, null, res);
      } catch (e) {
        return import_db_base.tools.maybeCallbackWithError(callback, e);
      }
    });
  }
  /**
   *
   * @param id
   * @param obj
   * @param options
   * @deprecated use `setObject` without callback instead
   */
  setObjectAsync(id, obj, options2) {
    return new Promise((resolve, reject) => (
      // @ts-expect-error TODO we are returning type Object for ease of use to devs, but formally these are AnyObjects, e.g. not guaranteed to have common
      this.setObject(id, obj, options2, (err, res) => err ? reject(err) : resolve(res))
    ));
  }
  async _delObject(id, options2) {
    if (!id || typeof id !== "string" || utils.REG_CHECK_ID.test(id)) {
      throw new Error(`Invalid ID: ${id}`);
    }
    if (!this.client) {
      throw new Error(ERRORS.ERROR_DB_CLOSED);
    }
    let oldObjStr;
    try {
      oldObjStr = await this.client.get(this.objNamespace + id);
    } catch (e) {
      this.log.warn(`${this.namespace} redis get ${id}, error - ${e.message}`);
      return;
    }
    if (!oldObjStr) {
      return;
    }
    let oldObj;
    try {
      oldObj = JSON.parse(oldObjStr);
    } catch (e) {
      this.log.warn(`${this.namespace} Cannot parse ${id} - ${oldObjStr}: ${e.message}`);
      oldObj = null;
    }
    if (!utils.checkObject(oldObj, options2, CONSTS.ACCESS_WRITE)) {
      throw new Error(ERRORS.ERROR_PERMISSION);
    } else {
      const commands = [];
      if (oldObj && this.useSets) {
        if (oldObj.type) {
          commands.push(["srem", `${this.setNamespace}object.type.${oldObj.type}`, this.objNamespace + id]);
        }
        if (oldObj.common?.custom) {
          commands.push(["srem", `${this.setNamespace}object.common.custom`, this.objNamespace + id]);
        }
      }
      if (!commands.length) {
        await this.client.del(this.objNamespace + id);
      } else {
        commands.push(["del", this.objNamespace + id]);
        await this.client.multi(commands).exec();
      }
      if (this.existingMetaObjects[id]) {
        this.existingMetaObjects[id] = false;
      }
      await this.client.publish(this.objNamespace + id, "null");
    }
  }
  delObject(id, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = null;
    }
    if (!callback) {
      return new Promise((resolve, reject) => this.delObject(id, options2, (err) => err ? reject(err) : resolve()));
    }
    if (options2?.acl) {
      options2.acl = null;
    }
    utils.checkObjectRights(this, null, null, options2, CONSTS.ACCESS_DELETE, async (err, options3) => {
      if (err) {
        return import_db_base.tools.maybeCallbackWithError(callback, err);
      }
      try {
        await this._delObject(id, options3);
        return import_db_base.tools.maybeCallback(callback);
      } catch (e) {
        return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
      }
    });
  }
  delObjectAsync(id, options2) {
    return this.delObject(id, options2);
  }
  /**
   * Function to checks if comparisons will work according to the configured Locale
   */
  async isSystemLocaleSupported() {
    if (!this.client) {
      throw new Error(ERRORS.ERROR_DB_CLOSED);
    }
    try {
      const res = await this.client.eval(`return 'c-i.t' >= 'c.' and 'c-i.t' < 'c.\u9999'`, 0);
      return res === null;
    } catch (e) {
      this.log.warn(`${this.namespace} Cannot check if locale is supported: ${e.message}`);
      return true;
    }
  }
  // this function is very ineffective. Because reads all objects and then process them
  async _applyViewFunc(func, params, options = {}) {
    if (!this.client) {
      throw new Error(ERRORS.ERROR_DB_CLOSED);
    }
    const result = {
      rows: []
    };
    const filterEntries = (arr, duplicateFiltering) => {
      if (duplicateFiltering) {
        const included = /* @__PURE__ */ new Map();
        return arr.filter((obj) => {
          if (included.has(obj.id) || obj.value === null) {
            return false;
          }
          included.set(obj.id, true);
          return true;
        });
      }
      return arr.filter((obj) => {
        return obj.value !== null;
      });
    };
    params = params || {};
    params.startkey = params.startkey || "";
    params.endkey = params.endkey || "\u9999";
    const wildcardPos = params.endkey.indexOf("\u9999");
    let wildCardLastPos = true;
    if (wildcardPos !== -1 && wildcardPos !== params.endkey.length - 1) {
      wildCardLastPos = false;
    }
    if (params.startkey === params.endkey) {
      params.endkey = `${params.endkey}\0`;
    }
    const matches = func.map.match(/if\s\(doc\.type\s?===?\s?'(\w+)'\)\semit\(([^,]+),\s?doc\s?\)/);
    if (wildCardLastPos && func?.map && this.scripts.filter && matches) {
      let cursor = "0";
      let filterRequired = true;
      do {
        if (!this.client) {
          throw new Error(ERRORS.ERROR_DB_CLOSED);
        }
        let objs2;
        try {
          objs2 = await this.client.evalsha([
            this.scripts.filter,
            6,
            this.objNamespace,
            params.startkey,
            params.endkey,
            matches[1],
            cursor,
            `${this.setNamespace}object.type.${matches[1]}`
          ]);
        } catch (e) {
          this.log.warn(`${this.namespace} Cannot get view: ${e.message}`);
          throw e;
        }
        objs2 = objs2 || [];
        if (Array.isArray(objs2[0])) {
          cursor = objs2[1] || "0";
          objs2 = objs2[0];
        } else {
          cursor = "0";
          filterRequired = false;
        }
        const currRows = objs2.map((_obj) => {
          let obj;
          try {
            obj = JSON.parse(_obj);
          } catch {
            this.log.error(`${this.namespace} Cannot parse JSON: ${_obj}`);
            return { id: "parseError", value: null };
          }
          if (!obj) {
            this.log.error(`${this.namespace} empty object!`);
            return { id: "parseError", value: null };
          }
          if (matches[2] && matches[2].trim() === "doc._id") {
            return { id: obj._id, value: obj };
          } else if (matches[2] && matches[2].trim() === "doc.common.name" && obj.common) {
            if (typeof obj.common.name === "object") {
              if (obj.common.name.en) {
                return { id: obj.common.name.en, value: obj };
              }
              return { id: JSON.stringify(obj.common.name), value: obj };
            }
            return { id: obj.common.name, value: obj };
          }
          this.log.error(`${this.namespace} Cannot filter "${matches[2]}": ${JSON.stringify(obj)}`);
          return { id: "parseError", value: null };
        });
        if (currRows.length) {
          result.rows = [...result.rows, ...currRows];
        }
      } while (cursor !== "0");
      if (func.reduce === "_stats") {
        let max = null;
        for (let i = 0; i < result.rows.length; i++) {
          if (max === null || result.rows[i].value > max) {
            max = result.rows[i].value;
          }
        }
        if (max !== null) {
          result.rows = [{ id: "_stats", value: { max } }];
        } else {
          result.rows = [];
        }
      }
      result.rows = filterEntries(result.rows, filterRequired);
      return result;
    } else if (
      // filter by script
      wildCardLastPos && func?.map && this.scripts.script && func.map.includes("doc.common.engineType")
    ) {
      let cursor = "0";
      let filterRequired = true;
      do {
        if (!this.client) {
          throw new Error(ERRORS.ERROR_DB_CLOSED);
        }
        let res;
        try {
          res = await this.client.evalsha([
            this.scripts.script,
            5,
            this.objNamespace,
            params.startkey,
            params.endkey,
            cursor,
            `${this.setNamespace}object.type.script`
          ]);
        } catch (e) {
          this.log.warn(`${this.namespace} Cannot get "scripts" view: ${e.message}`);
          throw e;
        }
        let objs2;
        if (Array.isArray(res[0])) {
          cursor = res[1] || "0";
          objs2 = res[0];
        } else {
          cursor = "0";
          filterRequired = false;
          objs2 = res;
        }
        const currRows = objs2.map((obj) => {
          try {
            const scriptObj = JSON.parse(obj);
            return { id: scriptObj._id, value: scriptObj };
          } catch {
            this.log.error(`${this.namespace} Cannot parse JSON: ${obj}`);
            return { id: "parseError", value: null };
          }
        });
        if (currRows.length) {
          result.rows = [...result.rows, ...currRows];
        }
      } while (cursor !== "0");
      result.rows = filterEntries(result.rows, filterRequired);
      return result;
    } else if (
      // filter by hm-rega programs
      wildCardLastPos && func?.map && this.scripts.programs && func.map.includes("doc.native.TypeName === 'PROGRAM'")
    ) {
      let cursor = "0";
      let filterRequired = true;
      do {
        if (!this.client) {
          throw new Error(ERRORS.ERROR_DB_CLOSED);
        }
        let objs2;
        try {
          objs2 = await this.client.evalsha([
            this.scripts.programs,
            5,
            `${this.objNamespace}hm-rega.`,
            params.startkey,
            params.endkey,
            cursor,
            `${this.setNamespace}object.type.channel`
          ]);
        } catch (e) {
          this.log.warn(`${this.namespace} Cannot get view: ${e.message}`);
          throw e;
        }
        if (Array.isArray(objs2[0])) {
          cursor = objs2[1] || "0";
          objs2 = objs2[0];
        } else {
          cursor = "0";
          filterRequired = false;
        }
        const currRows = objs2.map((_obj) => {
          try {
            const obj = JSON.parse(_obj);
            return { id: obj._id, value: obj };
          } catch {
            this.log.error(`${this.namespace} Cannot parse JSON: ${_obj}`);
            return { id: "parseError", value: null };
          }
        });
        if (currRows.length) {
          result.rows = [...result.rows, ...currRows];
        }
      } while (cursor !== "0");
      result.rows = filterEntries(result.rows, filterRequired);
      return result;
    } else if (
      // filter by hm-rega variables
      wildCardLastPos && func?.map && this.scripts.variables && func.map.includes("doc.native.TypeName === 'ALARMDP'")
    ) {
      let cursor = "0";
      let filterRequired = true;
      do {
        if (!this.client) {
          throw new Error(ERRORS.ERROR_DB_CLOSED);
        }
        let objs2;
        try {
          objs2 = await this.client.evalsha([
            this.scripts.variables,
            5,
            `${this.objNamespace}hm-rega.`,
            params.startkey,
            params.endkey,
            cursor,
            `${this.setNamespace}object.type.state`
          ]);
        } catch (e) {
          this.log.warn(`${this.namespace} Cannot get view ${e.message}`);
          throw e;
        }
        if (Array.isArray(objs2[0])) {
          cursor = objs2[1] || "0";
          objs2 = objs2[0];
        } else {
          cursor = "0";
          filterRequired = false;
        }
        const currRows = objs2.map((_obj) => {
          try {
            const obj = JSON.parse(_obj);
            return { id: obj._id, value: obj };
          } catch {
            this.log.error(`${this.namespace} Cannot parse JSON: ${_obj}`);
            return { id: "parseError", value: null };
          }
        });
        if (currRows.length) {
          result.rows = [...result.rows, ...currRows];
        }
      } while (cursor !== "0");
      result.rows = filterEntries(result.rows, filterRequired);
      return result;
    } else if (
      // filter by custom, redis also returns if common.custom is not present
      wildCardLastPos && func?.map && this.scripts.custom && func.map.includes("doc.common.custom")
    ) {
      let cursor = "0";
      let filterRequired = true;
      do {
        if (!this.client) {
          throw new Error(ERRORS.ERROR_DB_CLOSED);
        }
        let objs2;
        try {
          objs2 = await this.client.evalsha([
            this.scripts.custom,
            5,
            this.objNamespace,
            params.startkey,
            params.endkey,
            cursor,
            `${this.setNamespace}object.common.custom`
          ]);
        } catch (e) {
          this.log.warn(`${this.namespace} Cannot get view: ${e.message}`);
          throw e;
        }
        if (Array.isArray(objs2[0])) {
          cursor = objs2[1] || "0";
          objs2 = objs2[0];
        } else {
          cursor = "0";
          filterRequired = false;
        }
        const useFullObject = func.map.includes("emit(doc._id, doc)");
        for (const _obj of objs2) {
          let obj;
          try {
            obj = JSON.parse(_obj);
          } catch {
            this.log.error(`${this.namespace} Cannot parse JSON: ${_obj}`);
            continue;
          }
          if (obj?.common?.custom) {
            if (useFullObject) {
              result.rows.push({ id: obj._id, value: obj });
            } else {
              result.rows.push({ id: obj._id, value: obj.common.custom });
            }
          }
        }
      } while (cursor !== "0");
      result.rows = filterEntries(result.rows, filterRequired);
      return result;
    }
    if (!wildCardLastPos) {
      this.log.debug(`${this.namespace} Search can't be optimized because wildcard not at the end, fallback to keys!: ${func.map}`);
    } else {
      this.log.debug(`${this.namespace} No suitable Lua script, fallback to keys!: ${func.map}`);
    }
    let searchKeys = `${this.objNamespace}*`;
    if (wildcardPos !== -1) {
      searchKeys = this.objNamespace + params.endkey.replace(/\u9999/g, "*");
    }
    let keys;
    keys = await this._getKeysViaScan(searchKeys);
    if (!this.client) {
      throw new Error(ERRORS.ERROR_DB_CLOSED);
    }
    const endAfterWildcard = params.endkey.substr(wildcardPos + 1);
    params.startkey = this.objNamespace + params.startkey;
    params.endkey = this.objNamespace + params.endkey;
    keys = keys.sort().filter((key) => {
      if (key && !utils.REG_CHECK_ID.test(key)) {
        if (params && wildcardPos > 0) {
          if (params.startkey && key < params.startkey) {
            return false;
          }
          if (params.endkey && key > params.endkey) {
            return false;
          }
        } else if (params && wildcardPos === 0) {
          if (!key.endsWith(endAfterWildcard)) {
            return false;
          }
        }
        return true;
      }
      return false;
    });
    let objs;
    try {
      objs = await this.client.mget(keys);
    } catch {
      objs = [];
    }
    const _emit_ = (id, obj) => {
      result.rows.push({ id, value: obj });
    };
    const f = eval(`(${func.map.replace(/^function\(([a-z0-9A-Z_]+)\)/g, "function($1, emit)")})`);
    for (let i = 0; i < keys.length; i++) {
      const strObj = objs[i];
      let obj;
      try {
        obj = strObj !== null ? JSON.parse(strObj) : null;
      } catch {
        this.log.error(`${this.namespace} Cannot parse JSON ${keys[i]}: ${objs[i]}`);
        continue;
      }
      if (!utils.checkObject(obj, options, CONSTS.ACCESS_READ)) {
        continue;
      }
      if (obj) {
        try {
          f(obj, _emit_);
        } catch (e) {
          this.log.error(`${this.namespace} Cannot execute map: ${e.message}`);
        }
      }
    }
    if (func.reduce === "_stats") {
      let max = null;
      for (let i = 0; i < result.rows.length; i++) {
        if (max === null || result.rows[i].value > max) {
          max = result.rows[i].value;
        }
      }
      if (max !== null) {
        result.rows = [{ id: "_stats", value: { max } }];
      } else {
        result.rows = [];
      }
    }
    return result;
  }
  async _getObjectView(design, search, params2, options2) {
    if (!this.client) {
      throw new Error(ERRORS.ERROR_DB_CLOSED);
    }
    let obj;
    try {
      obj = await this.client.get(`${this.objNamespace}_design/${design}`);
    } catch (e) {
      this.log.error(`${this.namespace} Cannot find view "${design}" for search "${search}" : ${e.message}`);
      throw new Error(`Cannot find view "${design}"`);
    }
    if (obj) {
      try {
        obj = JSON.parse(obj);
      } catch {
        this.log.error(`${this.namespace} Cannot parse JSON: ${obj}`);
        throw new Error(`Cannot parse JSON: "_design/${design}" / "${obj}"`);
      }
      if (obj.views?.[search]) {
        return this._applyViewFunc(obj.views[search], params2, options2);
      }
      this.log.error(`${this.namespace} Cannot find search "${search}" in "${design}"`);
      throw new Error(`Cannot find search "${search}" in "${design}"`);
    } else {
      this.log.error(`${this.namespace} Cannot find view "${design}" for search "${search}"`);
      throw new Error(`Cannot find view "${design}"`);
    }
  }
  getObjectView(design, search, params2, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = null;
    }
    if (!callback) {
      return new Promise((resolve, reject) => this.getObjectView(design, search, params2, options2, (err, obj) => err ? reject(err) : resolve(obj)));
    }
    if (options2?.acl) {
      options2.acl = null;
    }
    if (typeof callback === "function") {
      utils.checkObjectRights(this, null, null, options2, "list", async (err, options3) => {
        if (err) {
          return import_db_base.tools.maybeCallbackWithRedisError(callback, err);
        }
        try {
          const res = await this._getObjectView(design, search, params2, options3);
          return import_db_base.tools.maybeCallbackWithError(callback, null, res);
        } catch (e) {
          return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
        }
      });
    }
  }
  getObjectViewAsync(design, search, params2, options2) {
    return this.getObjectView(design, search, params2, options2);
  }
  async _getObjectList(params2, options2) {
    if (!this.client) {
      throw new Error(ERRORS.ERROR_DB_CLOSED);
    }
    params2 = params2 || {};
    params2.startkey = params2.startkey || "";
    params2.endkey = params2.endkey || "\u9999";
    const pattern = params2.endkey.substring(0, params2.startkey.length) === params2.startkey ? `${this.objNamespace + params2.startkey}*` : `${this.objNamespace}*`;
    const keys2 = await this._getKeysViaScan(pattern);
    if (!this.client) {
      throw new Error(ERRORS.ERROR_DB_CLOSED);
    }
    const _keys = [];
    for (const key of keys2) {
      const id = key.substring(this.objNamespaceL);
      if (params2.startkey && id < params2.startkey) {
        continue;
      }
      if (params2.endkey && id > params2.endkey) {
        continue;
      }
      if (!id || utils.REG_CHECK_ID.test(id) || id.match(/\|file\$%\$/)) {
        continue;
      }
      if (!params2.include_docs && id[0] === "_") {
        continue;
      }
      _keys.push(key);
    }
    _keys.sort();
    let objs2;
    try {
      objs2 = await this.client.mget(_keys);
    } catch {
    }
    const result2 = {
      rows: []
    };
    if (objs2) {
      for (let i = 0; i < objs2.length; i++) {
        const strObj = objs2[i];
        let obj;
        try {
          obj = strObj ? JSON.parse(strObj) : null;
        } catch {
          this.log.error(`${this.namespace} Cannot parse JSON ${_keys[i]}: ${objs2[i]}`);
          continue;
        }
        if (!obj || !utils.checkObject(obj, options2, CONSTS.ACCESS_READ)) {
          continue;
        }
        result2.rows.push({ id: obj._id, value: obj, doc: obj });
      }
    }
    return result2;
  }
  getObjectList(params2, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = null;
    }
    if (!callback) {
      return new Promise((resolve, reject) => this.getObjectList(params2, options2, (err, obj) => err ? reject(err) : resolve(obj)));
    }
    if (options2?.acl) {
      options2.acl = null;
    }
    if (typeof callback === "function") {
      utils.checkObjectRights(this, null, null, options2, "list", async (err, options3) => {
        if (err) {
          return import_db_base.tools.maybeCallbackWithRedisError(callback, err);
        }
        try {
          const res = await this._getObjectList(params2, options3 || {});
          return import_db_base.tools.maybeCallbackWithError(callback, null, res);
        } catch (e) {
          return import_db_base.tools.maybeCallbackWithError(callback, e);
        }
      });
    }
  }
  getObjectListAsync(params2, options2) {
    return this.getObjectList(params2, options2);
  }
  // could be optimized, to read object only once. Now it will read 3 times
  async _extendObject(id, obj, options2, callback) {
    if (!id || typeof id !== "string" || utils.REG_CHECK_ID.test(id)) {
      return import_db_base.tools.maybeCallbackWithError(callback, `Invalid ID: ${id}`);
    }
    if (!this.client) {
      return import_db_base.tools.maybeCallbackWithRedisError(callback, ERRORS.ERROR_DB_CLOSED);
    }
    let oldObj;
    try {
      oldObj = await this.client.get(this.objNamespace + id);
    } catch (e) {
      return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
    }
    try {
      oldObj = oldObj ? JSON.parse(oldObj) : null;
    } catch {
      this.log.error(`${this.namespace} Cannot parse JSON ${id}: ${oldObj}`);
      return import_db_base.tools.maybeCallbackWithError(callback, `Cannot parse JSON ${id}: ${oldObj}`);
    }
    if (!utils.checkObject(oldObj, options2, CONSTS.ACCESS_WRITE)) {
      return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_PERMISSION);
    }
    let _oldObj;
    if (oldObj?.nonEdit) {
      _oldObj = (0, import_deep_clone.default)(oldObj);
    }
    const oldObjHasCustom = !!oldObj?.common?.custom;
    oldObj = oldObj || {};
    obj = (0, import_deep_clone.default)(obj);
    if (oldObj.common && oldObj.common.custom !== void 0 && oldObj.common.custom !== null && !import_db_base.tools.isObject(oldObj.common.custom)) {
      delete oldObj.common.custom;
    }
    const oldType = oldObj.type;
    oldObj = (0, import_node.default)(true, oldObj, obj);
    oldObj._id = id;
    if (this.defaultNewAcl && !oldObj.acl) {
      oldObj.acl = (0, import_deep_clone.default)(this.defaultNewAcl);
      delete oldObj.acl.file;
      if (oldObj.type !== "state") {
        delete oldObj.acl.state;
      }
      if (options2.owner) {
        oldObj.acl.owner = options2.owner;
        if (!options2.ownerGroup) {
          oldObj.acl.ownerGroup = null;
          return void this.getUserGroup(options2.owner, (user, groups) => {
            if (!groups || !groups[0]) {
              options2.ownerGroup = this.defaultNewAcl && this.defaultNewAcl.ownerGroup || CONSTS.SYSTEM_ADMIN_GROUP;
            } else {
              options2.ownerGroup = groups[0];
            }
            this._extendObject(id, obj, options2, callback);
          });
        }
      }
    }
    if (this.defaultNewAcl && options2.ownerGroup && oldObj.acl && !oldObj.acl.ownerGroup) {
      oldObj.acl.ownerGroup = options2.ownerGroup;
    }
    if (obj.common && "alias" in obj.common && obj.common.alias.id) {
      if (typeof obj.common.alias.id === "object") {
        if (typeof obj.common.alias.id.write !== "string" || typeof obj.common.alias.id.read !== "string") {
          return import_db_base.tools.maybeCallbackWithError(callback, "Invalid alias ID");
        }
        if (obj.common.alias.id.write.startsWith("alias.") || obj.common.alias.id.read.startsWith("alias.")) {
          return import_db_base.tools.maybeCallbackWithError(callback, "Cannot make alias on alias");
        }
      } else {
        if (typeof obj.common.alias.id !== "string") {
          return import_db_base.tools.maybeCallbackWithError(callback, "Invalid alias ID");
        }
        if (obj.common.alias.id.startsWith("alias.")) {
          return import_db_base.tools.maybeCallbackWithError(callback, "Cannot make alias on alias");
        }
      }
    }
    if (_oldObj && !import_db_base.tools.checkNonEditable(_oldObj, oldObj)) {
      return import_db_base.tools.maybeCallbackWithError(callback, "Invalid password for update of vendor information");
    }
    const message = JSON.stringify(oldObj);
    try {
      const commands = [];
      if (this.useSets) {
        if (oldObj.type && !oldType) {
          commands.push(["sadd", `${this.setNamespace}object.type.${obj.type}`, this.objNamespace + id]);
        } else if (oldObj.type && oldType && oldObj.type !== oldType) {
          commands.push(["sadd", `${this.setNamespace}object.type.${obj.type}`, this.objNamespace + id], ["srem", `${this.setNamespace}object.type.${oldObj.type}`, this.objNamespace + id]);
        } else if (oldType && !oldObj.type) {
          commands.push(["srem", `${this.setNamespace}object.type.${obj.type}`, this.objNamespace + id]);
        }
      }
      if (oldObj.common && oldObj.common.custom && !oldObjHasCustom) {
        commands.push(["sadd", `${this.setNamespace}object.common.custom`, this.objNamespace + id]);
      } else if (oldObjHasCustom && (!oldObj.common || !oldObj.common.custom)) {
        commands.push(["srem", `${this.setNamespace}object.common.custom`, this.objNamespace + id]);
      }
      if (!commands.length) {
        await this.client.set(this.objNamespace + id, message);
      } else {
        commands.push(["set", this.objNamespace + id, message]);
        await this.client.multi(commands).exec();
      }
      if (this.existingMetaObjects[id] === false && oldObj && oldObj.type === "meta") {
        this.existingMetaObjects[id] = true;
      }
      await this.client.publish(this.objNamespace + id, message);
      return import_db_base.tools.maybeCallbackWithError(callback, null, { id, value: oldObj }, id);
    } catch (e) {
      return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
    }
  }
  extendObject(id, obj, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = null;
    }
    if (!callback) {
      return new Promise((resolve, reject) => this.extendObject(id, obj, options2, (err, res) => err ? reject(err) : resolve(res)));
    }
    if (options2 && options2.acl) {
      options2.acl = null;
    }
    utils.checkObjectRights(this, null, null, options2, CONSTS.ACCESS_WRITE, (err, options3) => {
      if (err) {
        return import_db_base.tools.maybeCallbackWithRedisError(callback, err);
      }
      return this._extendObject(id, obj, options3, callback);
    });
  }
  extendObjectAsync(id, obj, options2) {
    return new Promise((resolve, reject) => this.extendObject(id, obj, options2 || null, (err, res) => err ? reject(err) : resolve(res)));
  }
  /**
   * Returns the object id if found
   *
   * @param idOrName
   * @param type
   * @param options
   * @param callback
   */
  _findObject(idOrName, type, options2, callback) {
    this._getObject(idOrName, options2, (err, obj) => {
      if (obj && utils.checkObject(obj, options2, CONSTS.ACCESS_READ) && (!type || obj.common && obj.common.type === type)) {
        return import_db_base.tools.maybeCallbackWithError(callback, null, idOrName, obj.common.name);
      }
      this._getKeys("*", options2, async (err2, keys2) => {
        if (!this.client) {
          return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);
        }
        if (!keys2 || err2) {
          return import_db_base.tools.maybeCallbackWithError(callback, err2);
        }
        let objs2;
        try {
          objs2 = await this.client.mget(keys2);
        } catch (e) {
          return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
        }
        objs2 = objs2 || [];
        for (let i = 0; i < keys2.length; i++) {
          const strObj = objs2[i];
          let obj2;
          try {
            obj2 = strObj ? JSON.parse(strObj) : null;
          } catch {
            this.log.error(`${this.namespace} Cannot parse JSON ${keys2[i]}: ${objs2[i]}`);
            continue;
          }
          if (obj2?.common && obj2.common.name === idOrName && (!type || "type" in obj2.common && obj2.common.type === type)) {
            return import_db_base.tools.maybeCallbackWithError(callback, null, obj2._id, idOrName);
          }
        }
        return import_db_base.tools.maybeCallbackWithError(callback, null, void 0, idOrName);
      }, true);
    });
  }
  findObject(idOrName, type, options2, callback) {
    if (typeof type === "function") {
      callback = type;
      options2 = null;
      type = null;
    }
    if (typeof options2 === "function") {
      callback = options2;
      options2 = null;
    }
    if (!callback) {
      return new Promise((resolve, reject) => this.findObject(idOrName, type, options2, (err, id, _idOrName) => err ? reject(err) : resolve(id)));
    }
    if (options2?.acl) {
      options2.acl = null;
    }
    if (typeof callback === "function") {
      utils.checkObjectRights(this, null, null, options2, CONSTS.ACCESS_LIST, (err, options3) => {
        if (err) {
          return import_db_base.tools.maybeCallbackWithError(callback, err);
        }
        return this._findObject(idOrName, type, options3, callback);
      });
    }
  }
  // can be called only from js-controller
  addPreserveSettings(settings) {
    if (!Array.isArray(settings)) {
      settings = [settings];
    }
    for (const setting of settings) {
      if (this.preserveSettings.indexOf(setting) === -1) {
        this.preserveSettings.push(setting);
      }
    }
  }
  async _destroyDBHelper(keys2, callback) {
    if (!keys2 || !keys2.length) {
      return import_db_base.tools.maybeCallback(callback);
    }
    if (!this.client) {
      return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);
    }
    for (const id of keys2) {
      try {
        await this.client.del(id);
      } catch {
      }
    }
    return import_db_base.tools.maybeCallback(callback);
  }
  async _destroyDB(callback) {
    if (!this.client) {
      return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);
    }
    try {
      const keys2 = await this._getKeysViaScan(`${this.redisNamespace}*`);
      return this._destroyDBHelper(keys2, callback);
    } catch (e) {
      return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
    }
  }
  destroyDB(options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = null;
    }
    options2 = options2 || {};
    utils.checkObjectRights(this, null, null, options2, CONSTS.ACCESS_WRITE, (err, options3) => {
      if (err) {
        return import_db_base.tools.maybeCallbackWithRedisError(callback, err);
      }
      if (!options3.acl.file.write || options3.user !== CONSTS.SYSTEM_ADMIN_USER) {
        return import_db_base.tools.maybeCallbackWithError(callback, ERRORS.ERROR_PERMISSION);
      }
      return this._destroyDB(callback);
    });
  }
  destroyDBAsync(options2) {
    return new Promise((resolve, reject) => this.destroyDB(options2, (err) => err ? reject(err) : resolve()));
  }
  // Destructor of the class. Called by shutting down.
  async destroy() {
    this.stop = true;
    if (this.client) {
      try {
        await this.client.quit();
        this.client.removeAllListeners();
        this.client = null;
      } catch {
      }
    }
    if (this.sub) {
      try {
        await this.sub.quit();
        this.sub.removeAllListeners();
        this.sub = null;
      } catch {
      }
    }
    if (this.subSystem) {
      try {
        await this.subSystem.quit();
        this.subSystem.removeAllListeners();
        this.subSystem = null;
      } catch {
      }
    }
  }
  async loadLuaScripts() {
    let luaDirName;
    if (this.noLegacyMultihost && this.useSets) {
      luaDirName = "lua-v4";
    } else if (this.noLegacyMultihost) {
      luaDirName = "lua-v4-no-sets";
    } else {
      luaDirName = "lua-v3";
    }
    const luaPath = import_node_path.default.join(thisDir, luaDirName);
    const scripts = import_node_fs.default.readdirSync(luaPath).map((name) => {
      const shasum = import_node_crypto.default.createHash("sha1");
      const script = import_node_fs.default.readFileSync(import_node_path.default.join(luaPath, name));
      shasum.update(script);
      const hash = shasum.digest("hex");
      return { name: name.replace(/\.lua$/, ""), text: script, hash };
    });
    const hashes = scripts.map((e) => e.hash);
    hashes.unshift("EXISTS");
    if (!this.client) {
      throw new Error(import_db_base.tools.ERRORS.ERROR_DB_CLOSED);
    }
    let arr;
    try {
      arr = await this.client.script(hashes);
      if (arr) {
        scripts.forEach((e, i) => scripts[i].loaded = !!arr[i]);
      }
    } catch {
    }
    if (!this.client) {
      throw new Error(import_db_base.tools.ERRORS.ERROR_DB_CLOSED);
    }
    for (const script of scripts) {
      if (!script.loaded) {
        let hash;
        try {
          hash = await this.client.script(["LOAD", script.text]);
          script.loaded = true;
        } catch (e) {
          script.loaded = false;
          this.log.error(`${this.namespace} Cannot load "${script.name}": ${e.message}`);
          if (!script.name.startsWith("redlock_")) {
            throw new Error(`Cannot load "${script.name}" into objects database: ${e.message}`);
          }
        }
        script.hash = hash;
      }
    }
    this.scripts = {};
    scripts.forEach((e) => this.scripts[e.name] = e.hash);
  }
  /**
   * Get all keys matching a pattern using redis SCAN command, duplicates are filtered out
   *
   * @param pattern - pattern to match, e. g. io.hm-rpc.0*
   * @param count - count argument used by redis SCAN, default is 250
   */
  _getKeysViaScan(pattern, count = 250) {
    return new Promise((resolve, reject) => {
      if (!this.client) {
        reject(new Error(ERRORS.ERROR_DB_CLOSED));
        return;
      }
      const stream = this.client.scanStream({ match: pattern, count });
      let uniqueKeys = [];
      stream.on("data", (resultKeys) => {
        if (!Array.isArray(resultKeys)) {
          return;
        }
        uniqueKeys = [...uniqueKeys, ...resultKeys];
      });
      stream.on("end", () => {
        resolve(Array.from(new Set(uniqueKeys)));
      });
    });
  }
  /**
   * Checks if a given set exists
   *
   * @param id - id of the set
   */
  async setExists(id) {
    if (!this.client) {
      throw new Error(ERRORS.ERROR_DB_CLOSED);
    }
    const exists = await this.client.exists(this.setNamespace + id);
    return !!exists;
  }
  /**
   * Migrate all objects to sets
   *
   * @returns number of migrated sets
   */
  async migrateToSets() {
    if (!this.useSets) {
      return 0;
    }
    if (!this.client) {
      throw new Error(ERRORS.ERROR_DB_CLOSED);
    }
    const keys2 = await this._getKeysViaScan(`${this.setNamespace}object.type.*`);
    for (const key of keys2) {
      await this.client.del(key);
    }
    let noMigrated = 0;
    const objs2 = await this.getObjectList({ startkey: "", endkey: "\u9999" });
    if (!objs2) {
      return noMigrated;
    }
    for (const obj of objs2.rows) {
      if (obj.value.type) {
        const migrated = await this.client.sadd(`${this.setNamespace}object.type.${obj.value.type}`, this.objNamespace + obj.id);
        noMigrated += migrated;
      }
      if (obj.value.common?.custom) {
        const migrated = await this.client.sadd(`${this.setNamespace}object.common.custom`, this.objNamespace + obj.id);
        noMigrated += migrated;
      }
    }
    return noMigrated;
  }
  /**
   * Returns the protocol version from DB
   */
  getProtocolVersion() {
    if (!this.client) {
      throw new Error(ERRORS.ERROR_DB_CLOSED);
    }
    return this.client.get(`${this.metaNamespace}objects.protocolVersion`);
  }
  /**
   * Extend the primary host lock time
   * Value will expire after ms milliseconds
   *
   * @param ms - ms until value expires
   * @returns 1 if extended else 0
   */
  extendPrimaryHostLock(ms) {
    if (!this.client) {
      throw new Error(ERRORS.ERROR_DB_CLOSED);
    }
    if (!this.noLegacyMultihost) {
      return Promise.resolve(0);
    }
    return this.client.evalsha([
      this.scripts.redlock_extend,
      3,
      `${this.metaNamespace}objects.primaryHost`,
      this.hostname,
      ms
    ]);
  }
  /**
   * Sets current host as primary if no primary host active
   * Value will expire after ms milliseconds
   *
   * @param ms - ms until value expires
   * @returns 1 if lock acquired else 0
   */
  setPrimaryHost(ms) {
    if (!this.client) {
      throw new Error(ERRORS.ERROR_DB_CLOSED);
    }
    if (!this.noLegacyMultihost) {
      return Promise.resolve(0);
    }
    return this.client.evalsha([
      this.scripts.redlock_acquire,
      3,
      `${this.metaNamespace}objects.primaryHost`,
      this.hostname,
      ms
    ]);
  }
  /**
   * Get name of the primary host
   */
  getPrimaryHost() {
    if (!this.client) {
      throw new Error(ERRORS.ERROR_DB_CLOSED);
    }
    if (!this.noLegacyMultihost) {
      return Promise.resolve("");
    }
    return this.client.get(`${this.metaNamespace}objects.primaryHost`);
  }
  /**
   * Ensure we are no longer the primary host
   */
  releasePrimaryHost() {
    if (!this.client) {
      throw new Error(ERRORS.ERROR_DB_CLOSED);
    }
    if (!this.noLegacyMultihost) {
      return Promise.resolve();
    }
    return this.client.evalsha([
      this.scripts.redlock_release,
      4,
      `${this.metaNamespace}objects.primaryHost`,
      this.hostname,
      this.settings.connection.options.db,
      `${this.metaNamespace}objects.primaryHost`
    ]);
  }
  /**
   * Sets the protocol version to the DB
   *
   * @param version - protocol version
   */
  async setProtocolVersion(version) {
    if (!this.client) {
      throw new Error(ERRORS.ERROR_DB_CLOSED);
    }
    version = version.toString();
    if (this.supportedProtocolVersions.includes(version)) {
      await this.client.set(`${this.metaNamespace}objects.protocolVersion`, version);
      await this.client.publish(`${this.metaNamespace}objects.protocolVersion`, version);
    } else {
      throw new Error("Cannot set an unsupported protocol version on the current host");
    }
  }
  /**
   * Subscribe to expired events to get expiration of primary host
   */
  async subscribePrimaryHost() {
    if (this.subSystem) {
      await this.subSystem.subscribe(`__keyevent@${this.settings.connection.options.db}__:expired`);
      await this.subSystem.subscribe(`__keyevent@${this.settings.connection.options.db}__:evicted`);
    }
  }
  /**
   * Activates the usage of sets
   */
  async activateSets() {
    if (!this.client) {
      throw new Error(ERRORS.ERROR_DB_CLOSED);
    }
    await this.client.set(`${this.metaNamespace}objects.features.useSets`, "1");
    this.useSets = true;
  }
  /**
   * Deactivates the usage of sets
   */
  async deactivateSets() {
    if (!this.client) {
      throw new Error(ERRORS.ERROR_DB_CLOSED);
    }
    await this.client.set(`${this.metaNamespace}objects.features.useSets`, "0");
    this.useSets = false;
  }
  /**
   * Get value from meta namespace
   *
   * @param id redis key
   */
  getMeta(id) {
    if (!this.client) {
      throw new Error(ERRORS.ERROR_DB_CLOSED);
    }
    return this.client.get(this.metaNamespace + id);
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ObjectsInRedisClient
});
//# sourceMappingURL=objectsInRedisClient.js.map
