{
  "version": 3,
  "sources": ["../../../../src/lib/objects/objectsInRedisClient.ts", "../../../../../../node_modules/@alcalzone/esm2cjs/shims/import.meta.url/shim.js"],
  "sourcesContent": ["/**\n * Object DB in REDIS - Client\n *\n * MIT License\n * Written by bluefox <dogafox@gmail.com>, 2014-2024\n *\n */\n// @ts-expect-error no ts module\nimport extend from 'node.extend';\nimport type IORedis from 'ioredis';\nimport Redis from 'ioredis';\nimport { tools } from '@iobroker/db-base';\nimport fs from 'node:fs';\nimport path from 'node:path';\nimport crypto from 'node:crypto';\nimport { isDeepStrictEqual } from 'node:util';\nimport deepClone from 'deep-clone';\nimport type {\n    ACLObject,\n    FileObject,\n    CheckFileRightsCallback,\n    GetUserGroupPromiseReturn,\n} from '@/lib/objects/objectsUtils.js';\nimport * as utils from '@/lib/objects/objectsUtils.js';\nimport semver from 'semver';\nimport * as CONSTS from '@/lib/objects/constants.js';\nimport type { InternalLogger } from '@iobroker/js-controller-common-db/tools';\nimport type { ConnectionOptions, DbStatus } from '@iobroker/db-base/inMemFileDB';\n\nimport * as url from 'node:url';\n// eslint-disable-next-line unicorn/prefer-module\nconst thisDir = url.fileURLToPath(new URL('.', import.meta.url || `file://${__filename}`));\n\nconst ERRORS = CONSTS.ERRORS;\n\ntype ChangeFunction = (id: string, object: ioBroker.Object | null) => void;\n\ntype GetUserGroupCallbackNoError = (user: string, groups: string[], acl: ioBroker.ObjectPermissions) => void;\n\ninterface ViewFuncResult<T extends ioBroker.AnyObject> {\n    rows: ioBroker.GetObjectViewItem<T>[];\n}\n\ninterface ObjectListResult {\n    rows: ioBroker.GetObjectListItem<ioBroker.Object>[];\n}\n\ninterface RedisConnectionOptions extends ConnectionOptions {\n    redisNamespace?: string;\n}\n\nexport interface ObjectsSettings {\n    connected: () => void;\n    controller?: boolean;\n    primaryHostLost?: () => void;\n    disconnected?: () => void;\n    change?: ChangeFunction;\n    changeUser?: ChangeFunction;\n    changeFileUser?: ioBroker.FileChangeHandler;\n    autoConnect?: boolean;\n    logger: InternalLogger;\n    hostname?: string;\n    namespace?: string;\n    defaultNewAcl?: ACLObject;\n    metaNamespace?: string;\n    redisNamespace?: string;\n    connection: RedisConnectionOptions;\n}\n\ninterface CallOptions {\n    groups?: string[];\n    group?: string;\n    user?: ioBroker.ObjectIDs.User;\n    owner?: ioBroker.ObjectIDs.User;\n    ownerGroup?: string;\n    acl?: any;\n    [other: string]: any;\n}\n\ninterface ObjectIdValue {\n    id: string;\n    value: ioBroker.AnyObject;\n}\n\ninterface ObjectViewFunction {\n    map: string;\n    reduce?: '_stats';\n}\n\ninterface WriteFileOptions extends CallOptions {\n    mimeType?: string;\n}\n\ninterface MetaObject {\n    modifiedAt?: number;\n    createdAt?: number;\n    binary?: boolean;\n    mimeType?: string;\n    notExists?: boolean;\n    path?: string;\n    file?: string;\n    stats?: any;\n    isDir?: boolean;\n    acl?: any;\n}\n\ninterface ChmodMetaObject extends MetaObject {\n    modifiedAt: number;\n    createdAt: number;\n}\n\ninterface Script {\n    name: string;\n    hash: string;\n    text: Buffer;\n    loaded?: boolean;\n}\n\ninterface Options {\n    /** The user id for database operations */\n    user?: string;\n    [other: string]: unknown;\n}\n\ntype CheckFileCallback = (checkFailed: boolean, options?: CallOptions, fileOptions?: { notExists: boolean }) => void;\n\nexport class ObjectsInRedisClient {\n    private client: IORedis.Redis | null;\n    private readonly fileNamespace: string;\n    private readonly redisNamespace: string;\n    private readonly fileNamespaceL: number;\n    private readonly objNamespace: string;\n    private readonly setNamespace: string;\n    private readonly metaNamespace: string;\n    private readonly objNamespaceL: number;\n    private readonly supportedProtocolVersions: string[];\n    private stop: boolean;\n    private sub: IORedis.Redis | null;\n    private subSystem: IORedis.Redis | null;\n    private settings: ObjectsSettings;\n    private readonly preserveSettings: ('custom' | 'smartName' | 'material' | 'habpanel' | 'mobile')[];\n    private defaultNewAcl: ACLObject | null;\n    private readonly namespace: string;\n    private readonly hostname: string;\n    private scripts: Record<string, string>;\n    private readonly existingMetaObjects: Record<string, boolean>;\n    private log: InternalLogger;\n    private activeProtocolVersion?: string;\n    private useSets?: boolean;\n    private noLegacyMultihost?: boolean;\n    private readonly userSubscriptions: Record<string, boolean>;\n    private readonly systemSubscriptions: Record<string, boolean>;\n\n    constructor(settings: ObjectsSettings) {\n        this.settings = settings || {};\n        this.redisNamespace = `${\n            this.settings.redisNamespace ||\n            (this.settings.connection && this.settings.connection.redisNamespace) ||\n            'cfg'\n        }.`;\n        this.fileNamespace = `${this.redisNamespace}f.`;\n        this.fileNamespaceL = this.fileNamespace.length;\n        this.objNamespace = `${this.redisNamespace}o.`;\n        this.setNamespace = `${this.redisNamespace}s.`;\n        this.metaNamespace = `${this.settings.metaNamespace || 'meta'}.`;\n        this.objNamespaceL = this.objNamespace.length;\n        this.supportedProtocolVersions = ['4'];\n\n        this.stop = false;\n        this.client = null;\n        this.sub = null;\n        this.subSystem = null;\n        this.preserveSettings = ['custom', 'smartName', 'material', 'habpanel', 'mobile'];\n        this.defaultNewAcl = this.settings.defaultNewAcl || null;\n        this.namespace = this.settings.namespace || this.settings.hostname || '';\n        this.hostname = this.settings.hostname || tools.getHostName();\n        this.scripts = {};\n        this.userSubscriptions = {};\n        this.systemSubscriptions = {};\n\n        // cached meta-objects for file operations\n        this.existingMetaObjects = {};\n\n        this.log = tools.getLogger(this.settings.logger);\n\n        if (this.settings.autoConnect !== false) {\n            this.connectDb();\n        }\n    }\n\n    /**\n     * Checks if we are allowed to start and sets the protocol version accordingly\n     */\n    private async _determineProtocolVersion(): Promise<void> {\n        if (!this.client) {\n            throw new Error(ERRORS.ERROR_DB_CLOSED);\n        }\n\n        let protoVersion;\n        try {\n            protoVersion = await this.client.get(`${this.metaNamespace}objects.protocolVersion`);\n        } catch (e) {\n            if (e.message.includes('GET-UNSUPPORTED')) {\n                // secondary updated and primary < 4.0\n                return;\n            }\n        }\n\n        if (!protoVersion) {\n            // if no proto version existent yet, we set ours\n            const highestVersion = Math.max(...this.supportedProtocolVersions.map(value => parseInt(value)));\n            await this.setProtocolVersion(highestVersion);\n            this.activeProtocolVersion = highestVersion.toString();\n            return;\n        }\n\n        // check if we can support this version\n        if (this.supportedProtocolVersions.includes(protoVersion)) {\n            this.activeProtocolVersion = protoVersion;\n        } else {\n            throw new Error(`This host does not support protocol version \"${protoVersion}\"`);\n        }\n    }\n\n    connectDb(): void {\n        this.settings.connection = this.settings.connection || {};\n\n        const onChange = this.settings.change; // on change handler\n        const onChangeUser = this.settings.changeUser; // on change handler for User events\n        const onChangeFileUser = this.settings.changeFileUser; // on change handler for User file events\n\n        // limit max number of log entries in the list\n        this.settings.connection.maxQueue = this.settings.connection.maxQueue || 1_000;\n\n        this.settings.connection.options = this.settings.connection.options || {};\n        const retry_max_delay: number = this.settings.connection.options.retry_max_delay || 5_000;\n        const retry_max_count: number = this.settings.connection.options.retry_max_count || 19;\n\n        let ready = false;\n        let initError = false;\n        let connected = false;\n        let reconnectCounter = 0;\n        let errorLogged = false;\n\n        this.settings.connection.options.retryStrategy = (reconnectCount: number): Error | number => {\n            if (!ready && initError) {\n                return new Error('No more tries');\n            }\n            if (this.stop) {\n                return new Error('Client has stopped ... no retries anymore');\n            }\n            if (ready && reconnectCount >= retry_max_count) {\n                return new Error('Stop trying to reconnect');\n            }\n            // A function that receives an options object as parameter including the retry attempt,\n            // the total_retry_time indicating how much time passed since the last time connected,\n            // the error why the connection was lost and the number of times_connected in total.\n            // If you return a number from this function, the retry will happen exactly after that\n            // time in milliseconds. If you return a non-number, no further retry will happen and\n            // all offline commands are flushed with errors. Return an error to return that\n            // specific error to all offline commands.\n\n            if (!ready) {\n                return 300;\n            }\n            return retry_max_delay;\n        };\n\n        delete this.settings.connection.options.retry_max_delay;\n        this.settings.connection.options.enableReadyCheck = true;\n\n        if (this.settings.connection.port === 0) {\n            // Port = 0 means unix socket\n            // initiate a unix socket connection\n            this.settings.connection.options.path = this.settings.connection.host;\n            this.log.debug(\n                `${this.namespace} Redis Objects: Use File Socket for connection: ${this.settings.connection.options.path}`,\n            );\n        } else if (Array.isArray(this.settings.connection.host)) {\n            const configuredPort = this.settings.connection.port;\n            // Host is an array means we use a sentinel\n            const defaultPort = Array.isArray(configuredPort) ? null : configuredPort;\n\n            this.settings.connection.options.sentinels = this.settings.connection.host.map((redisNode, idx) => ({\n                host: redisNode,\n                // @ts-expect-error ts does not get that if defPort is null we have an array\n                port: defaultPort === null ? configuredPort[idx] : defaultPort,\n            }));\n\n            this.settings.connection.options.name = this.settings.connection.sentinelName\n                ? this.settings.connection.sentinelName\n                : 'mymaster';\n            this.log.debug(\n                `${this.namespace} Redis Objects: Use Sentinel for connection: ${\n                    this.settings.connection.options.name\n                }, ${JSON.stringify(this.settings.connection.options.sentinels)}`,\n            );\n        } else {\n            this.settings.connection.options.host = this.settings.connection.host;\n            this.settings.connection.options.port = this.settings.connection.port;\n            this.log.debug(\n                `${this.namespace} Redis Objects: Use Redis connection: ${this.settings.connection.options.host}:${this.settings.connection.options.port}`,\n            );\n        }\n        this.settings.connection.options.db = this.settings.connection.options.db || 0;\n        this.settings.connection.options.family = this.settings.connection.options.family || 0;\n        this.settings.connection.options.password =\n            this.settings.connection.options.auth_pass || this.settings.connection.pass || null;\n\n        this.settings.connection.options.autoResubscribe = false; // We do our own resubscribe because other sometimes not work\n        // REDIS does not allow whitespaces, we have some because of pid\n        this.settings.connection.options.connectionName = this.namespace.replace(/\\s/g, '');\n\n        this.client = new Redis(this.settings.connection.options);\n\n        this.client.on('error', error => {\n            this.settings.connection.enhancedLogging &&\n                this.log.silly(\n                    `${this.namespace} Redis ERROR Objects: (${this.stop}) ${error.message} / ${error.stack}`,\n                );\n            if (this.stop) {\n                return;\n            }\n            if (!ready) {\n                initError = true;\n                // Seems we have a socket.io server\n                if (error.message.startsWith('Protocol error, got \"H\" as reply type byte.')) {\n                    this.log.error(\n                        `${this.namespace} Could not connect to objects database at ${this.settings.connection.options.host}:${this.settings.connection.options.port} (invalid protocol). Please make sure the configured IP and port points to a host running JS-Controller >= 2.0. and that the port is not occupied by other software!`,\n                    );\n                }\n                return;\n            }\n            this.log.error(`${this.namespace} Objects database error: ${error.message}`);\n            errorLogged = true;\n        });\n\n        this.client.on('end', () => {\n            this.settings.connection.enhancedLogging &&\n                this.log.silly(`${this.namespace} Objects-Redis Event end (stop=${this.stop})`);\n            ready && typeof this.settings.disconnected === 'function' && this.settings.disconnected();\n        });\n\n        this.client.on('connect', () => {\n            this.settings.connection.enhancedLogging &&\n                this.log.silly(`${this.namespace} Objects-Redis Event connect (stop=${this.stop})`);\n            connected = true;\n            if (errorLogged) {\n                this.log.info(`${this.namespace} Objects database successfully reconnected`);\n                errorLogged = false;\n            }\n        });\n\n        this.client.on('close', () => {\n            this.settings.connection.enhancedLogging &&\n                this.log.silly(`${this.namespace} Objects-Redis Event close (stop=${this.stop})`);\n            //if (ready && typeof this.settings.disconnected === 'function') this.settings.disconnected();\n        });\n\n        this.client.on('reconnecting', () => {\n            if (connected && !ready && !initError) {\n                reconnectCounter++;\n            }\n\n            this.settings.connection.enhancedLogging &&\n                this.log.silly(\n                    `${this.namespace} Objects-Redis Event reconnect (reconnectCounter=${reconnectCounter}, stop=${this.stop})`,\n                );\n\n            if (reconnectCounter > 2) {\n                // fallback logic for nodejs <10\n                this.log.error(\n                    `${this.namespace} The DB port  ${this.settings.connection.options.port} is occupied by something that is not a Redis protocol server. Please check other software running on this port or, if you use iobroker, make sure to update to js-controller 2.0 or higher!`,\n                );\n                return;\n            }\n            connected = false;\n            initError = false;\n        });\n\n        this.client.on('ready', async () => {\n            if (this.stop || !this.client) {\n                return;\n            }\n            initError = false;\n\n            this.log.debug(`${this.namespace} Objects client ready ... initialize now`);\n            try {\n                await this.client.config('SET', 'lua-time-limit', 10000); // increase LUA timeout TODO still necessary with scan?\n            } catch (e) {\n                this.log.warn(`${this.namespace} Unable to increase LUA script timeout: ${e.message}`);\n            }\n\n            let initCounter = 0;\n            if (!this.subSystem && typeof onChange === 'function') {\n                initCounter++;\n                this.log.debug(`${this.namespace} Objects create System PubSub Client`);\n                this.subSystem = new Redis(this.settings.connection.options);\n\n                if (typeof this.settings.primaryHostLost === 'function') {\n                    try {\n                        // enable Expiry/Evicted events in server - same as states (could be same db)\n                        await this.client.config('SET', 'notify-keyspace-events', 'Exe');\n                    } catch (e) {\n                        this.log.warn(\n                            `${this.namespace} Unable to enable Expiry Keyspace events from Redis Server: ${e.message}`,\n                        );\n                    }\n\n                    this.subSystem.on('message', (channel, message) => {\n                        if (\n                            channel === `__keyevent@${this.settings.connection.options.db}__:expired` ||\n                            channel === `__keyevent@${this.settings.connection.options.db}__:evicted`\n                        ) {\n                            this.log.silly(`${this.namespace} redis message expired/evicted ${channel}:${message}`);\n\n                            if (\n                                message === `${this.metaNamespace}objects.primaryHost` &&\n                                typeof this.settings.primaryHostLost === 'function'\n                            ) {\n                                this.settings.primaryHostLost();\n                            }\n                        }\n                    });\n                }\n\n                if (typeof onChange === 'function') {\n                    this.subSystem.on('pmessage', (pattern, channel, message) =>\n                        setImmediate(() => {\n                            this.log.silly(\n                                `${this.namespace} Objects system redis pmessage ${pattern}/${channel}:${message}`,\n                            );\n\n                            if (channel.startsWith(this.metaNamespace)) {\n                                if (\n                                    channel === `${this.metaNamespace}objects.protocolVersion` &&\n                                    message !== this.activeProtocolVersion\n                                ) {\n                                    if (typeof this.settings.disconnected === 'function') {\n                                        // protocol version has changed, restart controller\n                                        this.log.info(\n                                            `${this.namespace} Objects protocol version has changed, disconnecting!`,\n                                        );\n                                        this.settings.disconnected();\n                                    }\n                                } else if (channel === `${this.metaNamespace}objects.features.useSets`) {\n                                    const newUseSets = !!parseInt(message);\n                                    if (newUseSets !== this.useSets) {\n                                        this.log.info(\n                                            `${this.namespace} Sets ${\n                                                newUseSets ? 'activated' : 'deactivated'\n                                            }: restarting ...`,\n                                        );\n                                        this.useSets = newUseSets;\n                                        // luas are no longer up to date, lets restart\n                                        if (typeof this.settings.disconnected === 'function') {\n                                            this.settings.disconnected();\n                                        }\n                                    }\n                                }\n                                return;\n                            }\n\n                            try {\n                                if (channel.startsWith(this.objNamespace) && channel.length > this.objNamespaceL) {\n                                    const id = channel.substring(this.objNamespaceL);\n                                    try {\n                                        const obj = message ? JSON.parse(message) : null;\n\n                                        if (\n                                            id === 'system.config' &&\n                                            obj &&\n                                            obj.common &&\n                                            obj.common.defaultNewAcl &&\n                                            !isDeepStrictEqual(obj.common.defaultNewAcl, this.defaultNewAcl)\n                                        ) {\n                                            this.defaultNewAcl = deepClone(obj.common.defaultNewAcl);\n                                            this.settings.controller && this.setDefaultAcl(this.defaultNewAcl);\n                                        }\n\n                                        onChange(id, obj);\n                                    } catch (e) {\n                                        this.log.warn(\n                                            `${this.namespace} Objects Cannot process system pmessage ${id} - ${message}: ${e.message}`,\n                                        );\n                                        this.log.warn(`${this.namespace} ${e.stack}`);\n                                    }\n                                } else {\n                                    this.log.warn(\n                                        `${this.namespace} Objects Received unexpected system pmessage: ${channel}`,\n                                    );\n                                }\n                            } catch (e) {\n                                this.log.warn(\n                                    `${this.namespace} Objects system pmessage ${channel} ${JSON.stringify(message)} ${\n                                        e.message\n                                    }`,\n                                );\n                                this.log.warn(`${this.namespace} ${e.stack}`);\n                            }\n                        }),\n                    );\n                }\n\n                this.subSystem.on('end', () => {\n                    this.settings.connection.enhancedLogging &&\n                        this.log.silly(`${this.namespace} Objects-Redis System Event end sub (stop=${this.stop})`);\n                    ready && typeof this.settings.disconnected === 'function' && this.settings.disconnected();\n                });\n\n                this.subSystem.on('error', error => {\n                    if (this.stop) {\n                        return;\n                    }\n                    this.settings.connection.enhancedLogging &&\n                        this.log.silly(\n                            `${this.namespace} PubSub System client Objects No redis connection: ${JSON.stringify(\n                                error,\n                            )}`,\n                        );\n                });\n\n                if (this.settings.connection.enhancedLogging) {\n                    this.subSystem.on('connect', () =>\n                        this.log.silly(\n                            `${this.namespace} PubSub System client Objects-Redis Event connect (stop=${this.stop})`,\n                        ),\n                    );\n\n                    this.subSystem.on('close', () =>\n                        this.log.silly(\n                            `${this.namespace} PubSub System client Objects-Redis Event close (stop=${this.stop})`,\n                        ),\n                    );\n\n                    this.subSystem.on('reconnecting', reconnectCounter =>\n                        this.log.silly(\n                            `${this.namespace} PubSub System client Objects-Redis Event reconnect (reconnectCounter=${reconnectCounter}, stop=${this.stop})`,\n                        ),\n                    );\n                }\n\n                this.subSystem.on('ready', async () => {\n                    if (--initCounter < 1) {\n                        if (this.settings.connection.port === 0) {\n                            this.log.debug(\n                                `${this.namespace} Objects ${\n                                    ready ? 'system re' : ''\n                                }connected to redis: ${tools.maybeArrayToString(this.settings.connection.host)}`,\n                            );\n                        } else {\n                            this.log.debug(\n                                `${this.namespace} Objects ${\n                                    ready ? 'system re' : ''\n                                }connected to redis: ${tools.maybeArrayToString(\n                                    this.settings.connection.host,\n                                )}:${tools.maybeArrayToString(this.settings.connection.port)}`,\n                            );\n                        }\n                        !ready && typeof this.settings.connected === 'function' && this.settings.connected();\n                        ready = true;\n                    }\n                    // subscribe on system.config anytime because also adapters need stuff like defaultNewAcl (especially admin)\n                    try {\n                        this.subSystem && (await this.subSystem.psubscribe(`${this.objNamespace}system.config`));\n                    } catch {\n                        // ignore\n                    }\n\n                    // subscribe to meta changes\n                    try {\n                        this.subSystem && (await this.subSystem.psubscribe(`${this.metaNamespace}*`));\n                    } catch (e) {\n                        this.log.warn(\n                            `${this.namespace} Unable to subscribe to meta namespace \"${this.metaNamespace}\" changes: ${e.message}`,\n                        );\n                    }\n\n                    if (this.subSystem) {\n                        for (const sub of Object.keys(this.systemSubscriptions)) {\n                            try {\n                                await this.subSystem.psubscribe(sub);\n                            } catch {\n                                // ignore\n                            }\n                        }\n                    }\n                });\n            }\n\n            if (!this.sub && (typeof onChangeUser === 'function' || typeof onChangeFileUser === 'function')) {\n                initCounter++;\n                this.log.debug(`${this.namespace} Objects create User PubSub Client`);\n                this.sub = new Redis(this.settings.connection.options);\n\n                this.sub.on('pmessage', (pattern, channel, message) => {\n                    setImmediate(() => {\n                        this.log.silly(\n                            `${this.namespace} Objects user redis pmessage ${pattern}/${channel}:${message}`,\n                        );\n                        try {\n                            if (channel.startsWith(this.objNamespace) && channel.length > this.objNamespaceL) {\n                                if (onChangeUser) {\n                                    const id = channel.substring(this.objNamespaceL);\n                                    try {\n                                        const obj = message ? JSON.parse(message) : null;\n\n                                        onChangeUser(id, obj);\n                                    } catch (e) {\n                                        this.log.warn(\n                                            `${this.namespace} Objects user cannot process pmessage ${id} - ${message}: ${e.message}`,\n                                        );\n                                        this.log.warn(`${this.namespace} ${e.stack}`);\n                                    }\n                                }\n                            } else if (channel.startsWith(this.fileNamespace) && channel.length > this.fileNamespaceL) {\n                                if (onChangeFileUser) {\n                                    // cfg.f.vis-2.0$%$main/historyChart.js$%$data\n                                    const [id, fileName] = channel.substring(this.fileNamespaceL).split('$%$');\n\n                                    try {\n                                        const obj = message ? JSON.parse(message) : null;\n\n                                        onChangeFileUser(id, fileName, obj);\n                                    } catch (e) {\n                                        this.log.warn(\n                                            `${this.namespace} Objects user cannot process pmessage ${id}/${fileName} - ${message}: ${e.message}`,\n                                        );\n                                        this.log.warn(`${this.namespace} ${e.stack}`);\n                                    }\n                                }\n                            } else {\n                                this.log.warn(\n                                    `${this.namespace} Objects user received unexpected pmessage: ${channel}`,\n                                );\n                            }\n                        } catch (e) {\n                            this.log.warn(\n                                `${this.namespace} Objects user pmessage ${channel} ${JSON.stringify(message)} ${\n                                    e.message\n                                }`,\n                            );\n                            this.log.warn(`${this.namespace} ${e.stack}`);\n                        }\n                    });\n                });\n\n                this.sub.on('end', () => {\n                    this.settings.connection.enhancedLogging &&\n                        this.log.silly(`${this.namespace} Objects-Redis Event end user sub (stop=${this.stop})`);\n                    ready && typeof this.settings.disconnected === 'function' && this.settings.disconnected();\n                });\n\n                this.sub.on('error', error => {\n                    if (this.stop) {\n                        return;\n                    }\n                    this.settings.connection.enhancedLogging &&\n                        this.log.silly(\n                            `${this.namespace} PubSub user client Objects No redis connection: ${JSON.stringify(error)}`,\n                        );\n                });\n\n                if (this.settings.connection.enhancedLogging) {\n                    this.sub.on('connect', () =>\n                        this.log.silly(\n                            `${this.namespace} PubSub user client Objects-Redis Event connect (stop=${this.stop})`,\n                        ),\n                    );\n\n                    this.sub.on('close', () =>\n                        this.log.silly(\n                            `${this.namespace} PubSub user client Objects-Redis Event close (stop=${this.stop})`,\n                        ),\n                    );\n\n                    this.sub.on('reconnecting', reconnectCounter =>\n                        this.log.silly(\n                            `${this.namespace} PubSub user client Objects-Redis Event reconnect (reconnectCounter=${reconnectCounter}, stop=${this.stop})`,\n                        ),\n                    );\n                }\n\n                this.sub.on('ready', async () => {\n                    if (!this.sub) {\n                        // client gone while ready emitted, can maybe not happen but ts is happy\n                        return;\n                    }\n\n                    if (--initCounter < 1) {\n                        if (this.settings.connection.port === 0) {\n                            this.log.debug(\n                                `${this.namespace} Objects ${\n                                    ready ? 'user re' : ''\n                                }connected to redis: ${tools.maybeArrayToString(this.settings.connection.host)}`,\n                            );\n                        } else {\n                            this.log.debug(\n                                `${this.namespace} Objects ${\n                                    ready ? 'user re' : ''\n                                }connected to redis: ${tools.maybeArrayToString(\n                                    this.settings.connection.host,\n                                )}:${tools.maybeArrayToString(this.settings.connection.port)}`,\n                            );\n                        }\n                        !ready && typeof this.settings.connected === 'function' && this.settings.connected();\n                        ready = true;\n                    }\n\n                    for (const sub of Object.keys(this.userSubscriptions)) {\n                        try {\n                            await this.sub.psubscribe(sub);\n                        } catch {\n                            // ignore\n                        }\n                    }\n                });\n            }\n\n            if (!this.client) {\n                return;\n            }\n\n            // do this before starting with async calls ;-)\n            initCounter++;\n\n            try {\n                // check if we are allowed to use sets\n                this.useSets = !!parseInt(\n                    (await this.client.get(`${this.metaNamespace}objects.features.useSets`)) || '0',\n                );\n            } catch (e) {\n                // if unsupported we have a legacy host\n                if (!e.message.includes('UNSUPPORTED')) {\n                    this.log.error(`${this.namespace} Cannot determine Set feature status: ${e.message}`);\n                    return;\n                }\n                this.useSets = false;\n            }\n\n            try {\n                await this._determineProtocolVersion();\n            } catch (e) {\n                this.log.error(`${this.namespace} ${e.message}`);\n                throw new Error('Objects DB is not allowed to start in the current Multihost environment');\n            }\n\n            // for controller v4 we have to check if we can use the new lua scripts and set logic\n            // TODO: remove this backward shim if controller v4.0 is old enough\n            let keys = await this._getKeysViaScan(`${this.objNamespace}system.host.*`);\n\n            // filter out obvious non-host objects\n            const hostRegex = new RegExp(`^${this.objNamespace.replace(/\\./g, '\\\\.')}system\\\\.host\\\\.[^.]+$`);\n            keys = keys.filter(id => hostRegex.test(id));\n            /** if false we have a host smaller 4 (no proto version for this existing) */\n            this.noLegacyMultihost = true;\n\n            try {\n                if (keys.length) {\n                    // else no host known yet - so we are single host\n                    const objs = await this.client.mget(keys);\n                    for (const strObj of objs) {\n                        const obj = strObj !== null ? JSON.parse(strObj) : strObj;\n                        if (\n                            obj &&\n                            obj.type === 'host' &&\n                            obj._id !== `system.host.${this.hostname}` &&\n                            obj.common &&\n                            obj.common.installedVersion &&\n                            semver.lt(obj.common.installedVersion, '4.0.0')\n                        ) {\n                            // one of the host has a version smaller 4, we have to use legacy db\n                            this.noLegacyMultihost = false;\n                            this.log.info(`${this.namespace} Sets unsupported`);\n                        }\n                    }\n                }\n            } catch (e) {\n                this.log.error(\n                    `${this.namespace} Cannot determine Lua scripts strategy: ${e.message} ${JSON.stringify(keys)}`,\n                );\n                return;\n            }\n\n            this.log.debug(`${this.namespace} Objects client initialize lua scripts`);\n\n            try {\n                await this.loadLuaScripts();\n            } catch (err) {\n                this.log.error(`${this.namespace} Cannot initialize database scripts: ${err.message}`);\n                return;\n            }\n\n            // init default new acl\n            let obj;\n            try {\n                obj = await this.client.get(`${this.objNamespace}system.config`);\n            } catch {\n                // ignore\n            }\n            if (obj) {\n                try {\n                    obj = JSON.parse(obj);\n                } catch {\n                    this.log.error(`${this.namespace} Cannot parse JSON system.config: ${obj}`);\n                    obj = null;\n                }\n                if (obj && obj.common && obj.common.defaultNewAcl) {\n                    this.defaultNewAcl = obj.common.defaultNewAcl;\n                }\n            } else {\n                this.log.error(`${this.namespace} Cannot read system.config: ${obj} (OK when migrating or restoring)`);\n            }\n\n            if (--initCounter < 1) {\n                if (this.settings.connection.port === 0) {\n                    this.log.debug(\n                        `${this.namespace} Objects ${\n                            ready ? 'client re' : ''\n                        }connected to redis: ${tools.maybeArrayToString(this.settings.connection.host)}`,\n                    );\n                } else {\n                    this.log.debug(\n                        `${this.namespace} Objects ${\n                            ready ? 'client re' : ''\n                        }connected to redis: ${tools.maybeArrayToString(\n                            this.settings.connection.host,\n                        )}:${tools.maybeArrayToString(this.settings.connection.port)}`,\n                    );\n                }\n                !ready && typeof this.settings.connected === 'function' && this.settings.connected();\n                ready = true;\n            }\n        });\n    }\n\n    getStatus(): DbStatus {\n        return { type: 'redis', server: false };\n    }\n\n    /**\n     * Checks if given ID is a meta-object, else throws error\n     *\n     * @param id to check\n     * @throws Error if id is invalid\n     */\n    async validateMetaObject(id: string): Promise<void> {\n        if (this.existingMetaObjects[id] === undefined) {\n            // if not cached -> getObject\n            const obj = await this.getObjectAsync(id);\n            if (obj && obj.type === 'meta') {\n                this.existingMetaObjects[id] = true;\n            } else {\n                this.existingMetaObjects[id] = false;\n                return Promise.reject(new Error(`${id} is not an object of type \"meta\"`));\n            }\n        } else if (this.existingMetaObjects[id] === false) {\n            return Promise.reject(new Error(`${id} is not an object of type \"meta\"`));\n        }\n    }\n\n    normalizeFilename(name: string): string {\n        return name ? name.replace(/[/\\\\]+/g, '/') : name;\n    }\n\n    // -------------- FILE FUNCTIONS -------------------------------------------\n    /**\n     * Sets a buffer to the Redis DB\n     *\n     * @param id id of the file\n     * @param data content, if string is passed it will be converted to a Buffer\n     */\n    private async _setBinaryState(id: string, data: Buffer | string): Promise<void> {\n        if (!this.client) {\n            throw new Error(ERRORS.ERROR_DB_CLOSED);\n        }\n        if (!Buffer.isBuffer(data)) {\n            data = Buffer.from(data);\n        }\n\n        await this.client.set(id, data);\n        await this.client.publish(id, data.byteLength.toString(10));\n    }\n\n    /**\n     * get buffer of given id from redis\n     *\n     * @param id - id of the data with namespace prefix\n     */\n    private _getBinaryState(id: string): Promise<Buffer> {\n        if (!this.client) {\n            throw new Error(ERRORS.ERROR_DB_CLOSED);\n        }\n\n        return this.client.getBuffer(id);\n    }\n\n    /**\n     * deletes binary state of given id from redis db\n     *\n     * @param id - id to delete, with namespace prefix\n     */\n    private async _delBinaryState(id: string): Promise<void> {\n        if (!this.client) {\n            throw new Error(ERRORS.ERROR_DB_CLOSED);\n        } else {\n            await this.client.del(id);\n            await this.client.publish(id, 'null'); // inform about deletion\n        }\n    }\n\n    getFileId(id: string, name: string, isMeta?: boolean): string {\n        name = this.normalizeFilename(name);\n        // e.g. ekey.admin and admin/ekey.png\n        if (id.endsWith('.admin')) {\n            if (name.startsWith('admin/')) {\n                name = name.replace(/^admin\\//, '');\n            } else if (name.match(/^iobroker.[-\\d\\w]\\/admin\\//i)) {\n                // e.g. ekey.admin and iobroker.ekey/admin/ekey.png\n                name = name.replace(/^iobroker.[-\\d\\w]\\/admin\\//i, '');\n            }\n        }\n        let normalized;\n        try {\n            normalized = utils.sanitizePath(id, name);\n        } catch {\n            this.log.debug(`${this.namespace} Invalid file path ${id}/${name}`);\n            return '';\n        }\n        if (id !== '*') {\n            id = normalized.id;\n        }\n        name = normalized.name;\n\n        return `${this.fileNamespace + id}$%$${name}${isMeta !== undefined ? (isMeta ? '$%$meta' : '$%$data') : ''}`;\n    }\n\n    async checkFile(\n        id: string,\n        name: string,\n        options: CallOptions,\n        flag: any,\n        callback?: CheckFileCallback,\n    ): Promise<ioBroker.CallbackReturnTypeOf<CheckFileCallback> | void> {\n        // read file settings from redis\n        const fileId = this.getFileId(id, name, true);\n        if (!fileId) {\n            const fileOptions = { notExists: true };\n            if (utils.checkFile(fileOptions, options, flag, this.defaultNewAcl)) {\n                return tools.maybeCallback(callback, false, options, fileOptions); // NO error\n            }\n            return tools.maybeCallback(callback, true, options); // error\n        }\n        if (!this.client) {\n            // @ts-expect-error TODO: not in specs, better just maybe cb check false?\n            return tools.maybeCallbackWithRedisError(callback, ERRORS.ERROR_DB_CLOSED, options);\n        }\n        let fileOptions;\n        try {\n            fileOptions = await this.client.get(fileId);\n        } catch {\n            // ignore\n        }\n        fileOptions = fileOptions || '{\"notExists\": true}';\n        try {\n            fileOptions = JSON.parse(fileOptions);\n        } catch {\n            this.log.error(`${this.namespace} Cannot parse JSON ${id}: ${fileOptions}`);\n            fileOptions = { notExists: true };\n        }\n        if (utils.checkFile(fileOptions, options, flag, this.defaultNewAcl)) {\n            return tools.maybeCallback(callback, false, options, fileOptions); // NO error\n        }\n        return tools.maybeCallback(callback, true, options); // error\n    }\n\n    checkFileRights(\n        id: string,\n        name: string | null,\n        options?: CallOptions | null,\n        flag?: any,\n        callback?: CheckFileRightsCallback,\n    ): void {\n        return utils.checkFileRights(this, id, name, options, flag, callback);\n    }\n\n    private async _setDefaultAcl(ids: string[], defaultAcl: any): Promise<void> {\n        for (const id of ids) {\n            try {\n                const obj = await this.getObject(id);\n                if (obj && !obj.acl) {\n                    obj.acl = defaultAcl;\n                    await this.setObjectAsync(id, obj, null);\n                }\n            } catch (e) {\n                this.log.error(\n                    `${this.namespace} _setDefaultAcl error on id \"${id}\" with acl \"${JSON.stringify(defaultAcl)}\": ${\n                        e.message\n                    }`,\n                );\n            }\n        }\n    }\n\n    async setDefaultAcl(defaultNewAcl: ACLObject | null): Promise<void> {\n        this.defaultNewAcl = defaultNewAcl || {\n            owner: CONSTS.SYSTEM_ADMIN_USER,\n            ownerGroup: CONSTS.SYSTEM_ADMIN_GROUP,\n            object: 0x664,\n            state: 0x664,\n            file: 0x664,\n        };\n        try {\n            // Get ALL Objects\n            const ids = await this.getKeysAsync('*');\n            if (ids) {\n                await this._setDefaultAcl(ids, this.defaultNewAcl);\n            }\n        } catch (e) {\n            this.log.error(`${this.namespace} Could not update default acl: ${e.message}`);\n        }\n    }\n\n    getUserGroup(\n        user: ioBroker.ObjectIDs.User,\n        callback: GetUserGroupCallbackNoError,\n    ): Promise<GetUserGroupPromiseReturn> | void {\n        return utils.getUserGroup(this, user, (error, user, userGroups, userAcl) => {\n            if (error) {\n                this.log.error(`${this.namespace} ${error.stack}`);\n            }\n            return tools.maybeCallback(callback, user, userGroups, userAcl);\n        });\n    }\n\n    private async _writeFile(\n        id: string,\n        name: string,\n        data: Buffer | string,\n        options: {\n            virtualFile?: any;\n            user?: any;\n            group?: any;\n            mode?: any;\n            mimeType?: string;\n        },\n        callback: ioBroker.ErrorCallback | undefined,\n        meta: {\n            acl?: Record<string, any>;\n            stats?: {\n                size: number;\n            };\n            notExists?: boolean;\n            mimeType?: string;\n            binary?: boolean;\n            modifiedAt?: number;\n            virtualFile?: boolean;\n            createdAt?: number;\n        },\n    ): Promise<void> {\n        const matchedExtension = name.match(/\\.[^.]+$/);\n        const ext = matchedExtension ? matchedExtension[0] : '';\n\n        const isTextData = typeof data === 'string';\n\n        const { mimeType, isBinary } = utils.getMimeType(ext, isTextData);\n\n        const metaID = this.getFileId(id, name, true);\n        if (!this.client) {\n            return tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);\n        }\n        // virtual files only get Meta objects\n        if (options.virtualFile) {\n            meta = {\n                notExists: true,\n                virtualFile: true,\n            }; // Store file with flags as it would not exist\n            try {\n                await this.client.set(metaID, JSON.stringify(meta));\n                return tools.maybeCallback(callback);\n            } catch (e) {\n                return tools.maybeCallbackWithRedisError(callback, e);\n            }\n        } else {\n            if (!meta) {\n                meta = { createdAt: Date.now() };\n            }\n            if (!meta.acl) {\n                meta.acl = {\n                    owner: options.user || (this.defaultNewAcl && this.defaultNewAcl.owner) || CONSTS.SYSTEM_ADMIN_USER,\n                    ownerGroup:\n                        options.group ||\n                        (this.defaultNewAcl && this.defaultNewAcl.ownerGroup) ||\n                        CONSTS.SYSTEM_ADMIN_GROUP,\n                    permissions: options.mode || (this.defaultNewAcl && this.defaultNewAcl.file) || 0x644,\n                };\n            }\n            meta.stats = {\n                size: data ? data.length : 0,\n            };\n            if (Object.prototype.hasOwnProperty.call(meta, 'notExists')) {\n                delete meta.notExists;\n            }\n\n            meta.mimeType = options.mimeType || mimeType;\n            meta.binary = isBinary;\n            meta.acl.ownerGroup =\n                meta.acl.ownerGroup ||\n                (this.defaultNewAcl && this.defaultNewAcl.ownerGroup) ||\n                CONSTS.SYSTEM_ADMIN_GROUP;\n            meta.modifiedAt = Date.now();\n\n            try {\n                await this._setBinaryState(this.getFileId(id, name, false), data);\n                await this.client.set(metaID, JSON.stringify(meta));\n                return tools.maybeCallback(callback);\n            } catch (e) {\n                return tools.maybeCallbackWithRedisError(callback, e);\n            }\n        }\n    }\n\n    // No options provided by the user\n    async writeFile(id: string, name: string, data: any, callback?: ioBroker.ErrorCallback): Promise<void>;\n    // Options provided by the user\n    async writeFile(\n        id: string,\n        name: string,\n        data: any,\n        options?: WriteFileOptions | null,\n        callback?: ioBroker.ErrorCallback,\n    ): Promise<void>;\n\n    async writeFile(\n        id: string,\n        name: string,\n        data: any,\n        options?: WriteFileOptions | ioBroker.ErrorCallback | null,\n        callback?: ioBroker.ErrorCallback,\n    ): Promise<void> {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n        if (typeof options === 'string') {\n            options = { mimeType: options };\n        }\n\n        if (options?.acl) {\n            options.acl = null;\n        }\n\n        if (!callback) {\n            return this.writeFileAsync(id, name, data, options);\n        }\n\n        try {\n            await this.validateMetaObject(id);\n        } catch (e) {\n            this.log.error(`${this.namespace} Cannot write file ${name}: ${e.message}`);\n            return tools.maybeCallbackWithError(callback, e);\n        }\n\n        if (typeof name !== 'string' || !name.length || name === '/') {\n            return tools.maybeCallbackWithError(callback, ERRORS.ERROR_NOT_FOUND);\n        }\n\n        if (name.startsWith('/')) {\n            name = name.substring(1);\n        }\n\n        if (data === undefined) {\n            data = null;\n        }\n\n        // If file yet exists => check the permissions\n        return this.checkFileRights(id, name, options, CONSTS.ACCESS_WRITE, (err, options, meta) => {\n            if (err) {\n                return tools.maybeCallbackWithError(callback, err);\n            }\n            return this._writeFile(id, name, data, options, callback, meta);\n        });\n    }\n\n    writeFileAsync(id: string, name: string, data: any, options?: WriteFileOptions | null): Promise<void> {\n        return new Promise<void>((resolve, reject) =>\n            this.writeFile(id, name, data, options, err => (err ? reject(err) : resolve())),\n        );\n    }\n\n    private async _readFile(id: string, name: string, meta: MetaObject): ioBroker.ReadFilePromise {\n        if (meta.notExists) {\n            throw new Error(ERRORS.ERROR_NOT_FOUND);\n        }\n        if (!this.client) {\n            throw new Error(ERRORS.ERROR_DB_CLOSED);\n        }\n\n        let buffer;\n        buffer = await this._getBinaryState(this.getFileId(id, name, false));\n\n        const mimeType = meta && meta.mimeType;\n        if (meta && !meta.binary && buffer) {\n            buffer = buffer.toString();\n        }\n\n        return { file: buffer, mimeType: mimeType };\n    }\n\n    // User has provided no callback, we will return the Promise\n    readFile(id: string, name: string, options?: CallOptions | null): ioBroker.ReadFilePromise;\n\n    // User has provided a callback, thus we will call it\n    readFile(\n        id: string,\n        name: string,\n        options: CallOptions | null | undefined,\n        callback: ioBroker.ReadFileCallback,\n    ): void;\n    readFile(\n        id: string,\n        name: string,\n        options?: CallOptions | null,\n        callback?: ioBroker.ReadFileCallback,\n    ): void | ioBroker.ReadFilePromise {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n        if (options && options.acl) {\n            options.acl = null;\n        }\n\n        if (!callback) {\n            return new Promise((resolve, reject) =>\n                this.readFile(id, name, options, (err, res, mimeType) =>\n                    err ? reject(err) : resolve({ file: res!, mimeType: mimeType }),\n                ),\n            );\n        }\n\n        if (typeof name !== 'string' || !name.length || name === '/') {\n            return tools.maybeCallbackWithError(callback, ERRORS.ERROR_NOT_FOUND);\n        }\n\n        if (name.startsWith('/')) {\n            name = name.substring(1);\n        }\n\n        options = options || {};\n        this.checkFileRights(id, name, options, CONSTS.ACCESS_READ, async (err, options, meta) => {\n            if (err) {\n                return tools.maybeCallbackWithError(callback, err);\n            }\n            try {\n                const { file, mimeType } = await this._readFile(id, name, meta);\n                return tools.maybeCallbackWithError(callback, null, file, mimeType);\n            } catch (e) {\n                return tools.maybeCallbackWithError(callback, e);\n            }\n        });\n    }\n\n    /**\n     * Check if given object exists\n     *\n     * @param id id of the object\n     * @param options optional user context\n     */\n    async objectExists(id: string, options?: CallOptions | null): Promise<boolean> {\n        if (!this.client) {\n            throw new Error(ERRORS.ERROR_DB_CLOSED);\n        }\n        if (!id || typeof id !== 'string') {\n            throw new Error(`invalid id ${JSON.stringify(id)}`);\n        }\n\n        try {\n            await new Promise<void>((resolve, reject) => {\n                utils.checkObjectRights(this, null, null, options, CONSTS.ACCESS_LIST, err => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve();\n                    }\n                });\n            });\n            const exists = await this.client.exists(this.objNamespace + id);\n            return !!exists;\n        } catch (e) {\n            this.log.error(`${this.namespace} Cannot check object existence of \"${id}\": ${e.message}`);\n            return Promise.reject(new Error(`Cannot check object existence of \"${id}\": ${e.message}`));\n        }\n    }\n\n    /**\n     * Check if given file exists\n     *\n     * @param id id of the namespace\n     * @param name name of the file\n     * @param options optional user context\n     */\n    async fileExists(id: string, name: string, options?: CallOptions | null): Promise<boolean> {\n        if (typeof name !== 'string') {\n            name = '';\n        }\n\n        if (name.startsWith('/')) {\n            name = name.substring(1);\n        }\n\n        try {\n            await new Promise<void>((resolve, reject) => {\n                this.checkFileRights(id, name, options, CONSTS.ACCESS_READ, err => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve();\n                    }\n                });\n            });\n\n            if (!this.client) {\n                throw new Error(ERRORS.ERROR_DB_CLOSED);\n            }\n\n            id = this.getFileId(id, name, false);\n            const exists = await this.client.exists(id);\n            return !!exists;\n        } catch (e) {\n            this.log.error(`${this.namespace} Cannot check file existence of \"${id}\": ${e.message}`);\n            throw new Error(`Cannot check file existence of \"${id}\": ${e.message}`);\n        }\n    }\n\n    private async _unlink(\n        id: string,\n        name: string,\n        options: CallOptions,\n        meta: MetaObject,\n    ): Promise<undefined | ioBroker.RmResult[]> {\n        if (!this.client) {\n            throw new Error(ERRORS.ERROR_DB_CLOSED);\n        }\n        if (meta && meta.notExists) {\n            return this._rm(id, name, options);\n        }\n        const metaID = this.getFileId(id, name, true);\n        const dataID = this.getFileId(id, name, false);\n        await this._delBinaryState(dataID);\n        await this.client.del(metaID);\n    }\n\n    unlink(id: string, name: string, options: CallOptions | null | undefined, callback?: ioBroker.RmCallback): void {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n        if (options && options.acl) {\n            options.acl = null;\n        }\n\n        if (typeof name !== 'string') {\n            name = '';\n        }\n\n        if (name.startsWith('/')) {\n            name = name.substring(1);\n        }\n\n        this.checkFileRights(id, name, options, CONSTS.ACCESS_DELETE, async (err, options, meta) => {\n            if (err) {\n                return tools.maybeCallbackWithError(callback, err);\n            }\n            if (!options.acl.file.delete) {\n                return tools.maybeCallbackWithError(callback, ERRORS.ERROR_PERMISSION);\n            }\n            try {\n                const files = await this._unlink(id, name, options, meta);\n                return tools.maybeCallbackWithError(callback, null, files);\n            } catch (e) {\n                return tools.maybeCallbackWithError(callback, e);\n            }\n        });\n    }\n\n    unlinkAsync(id: string, name: string, options?: CallOptions): Promise<void> {\n        return new Promise<void>((resolve, reject) =>\n            this.unlink(id, name, options, err => (err ? reject(err) : resolve())),\n        );\n    }\n\n    delFile(id: string, name: string, options: CallOptions, callback: ioBroker.ErrorCallback): void {\n        return this.unlink(id, name, options, callback);\n    }\n\n    delFileAsync(id: string, name: string, options: CallOptions): Promise<void> {\n        return this.unlinkAsync(id, name, options);\n    }\n\n    private async _readDir(\n        id: string,\n        name: string,\n        options: CallOptions,\n        callback: (err?: Error | null, res?: ioBroker.ReadDirResult[]) => void,\n    ): Promise<void> {\n        name = this.normalizeFilename(name);\n        if (!this.client) {\n            return tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);\n        }\n        if (id === '') {\n            // special case for \"root\"\n            const dirID = this.getFileId('*', '*');\n\n            let keys;\n            try {\n                keys = await this._getKeysViaScan(dirID);\n            } catch (e) {\n                return tools.maybeCallbackWithRedisError(callback, e);\n            }\n\n            if (!this.client) {\n                return tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);\n            }\n\n            const result: ioBroker.ReadDirResult[] = [];\n            if (!keys || !keys.length) {\n                return tools.maybeCallbackWithError(callback, null, result);\n            }\n            let lastDir: string;\n            keys.sort().forEach(dir => {\n                dir = dir.substring(this.fileNamespaceL, dir.indexOf('$%$'));\n                if (dir !== lastDir) {\n                    result.push({\n                        file: dir,\n                        stats: {},\n                        isDir: true,\n                    });\n                }\n                lastDir = dir;\n            });\n            return tools.maybeCallbackWithError(callback, null, result);\n        }\n\n        const dirID = this.getFileId(id, `${name}${name.length ? '/' : ''}*`);\n\n        let keys;\n        try {\n            keys = await this._getKeysViaScan(dirID);\n        } catch (e) {\n            return tools.maybeCallbackWithRedisError(callback, e);\n        }\n\n        if (!this.client) {\n            return tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);\n        }\n\n        const start = dirID.indexOf('$%$') + 3;\n        const end = '$%$meta'.length;\n\n        const baseName = name + (name.length ? '/' : '');\n        const dirs: string[] = [];\n        const deepLevel = baseName.split('/').length;\n        if (!keys || !keys.length) {\n            return tools.maybeCallbackWithError(callback, ERRORS.ERROR_NOT_FOUND, []);\n        }\n        keys = keys.sort().filter(key => {\n            if (key.endsWith('$%$meta')) {\n                const parts = key.substr(start, key.length - end).split('/');\n                if (parts.length === deepLevel) {\n                    return !key.includes('/_data.json$%$') && key !== '_data.json'; // sort out \"virtual\" files that are used to mark directories\n                }\n                const dir = parts[deepLevel - 1];\n                if (dirs.indexOf(dir) === -1) {\n                    dirs.push(dir);\n                }\n            }\n        });\n        if (!keys.length) {\n            const result: ioBroker.ReadDirResult[] = dirs.map(file => ({\n                file,\n                stats: {},\n                isDir: true,\n            }));\n\n            return tools.maybeCallbackWithError(callback, null, result);\n        }\n\n        // Check permissions\n        let strObjs: (null | string)[];\n        try {\n            strObjs = await this.client.mget(keys);\n        } catch (e) {\n            return tools.maybeCallbackWithRedisError(callback, e);\n        }\n\n        const result: ioBroker.ReadDirResult[] = [];\n        const dontCheck =\n            options.user === CONSTS.SYSTEM_ADMIN_USER ||\n            options.group !== CONSTS.SYSTEM_ADMIN_GROUP ||\n            (options.groups && options.groups.indexOf(CONSTS.SYSTEM_ADMIN_GROUP) !== -1);\n\n        for (let i = 0; i < keys.length; i++) {\n            const file = keys[i].substring(start + baseName.length, keys[i].length - end);\n            while (dirs.length && dirs[0] < file) {\n                result.push({\n                    file: dirs.shift()!,\n                    stats: {},\n                    isDir: true,\n                });\n            }\n\n            const strObj = strObjs[i];\n            let obj: FileObject | null;\n            try {\n                obj = strObj ? JSON.parse(strObj) : null;\n            } catch {\n                this.log.error(`${this.namespace} Cannot parse JSON ${keys[i]}: ${strObj}`);\n                continue;\n            }\n            if (dontCheck || utils.checkObject(obj, options, CONSTS.ACCESS_READ)) {\n                if (!obj || obj.virtualFile) {\n                    // virtual file, ignore\n                    continue;\n                }\n                obj.acl = obj.acl || {};\n                if (\n                    options.user !== CONSTS.SYSTEM_ADMIN_USER &&\n                    options.groups &&\n                    options.groups.indexOf(CONSTS.SYSTEM_ADMIN_GROUP) === -1\n                ) {\n                    obj.acl.read = !!(obj.acl.permissions & CONSTS.ACCESS_EVERY_READ);\n                    obj.acl.write = !!(obj.acl.permissions & CONSTS.ACCESS_EVERY_WRITE);\n                } else {\n                    obj.acl.read = true;\n                    obj.acl.write = true;\n                }\n                result.push({\n                    file: file,\n                    stats: obj.stats,\n                    isDir: false,\n                    acl: obj.acl,\n                    modifiedAt: obj.modifiedAt,\n                    createdAt: obj.createdAt,\n                });\n            }\n        }\n        while (dirs.length) {\n            result.push({\n                file: dirs.shift()!,\n                stats: {},\n                isDir: true,\n            });\n        }\n        return tools.maybeCallbackWithError(callback, null, result);\n    }\n\n    readDir(\n        id: string,\n        name: string,\n        options: CallOptions | null | undefined,\n        callback: ioBroker.ReadDirCallback,\n    ): void {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n        if (options && options.acl) {\n            options.acl = null;\n        }\n\n        if (typeof name !== 'string') {\n            name = '';\n        }\n\n        // remove first and last\n        if (name.startsWith('/')) {\n            name = name.substring(1);\n        }\n        if (name.endsWith('/')) {\n            name = name.substring(0, name.length - 1);\n        }\n\n        this.checkFileRights(id, name, options, CONSTS.ACCESS_READ, (err, options) => {\n            if (err) {\n                return tools.maybeCallbackWithError(callback, err);\n            }\n            if (!options.acl.file.list) {\n                return tools.maybeCallbackWithError(callback, ERRORS.ERROR_PERMISSION);\n            }\n            this._readDir(id, name, options, callback);\n        });\n    }\n\n    readDirAsync(id: string, name: string, options?: CallOptions): ioBroker.ReadDirPromise {\n        return new Promise((resolve, reject) =>\n            this.readDir(id, name, options, (err, res) => (err ? reject(err) : resolve(res!))),\n        );\n    }\n\n    private async _renameHelper(\n        keys: string[],\n        oldBase: string,\n        newBase: string,\n        callback?: ioBroker.ErrorCallback,\n    ): Promise<void> {\n        if (!keys || !keys.length) {\n            return tools.maybeCallback(callback);\n        }\n        if (!this.client) {\n            return tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);\n        }\n        for (const id of keys) {\n            try {\n                try {\n                    await this.client.rename(\n                        id.replace(/\\$%\\$meta$/, '$%$data'),\n                        id.replace(oldBase, newBase).replace(/\\$%\\$meta$/, '$%$data'),\n                    );\n                } catch (e) {\n                    // _data.json is not having a data key, so ignore error\n                    if (!(id.endsWith('/_data.json$%$meta') && e.message.includes('no such key'))) {\n                        throw e;\n                    }\n                }\n                await this.client.rename(id, id.replace(oldBase, newBase));\n            } catch (e) {\n                return tools.maybeCallbackWithRedisError(callback, e);\n            }\n        }\n        return tools.maybeCallback(callback);\n    }\n\n    private async _rename(\n        id: string,\n        oldName: string,\n        newName: string,\n        options: CallOptions,\n        callback?: ioBroker.ErrorCallback,\n        meta?: MetaObject,\n    ): Promise<void> {\n        const oldMetaID = this.getFileId(id, oldName, true);\n        const oldDataID = this.getFileId(id, oldName, false);\n        const newMetaID = this.getFileId(id, newName, true);\n        const newDataID = this.getFileId(id, newName, false);\n        if (!meta || !this.client) {\n            return tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);\n        } else if (meta.notExists) {\n            oldName = this.normalizeFilename(oldName);\n            newName = this.normalizeFilename(newName);\n\n            // it could be dir\n            if (!oldName.endsWith('/*')) {\n                oldName += '/*';\n            } else if (oldName.endsWith('/')) {\n                oldName += '*';\n            }\n\n            if (!newName.endsWith('/*')) {\n                newName += '/*';\n            } else if (newName.endsWith('/')) {\n                newName += '*';\n            }\n\n            const oldBase = oldName.substring(0, oldName.length - 1);\n            const newBase = newName.substring(0, newName.length - 1);\n            const dirID = this.getFileId(id, oldName);\n            let keys;\n            try {\n                keys = await this._getKeysViaScan(dirID);\n            } catch (e) {\n                return tools.maybeCallbackWithRedisError(callback, e);\n            }\n\n            if (!this.client) {\n                return tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);\n            }\n            if (!keys) {\n                return tools.maybeCallbackWithError(callback, ERRORS.ERROR_NOT_FOUND);\n            }\n\n            keys = keys.sort().filter(key => key.endsWith('$%$meta'));\n\n            if (!keys.length) {\n                return tools.maybeCallbackWithError(callback, ERRORS.ERROR_NOT_FOUND);\n            }\n            // Check permissions\n            let strObjs: (string | null)[];\n            try {\n                strObjs = await this.client.mget(keys);\n            } catch (e) {\n                return tools.maybeCallbackWithRedisError(callback, e);\n            }\n            let result;\n            const dontCheck =\n                options.user === CONSTS.SYSTEM_ADMIN_USER ||\n                options.group !== CONSTS.SYSTEM_ADMIN_GROUP ||\n                (options.groups && options.groups.indexOf(CONSTS.SYSTEM_ADMIN_GROUP) !== -1);\n\n            if (!dontCheck) {\n                result = [];\n                for (let i = 0; i < keys.length; i++) {\n                    const strObj = strObjs[i];\n                    let obj: ioBroker.AnyObject | null;\n                    try {\n                        obj = strObj ? JSON.parse(strObj) : null;\n                    } catch {\n                        this.log.error(`${this.namespace} Cannot parse JSON ${keys[i]}: ${strObj}`);\n                        continue;\n                    }\n                    if (utils.checkObject(obj, options, CONSTS.ACCESS_READ)) {\n                        result.push(keys[i]);\n                    }\n                }\n            } else {\n                result = keys;\n            }\n            return this._renameHelper(result, oldBase, newBase, callback);\n        }\n        try {\n            await this.client.rename(oldDataID, newDataID);\n            await this.client.rename(oldMetaID, newMetaID);\n            return tools.maybeCallback(callback);\n        } catch (e) {\n            return tools.maybeCallbackWithRedisError(callback, e);\n        }\n    }\n\n    rename(\n        id: string,\n        oldName: string,\n        newName: string,\n        options?: CallOptions | null,\n        callback?: ioBroker.ErrorCallback,\n    ): void | Promise<void> {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n        if (options && options.acl) {\n            options.acl = null;\n        }\n        if (\n            typeof oldName !== 'string' ||\n            !oldName.length ||\n            oldName === '/' ||\n            oldName === '//' ||\n            typeof newName !== 'string' ||\n            !newName.length ||\n            newName === '/' ||\n            newName === '//'\n        ) {\n            return tools.maybeCallbackWithError(callback, ERRORS.ERROR_NOT_FOUND);\n        }\n        if (oldName.startsWith('/')) {\n            oldName = oldName.substring(1);\n        }\n        if (newName.startsWith('/')) {\n            newName = newName.substring(1);\n        }\n        if (oldName.endsWith('/')) {\n            oldName = oldName.substring(0, oldName.length - 1);\n        }\n        if (newName.endsWith('/')) {\n            newName = newName.substring(0, newName.length - 1);\n        }\n\n        this.checkFileRights(id, oldName, options, CONSTS.ACCESS_WRITE, (err, options, meta) => {\n            if (err) {\n                return tools.maybeCallbackWithError(callback, err);\n            }\n            if (!options.acl.file.write) {\n                return tools.maybeCallbackWithError(callback, ERRORS.ERROR_PERMISSION);\n            }\n            this._rename(id, oldName, newName, options, callback, meta);\n        });\n    }\n\n    renameAsync(id: string, oldName: string, newName: string, options: CallOptions): Promise<void> {\n        return new Promise((resolve, reject) =>\n            this.rename(id, oldName, newName, options, err => (err ? reject(err) : resolve())),\n        );\n    }\n\n    private async _touch(id: string, name: string, callback: ioBroker.ErrorCallback, meta: MetaObject): Promise<void> {\n        const metaID = this.getFileId(id, name, true);\n        if (!this.client) {\n            return tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);\n        }\n        if (!meta || meta.notExists) {\n            return tools.maybeCallbackWithError(callback, ERRORS.ERROR_NOT_FOUND);\n        }\n        meta.modifiedAt = Date.now();\n        try {\n            await this.client.set(metaID, JSON.stringify(meta));\n            return tools.maybeCallback(callback);\n        } catch (e) {\n            return tools.maybeCallbackWithRedisError(callback, e);\n        }\n    }\n\n    touch(id: string, name: string, options: CallOptions | null, callback: ioBroker.ErrorCallback): void {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n        if (options && options.acl) {\n            options.acl = null;\n        }\n\n        if (typeof name !== 'string' || !name.length || name === '/') {\n            return tools.maybeCallbackWithError(callback, ERRORS.ERROR_NOT_FOUND);\n        }\n\n        if (name.startsWith('/')) {\n            name = name.substring(1);\n        }\n\n        this.checkFileRights(id, name, options, CONSTS.ACCESS_WRITE, (err, options, meta) => {\n            if (err) {\n                return tools.maybeCallbackWithError(callback, err);\n            }\n            return this._touch(id, name, callback, meta);\n        });\n    }\n\n    touchAsync(id: string, name: string, options: CallOptions): Promise<void> {\n        return new Promise((resolve, reject) => this.touch(id, name, options, err => (err ? reject(err) : resolve())));\n    }\n\n    private async _rmHelper(keys: string[]): Promise<void> {\n        if (!keys.length) {\n            return;\n        }\n        if (!this.client) {\n            throw new Error(ERRORS.ERROR_DB_CLOSED);\n        }\n\n        for (const id of keys) {\n            await this._delBinaryState(id.replace(/\\$%\\$meta$/, '$%$data'));\n            await this.client.del(id);\n        }\n    }\n\n    private async _rm(\n        id: string,\n        name: string,\n        options: CallOptions,\n        meta?: any,\n    ): Promise<ioBroker.RmResult[] | undefined> {\n        if (meta && !meta.isDir) {\n            // it is file\n            const metaID = this.getFileId(id, name, true);\n            const dataID = this.getFileId(id, name, false);\n            await this.delObjectAsync(dataID);\n            await this.delObjectAsync(metaID);\n        } else {\n            if (!this.client) {\n                throw new Error(ERRORS.ERROR_DB_CLOSED);\n            }\n            name = this.normalizeFilename(name);\n            // it could be dir\n            if (!name.endsWith('/*')) {\n                name += '/*';\n            } else if (name.endsWith('/')) {\n                name += '*';\n            }\n            const dirID = this.getFileId(id, name);\n            let keys = await this._getKeysViaScan(dirID);\n\n            if (!this.client) {\n                throw new Error(ERRORS.ERROR_DB_CLOSED);\n            }\n            if (!keys) {\n                throw new Error(ERRORS.ERROR_NOT_FOUND);\n            }\n\n            keys = keys.sort().filter(key => key.endsWith('$%$meta'));\n\n            if (!keys.length) {\n                throw new Error(ERRORS.ERROR_NOT_FOUND);\n            }\n            // Check permissions\n            let objs;\n            try {\n                objs = await this.client.mget(keys);\n            } catch {\n                // ignore\n            }\n            let result;\n            const dontCheck =\n                options.user === CONSTS.SYSTEM_ADMIN_USER ||\n                options.group !== CONSTS.SYSTEM_ADMIN_GROUP ||\n                (options.groups && options.groups.indexOf(CONSTS.SYSTEM_ADMIN_GROUP) !== -1);\n\n            objs = objs || [];\n            if (!dontCheck) {\n                result = [];\n                for (let i = 0; i < keys.length; i++) {\n                    try {\n                        const strObj = objs[i];\n                        const obj: ioBroker.AnyObject | null = strObj ? JSON.parse(strObj) : null;\n                        if (utils.checkObject(obj, options, CONSTS.ACCESS_READ)) {\n                            result.push(keys[i]);\n                        }\n                    } catch {\n                        this.log.error(`${this.namespace} Cannot parse JSON ${keys[i]}: ${objs[i]}`);\n                    }\n                }\n            } else {\n                result = keys;\n            }\n            const files = result.map(key => {\n                const name = key.substring(this.fileNamespaceL + id.length + 3, key.length - 7);\n                const pos = name.lastIndexOf('/');\n                if (pos !== -1) {\n                    return { file: name.substring(pos + 1), path: name.substring(0, pos) };\n                }\n                return { file: id, path: '' };\n            });\n\n            try {\n                await this._rmHelper(result);\n            } catch (e) {\n                this.log.error(`${this.namespace} Could not remove files: ${e.message}`);\n            }\n\n            return files;\n        }\n    }\n\n    rm(id: string, name: string, options: CallOptions | null, callback: ioBroker.RmCallback): void {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n        if (options && options.acl) {\n            options.acl = null;\n        }\n\n        if (typeof name !== 'string') {\n            name = '';\n        }\n\n        this.checkFileRights(id, null, options, CONSTS.ACCESS_DELETE, async (err, options, meta) => {\n            if (err) {\n                return tools.maybeCallbackWithError(callback, err);\n            }\n            if (!options.acl.file.delete) {\n                return tools.maybeCallbackWithError(callback, ERRORS.ERROR_PERMISSION);\n            }\n            try {\n                const files = await this._rm(id, name, options, meta && meta.notExists ? null : meta);\n                return tools.maybeCallbackWithError(callback, null, files);\n            } catch (e) {\n                return tools.maybeCallbackWithError(callback, e);\n            }\n        });\n    }\n\n    rmAsync(id: string, name: string, options: CallOptions): Promise<void | ioBroker.RmResult[]> {\n        return new Promise((resolve, reject) =>\n            this.rm(id, name, options, (err, files) => (err ? reject(err) : resolve(files))),\n        );\n    }\n\n    // simulate. redis has no dirs\n    mkdir(id: string, dirName?: string, options?: CallOptions | null, callback?: ioBroker.ErrorCallback): void {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n        if (typeof dirName !== 'string') {\n            dirName = '';\n        }\n\n        dirName = this.normalizeFilename(dirName);\n        if (dirName.startsWith('/')) {\n            dirName = dirName.substring(1);\n        }\n        this.checkFileRights(id, dirName, options, CONSTS.ACCESS_WRITE, (err, options) => {\n            if (err) {\n                return tools.maybeCallbackWithError(callback, err);\n            }\n            if (!options.acl.file.write) {\n                return tools.maybeCallbackWithError(callback, ERRORS.ERROR_PERMISSION);\n            }\n            // we create a dummy file (for file this file exists to store meta data) - do not override passed options\n            options = { ...options, virtualFile: true };\n            const realName = dirName + (dirName.endsWith('/') ? '' : '/');\n            this.writeFile(id, `${realName}_data.json`, '', options, callback);\n        });\n    }\n\n    mkdirAsync(id: string, dirName?: string, options?: CallOptions): Promise<void> {\n        return new Promise((resolve, reject) =>\n            this.mkdir(id, dirName, options, err => (err ? reject(err) : resolve())),\n        );\n    }\n\n    private async _chownFileHelper(\n        keys: string[],\n        metas: any[],\n        options: CallOptions,\n        callback: ioBroker.ErrorCallback,\n    ): Promise<void> {\n        if (!keys.length) {\n            return tools.maybeCallback(callback);\n        }\n        if (!this.client) {\n            return tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);\n        }\n\n        for (const id of keys) {\n            const meta = metas.shift();\n            meta.acl.owner = options.owner;\n            meta.acl.ownerGroup = options.ownerGroup;\n            try {\n                await this.client.set(id, JSON.stringify(meta));\n            } catch (e) {\n                return tools.maybeCallbackWithRedisError(callback, e);\n            }\n        }\n        return tools.maybeCallback(callback);\n    }\n\n    private async _chownFile(\n        id: string,\n        name: string,\n        options: CallOptions,\n        callback: ioBroker.ChownFileCallback,\n        meta: ChmodMetaObject,\n    ): Promise<ioBroker.ChownFileResult | void> {\n        if (!meta) {\n            return tools.maybeCallbackWithError(callback, ERRORS.ERROR_NOT_FOUND);\n        }\n\n        name = this.normalizeFilename(name);\n        if (!this.client) {\n            return tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);\n        }\n        if (!meta.isDir && !meta.notExists) {\n            // it is file\n            const metaID = this.getFileId(id, name, true);\n            meta.acl.owner = options.owner;\n            meta.acl.ownerGroup = options.ownerGroup;\n            try {\n                await this.client.set(metaID, JSON.stringify(meta));\n            } catch (e) {\n                return tools.maybeCallbackWithRedisError(callback, e);\n            }\n            const nameArr = name.split('/');\n            const file = nameArr.pop() as string;\n            const res = [\n                {\n                    path: nameArr.join('/'),\n                    file: file,\n                    stats: meta.stats,\n                    isDir: false,\n                    acl: meta.acl || {},\n                    modifiedAt: meta.modifiedAt,\n                    createdAt: meta.createdAt,\n                },\n            ];\n            return tools.maybeCallbackWithError(callback, null, res);\n        }\n\n        // it could be dir\n        if (!name.endsWith('/*')) {\n            name += '/*';\n        } else if (name.endsWith('/')) {\n            name += '*';\n        }\n        const dirID = this.getFileId(id, name);\n\n        let keys;\n        try {\n            keys = await this._getKeysViaScan(dirID);\n        } catch (e) {\n            return tools.maybeCallbackWithRedisError(callback, e);\n        }\n\n        if (!this.client) {\n            return tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);\n        }\n        if (!keys) {\n            return tools.maybeCallbackWithError(callback, ERRORS.ERROR_NOT_FOUND);\n        }\n\n        keys = keys.sort().filter(key => key.endsWith('$%$meta'));\n\n        // Check permissions\n        let metasStr: (string | null)[];\n        try {\n            metasStr = await this.client.mget(keys);\n        } catch (e) {\n            return tools.maybeCallbackWithRedisError(callback, e);\n        }\n        const dontCheck =\n            options.user === CONSTS.SYSTEM_ADMIN_USER ||\n            options.group !== CONSTS.SYSTEM_ADMIN_GROUP ||\n            (options.groups && options.groups.indexOf(CONSTS.SYSTEM_ADMIN_GROUP) !== -1);\n        const keysFiltered = [];\n        const objsFiltered = [];\n        const processed: ioBroker.ChownFileResult[] = [];\n        const start = dirID.indexOf('$%$') + 3;\n        const end = '$%$meta'.length;\n\n        for (let i = 0; i < keys.length; i++) {\n            const metaStr = metasStr[i];\n            let meta: null | FileObject;\n            try {\n                meta = metaStr ? JSON.parse(metaStr) : null;\n            } catch {\n                this.log.error(`${this.namespace} Cannot parse JSON ${keys[i]}: ${metaStr}`);\n                continue;\n            }\n            if (dontCheck || utils.checkObject(meta, options, CONSTS.ACCESS_WRITE)) {\n                if (!meta || meta.virtualFile) {\n                    continue;\n                } // virtual file, ignore\n                keysFiltered.push(keys[i]);\n                objsFiltered.push(meta);\n\n                const name = keys[i].substring(start, keys[i].length - end);\n                const nameArr = name.split('/');\n                const file = nameArr.pop() as string;\n                processed.push({\n                    path: nameArr.join('/'),\n                    file: file,\n                    stats: meta.stats || {},\n                    isDir: false,\n                    acl: meta.acl || {},\n                    modifiedAt: meta.modifiedAt,\n                    createdAt: meta.createdAt,\n                });\n            }\n        }\n        this._chownFileHelper(keysFiltered, objsFiltered, options, err => {\n            return tools.maybeCallbackWithError(callback, err, processed);\n        });\n    }\n\n    chownFile(id: string, name: string, options: CallOptions, callback: ioBroker.ChownFileCallback): void {\n        if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n        options = options || {};\n        if (typeof options !== 'object') {\n            options = { owner: options };\n        }\n\n        if (typeof name !== 'string' || !name.length || name === '/') {\n            return tools.maybeCallbackWithError(callback, ERRORS.ERROR_NOT_FOUND);\n        }\n\n        if (name.startsWith('/')) {\n            name = name.substring(1);\n        }\n\n        if (!options.ownerGroup && options.group) {\n            options.ownerGroup = options.group;\n        }\n        if (!options.owner && options.user) {\n            options.owner = options.user;\n        }\n\n        if (!options.owner) {\n            this.log.error(`${this.namespace} user is not defined`);\n            return tools.maybeCallbackWithError(callback, 'invalid parameter');\n        }\n\n        if (!options.ownerGroup) {\n            // get user group\n            this.getUserGroup(options.owner, (user, groups) => {\n                if (!groups || !groups[0]) {\n                    return tools.maybeCallbackWithError(callback, `user \"${options.owner}\" belongs to no group`);\n                }\n                options.ownerGroup = groups[0];\n\n                this.chownFile(id, name, options, callback);\n            });\n            return;\n        }\n\n        this.checkFileRights(id, name, options, CONSTS.ACCESS_WRITE, (err, options, meta) => {\n            if (err) {\n                return tools.maybeCallbackWithError(callback, err);\n            }\n            if (!options.acl.file.write) {\n                return tools.maybeCallbackWithError(callback, ERRORS.ERROR_PERMISSION);\n            }\n            return this._chownFile(id, name, options, callback, meta);\n        });\n    }\n\n    chownFileAsync(\n        id: string,\n        name: string,\n        options: CallOptions,\n    ): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.ChownFileCallback>> {\n        return new Promise((resolve, reject) =>\n            this.chownFile(id, name, options, (err, processed) => (err ? reject(err) : resolve(processed))),\n        );\n    }\n\n    /**\n     *\n     * @param keys Key names to handle\n     * @param metas Objects for the keys to handle\n     * @param options options\n     * @param callback callback function\n     */\n    private async _chmodFileHelper(\n        keys: string[],\n        metas: any[],\n        options: CallOptions,\n        callback: ioBroker.ErrorCallback,\n    ): Promise<void> {\n        if (!keys || !keys.length) {\n            return tools.maybeCallback(callback);\n        }\n        if (!this.client) {\n            return tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);\n        }\n\n        for (const i in keys) {\n            const id = keys[i];\n            const meta = metas[i];\n            meta.acl.permissions = options.mode;\n            try {\n                await this.client.set(id, JSON.stringify(meta));\n            } catch (e) {\n                return tools.maybeCallbackWithRedisError(callback, e);\n            }\n        }\n        return tools.maybeCallback(callback);\n    }\n\n    private async _chmodFile(\n        id: string,\n        name: string,\n        options: CallOptions,\n        callback: ioBroker.ChownFileCallback,\n        meta: ChmodMetaObject,\n    ): Promise<void> {\n        if (!meta) {\n            return tools.maybeCallbackWithError(callback, ERRORS.ERROR_NOT_FOUND);\n        }\n        name = this.normalizeFilename(name);\n        if (!this.client) {\n            return tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);\n        }\n        if (!meta.isDir && !meta.notExists) {\n            // it is file\n            const metaID = this.getFileId(id, name, true);\n            meta.acl.permissions = options.mode;\n            try {\n                await this.client.set(metaID, JSON.stringify(meta));\n            } catch (e) {\n                return tools.maybeCallbackWithRedisError(callback, e);\n            }\n\n            const nameArr = name.split('/');\n            const file = nameArr.pop() as string;\n            const res = [\n                {\n                    path: nameArr.join('/'),\n                    file: file,\n                    stats: meta.stats,\n                    isDir: false,\n                    acl: meta.acl || {},\n                    modifiedAt: meta.modifiedAt,\n                    createdAt: meta.createdAt,\n                },\n            ];\n            return tools.maybeCallbackWithError(callback, null, res);\n        }\n\n        // it could be dir\n        if (!name.endsWith('/*')) {\n            name += '/*';\n        } else if (name.endsWith('/')) {\n            name += '*';\n        }\n        const dirID = this.getFileId(id, name);\n\n        let keys;\n        try {\n            keys = await this._getKeysViaScan(dirID);\n        } catch (e) {\n            return tools.maybeCallbackWithRedisError(callback, e);\n        }\n\n        if (!this.client) {\n            return tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);\n        }\n        if (!keys) {\n            return tools.maybeCallbackWithError(callback, ERRORS.ERROR_NOT_FOUND);\n        }\n\n        keys = keys.sort().filter(key => key.endsWith('$%$meta'));\n\n        // Check permissions\n        let strObjs: (null | string)[];\n        try {\n            strObjs = await this.client.mget(keys);\n        } catch (e) {\n            return tools.maybeCallbackWithRedisError(callback, e);\n        }\n\n        const dontCheck =\n            options.user === CONSTS.SYSTEM_ADMIN_USER ||\n            options.group !== CONSTS.SYSTEM_ADMIN_GROUP ||\n            (options.groups && options.groups.indexOf(CONSTS.SYSTEM_ADMIN_GROUP) !== -1);\n\n        const keysFiltered = [];\n        const objsFiltered = [];\n        const processed: ioBroker.ChownFileResult[] = [];\n        const start = dirID.indexOf('$%$') + 3;\n        const end = '$%$meta'.length;\n\n        for (let i = 0; i < keys.length; i++) {\n            const strObj = strObjs[i];\n            let obj: null | FileObject;\n            try {\n                obj = strObj ? JSON.parse(strObj) : null;\n            } catch {\n                this.log.error(`${this.namespace} Cannot parse JSON ${keys[i]}: ${strObj}`);\n                continue;\n            }\n            if (dontCheck || utils.checkObject(obj, options, CONSTS.ACCESS_WRITE)) {\n                if (!obj || obj.virtualFile) {\n                    continue;\n                } // virtual file, ignore\n                keysFiltered.push(keys[i]);\n                objsFiltered.push(obj);\n\n                const name = keys[i].substring(start, keys[i].length - end);\n                const nameArr = name.split('/');\n                const file = nameArr.pop() as string;\n                processed.push({\n                    path: nameArr.join('/'),\n                    file: file,\n                    stats: obj.stats,\n                    isDir: false,\n                    acl: obj.acl || {},\n                    modifiedAt: obj.modifiedAt,\n                    createdAt: obj.createdAt,\n                });\n            }\n        }\n        this._chmodFileHelper(keysFiltered, objsFiltered, options, err =>\n            tools.maybeCallbackWithError(callback, err, processed),\n        );\n    }\n\n    chmodFile(id: string, name: string, options: CallOptions | null, callback: ioBroker.ChownFileCallback): void {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n        options = options || {};\n\n        if (typeof name !== 'string' || !name.length || name === '/') {\n            return tools.maybeCallbackWithError(callback, ERRORS.ERROR_NOT_FOUND);\n        }\n\n        if (name[0].startsWith('/')) {\n            name = name.substring(1);\n        }\n\n        if (typeof options !== 'object') {\n            options = { mode: options };\n        }\n\n        if (options.mode === undefined) {\n            this.log.error(`${this.namespace} mode is not defined`);\n            return tools.maybeCallbackWithError(callback, 'invalid parameter');\n        } else if (typeof options.mode === 'string') {\n            options.mode = parseInt(options.mode, 16);\n        }\n\n        this.checkFileRights(id, name, options, CONSTS.ACCESS_WRITE, (err, options, meta) => {\n            if (err) {\n                return tools.maybeCallbackWithError(callback, err);\n            }\n            if (!options.acl.file.write) {\n                return tools.maybeCallbackWithError(callback, ERRORS.ERROR_PERMISSION);\n            }\n            return this._chmodFile(id, name, options, callback, meta);\n        });\n    }\n\n    chmodFileAsync(\n        id: string,\n        name: string,\n        options: CallOptions,\n    ): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.ChownFileCallback>> {\n        return new Promise((resolve, reject) =>\n            this.chmodFile(id, name, options, (err, processed) => (err ? reject(err) : resolve(processed))),\n        );\n    }\n\n    // no options provided by user\n    enableFileCache(enabled: boolean, callback?: (err: Error | null | undefined, res: boolean) => void): void;\n    // options provided by user\n    enableFileCache(\n        enabled: boolean,\n        options?: CallOptions,\n        callback?: (err: Error | null | undefined, res: boolean) => void,\n    ): void;\n    enableFileCache(\n        enabled: boolean,\n        options?: any,\n        callback?: (err: Error | null | undefined, res: boolean) => void,\n    ): void {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        if (options && options.acl) {\n            options.acl = null;\n        }\n\n        utils.checkObjectRights(this, null, null, options, CONSTS.ACCESS_WRITE, (err, _options) => {\n            if (err) {\n                return tools.maybeCallbackWithError(callback, err);\n            }\n            // cache cannot be enabled\n            return tools.maybeCallbackWithError(callback, null, false);\n        });\n    }\n\n    enableFileCacheAsync(enabled: boolean, options?: CallOptions): Promise<boolean> {\n        return new Promise((resolve, reject) =>\n            this.enableFileCache(enabled, options, (err, res) => (err ? reject(err) : resolve(res))),\n        );\n    }\n\n    private async _subscribeFile(id: string, pattern: string | string[]): Promise<void> {\n        if (!this.sub) {\n            throw new Error(ERRORS.ERROR_DB_CLOSED);\n        }\n        if (Array.isArray(pattern)) {\n            for (const _pattern of pattern) {\n                const fileId = this.getFileId(id, _pattern, false);\n                this.log.silly(`${this.namespace} redis psubscribe ${fileId}`);\n                if (this.sub) {\n                    await this.sub.psubscribe(fileId);\n                    this.userSubscriptions[fileId] = true;\n                }\n            }\n        } else {\n            const fileId = this.getFileId(id, pattern, false);\n            this.log.silly(`${this.namespace} redis psubscribe ${fileId}`);\n            await this.sub.psubscribe(fileId);\n            this.userSubscriptions[fileId] = true;\n        }\n    }\n\n    private async _unsubscribeFile(id: string, pattern: string | string[]): Promise<void> {\n        if (!this.sub) {\n            throw new Error(ERRORS.ERROR_DB_CLOSED);\n        }\n        if (Array.isArray(pattern)) {\n            for (const _pattern of pattern) {\n                const fileId = this.getFileId(id, _pattern, false);\n                this.log.silly(`${this.namespace} redis punsubscribe ${fileId}`);\n                if (this.sub) {\n                    await this.sub.punsubscribe(fileId);\n                    if (this.userSubscriptions[fileId] !== undefined) {\n                        delete this.userSubscriptions[fileId];\n                    }\n                }\n            }\n        } else {\n            this.log.silly(`${this.namespace} redis punsubscribe ${this.objNamespace}${pattern}`);\n            const fileId = this.getFileId(id, pattern, false);\n            await this.sub.punsubscribe(fileId);\n            if (this.userSubscriptions[fileId] !== undefined) {\n                delete this.userSubscriptions[fileId];\n            }\n        }\n    }\n\n    subscribeUserFile(id: string, pattern: string | string[], options?: CallOptions | null): Promise<void> {\n        return new Promise((resolve, reject) => {\n            utils.checkObjectRights(this, null, null, options, 'list', err => {\n                if (err) {\n                    reject(err);\n                } else {\n                    return this._subscribeFile(id, pattern)\n                        .then(() => resolve())\n                        .catch((err: Error) => reject(err));\n                }\n            });\n        });\n    }\n\n    unsubscribeUserFile(id: string, pattern: string | string[], options?: CallOptions | null): Promise<void> {\n        return new Promise((resolve, reject) => {\n            utils.checkObjectRights(this, null, null, options, 'list', err => {\n                if (err) {\n                    reject(err);\n                } else {\n                    return this._unsubscribeFile(id, pattern)\n                        .then(() => resolve())\n                        .catch((err: Error) => reject(err));\n                }\n            });\n        });\n    }\n\n    // -------------- OBJECT FUNCTIONS -------------------------------------------\n    // If callback provided by user, we call callback else we return a Promise\n    private _subscribe<T extends ioBroker.ErrorCallback>(\n        pattern: string | string[],\n        asUser: boolean,\n        callback?: T,\n    ): T extends ioBroker.ErrorCallback ? void : Promise<void>;\n    private _subscribe(\n        pattern: string | string[],\n        asUser: boolean,\n        callback?: ioBroker.ErrorCallback,\n    ): void | Promise<void> {\n        const subClient = asUser ? this.sub : this.subSystem;\n        if (!subClient) {\n            return tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);\n        }\n        if (Array.isArray(pattern)) {\n            let count = pattern.length;\n            pattern.forEach(pattern => {\n                this.log.silly(`${this.namespace} redis psubscribe ${this.objNamespace}${pattern}`);\n                subClient.psubscribe(this.objNamespace + pattern, err => {\n                    if (!err) {\n                        const subscriptions = asUser ? this.userSubscriptions : this.systemSubscriptions;\n                        subscriptions[this.objNamespace + pattern] = true;\n                    }\n                    if (!--count) {\n                        return tools.maybeCallbackWithError(callback, err);\n                    }\n                });\n            });\n        } else {\n            this.log.silly(`${this.namespace} redis psubscribe ${this.objNamespace}${pattern}`);\n            subClient.psubscribe(this.objNamespace + pattern, err => {\n                if (!err) {\n                    const subscriptions = asUser ? this.userSubscriptions : this.systemSubscriptions;\n                    subscriptions[this.objNamespace + pattern] = true;\n                }\n                return tools.maybeCallbackWithError(callback, err);\n            });\n        }\n    }\n\n    private subscribeConfig(\n        pattern: string | string[],\n        options?: CallOptions | null,\n        callback?: ioBroker.ErrorCallback,\n    ): void {\n        utils.checkObjectRights(this, null, null, options, 'list', err => {\n            if (err) {\n                return tools.maybeCallbackWithRedisError(callback, err);\n            }\n            return this._subscribe(pattern, false, callback);\n        });\n    }\n\n    subscribe(pattern: string | string[], callback?: ioBroker.ErrorCallback): void;\n    subscribe(pattern: string | string[], options?: CallOptions, callback?: ioBroker.ErrorCallback): void;\n    subscribe(\n        pattern: string | string[],\n        options?: CallOptions | ioBroker.ErrorCallback | null,\n        callback?: ioBroker.ErrorCallback,\n    ): void {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n        return this.subscribeConfig(pattern, options, callback);\n    }\n\n    subscribeAsync(pattern: string | string[], options?: CallOptions): Promise<void> {\n        return new Promise((resolve, reject) =>\n            this.subscribe(pattern, options, err => (err ? reject(err) : resolve())),\n        );\n    }\n\n    // User has called the method without providing options\n    subscribeUser(pattern: string | string[], callback?: ioBroker.ErrorCallback): void;\n    // User has called the method by providing options\n    subscribeUser(pattern: string | string[], options?: CallOptions | null, callback?: ioBroker.ErrorCallback): void;\n    subscribeUser(pattern: string | string[], options?: any, callback?: ioBroker.ErrorCallback): void {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n        utils.checkObjectRights(this, null, null, options, 'list', err => {\n            if (err) {\n                return tools.maybeCallbackWithRedisError(callback, err);\n            }\n            return this._subscribe(pattern, true, callback);\n        });\n    }\n\n    subscribeUserAsync(pattern: string | string[], options: CallOptions): Promise<void> {\n        return new Promise((resolve, reject) =>\n            this.subscribeUser(pattern, options, err => (err ? reject(err) : resolve())),\n        );\n    }\n\n    private async _unsubscribe(pattern: string | string[], asUser: boolean): Promise<void> {\n        const subClient = asUser ? this.sub : this.subSystem;\n        if (!subClient) {\n            throw new Error(ERRORS.ERROR_DB_CLOSED);\n        }\n        if (Array.isArray(pattern)) {\n            for (const _pattern of pattern) {\n                this.log.silly(`${this.namespace} redis punsubscribe ${this.objNamespace}${_pattern}`);\n                await subClient.punsubscribe(this.objNamespace + _pattern);\n                const subscriptions = asUser ? this.userSubscriptions : this.systemSubscriptions;\n                if (subscriptions[this.objNamespace + _pattern] !== undefined) {\n                    delete subscriptions[this.objNamespace + _pattern];\n                }\n            }\n        } else {\n            this.log.silly(`${this.namespace} redis punsubscribe ${this.objNamespace}${pattern}`);\n\n            await subClient.punsubscribe(this.objNamespace + pattern);\n            const subscriptions = asUser ? this.userSubscriptions : this.systemSubscriptions;\n            if (subscriptions[this.objNamespace + pattern] !== undefined) {\n                delete subscriptions[this.objNamespace + pattern];\n            }\n        }\n    }\n\n    private unsubscribeConfig(\n        pattern: string | string[],\n        options?: CallOptions | null,\n        callback?: ioBroker.ErrorCallback,\n    ): void {\n        utils.checkObjectRights(this, null, null, options, 'list', async err => {\n            if (err) {\n                return tools.maybeCallbackWithRedisError(callback, err);\n            }\n            try {\n                await this._unsubscribe(pattern, false);\n                return tools.maybeCallback(callback);\n            } catch (e) {\n                return tools.maybeCallbackWithRedisError(callback, e);\n            }\n        });\n    }\n\n    // User has not provided any options\n    unsubscribe(pattern: string | string[], callback?: ioBroker.ErrorCallback): void;\n    // User has provided options\n    unsubscribe(pattern: string | string[], options?: CallOptions | null, callback?: ioBroker.ErrorCallback): void;\n    unsubscribe(\n        pattern: string | string[],\n        options?: CallOptions | ioBroker.ErrorCallback | null,\n        callback?: ioBroker.ErrorCallback,\n    ): void {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        return this.unsubscribeConfig(pattern, options, callback);\n    }\n\n    unsubscribeAsync(pattern: string | string[], options: CallOptions): Promise<void> {\n        return new Promise((resolve, reject) =>\n            this.unsubscribe(pattern, options, err => (err ? reject(err) : resolve())),\n        );\n    }\n\n    unsubscribeUser(pattern: string | string[], options?: CallOptions | null, callback?: ioBroker.ErrorCallback): void {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n        utils.checkObjectRights(this, null, null, options, 'list', async err => {\n            if (err) {\n                return tools.maybeCallbackWithError(callback, err);\n            }\n            try {\n                await this._unsubscribe(pattern, true);\n                return tools.maybeCallback(callback);\n            } catch (e) {\n                return tools.maybeCallbackWithRedisError(callback, e);\n            }\n        });\n    }\n\n    unsubscribeUserAsync(pattern: string | string[], options: CallOptions): Promise<void> {\n        return new Promise<void>((resolve, reject) =>\n            this.unsubscribeUser(pattern, options, err => (err ? reject(err) : resolve())),\n        );\n    }\n\n    private async _objectHelper(keys: string[], objs: any[]): Promise<void> {\n        if (!keys.length) {\n            return;\n        }\n        if (!this.client) {\n            throw new Error(ERRORS.ERROR_DB_CLOSED);\n        }\n        for (const id of keys) {\n            const obj = objs.shift();\n            const message = JSON.stringify(obj);\n            const commands = [];\n            if (this.useSets) {\n                if (obj.type) {\n                    // e.g. _design/ has no type\n                    // add the object to the set + set object atomic\n                    commands.push(['sadd', `${this.setNamespace}object.type.${obj.type}`, id]);\n                }\n\n                if (obj.common?.custom) {\n                    // add to \"common\" set\n                    commands.push(['sadd', `${this.setNamespace}object.common.custom`, id]);\n                }\n            }\n\n            if (!commands.length) {\n                // only set\n                await this.client.set(id, message);\n            } else {\n                // set all commands atomic\n                commands.push(['set', id, message]);\n                await this.client.multi(commands).exec();\n            }\n            await this.client.publish(id, message);\n        }\n    }\n\n    private _chownObject(pattern: string, options: CallOptions, callback?: ioBroker.ChownObjectCallback): void {\n        this.getKeys(\n            pattern,\n            options,\n            async (err, keys) => {\n                if (err) {\n                    return tools.maybeCallbackWithError(callback, err);\n                }\n                if (!this.client) {\n                    return tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);\n                }\n\n                if (!keys) {\n                    return tools.maybeCallbackWithError(callback, ERRORS.ERROR_NOT_FOUND);\n                }\n\n                let strObjects;\n                try {\n                    strObjects = await this.client.mget(keys);\n                } catch (e) {\n                    return tools.maybeCallbackWithRedisError(callback, e);\n                }\n                const filteredKeys = [];\n                const filteredObjs = [];\n\n                for (let i = 0; i < keys.length; i++) {\n                    const strObj = strObjects[i];\n                    let obj: null | ioBroker.AnyObject;\n                    try {\n                        obj = strObj ? JSON.parse(strObj) : null;\n                    } catch {\n                        this.log.error(`${this.namespace} Cannot parse JSON ${keys[i]}: ${strObj}`);\n                        continue;\n                    }\n                    if (!obj || !utils.checkObject(obj, options, CONSTS.ACCESS_WRITE)) {\n                        continue;\n                    }\n                    if (!obj.acl) {\n                        obj.acl = {\n                            owner: (this.defaultNewAcl && this.defaultNewAcl.owner) || CONSTS.SYSTEM_ADMIN_USER,\n                            ownerGroup:\n                                (this.defaultNewAcl && this.defaultNewAcl.ownerGroup) || CONSTS.SYSTEM_ADMIN_GROUP,\n                            object:\n                                (this.defaultNewAcl && this.defaultNewAcl.object) ||\n                                CONSTS.ACCESS_USER_RW | CONSTS.ACCESS_GROUP_READ | CONSTS.ACCESS_EVERY_READ, // '0644'\n                        };\n                        if (obj.type === 'state') {\n                            obj.acl!.state =\n                                (this.defaultNewAcl && this.defaultNewAcl.state) ||\n                                CONSTS.ACCESS_USER_RW | CONSTS.ACCESS_GROUP_READ | CONSTS.ACCESS_EVERY_READ; // '0644'\n                        }\n                    }\n                    obj.acl.owner = options.owner || obj.acl.owner;\n                    obj.acl.ownerGroup = options.ownerGroup || obj.acl.ownerGroup;\n                    filteredKeys.push(keys[i]);\n                    filteredObjs.push(obj);\n                }\n                try {\n                    await this._objectHelper(filteredKeys, filteredObjs);\n                } catch (e) {\n                    this.log.error(`${this.namespace} _chownObject error: ${e.message}`);\n                }\n                // @ts-expect-error TODO we are returning type Object for ease of use to devs, but formally these are AnyObjects, e.g. not guaranteed to have common\n                return tools.maybeCallbackWithError(callback, null, filteredObjs);\n            },\n            true,\n        );\n    }\n\n    chownObject(pattern: string, options: CallOptions, callback?: ioBroker.ChownObjectCallback): void | Promise<void> {\n        if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n        options = options || {};\n        options.acl = null;\n\n        if (typeof options !== 'object') {\n            options = { owner: options };\n        }\n\n        if (!options.ownerGroup && options.group) {\n            options.ownerGroup = options.group;\n        }\n        if (!options.owner && options.user) {\n            options.owner = options.user;\n        }\n\n        if (!options.owner) {\n            this.log.error(`${this.namespace} user is not defined`);\n            return tools.maybeCallbackWithError(callback, 'invalid parameter');\n        }\n\n        if (!options.ownerGroup) {\n            // get user group\n            this.getUserGroup(options.owner, (user, groups /* , permissions*/) => {\n                if (!groups || !groups[0]) {\n                    return tools.maybeCallbackWithError(callback, `user \"${options.owner}\" belongs to no group`);\n                }\n                options.ownerGroup = groups[0];\n\n                this.chownObject(pattern, options, callback);\n            });\n            return;\n        }\n\n        utils.checkObjectRights(this, null, null, options, CONSTS.ACCESS_WRITE, (err, options) => {\n            if (err) {\n                return tools.maybeCallbackWithRedisError(callback, err);\n            }\n            if (!options.acl.object || !options.acl.object.write) {\n                return tools.maybeCallbackWithError(callback, ERRORS.ERROR_PERMISSION);\n            }\n            return this._chownObject(pattern, options, callback);\n        });\n    }\n\n    chownObjectAsync(\n        pattern: string,\n        options: CallOptions,\n    ): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.ChownObjectCallback>> {\n        return new Promise((resolve, reject) =>\n            this.chownObject(pattern, options, (err, list) => (err ? reject(err) : resolve(list))),\n        );\n    }\n\n    private _chmodObject(pattern: string, options: CallOptions, callback?: ioBroker.ChownObjectCallback): void {\n        this.getKeys(\n            pattern,\n            options,\n            async (err, keys) => {\n                if (err) {\n                    return tools.maybeCallbackWithRedisError(callback, err);\n                }\n                if (!this.client) {\n                    return tools.maybeCallbackWithRedisError(callback, ERRORS.ERROR_DB_CLOSED);\n                }\n\n                if (!keys) {\n                    return tools.maybeCallbackWithError(callback, ERRORS.ERROR_NOT_FOUND);\n                }\n\n                let strObjs: (null | string)[];\n                try {\n                    strObjs = await this.client.mget(keys);\n                } catch (e) {\n                    return tools.maybeCallbackWithRedisError(callback, e);\n                }\n\n                const filteredKeys = [];\n                const filteredObjs = [];\n\n                for (let i = 0; i < keys.length; i++) {\n                    const strObj = strObjs[i];\n                    let obj: null | ioBroker.AnyObject;\n                    try {\n                        obj = strObj ? JSON.parse(strObj) : null;\n                    } catch {\n                        this.log.error(`${this.namespace} Cannot parse JSON ${keys[i]}: ${strObj}`);\n                        continue;\n                    }\n                    if (!utils.checkObject(obj, options, CONSTS.ACCESS_WRITE) || !obj) {\n                        continue;\n                    }\n                    if (!obj.acl) {\n                        obj.acl = {\n                            owner: (this.defaultNewAcl && this.defaultNewAcl.owner) || CONSTS.SYSTEM_ADMIN_USER,\n                            ownerGroup:\n                                (this.defaultNewAcl && this.defaultNewAcl.ownerGroup) || CONSTS.SYSTEM_ADMIN_GROUP,\n                            object:\n                                (this.defaultNewAcl && this.defaultNewAcl.object) ||\n                                CONSTS.ACCESS_USER_RW | CONSTS.ACCESS_GROUP_READ | CONSTS.ACCESS_EVERY_READ, // '0644'\n                        };\n                        if (obj.type === 'state') {\n                            obj.acl!.state =\n                                (this.defaultNewAcl && this.defaultNewAcl.state) ||\n                                CONSTS.ACCESS_USER_RW | CONSTS.ACCESS_GROUP_READ | CONSTS.ACCESS_EVERY_READ; // '0644'\n                        }\n                    }\n                    if (options.object !== undefined) {\n                        obj.acl.object = options.object;\n                    }\n\n                    if (options.state !== undefined && 'state' in obj.acl) {\n                        obj.acl.state = options.state;\n                    }\n\n                    filteredKeys.push(keys[i]);\n                    filteredObjs.push(obj);\n                }\n                try {\n                    await this._objectHelper(filteredKeys, filteredObjs);\n                } catch (e) {\n                    this.log.error(`${this.namespace} _chmodObject error: ${e.message}`);\n                }\n            },\n            true,\n        );\n    }\n\n    chmodObject(\n        pattern: string,\n        options: CallOptions | null,\n        callback?: ioBroker.ChownObjectCallback,\n    ): void | Promise<void> {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n        options = options || {};\n        options.acl = null;\n\n        if (typeof options !== 'object') {\n            options = { object: options };\n        }\n\n        if (options.mode && !options.object) {\n            options.object = options.mode;\n        }\n\n        if (options.object === undefined) {\n            this.log.error(`${this.namespace} mode is not defined`);\n            return tools.maybeCallbackWithError(callback, 'invalid parameter');\n        } else if (typeof options.mode === 'string') {\n            options.mode = parseInt(options.mode, 16);\n        }\n\n        utils.checkObjectRights(this, null, null, options, CONSTS.ACCESS_WRITE, (err, options) => {\n            if (err) {\n                return tools.maybeCallbackWithRedisError(callback, err);\n            }\n            if (!options.acl.file.write) {\n                return tools.maybeCallbackWithError(callback, ERRORS.ERROR_PERMISSION);\n            }\n            return this._chmodObject(pattern, options, callback);\n        });\n    }\n\n    chmodObjectAsync(\n        pattern: string,\n        options: CallOptions,\n    ): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.ChownObjectCallback>> {\n        return new Promise((resolve, reject) =>\n            this.chmodObject(pattern, options, (err, list) => (err ? reject(err) : resolve(list))),\n        );\n    }\n\n    private async _getObject(id: string, options: CallOptions, callback: ioBroker.GetObjectCallback): Promise<void> {\n        if (!this.client) {\n            return tools.maybeCallbackWithRedisError(callback, ERRORS.ERROR_DB_CLOSED);\n        }\n        if (!id || typeof id !== 'string') {\n            return tools.maybeCallbackWithError(callback, `invalid id ${JSON.stringify(id)}`);\n        }\n\n        let obj, err;\n        try {\n            obj = await this.client.get(this.objNamespace + id);\n        } catch (e) {\n            this.log.debug(`${this.namespace} redis get ${id}, error - ${e.message}`);\n            err = e;\n        }\n\n        try {\n            obj = obj ? JSON.parse(obj) : null;\n        } catch (e) {\n            this.log.warn(`${this.namespace} Cannot parse ${id} - ${obj}: ${e.message}`);\n            obj = null;\n            if (!err) {\n                err = e;\n            }\n        }\n        if (obj) {\n            // Check permissions\n            if (utils.checkObject(obj, options, CONSTS.ACCESS_READ)) {\n                return tools.maybeCallbackWithError(callback, null, obj);\n            }\n            return tools.maybeCallbackWithError(callback, ERRORS.ERROR_PERMISSION);\n        }\n        return tools.maybeCallbackWithRedisError(callback, err, obj);\n    }\n\n    // cb version with options\n    getObject<T extends string>(\n        id: T,\n        options: Options | undefined | null,\n        callback: ioBroker.GetObjectCallback<T>,\n    ): void;\n    // Promise version\n    getObject<T extends string>(id: T, options?: Options | null): ioBroker.GetObjectPromise<T>;\n    // no options but cb\n    getObject<T extends string>(id: T, callback: ioBroker.GetObjectCallback<T>): void;\n\n    getObject<T extends string>(\n        id: T,\n        options?: any,\n        callback?: ioBroker.GetObjectCallback<T>,\n    ): void | ioBroker.GetObjectPromise<T> {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n        if (!callback) {\n            return new Promise((resolve, reject) =>\n                this.getObject(id, options, (err, obj) => (err ? reject(err) : resolve(obj))),\n            );\n        }\n\n        if (typeof callback === 'function') {\n            if (options?.acl) {\n                options.acl = null;\n            }\n            utils.checkObjectRights(this, null, null, options, CONSTS.ACCESS_READ, (err, options) => {\n                if (err) {\n                    return tools.maybeCallbackWithError(callback, err);\n                }\n                return this._getObject(id, options, callback);\n            });\n        }\n    }\n\n    /**\n     *\n     * @param id\n     * @param options\n     * @deprecated use `getObject` without callback instead\n     */\n    getObjectAsync<T extends string>(\n        id: T,\n        options?: Record<string, any> | null,\n    ): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.GetObjectCallback<T>>> {\n        return new Promise((resolve, reject) =>\n            this.getObject(id, options, (err, obj) => (err ? reject(err) : resolve(obj))),\n        );\n    }\n\n    private async _getKeys(\n        pattern: string,\n        options: CallOptions,\n        callback?: ioBroker.GetKeysCallback,\n        dontModify?: boolean,\n    ): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.GetKeysCallback> | void> {\n        if (!this.client) {\n            return tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);\n        }\n        if (!pattern || typeof pattern !== 'string') {\n            return tools.maybeCallbackWithError(callback, `invalid pattern ${JSON.stringify(pattern)}`);\n        }\n\n        const r = new RegExp(tools.pattern2RegEx(pattern));\n        let keys;\n\n        try {\n            keys = await this._getKeysViaScan(this.objNamespace + pattern);\n        } catch (e) {\n            return tools.maybeCallbackWithRedisError(callback, e);\n        }\n\n        if (!this.client) {\n            return tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);\n        }\n\n        const result: string[] = [];\n        if (keys) {\n            keys.sort();\n            const result = [];\n            const dontCheck =\n                options.user === CONSTS.SYSTEM_ADMIN_USER ||\n                options.group !== CONSTS.SYSTEM_ADMIN_GROUP ||\n                (options.groups && options.groups.indexOf(CONSTS.SYSTEM_ADMIN_GROUP) !== -1);\n\n            if (dontCheck) {\n                for (let i = 0; i < keys.length; i++) {\n                    const id = keys[i].substring(this.objNamespaceL);\n                    if (r.test(id)) {\n                        if (!dontModify) {\n                            result.push(id);\n                        } else {\n                            result.push(keys[i]);\n                        }\n                    }\n                }\n                return tools.maybeCallbackWithError(callback, null, result);\n            }\n            // Check permissions\n            let metas: (string | null)[];\n            try {\n                metas = await this.client.mget(keys);\n            } catch (e) {\n                return tools.maybeCallbackWithRedisError(callback, e);\n            }\n            metas = metas || [];\n            for (let i = 0; i < keys.length; i++) {\n                const metaStr = metas[i];\n                let meta: ioBroker.AnyObject;\n                try {\n                    meta = metaStr ? JSON.parse(metaStr) : null;\n                } catch {\n                    this.log.error(`${this.namespace} Cannot parse JSON ${keys[i]}: ${metaStr}`);\n                    continue;\n                }\n\n                if (r.test(keys[i]) && utils.checkObject(meta, options, CONSTS.ACCESS_READ)) {\n                    if (!dontModify) {\n                        result.push(keys[i].substring(this.objNamespaceL));\n                    } else {\n                        result.push(keys[i]);\n                    }\n                }\n            }\n            return tools.maybeCallbackWithError(callback, null, result);\n        }\n        return tools.maybeCallbackWithError(callback, null, result);\n    }\n\n    // User has provided a callback, thus we call the callback function\n    getKeys(\n        pattern: string,\n        options: CallOptions | null | undefined,\n        callback: ioBroker.GetKeysCallback,\n        dontModify?: boolean,\n    ): void;\n    // User has provided callback without options, we call it\n    getKeys(pattern: string, callback: ioBroker.GetKeysCallback): void;\n    // User has provided no callback, we return a promise\n    getKeys(\n        pattern: string,\n        options?: CallOptions | null,\n        callback?: undefined,\n        dontModify?: boolean,\n    ): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.GetKeysCallback>>;\n    getKeys(\n        pattern: string,\n        options?: CallOptions | null | ioBroker.GetKeysCallback,\n        callback?: ioBroker.GetKeysCallback,\n        dontModify?: boolean,\n    ): void | Promise<ioBroker.CallbackReturnTypeOf<ioBroker.GetKeysCallback>> {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n        if (!callback) {\n            return new Promise((resolve, reject) =>\n                this.getKeys(pattern, options, (err, obj) => (err ? reject(err) : resolve(obj)), dontModify),\n            );\n        }\n        if (typeof callback === 'function') {\n            utils.checkObjectRights(this, null, null, options, 'list', (err, options) => {\n                if (err) {\n                    return tools.maybeCallbackWithRedisError(callback, err);\n                }\n                return this._getKeys(pattern, options, callback, dontModify);\n            });\n        }\n    }\n\n    getKeysAsync(id: string, options?: CallOptions): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.GetKeysCallback>> {\n        return this.getKeys(id, options);\n    }\n\n    private async _getObjects(\n        keys: string[],\n        options: CallOptions,\n        callback?: (err?: Error | null, objs?: ioBroker.AnyObject[]) => void,\n        dontModify?: boolean,\n    ): Promise<void | ioBroker.AnyObject[]> {\n        if (!keys) {\n            return tools.maybeCallbackWithError(callback, 'no keys');\n        }\n        if (!keys.length) {\n            return tools.maybeCallbackWithError(callback, null, []);\n        }\n\n        let _keys: string[];\n        if (!dontModify) {\n            _keys = [];\n            for (let i = 0; i < keys.length; i++) {\n                _keys[i] = this.objNamespace + keys[i];\n            }\n        } else {\n            _keys = keys;\n        }\n\n        if (!this.client) {\n            return tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);\n        }\n\n        let objs;\n        try {\n            objs = await this.client.mget(_keys);\n            this.settings.connection.enhancedLogging &&\n                this.log.silly(`${this.namespace} redis mget ${!objs ? 0 : objs.length} ${_keys.length}`);\n        } catch (e) {\n            this.log.warn(`${this.namespace} redis mget ${!objs ? 0 : objs.length} ${_keys.length}, err: ${e.message}`);\n        }\n        let result = [];\n\n        if (objs) {\n            const dontCheck =\n                options &&\n                (options.user === CONSTS.SYSTEM_ADMIN_USER ||\n                    options.group !== CONSTS.SYSTEM_ADMIN_GROUP ||\n                    (options.groups && options.groups.indexOf(CONSTS.SYSTEM_ADMIN_GROUP) !== -1));\n\n            if (!dontCheck) {\n                for (let i = 0; i < objs.length; i++) {\n                    const strObj = objs[i];\n                    let obj: ioBroker.AnyObject | null;\n                    try {\n                        obj = strObj ? JSON.parse(strObj) : null;\n                    } catch {\n                        this.log.error(`${this.namespace} Cannot parse JSON ${_keys[i]}: ${objs[i]}`);\n                        // TODO why permission error? It should better be something like parse error\n                        result.push({ error: ERRORS.ERROR_PERMISSION });\n                        continue;\n                    }\n                    if (utils.checkObject(obj, options, CONSTS.ACCESS_READ)) {\n                        result.push(obj);\n                    } else {\n                        result.push({ error: ERRORS.ERROR_PERMISSION });\n                    }\n                }\n            } else {\n                result = objs.map((obj, i) => {\n                    try {\n                        return obj !== null ? JSON.parse(obj) : obj;\n                    } catch {\n                        this.log.error(`${this.namespace} Cannot parse JSON ${_keys[i]}: ${obj}`);\n                        return null;\n                    }\n                });\n            }\n        }\n        return tools.maybeCallbackWithError(callback, null, result);\n    }\n\n    // No callback provided, we return a Promise\n    getObjects(keys: string[], options?: CallOptions | null): Promise<ioBroker.AnyObject[]>;\n    getObjects(keys: string[], callback: (err?: Error | null, objs?: ioBroker.AnyObject[]) => void): void;\n    // Callback provided, thus we call it\n    getObjects(\n        keys: string[],\n        options: CallOptions | null,\n        callback: (err?: Error | null, objs?: ioBroker.AnyObject[]) => void,\n        dontModify?: boolean,\n    ): void;\n    getObjects(\n        keys: string[],\n        options?: CallOptions | null,\n        callback?: (err?: Error | null, objs?: ioBroker.AnyObject[]) => void,\n        dontModify?: boolean,\n    ): void | Promise<ioBroker.AnyObject[]> {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n        if (!callback) {\n            return new Promise((resolve, reject) =>\n                // @ts-expect-error need to clarify, that objs is not undefined if no error is provided\n                this.getObjects(keys, options, (err, objs) => (err ? reject(err) : resolve(objs)), dontModify),\n            );\n        }\n\n        if (options?.acl) {\n            options.acl = null;\n        }\n        if (typeof callback === 'function') {\n            utils.checkObjectRights(this, null, null, options, CONSTS.ACCESS_READ, (err, options) => {\n                if (err) {\n                    return tools.maybeCallbackWithRedisError(callback, err);\n                }\n                return this._getObjects(keys, options, callback, dontModify);\n            });\n        }\n    }\n\n    getObjectsAsync(keys: string[], options?: CallOptions | null): Promise<ioBroker.AnyObject[]> {\n        return this.getObjects(keys, options);\n    }\n\n    private async _getObjectsByPattern(\n        pattern: string,\n        options: CallOptions,\n        callback: (err?: Error | null, objs?: ioBroker.AnyObject[]) => void,\n    ): Promise<ioBroker.AnyObject[] | void> {\n        if (!pattern || typeof pattern !== 'string') {\n            return tools.maybeCallbackWithError(callback, `invalid pattern ${JSON.stringify(pattern)}`);\n        }\n\n        if (!this.client) {\n            return tools.maybeCallbackWithRedisError(callback, ERRORS.ERROR_DB_CLOSED);\n        }\n\n        let keys;\n        try {\n            keys = await this._getKeysViaScan(this.objNamespace + pattern);\n        } catch (e) {\n            return tools.maybeCallbackWithRedisError(callback, e);\n        }\n        if (!this.client) {\n            return tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);\n        }\n\n        this.settings.connection.enhancedLogging &&\n            this.log.silly(`${this.namespace} redis keys ${keys.length} ${pattern}`);\n        this._getObjects(keys, options, callback, true);\n    }\n\n    getObjectsByPattern(pattern: string, options: CallOptions | null): Promise<ioBroker.AnyObject[] | void>;\n    getObjectsByPattern(\n        pattern: string,\n        options: CallOptions | null,\n        callback: (err?: Error | null, objs?: ioBroker.AnyObject[]) => void,\n    ): void;\n    getObjectsByPattern(\n        pattern: string,\n        options: CallOptions | null,\n        callback?: (err?: Error | null, objs?: ioBroker.AnyObject[]) => void,\n    ): void | Promise<ioBroker.AnyObject[] | void> {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n        if (!callback) {\n            return new Promise((resolve, reject) =>\n                this.getObjectsByPattern(pattern, options, (err, obj) => (err ? reject(err) : resolve(obj))),\n            );\n        }\n        if (options && options.acl) {\n            options.acl = null;\n        }\n        if (typeof callback === 'function') {\n            utils.checkObjectRights(this, null, null, options, CONSTS.ACCESS_READ, (err, options) => {\n                if (err) {\n                    return tools.maybeCallbackWithRedisError(callback, err);\n                }\n                return this._getObjectsByPattern(pattern, options, callback);\n            });\n        }\n    }\n\n    getObjectsByPatternAsync(pattern: string, options: CallOptions): Promise<ioBroker.AnyObject[] | void> {\n        return new Promise((resolve, reject) =>\n            this.getObjectsByPattern(pattern, options, (err, objs) => (err ? reject(err) : resolve(objs))),\n        );\n    }\n\n    private async _setObject<T extends string>(\n        id: T,\n        obj: ioBroker.SettableObject<ioBroker.ObjectIdToObjectType<T>>,\n        options: CallOptions,\n    ): ioBroker.SetObjectPromise {\n        if (!id || typeof id !== 'string' || utils.REG_CHECK_ID.test(id)) {\n            throw new Error(`Invalid ID: ${id}`);\n        }\n\n        if (!obj) {\n            this.log.warn(`${this.namespace} setObject: Argument object is null`);\n            throw new Error('obj is null');\n        }\n        if (!tools.isObject(obj)) {\n            this.log.warn(`${this.namespace} setObject: Argument object is no object: ${obj as any}`);\n            throw new Error('obj is no object');\n        }\n        if (!this.client) {\n            throw new Error(ERRORS.ERROR_DB_CLOSED);\n        }\n        // make a copy of object, because we will modify it\n        obj = deepClone(obj);\n\n        obj._id = id;\n\n        const oldObjStr = await this.client.get(this.objNamespace + id);\n\n        let oldObj: ioBroker.AnyObject | null;\n        try {\n            oldObj = oldObjStr ? JSON.parse(oldObjStr) : null;\n        } catch (e) {\n            this.log.error(`${this.namespace} Cannot parse ${id} - ${oldObjStr}: ${e.message}`);\n            throw new Error(`Cannot parse ${id} - ${oldObjStr}: ${e.message}`);\n        }\n\n        if (!tools.checkNonEditable(oldObj, obj)) {\n            throw new Error('Invalid password for update of vendor information');\n        }\n\n        // we need to know if custom has been added/deleted\n        const oldObjHasCustom = oldObj?.common?.custom;\n\n        // do not delete common settings, like \"history\" or \"mobile\". It can be erased only with \"null\"\n        if (oldObj?.common) {\n            for (const commonSetting of this.preserveSettings) {\n                // special case if \"custom\"\n                if (commonSetting === 'custom') {\n                    // we had broken objects where common.custom was a \"non-object\" ... check and fix them here, no warning because users will most likely have no idea how to deal with it\n                    if (\n                        oldObj.common.custom !== undefined &&\n                        oldObj.common.custom !== null &&\n                        !tools.isObject(oldObj.common.custom)\n                    ) {\n                        delete oldObj.common.custom;\n                    }\n                    // also remove invalid data from new objects ... should not happen because adapter.js checks too\n                    if (\n                        obj.common &&\n                        obj.common.custom !== undefined &&\n                        obj.common.custom !== null &&\n                        !tools.isObject(obj.common.custom)\n                    ) {\n                        delete obj.common.custom;\n                    }\n\n                    if ((!obj.common || !obj.common.custom) && oldObj.common.custom && obj.type === 'state') {\n                        obj.common = obj.common || {};\n                        obj.common.custom = oldObj.common.custom;\n                    } else if (obj.common?.custom && oldObj.common.custom) {\n                        // merge together\n                        for (const attr of Object.keys(oldObj.common.custom)) {\n                            if (obj.common.custom[attr] === null) {\n                                delete obj.common.custom[attr];\n                            } else if (obj.common.custom[attr] === undefined) {\n                                obj.common.custom[attr] = oldObj.common.custom[attr];\n                            }\n                        }\n                    }\n                    // remove custom if no one attribute inside\n                    if (obj.common?.custom) {\n                        for (const attr of Object.keys(obj.common.custom)) {\n                            if (obj.common.custom[attr] === null) {\n                                delete obj.common.custom[attr];\n                            }\n                        }\n\n                        if (!Object.keys(obj.common.custom).length) {\n                            delete obj.common.custom;\n                        }\n                    }\n                } else {\n                    // preserve only relevant for StateCommon TODO: maybe better a type guard to be specific\n                    let objCommon: ioBroker.StateCommon = obj.common as ioBroker.StateCommon;\n                    // remove settings if desired\n                    if (objCommon && objCommon[commonSetting] === null) {\n                        delete objCommon[commonSetting];\n                    } else if (\n                        // if old setting present and new setting is absent\n                        // @ts-expect-error https://github.com/ioBroker/adapter-core/issues/455\n                        oldObj.common[commonSetting] !== undefined &&\n                        (!objCommon || objCommon[commonSetting] === undefined)\n                    ) {\n                        objCommon = objCommon || {};\n                        // @ts-expect-error https://github.com/ioBroker/adapter-core/issues/455\n                        objCommon[commonSetting] = oldObj.common[commonSetting];\n                    }\n                }\n            }\n        }\n\n        if (obj.common && 'alias' in obj.common && obj.common.alias.id) {\n            if (typeof obj.common.alias.id === 'object') {\n                if (typeof obj.common.alias.id.write !== 'string' || typeof obj.common.alias.id.read !== 'string') {\n                    throw new Error('Invalid alias ID');\n                }\n\n                if (obj.common.alias.id.write.startsWith('alias.') || obj.common.alias.id.read.startsWith('alias.')) {\n                    throw new Error('Cannot make alias on alias');\n                }\n            } else {\n                if (typeof obj.common.alias.id !== 'string') {\n                    throw new Error('Invalid alias ID');\n                }\n\n                if (obj.common.alias.id.startsWith('alias.')) {\n                    throw new Error('Cannot make alias on alias');\n                }\n            }\n        }\n\n        if (oldObj?.acl && !obj.acl) {\n            obj.acl = oldObj.acl;\n        }\n\n        // add user default rights if no acl provided\n        if (this.defaultNewAcl && !obj.acl) {\n            obj.acl = deepClone(this.defaultNewAcl);\n            // @ts-expect-error need to change assignments logic\n            delete obj.acl.file;\n            if (obj.type !== 'state') {\n                // @ts-expect-error need to change assignments logic\n                delete obj.acl.state;\n            }\n            // take the current user as owner if given, but if admin we keep default\n            if (options.user && options.user !== CONSTS.SYSTEM_ADMIN_USER) {\n                obj.acl.owner = options.user;\n            }\n            // take the current group as owner if given, but if admin we keep default\n            if (options.group && options.group !== CONSTS.SYSTEM_ADMIN_GROUP) {\n                obj.acl.ownerGroup = options.group;\n            }\n        }\n\n        if (this.defaultNewAcl && obj.acl && !obj.acl.ownerGroup && options.group) {\n            obj.acl.ownerGroup = options.group;\n        }\n\n        const message = JSON.stringify(obj);\n\n        const commands = [];\n        if (this.useSets) {\n            if (obj.type && !oldObj?.type) {\n                // new object or oldObj had no type -> add to set + set object\n                commands.push(['sadd', `${this.setNamespace}object.type.${obj.type}`, this.objNamespace + id]);\n            } else if (obj.type && oldObj && oldObj.type && oldObj.type !== obj.type) {\n                // the old obj had a type which differs from the new type -> rem old, add new\n                commands.push(\n                    ['sadd', `${this.setNamespace}object.type.${obj.type}`, this.objNamespace + id],\n                    ['srem', `${this.setNamespace}object.type.${oldObj.type}`, this.objNamespace + id],\n                );\n            } else if (oldObj?.type && !obj.type) {\n                // the oldObj had a type, the new one has no -> rem\n                // @ts-expect-error TODO remove in v5.1, for now support objs without type for legacy design objects\n                commands.push(['srem', `${this.setNamespace}object.type.${obj.type}`, this.objNamespace + id]);\n            }\n\n            if (obj.common?.custom && !oldObjHasCustom) {\n                // we now have custom, old object had no custom\n                commands.push(['sadd', `${this.setNamespace}object.common.custom`, this.objNamespace + id]);\n            } else if (oldObjHasCustom && !obj.common?.custom) {\n                // we no longer have custom\n                commands.push(['srem', `${this.setNamespace}object.common.custom`, this.objNamespace + id]);\n            }\n        }\n\n        if (!commands.length) {\n            await this.client.set(this.objNamespace + id, message);\n        } else {\n            // set all commands atomic\n            commands.push(['set', this.objNamespace + id, message]);\n            await this.client.multi(commands).exec();\n        }\n\n        // object updated -> if type changed to meta -> cache\n        if (oldObj?.type === 'meta' && this.existingMetaObjects[id] === false) {\n            this.existingMetaObjects[id] = true;\n        }\n\n        await this.client.publish(this.objNamespace + id, message);\n        return { id };\n    }\n\n    setObject<T extends string>(\n        id: T,\n        obj: ioBroker.SettableObject<ioBroker.ObjectIdToObjectType<T>>,\n    ): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.SetObjectCallback>>;\n\n    // method called without options\n    setObject<T extends string>(\n        id: T,\n        obj: ioBroker.SettableObject<ioBroker.ObjectIdToObjectType<T>>,\n        callback?: ioBroker.SetObjectCallback,\n    ): void | Promise<ioBroker.CallbackReturnTypeOf<ioBroker.SetObjectCallback>>;\n\n    // method called with options\n    setObject<T extends string>(\n        id: T,\n        obj: ioBroker.SettableObject<ioBroker.ObjectIdToObjectType<T>>,\n        options?: CallOptions | null,\n        callback?: ioBroker.SetObjectCallback,\n    ): void | Promise<ioBroker.CallbackReturnTypeOf<ioBroker.SetObjectCallback>>;\n\n    /**\n     * set anew or update object\n     *\n     * This function writes the object into DB\n     *\n     * @param id ID of the object\n     * @param obj\n     * @param options options for access control are optional\n     * @param callback return function\n     */\n    setObject<T extends string>(\n        id: T,\n        obj: ioBroker.SettableObject<ioBroker.ObjectIdToObjectType<T>>,\n        options?: CallOptions | null,\n        callback?: ioBroker.SetObjectCallback,\n    ): void | Promise<ioBroker.CallbackReturnTypeOf<ioBroker.SetObjectCallback>> {\n        if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n        if (!callback) {\n            return new Promise((resolve, reject) =>\n                this.setObject(id, obj, options, (err, res) => (err ? reject(err) : resolve(res))),\n            );\n        }\n        if (options && options.acl) {\n            options.acl = null;\n        }\n\n        utils.checkObjectRights(this, null, null, options, CONSTS.ACCESS_WRITE, async err => {\n            // do not use options from checkObjectRights because this will mess up configured default acl\n            if (err) {\n                return tools.maybeCallbackWithRedisError(callback, err);\n            }\n            try {\n                const res = await this._setObject(id, obj, options || {});\n                return tools.maybeCallbackWithError(callback, null, res);\n            } catch (e) {\n                return tools.maybeCallbackWithError(callback, e);\n            }\n        });\n    }\n\n    /**\n     *\n     * @param id\n     * @param obj\n     * @param options\n     * @deprecated use `setObject` without callback instead\n     */\n    setObjectAsync(\n        id: string,\n        obj: ioBroker.SettableObject,\n        options?: CallOptions | null,\n    ): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.SetObjectCallback>> {\n        return new Promise((resolve, reject) =>\n            // @ts-expect-error TODO we are returning type Object for ease of use to devs, but formally these are AnyObjects, e.g. not guaranteed to have common\n            this.setObject(id, obj, options, (err, res) => (err ? reject(err) : resolve(res))),\n        );\n    }\n\n    private async _delObject(id: string, options: CallOptions): Promise<void> {\n        if (!id || typeof id !== 'string' || utils.REG_CHECK_ID.test(id)) {\n            throw new Error(`Invalid ID: ${id}`);\n        }\n        if (!this.client) {\n            throw new Error(ERRORS.ERROR_DB_CLOSED);\n        }\n\n        // read object\n        let oldObjStr: string | null;\n        try {\n            oldObjStr = await this.client.get(this.objNamespace + id);\n        } catch (e) {\n            this.log.warn(`${this.namespace} redis get ${id}, error - ${e.message}`);\n            // TODO: maybe better throw? We have not deleted the object\n            return;\n        }\n\n        if (!oldObjStr) {\n            // Not existent, so goal reached :-)\n            return;\n        }\n\n        let oldObj: ioBroker.AnyObject | null;\n        try {\n            oldObj = JSON.parse(oldObjStr);\n        } catch (e) {\n            this.log.warn(`${this.namespace} Cannot parse ${id} - ${oldObjStr}: ${e.message}`);\n            oldObj = null;\n        }\n\n        if (!utils.checkObject(oldObj, options, CONSTS.ACCESS_WRITE)) {\n            throw new Error(ERRORS.ERROR_PERMISSION);\n        } else {\n            const commands = [];\n\n            if (oldObj && this.useSets) {\n                if (oldObj.type) {\n                    // e.g. _design/ has no type\n                    // del the object from the set + del object atomic\n                    commands.push(['srem', `${this.setNamespace}object.type.${oldObj.type}`, this.objNamespace + id]);\n                }\n\n                if (oldObj.common?.custom) {\n                    // del the object from \"custom\" set\n                    commands.push(['srem', `${this.setNamespace}object.common.custom`, this.objNamespace + id]);\n                }\n            }\n\n            if (!commands.length) {\n                // only del\n                await this.client.del(this.objNamespace + id);\n            } else {\n                // set all commands atomic\n                commands.push(['del', this.objNamespace + id]);\n                await this.client.multi(commands).exec();\n            }\n\n            // object has been deleted -> remove from cached meta if there\n            if (this.existingMetaObjects[id]) {\n                this.existingMetaObjects[id] = false;\n            }\n\n            await this.client.publish(this.objNamespace + id, 'null');\n        }\n    }\n\n    // User has not passed options parameter\n    delObject(id: string, callback: ioBroker.ErrorCallback): void;\n    // User has  passed options parameter\n    delObject(id: string, options: CallOptions | null, callback: ioBroker.ErrorCallback): void;\n    // User has not passed a callback, we will return a Promise\n    delObject(id: string, options?: CallOptions | null): Promise<void>;\n\n    delObject(id: string, options: CallOptions | null, callback?: ioBroker.ErrorCallback): void | Promise<void> {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n        if (!callback) {\n            return new Promise((resolve, reject) =>\n                this.delObject(id, options, err => (err ? reject(err) : resolve())),\n            );\n        }\n\n        if (options?.acl) {\n            options.acl = null;\n        }\n        utils.checkObjectRights(this, null, null, options, CONSTS.ACCESS_DELETE, async (err, options) => {\n            if (err) {\n                return tools.maybeCallbackWithError(callback, err);\n            }\n            try {\n                await this._delObject(id, options);\n                return tools.maybeCallback(callback);\n            } catch (e) {\n                return tools.maybeCallbackWithRedisError(callback, e);\n            }\n        });\n    }\n\n    delObjectAsync(id: string, options?: CallOptions): Promise<void> {\n        return this.delObject(id, options);\n    }\n\n    /**\n     * Function to checks if comparisons will work according to the configured Locale\n     */\n    async isSystemLocaleSupported(): Promise<boolean> {\n        if (!this.client) {\n            throw new Error(ERRORS.ERROR_DB_CLOSED);\n        }\n\n        try {\n            const res = await this.client.eval(`return 'c-i.t' >= 'c.' and 'c-i.t' < 'c.\u9999'`, 0);\n            return res === null;\n        } catch (e) {\n            this.log.warn(`${this.namespace} Cannot check if locale is supported: ${e.message}`);\n            return true;\n        }\n    }\n\n    // this function is very ineffective. Because reads all objects and then process them\n    private async _applyViewFunc(\n        func: ObjectViewFunction,\n        params?: ioBroker.GetObjectViewParams,\n        options: CallOptions = {},\n    ): ioBroker.GetObjectViewPromise<any> {\n        if (!this.client) {\n            throw new Error(ERRORS.ERROR_DB_CLOSED);\n        }\n        const result: ViewFuncResult<any> = {\n            rows: [],\n        };\n\n        /**\n         * filters objs which are already present (and parse Errors) in array by property 'id'\n         *\n         * @param arr - Array of objects which should be filtered\n         * @param duplicateFiltering - if duplicates need to be filtered\n         */\n        const filterEntries = (arr: ObjectIdValue[], duplicateFiltering: boolean): ObjectIdValue[] => {\n            if (duplicateFiltering) {\n                const included = new Map<string, boolean>();\n                return arr.filter(obj => {\n                    if (included.has(obj.id) || obj.value === null) {\n                        return false;\n                    }\n                    included.set(obj.id, true);\n                    return true;\n                });\n            }\n            return arr.filter(obj => {\n                // only filter parse Errors\n                return obj.value !== null;\n            });\n        };\n\n        params = params || {};\n        params.startkey = params.startkey || '';\n        params.endkey = params.endkey || '\\u9999';\n        const wildcardPos = params.endkey.indexOf('\\u9999');\n        let wildCardLastPos = true;\n        if (wildcardPos !== -1 && wildcardPos !== params.endkey.length - 1) {\n            wildCardLastPos = false; // TODO do in LUA\n        }\n\n        // if start and end keys are equal modify end key\n        if (params.startkey === params.endkey) {\n            params.endkey = `${params.endkey}\\u0000`;\n        }\n\n        const matches: string[] | null = func.map.match(\n            /if\\s\\(doc\\.type\\s?===?\\s?'(\\w+)'\\)\\semit\\(([^,]+),\\s?doc\\s?\\)/,\n        );\n\n        // filter by type\n        if (wildCardLastPos && func?.map && this.scripts.filter && matches) {\n            let cursor = '0';\n            let filterRequired = true;\n            do {\n                if (!this.client) {\n                    throw new Error(ERRORS.ERROR_DB_CLOSED);\n                }\n\n                let objs: string[];\n                try {\n                    objs = await this.client.evalsha([\n                        this.scripts.filter,\n                        6,\n                        this.objNamespace,\n                        params.startkey,\n                        params.endkey,\n                        matches[1],\n                        cursor,\n                        `${this.setNamespace}object.type.${matches[1]}`,\n                    ]);\n                } catch (e) {\n                    this.log.warn(`${this.namespace} Cannot get view: ${e.message}`);\n                    throw e;\n                }\n                objs = objs || [];\n                // if real redis we will have e.g. [[objs..], '0'], else [{}, .., {}]\n                if (Array.isArray(objs[0])) {\n                    cursor = objs[1] || '0';\n                    objs = objs[0];\n                } else {\n                    cursor = '0';\n                    filterRequired = false;\n                }\n\n                const currRows = objs.map(_obj => {\n                    let obj: ioBroker.AnyObject;\n                    try {\n                        obj = JSON.parse(_obj);\n                    } catch {\n                        this.log.error(`${this.namespace} Cannot parse JSON: ${_obj}`);\n                        return { id: 'parseError', value: null };\n                    }\n\n                    if (!obj) {\n                        this.log.error(`${this.namespace} empty object!`);\n                        return { id: 'parseError', value: null };\n                    }\n\n                    if (matches[2] && matches[2].trim() === 'doc._id') {\n                        return { id: obj._id, value: obj };\n                    } else if (matches[2] && matches[2].trim() === 'doc.common.name' && obj.common) {\n                        if (typeof obj.common.name === 'object') {\n                            if (obj.common.name.en) {\n                                return { id: obj.common.name.en, value: obj };\n                            }\n                            return { id: JSON.stringify(obj.common.name), value: obj };\n                        }\n                        return { id: obj.common.name, value: obj };\n                    }\n                    this.log.error(`${this.namespace} Cannot filter \"${matches[2]}\": ${JSON.stringify(obj)}`);\n                    return { id: 'parseError', value: null };\n                });\n                if (currRows.length) {\n                    result.rows = [...result.rows, ...currRows];\n                } // endIf\n            } while (cursor !== '0');\n\n            // Now we have all objects -> calculate max if desired\n            if (func.reduce === '_stats') {\n                let max = null;\n                for (let i = 0; i < result.rows.length; i++) {\n                    if (max === null || result.rows[i].value > max) {\n                        max = result.rows[i].value;\n                    }\n                }\n                if (max !== null) {\n                    result.rows = [{ id: '_stats', value: { max: max } }];\n                } else {\n                    result.rows = [];\n                }\n            }\n\n            // apply filter if needed\n            result.rows = filterEntries(result.rows, filterRequired);\n            return result;\n        } else if (\n            // filter by script\n            wildCardLastPos &&\n            func?.map &&\n            this.scripts.script &&\n            func.map.includes('doc.common.engineType')\n        ) {\n            let cursor = '0';\n            let filterRequired = true;\n            do {\n                if (!this.client) {\n                    throw new Error(ERRORS.ERROR_DB_CLOSED);\n                }\n                let res: string[] | [objStrings: string[], cursor: string];\n                try {\n                    res = await this.client.evalsha([\n                        this.scripts.script,\n                        5,\n                        this.objNamespace,\n                        params.startkey,\n                        params.endkey,\n                        cursor,\n                        `${this.setNamespace}object.type.script`,\n                    ]);\n                } catch (e) {\n                    this.log.warn(`${this.namespace} Cannot get \"scripts\" view: ${e.message}`);\n                    throw e;\n                }\n\n                let objs: string[];\n                // if real redis we will have e.g. [[objs..], '0'], else [{}, .., {}]\n                if (Array.isArray(res[0])) {\n                    cursor = res[1] || '0';\n                    objs = res[0];\n                } else {\n                    cursor = '0';\n                    filterRequired = false;\n                    objs = res as string[];\n                }\n\n                const currRows = objs.map(obj => {\n                    try {\n                        const scriptObj: ioBroker.ScriptObject = JSON.parse(obj);\n                        return { id: scriptObj._id, value: scriptObj };\n                    } catch {\n                        this.log.error(`${this.namespace} Cannot parse JSON: ${obj}`);\n                        return { id: 'parseError', value: null };\n                    }\n                });\n                if (currRows.length) {\n                    result.rows = [...result.rows, ...currRows];\n                } // endIf\n            } while (cursor !== '0');\n\n            // apply filter if needed\n            result.rows = filterEntries(result.rows, filterRequired);\n            return result;\n        } else if (\n            // filter by hm-rega programs\n            wildCardLastPos &&\n            func?.map &&\n            this.scripts.programs &&\n            func.map.includes(\"doc.native.TypeName === 'PROGRAM'\")\n        ) {\n            let cursor = '0';\n            let filterRequired = true;\n            do {\n                if (!this.client) {\n                    throw new Error(ERRORS.ERROR_DB_CLOSED);\n                }\n\n                let objs: string[];\n                try {\n                    objs = await this.client.evalsha([\n                        this.scripts.programs,\n                        5,\n                        `${this.objNamespace}hm-rega.`,\n                        params.startkey,\n                        params.endkey,\n                        cursor,\n                        `${this.setNamespace}object.type.channel`,\n                    ]);\n                } catch (e) {\n                    this.log.warn(`${this.namespace} Cannot get view: ${e.message}`);\n                    throw e;\n                }\n                // if real redis we will have e.g. [[objs..], '0'], else [{}, .., {}]\n                if (Array.isArray(objs[0])) {\n                    cursor = objs[1] || '0';\n                    objs = objs[0];\n                } else {\n                    cursor = '0';\n                    filterRequired = false;\n                }\n\n                const currRows = objs.map(_obj => {\n                    try {\n                        const obj: ioBroker.AnyObject = JSON.parse(_obj);\n                        return { id: obj._id, value: obj };\n                    } catch {\n                        this.log.error(`${this.namespace} Cannot parse JSON: ${_obj}`);\n                        return { id: 'parseError', value: null };\n                    }\n                });\n                if (currRows.length) {\n                    result.rows = [...result.rows, ...currRows];\n                } // endIf\n            } while (cursor !== '0');\n\n            // apply filter if needed\n            result.rows = filterEntries(result.rows, filterRequired);\n            return result;\n        } else if (\n            // filter by hm-rega variables\n            wildCardLastPos &&\n            func?.map &&\n            this.scripts.variables &&\n            func.map.includes(\"doc.native.TypeName === 'ALARMDP'\")\n        ) {\n            let cursor = '0';\n            let filterRequired = true;\n            do {\n                if (!this.client) {\n                    throw new Error(ERRORS.ERROR_DB_CLOSED);\n                }\n\n                let objs: string[];\n                try {\n                    objs = await this.client.evalsha([\n                        this.scripts.variables,\n                        5,\n                        `${this.objNamespace}hm-rega.`,\n                        params.startkey,\n                        params.endkey,\n                        cursor,\n                        `${this.setNamespace}object.type.state`,\n                    ]);\n                } catch (e) {\n                    this.log.warn(`${this.namespace} Cannot get view ${e.message}`);\n                    throw e;\n                }\n                // if real redis we will have e.g. [[objs..], '0'], else [{}, .., {}]\n                if (Array.isArray(objs[0])) {\n                    cursor = objs[1] || '0';\n                    objs = objs[0];\n                } else {\n                    cursor = '0';\n                    filterRequired = false;\n                }\n\n                const currRows = objs.map(_obj => {\n                    try {\n                        const obj: ioBroker.AnyObject = JSON.parse(_obj);\n                        return { id: obj._id, value: obj };\n                    } catch {\n                        this.log.error(`${this.namespace} Cannot parse JSON: ${_obj}`);\n                        return { id: 'parseError', value: null };\n                    }\n                });\n                if (currRows.length) {\n                    result.rows = [...result.rows, ...currRows];\n                } // endIf\n            } while (cursor !== '0');\n\n            // apply filter if needed\n            result.rows = filterEntries(result.rows, filterRequired);\n            return result;\n        } else if (\n            // filter by custom, redis also returns if common.custom is not present\n            wildCardLastPos &&\n            func?.map &&\n            this.scripts.custom &&\n            func.map.includes('doc.common.custom')\n        ) {\n            let cursor = '0';\n            let filterRequired = true;\n            do {\n                if (!this.client) {\n                    throw new Error(ERRORS.ERROR_DB_CLOSED);\n                }\n                let objs: string[];\n                try {\n                    objs = await this.client.evalsha([\n                        this.scripts.custom,\n                        5,\n                        this.objNamespace,\n                        params.startkey,\n                        params.endkey,\n                        cursor,\n                        `${this.setNamespace}object.common.custom`,\n                    ]);\n                } catch (e) {\n                    this.log.warn(`${this.namespace} Cannot get view: ${e.message}`);\n                    throw e;\n                }\n                // if real redis we will have e.g. [[objs..], '0'], else [{}, .., {}]\n                if (Array.isArray(objs[0])) {\n                    cursor = objs[1] || '0';\n                    objs = objs[0];\n                } else {\n                    cursor = '0';\n                    filterRequired = false;\n                }\n\n                const useFullObject = func.map.includes('emit(doc._id, doc)');\n\n                for (const _obj of objs) {\n                    let obj: ioBroker.AnyObject;\n                    try {\n                        obj = JSON.parse(_obj);\n                    } catch {\n                        this.log.error(`${this.namespace} Cannot parse JSON: ${_obj}`);\n                        continue;\n                    }\n\n                    if (obj?.common?.custom) {\n                        if (useFullObject) {\n                            result.rows.push({ id: obj._id, value: obj });\n                        } else {\n                            result.rows.push({ id: obj._id, value: obj.common.custom });\n                        }\n                    }\n                }\n            } while (cursor !== '0');\n\n            // apply filter if needed\n            result.rows = filterEntries(result.rows, filterRequired);\n            return result;\n        }\n        if (!wildCardLastPos) {\n            this.log.debug(\n                `${this.namespace} Search can't be optimized because wildcard not at the end, fallback to keys!: ${func.map}`,\n            );\n        } else {\n            this.log.debug(`${this.namespace} No suitable Lua script, fallback to keys!: ${func.map}`);\n        }\n\n        let searchKeys = `${this.objNamespace}*`;\n        if (wildcardPos !== -1) {\n            // Wildcard included\n            searchKeys = this.objNamespace + params.endkey.replace(/\\u9999/g, '*');\n        }\n\n        let keys;\n        keys = await this._getKeysViaScan(searchKeys);\n\n        if (!this.client) {\n            throw new Error(ERRORS.ERROR_DB_CLOSED);\n        }\n\n        const endAfterWildcard = params.endkey.substr(wildcardPos + 1);\n        params.startkey = this.objNamespace + params.startkey;\n        params.endkey = this.objNamespace + params.endkey;\n\n        keys = keys.sort().filter(key => {\n            if (key && !utils.REG_CHECK_ID.test(key)) {\n                if (params && wildcardPos > 0) {\n                    if (params.startkey && key < params.startkey) {\n                        return false;\n                    }\n                    if (params.endkey && key > params.endkey) {\n                        return false;\n                    }\n                } else if (params && wildcardPos === 0) {\n                    if (!key.endsWith(endAfterWildcard)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            return false;\n        });\n\n        let objs: (null | string)[];\n        try {\n            objs = await this.client.mget(keys);\n        } catch {\n            objs = [];\n        }\n\n        const _emit_ = (id: string, obj: ioBroker.AnyObject): void => {\n            result.rows.push({ id: id, value: obj });\n        };\n\n        const f = eval(`(${func.map.replace(/^function\\(([a-z0-9A-Z_]+)\\)/g, 'function($1, emit)')})`);\n\n        for (let i = 0; i < keys.length; i++) {\n            const strObj = objs[i];\n            let obj: ioBroker.AnyObject | null;\n            try {\n                obj = strObj !== null ? JSON.parse(strObj) : null;\n            } catch {\n                this.log.error(`${this.namespace} Cannot parse JSON ${keys[i]}: ${objs[i]}`);\n                continue;\n            }\n            if (!utils.checkObject(obj, options, CONSTS.ACCESS_READ)) {\n                continue;\n            }\n\n            if (obj) {\n                try {\n                    f(obj, _emit_);\n                } catch (e) {\n                    this.log.error(`${this.namespace} Cannot execute map: ${e.message}`);\n                }\n            }\n        }\n        // Calculate max\n        if (func.reduce === '_stats') {\n            let max = null;\n            for (let i = 0; i < result.rows.length; i++) {\n                if (max === null || result.rows[i].value > max) {\n                    max = result.rows[i].value;\n                }\n            }\n            if (max !== null) {\n                result.rows = [{ id: '_stats', value: { max: max } }];\n            } else {\n                result.rows = [];\n            }\n        }\n        return result;\n    }\n\n    private async _getObjectView<Design extends string = string, Search extends string = string>(\n        design: Design,\n        search: Search,\n        params?: ioBroker.GetObjectViewParams,\n        options?: CallOptions,\n    ): ioBroker.GetObjectViewPromise<ioBroker.InferGetObjectViewItemType<Design, Search>> {\n        if (!this.client) {\n            throw new Error(ERRORS.ERROR_DB_CLOSED);\n        }\n\n        let obj;\n        try {\n            obj = await this.client.get(`${this.objNamespace}_design/${design}`);\n        } catch (e) {\n            this.log.error(`${this.namespace} Cannot find view \"${design}\" for search \"${search}\" : ${e.message}`);\n            throw new Error(`Cannot find view \"${design}\"`);\n        }\n\n        if (obj) {\n            try {\n                obj = JSON.parse(obj);\n            } catch {\n                this.log.error(`${this.namespace} Cannot parse JSON: ${obj}`);\n                throw new Error(`Cannot parse JSON: \"_design/${design}\" / \"${obj}\"`);\n            }\n\n            if (obj.views?.[search]) {\n                return this._applyViewFunc(obj.views[search], params, options);\n            }\n            this.log.error(`${this.namespace} Cannot find search \"${search}\" in \"${design}\"`);\n            throw new Error(`Cannot find search \"${search}\" in \"${design}\"`);\n        } else {\n            this.log.error(`${this.namespace} Cannot find view \"${design}\" for search \"${search}\"`);\n            throw new Error(`Cannot find view \"${design}\"`);\n        }\n    }\n\n    // no callback provided, thus we return a result Promise\n    getObjectView<Design extends string = string, Search extends string = string>(\n        design: Design,\n        search: Search,\n        params?: ioBroker.GetObjectViewParams,\n        options?: CallOptions | null,\n    ): ioBroker.GetObjectViewPromise<ioBroker.InferGetObjectViewItemType<Design, Search>>;\n\n    // callback and options provided, we send result in callback\n    getObjectView<Design extends string = string, Search extends string = string>(\n        design: Design,\n        search: Search,\n        params: ioBroker.GetObjectViewParams | undefined,\n        options: CallOptions | undefined | null,\n        callback: ioBroker.GetObjectViewCallback<ioBroker.InferGetObjectViewItemType<Design, Search>>,\n    ): void;\n\n    // callback but no options provided, we send result in callback\n    getObjectView<Design extends string = string, Search extends string = string>(\n        design: Design,\n        search: Search,\n        params: ioBroker.GetObjectViewParams,\n        callback: ioBroker.GetObjectViewCallback<ioBroker.InferGetObjectViewItemType<Design, Search>>,\n    ): void;\n\n    getObjectView<Design extends string = string, Search extends string = string>(\n        design: Design,\n        search: Search,\n        params?: ioBroker.GetObjectViewParams,\n        options?: any,\n        callback?: ioBroker.GetObjectViewCallback<ioBroker.InferGetObjectViewItemType<Design, Search>>,\n    ): void | ioBroker.GetObjectViewPromise<ioBroker.InferGetObjectViewItemType<Design, Search>> {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n        if (!callback) {\n            return new Promise((resolve, reject) =>\n                this.getObjectView(design, search, params, options, (err, obj) => (err ? reject(err) : resolve(obj!))),\n            );\n        }\n\n        if (options?.acl) {\n            options.acl = null;\n        }\n\n        if (typeof callback === 'function') {\n            utils.checkObjectRights(this, null, null, options, 'list', async (err, options) => {\n                if (err) {\n                    return tools.maybeCallbackWithRedisError(callback, err);\n                }\n                try {\n                    const res = await this._getObjectView(design, search, params, options);\n                    return tools.maybeCallbackWithError(callback, null, res);\n                } catch (e) {\n                    return tools.maybeCallbackWithRedisError(callback, e);\n                }\n            });\n        }\n    }\n\n    getObjectViewAsync<Design extends string = string, Search extends string = string>(\n        design: Design,\n        search: Search,\n        params?: ioBroker.GetObjectViewParams,\n        options?: CallOptions,\n    ): ioBroker.GetObjectViewPromise<ioBroker.InferGetObjectViewItemType<Design, Search>> {\n        return this.getObjectView(design, search, params, options);\n    }\n\n    private async _getObjectList(\n        params: ioBroker.GetObjectListParams,\n        options: CallOptions,\n    ): ioBroker.GetObjectListPromise {\n        if (!this.client) {\n            throw new Error(ERRORS.ERROR_DB_CLOSED);\n        }\n\n        params = params || {};\n        params.startkey = params.startkey || '';\n        params.endkey = params.endkey || '\\u9999';\n        const pattern =\n            params.endkey.substring(0, params.startkey.length) === params.startkey\n                ? `${this.objNamespace + params.startkey}*`\n                : `${this.objNamespace}*`;\n\n        // todo: use lua script for this\n        const keys = await this._getKeysViaScan(pattern);\n\n        if (!this.client) {\n            throw new Error(ERRORS.ERROR_DB_CLOSED);\n        }\n\n        const _keys = [];\n        for (const key of keys) {\n            const id = key.substring(this.objNamespaceL);\n            if (params.startkey && id < params.startkey) {\n                continue;\n            }\n            if (params.endkey && id > params.endkey) {\n                continue;\n            }\n            if (!id || utils.REG_CHECK_ID.test(id) || id.match(/\\|file\\$%\\$/)) {\n                continue;\n            }\n            if (!params.include_docs && id[0] === '_') {\n                continue;\n            }\n            _keys.push(key);\n        }\n        _keys.sort();\n        let objs;\n        try {\n            objs = await this.client.mget(_keys);\n        } catch {\n            // ignore\n        }\n        // return rows with id and doc\n        const result: ObjectListResult = {\n            rows: [],\n        };\n        if (objs) {\n            for (let i = 0; i < objs.length; i++) {\n                const strObj = objs[i];\n                let obj: ioBroker.AnyObject | null;\n                try {\n                    obj = strObj ? JSON.parse(strObj) : null;\n                } catch {\n                    this.log.error(`${this.namespace} Cannot parse JSON ${_keys[i]}: ${objs[i]}`);\n                    continue;\n                }\n\n                if (!obj || !utils.checkObject(obj, options, CONSTS.ACCESS_READ)) {\n                    continue;\n                }\n                // @ts-expect-error TODO we are returning type Object for ease of use to devs, but formally these are AnyObjects, e.g. not guaranteed to have common\n                result.rows.push({ id: obj._id, value: obj, doc: obj });\n            }\n        }\n        return result;\n    }\n\n    // getObjectList is called without options without callback, we return a promise\n    getObjectList(params: ioBroker.GetObjectListParams): ioBroker.GetObjectListPromise;\n\n    // getObjectList is called without callback, thus we return a promise\n    getObjectList(params: ioBroker.GetObjectListParams, options?: CallOptions | null): ioBroker.GetObjectListPromise;\n\n    // getObjectList is called without options with callback\n    getObjectList(\n        params: ioBroker.GetObjectListParams,\n        callback: ioBroker.GetObjectListCallback<ioBroker.Object>,\n    ): void;\n\n    // getObjectList is called with options\n    getObjectList<T extends ioBroker.GetObjectListCallback<ioBroker.Object>>(\n        params: ioBroker.GetObjectListParams,\n        options?: CallOptions | null,\n        callback?: T,\n    ): T extends ioBroker.GetObjectListCallback<ioBroker.Object> ? void : ioBroker.GetObjectListPromise;\n\n    getObjectList(\n        params: ioBroker.GetObjectListParams,\n        options?: CallOptions | null,\n        callback?: ioBroker.GetObjectListCallback<ioBroker.Object>,\n    ): void | ioBroker.GetObjectListPromise {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n        if (!callback) {\n            return new Promise((resolve, reject) =>\n                this.getObjectList(params, options, (err, obj) => (err ? reject(err) : resolve(obj!))),\n            );\n        }\n\n        if (options?.acl) {\n            options.acl = null;\n        }\n\n        if (typeof callback === 'function') {\n            utils.checkObjectRights(this, null, null, options, 'list', async (err, options) => {\n                if (err) {\n                    return tools.maybeCallbackWithRedisError(callback, err);\n                }\n                try {\n                    const res = await this._getObjectList(params, options || {});\n                    return tools.maybeCallbackWithError(callback, null, res);\n                } catch (e) {\n                    return tools.maybeCallbackWithError(callback, e);\n                }\n            });\n        }\n    }\n\n    getObjectListAsync(params: ioBroker.GetObjectListParams, options?: CallOptions): ioBroker.GetObjectListPromise {\n        return this.getObjectList(params, options);\n    }\n\n    // could be optimized, to read object only once. Now it will read 3 times\n    private async _extendObject<T extends string>(\n        id: T,\n        obj: ioBroker.PartialObject<ioBroker.ObjectIdToObjectType<T, 'write'>>,\n        options: CallOptions,\n        callback?: (err?: Error | null, obj?: ObjectIdValue, id?: string) => void,\n    ): Promise<[ObjectIdValue, string] | void> {\n        if (!id || typeof id !== 'string' || utils.REG_CHECK_ID.test(id)) {\n            // @ts-expect-error we fix when removing cb\n            return tools.maybeCallbackWithError(callback, `Invalid ID: ${id}`);\n        }\n        if (!this.client) {\n            return tools.maybeCallbackWithRedisError(callback, ERRORS.ERROR_DB_CLOSED);\n        }\n\n        let oldObj;\n        try {\n            oldObj = await this.client.get(this.objNamespace + id);\n        } catch (e) {\n            return tools.maybeCallbackWithRedisError(callback, e);\n        }\n\n        try {\n            oldObj = oldObj ? JSON.parse(oldObj) : null;\n        } catch {\n            this.log.error(`${this.namespace} Cannot parse JSON ${id}: ${oldObj}`);\n            // @ts-expect-error we fix when removing cb\n            return tools.maybeCallbackWithError(callback, `Cannot parse JSON ${id}: ${oldObj}`);\n        }\n        if (!utils.checkObject(oldObj, options, CONSTS.ACCESS_WRITE)) {\n            return tools.maybeCallbackWithError(callback, ERRORS.ERROR_PERMISSION);\n        }\n\n        let _oldObj;\n        if (oldObj?.nonEdit) {\n            // copy object\n            _oldObj = deepClone(oldObj);\n        }\n\n        // we need to know if custom has been added/deleted\n        const oldObjHasCustom = !!oldObj?.common?.custom;\n\n        oldObj = oldObj || {};\n        obj = deepClone(obj); // copy here to prevent \"sandboxed\" objects from JavaScript adapter\n        if (\n            oldObj.common &&\n            oldObj.common.custom !== undefined &&\n            oldObj.common.custom !== null &&\n            !tools.isObject(oldObj.common.custom)\n        ) {\n            // custom has to be an object, else clean up\n            delete oldObj.common.custom;\n        }\n\n        // we need to check if type has changed\n        const oldType = oldObj.type;\n\n        oldObj = extend(true, oldObj, obj);\n        oldObj._id = id;\n\n        // add user default rights\n        if (this.defaultNewAcl && !oldObj.acl) {\n            oldObj.acl = deepClone(this.defaultNewAcl);\n            delete oldObj.acl.file;\n            if (oldObj.type !== 'state') {\n                delete oldObj.acl.state;\n            }\n\n            if (options.owner) {\n                oldObj.acl.owner = options.owner;\n\n                if (!options.ownerGroup) {\n                    oldObj.acl.ownerGroup = null;\n                    return void this.getUserGroup(options.owner, (user, groups /*, permissions */) => {\n                        if (!groups || !groups[0]) {\n                            options.ownerGroup =\n                                (this.defaultNewAcl && this.defaultNewAcl.ownerGroup) || CONSTS.SYSTEM_ADMIN_GROUP;\n                        } else {\n                            options.ownerGroup = groups[0];\n                        }\n                        this._extendObject(id, obj, options, callback);\n                    });\n                }\n            }\n        }\n\n        if (this.defaultNewAcl && options.ownerGroup && oldObj.acl && !oldObj.acl.ownerGroup) {\n            oldObj.acl.ownerGroup = options.ownerGroup;\n        }\n\n        if (obj.common && 'alias' in obj.common && obj.common.alias.id) {\n            if (typeof obj.common.alias.id === 'object') {\n                if (typeof obj.common.alias.id.write !== 'string' || typeof obj.common.alias.id.read !== 'string') {\n                    return tools.maybeCallbackWithError(callback, 'Invalid alias ID');\n                }\n\n                if (obj.common.alias.id.write.startsWith('alias.') || obj.common.alias.id.read.startsWith('alias.')) {\n                    return tools.maybeCallbackWithError(callback, 'Cannot make alias on alias');\n                }\n            } else {\n                if (typeof obj.common.alias.id !== 'string') {\n                    return tools.maybeCallbackWithError(callback, 'Invalid alias ID');\n                }\n\n                if (obj.common.alias.id.startsWith('alias.')) {\n                    return tools.maybeCallbackWithError(callback, 'Cannot make alias on alias');\n                }\n            }\n        }\n\n        if (_oldObj && !tools.checkNonEditable(_oldObj, oldObj)) {\n            return tools.maybeCallbackWithError(callback, 'Invalid password for update of vendor information');\n        }\n        const message = JSON.stringify(oldObj);\n\n        try {\n            const commands = [];\n            if (this.useSets) {\n                // what is called oldObj is acutally the obj we set, because it has been extended\n                if (oldObj.type && !oldType) {\n                    // new object or oldObj had no type -> add to set + set object\n                    commands.push(['sadd', `${this.setNamespace}object.type.${obj.type}`, this.objNamespace + id]);\n                } else if (oldObj.type && oldType && oldObj.type !== oldType) {\n                    // the old obj had a type which differs from the new type -> rem old, add new\n                    commands.push(\n                        ['sadd', `${this.setNamespace}object.type.${obj.type}`, this.objNamespace + id],\n                        ['srem', `${this.setNamespace}object.type.${oldObj.type}`, this.objNamespace + id],\n                    );\n                } else if (oldType && !oldObj.type) {\n                    // the oldObj had a type, the new one has no -> rem\n                    commands.push(['srem', `${this.setNamespace}object.type.${obj.type}`, this.objNamespace + id]);\n                }\n            }\n\n            if (oldObj.common && oldObj.common.custom && !oldObjHasCustom) {\n                // we now have custom, old object had no custom\n                commands.push(['sadd', `${this.setNamespace}object.common.custom`, this.objNamespace + id]);\n            } else if (oldObjHasCustom && (!oldObj.common || !oldObj.common.custom)) {\n                // we no longer have custom\n                commands.push(['srem', `${this.setNamespace}object.common.custom`, this.objNamespace + id]);\n            }\n\n            if (!commands.length) {\n                await this.client.set(this.objNamespace + id, message);\n            } else {\n                // set all commands atomic\n                commands.push(['set', this.objNamespace + id, message]);\n                await this.client.multi(commands).exec();\n            }\n\n            // extended -> if its now type meta and currently marked as not -> cache\n            if (this.existingMetaObjects[id] === false && oldObj && oldObj.type === 'meta') {\n                this.existingMetaObjects[id] = true;\n            }\n\n            await this.client.publish(this.objNamespace + id, message);\n            return tools.maybeCallbackWithError(callback, null, { id: id, value: oldObj }, id);\n        } catch (e) {\n            return tools.maybeCallbackWithRedisError(callback, e);\n        }\n    }\n\n    extendObject<T extends string>(\n        id: T,\n        obj: ioBroker.PartialObject<ioBroker.ObjectIdToObjectType<T, 'write'>>,\n        options?: ioBroker.ExtendObjectOptions | null,\n    ): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.ExtendObjectCallback>>;\n    extendObject<T extends string>(\n        id: T,\n        obj: ioBroker.PartialObject<ioBroker.ObjectIdToObjectType<T, 'write'>>,\n        options?: ioBroker.ExtendObjectOptions | null,\n        callback?: ioBroker.ExtendObjectCallback,\n    ): void | Promise<ioBroker.CallbackReturnTypeOf<ioBroker.ExtendObjectCallback>>;\n    extendObject<T extends string>(\n        id: T,\n        obj: ioBroker.PartialObject<ioBroker.ObjectIdToObjectType<T, 'write'>>,\n        options?: ioBroker.ExtendObjectOptions | null,\n        callback?: ioBroker.ExtendObjectCallback,\n    ): void | Promise<ioBroker.CallbackReturnTypeOf<ioBroker.ExtendObjectCallback>> {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n        if (!callback) {\n            return new Promise((resolve, reject) =>\n                this.extendObject(id, obj, options, (err, res) => (err ? reject(err) : resolve(res))),\n            );\n        }\n\n        if (options && options.acl) {\n            options.acl = null;\n        }\n\n        utils.checkObjectRights(this, null, null, options, CONSTS.ACCESS_WRITE, (err, options) => {\n            if (err) {\n                return tools.maybeCallbackWithRedisError(callback, err);\n            }\n            // @ts-expect-error TODO we are returning type Object for ease of use to devs, but formally these are AnyObjects, e.g. not guaranteed to have common\n            return this._extendObject(id, obj, options, callback);\n        });\n    }\n\n    extendObjectAsync(\n        id: string,\n        obj: Partial<ioBroker.AnyObject>,\n        options?: ioBroker.ExtendObjectOptions,\n    ): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.ExtendObjectCallback>> {\n        return new Promise((resolve, reject) =>\n            this.extendObject(id, obj, options || null, (err, res) => (err ? reject(err) : resolve(res))),\n        );\n    }\n\n    /**\n     * Returns the object id if found\n     *\n     * @param idOrName\n     * @param type\n     * @param options\n     * @param callback\n     */\n    private _findObject(\n        idOrName: string,\n        type: string | null,\n        options: CallOptions,\n        callback?: ioBroker.FindObjectCallback,\n    ): void {\n        this._getObject(idOrName, options, (err, obj) => {\n            // Assume it is ID\n            if (\n                obj &&\n                utils.checkObject(obj, options, CONSTS.ACCESS_READ) &&\n                (!type || (obj.common && obj.common.type === type))\n            ) {\n                return tools.maybeCallbackWithError(callback, null, idOrName, obj.common.name);\n            }\n            this._getKeys(\n                '*',\n                options,\n                async (err, keys) => {\n                    if (!this.client) {\n                        return tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);\n                    }\n\n                    if (!keys || err) {\n                        return tools.maybeCallbackWithError(callback, err);\n                    }\n\n                    let objs;\n                    try {\n                        objs = await this.client.mget(keys);\n                    } catch (e) {\n                        return tools.maybeCallbackWithRedisError(callback, e);\n                    }\n                    objs = objs || [];\n                    // Assume it is name\n                    for (let i = 0; i < keys.length; i++) {\n                        const strObj = objs[i];\n                        let obj: ioBroker.AnyObject | null;\n                        try {\n                            obj = strObj ? JSON.parse(strObj) : null;\n                        } catch {\n                            this.log.error(`${this.namespace} Cannot parse JSON ${keys[i]}: ${objs[i]}`);\n                            continue;\n                        }\n                        if (\n                            obj?.common &&\n                            obj.common.name === idOrName &&\n                            (!type || ('type' in obj.common && obj.common.type === type))\n                        ) {\n                            return tools.maybeCallbackWithError(callback, null, obj._id, idOrName);\n                        }\n                    }\n                    return tools.maybeCallbackWithError(callback, null, undefined, idOrName);\n                },\n                true,\n            );\n        });\n    }\n\n    // The user has provided a callback, thus we call it\n    findObject(\n        idOrName: string,\n        type: string | null,\n        options: CallOptions | null,\n        callback: ioBroker.FindObjectCallback,\n    ): void;\n\n    // The user has provided a callback without options\n    findObject(idOrName: string, type: string | null, callback: ioBroker.FindObjectCallback): void;\n\n    // No callback provided by user, we return a promise\n    findObject(\n        idOrName: string,\n        type?: string | null,\n        options?: CallOptions | null,\n    ): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.FindObjectCallback>>;\n\n    findObject(\n        idOrName: string,\n        type: string | null,\n        options: CallOptions | null,\n        callback?: ioBroker.FindObjectCallback,\n    ): void | Promise<ioBroker.CallbackReturnTypeOf<ioBroker.FindObjectCallback>> {\n        if (typeof type === 'function') {\n            callback = type;\n            options = null;\n            type = null;\n        }\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n        if (!callback) {\n            return new Promise((resolve, reject) =>\n                this.findObject(idOrName, type, options, (err, id, _idOrName) => (err ? reject(err) : resolve(id))),\n            );\n        }\n\n        if (options?.acl) {\n            options.acl = null;\n        }\n\n        if (typeof callback === 'function') {\n            utils.checkObjectRights(this, null, null, options, CONSTS.ACCESS_LIST, (err, options) => {\n                if (err) {\n                    return tools.maybeCallbackWithError(callback, err);\n                }\n                return this._findObject(idOrName, type, options, callback);\n            });\n        }\n    }\n\n    // can be called only from js-controller\n    addPreserveSettings(settings: string[] | string): void {\n        if (!Array.isArray(settings)) {\n            settings = [settings];\n        }\n\n        for (const setting of settings) {\n            // @ts-expect-error TODO: decide https://github.com/ioBroker/ioBroker.js-controller/issues/507\n            if (this.preserveSettings.indexOf(setting) === -1) {\n                // @ts-expect-error TODO: decide https://github.com/ioBroker/ioBroker.js-controller/issues/507\n                this.preserveSettings.push(setting);\n            }\n        }\n    }\n\n    private async _destroyDBHelper(keys: string[], callback: ioBroker.ErrorCallback): Promise<void> {\n        if (!keys || !keys.length) {\n            return tools.maybeCallback(callback);\n        }\n        if (!this.client) {\n            return tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);\n        }\n\n        for (const id of keys) {\n            try {\n                await this.client.del(id);\n            } catch {\n                // ignore\n            }\n        }\n\n        return tools.maybeCallback(callback);\n    }\n\n    private async _destroyDB(callback: ioBroker.ErrorCallback): Promise<void> {\n        if (!this.client) {\n            return tools.maybeCallbackWithError(callback, ERRORS.ERROR_DB_CLOSED);\n        }\n        try {\n            const keys = await this._getKeysViaScan(`${this.redisNamespace}*`);\n            return this._destroyDBHelper(keys, callback);\n        } catch (e) {\n            return tools.maybeCallbackWithRedisError(callback, e);\n        }\n    }\n\n    destroyDB(options: CallOptions | null | undefined, callback: ioBroker.ErrorCallback): void {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n        options = options || {};\n\n        utils.checkObjectRights(this, null, null, options, CONSTS.ACCESS_WRITE, (err, options) => {\n            if (err) {\n                return tools.maybeCallbackWithRedisError(callback, err);\n            }\n            if (!options.acl.file.write || options.user !== CONSTS.SYSTEM_ADMIN_USER) {\n                return tools.maybeCallbackWithError(callback, ERRORS.ERROR_PERMISSION);\n            }\n            return this._destroyDB(callback);\n        });\n    }\n\n    destroyDBAsync(options?: CallOptions): Promise<void> {\n        return new Promise<void>((resolve, reject) => this.destroyDB(options, err => (err ? reject(err) : resolve())));\n    }\n\n    // Destructor of the class. Called by shutting down.\n    async destroy(): Promise<void> {\n        this.stop = true;\n        if (this.client) {\n            try {\n                await this.client.quit();\n                this.client.removeAllListeners();\n                this.client = null;\n            } catch {\n                // ignore error\n            }\n        }\n        if (this.sub) {\n            try {\n                await this.sub.quit();\n                this.sub.removeAllListeners();\n                this.sub = null;\n            } catch {\n                // ignore error\n            }\n        }\n        if (this.subSystem) {\n            try {\n                await this.subSystem.quit();\n                this.subSystem.removeAllListeners();\n                this.subSystem = null;\n            } catch {\n                // ignore error\n            }\n        }\n    }\n\n    async loadLuaScripts(): Promise<void> {\n        let luaDirName;\n\n        if (this.noLegacyMultihost && this.useSets) {\n            luaDirName = 'lua-v4';\n        } else if (this.noLegacyMultihost) {\n            luaDirName = 'lua-v4-no-sets';\n        } else {\n            luaDirName = 'lua-v3';\n        }\n\n        const luaPath = path.join(thisDir, luaDirName);\n        const scripts: Script[] = fs.readdirSync(luaPath).map(name => {\n            const shasum = crypto.createHash('sha1');\n            const script = fs.readFileSync(path.join(luaPath, name));\n            shasum.update(script);\n            const hash = shasum.digest('hex');\n            return { name: name.replace(/\\.lua$/, ''), text: script, hash };\n        });\n\n        const hashes = scripts.map(e => e.hash);\n        hashes.unshift('EXISTS');\n\n        if (!this.client) {\n            throw new Error(tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        let arr: any[];\n        try {\n            arr = await this.client.script(hashes);\n            if (arr) {\n                scripts.forEach((e, i) => (scripts[i].loaded = !!arr[i]));\n            }\n        } catch {\n            // ignore\n        }\n\n        if (!this.client) {\n            throw new Error(tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        for (const script of scripts) {\n            if (!script.loaded) {\n                let hash;\n                try {\n                    hash = await this.client.script(['LOAD', script.text]);\n                    script.loaded = true;\n                } catch (e) {\n                    script.loaded = false;\n                    this.log.error(`${this.namespace} Cannot load \"${script.name}\": ${e.message}`);\n                    if (!script.name.startsWith('redlock_')) {\n                        // because of #1753 an upgrade from < 4.0 will run against the old db server which will not know redlock\n                        // TODO: remove if controller 4.0 is old enough\n                        throw new Error(`Cannot load \"${script.name}\" into objects database: ${e.message}`);\n                    }\n                }\n                script.hash = hash;\n            }\n        }\n        this.scripts = {};\n        scripts.forEach(e => (this.scripts[e.name] = e.hash));\n    }\n\n    /**\n     * Get all keys matching a pattern using redis SCAN command, duplicates are filtered out\n     *\n     * @param pattern - pattern to match, e. g. io.hm-rpc.0*\n     * @param count - count argument used by redis SCAN, default is 250\n     */\n    private _getKeysViaScan(pattern: string, count = 250): Promise<string[]> {\n        return new Promise((resolve, reject) => {\n            if (!this.client) {\n                reject(new Error(ERRORS.ERROR_DB_CLOSED));\n                return;\n            }\n\n            const stream = this.client.scanStream({ match: pattern, count: count });\n            let uniqueKeys: string[] = [];\n\n            stream.on('data', resultKeys => {\n                if (!Array.isArray(resultKeys)) {\n                    return;\n                }\n                // append result keys to uniqueKeys without duplicates\n                uniqueKeys = [...uniqueKeys, ...resultKeys];\n            });\n\n            stream.on('end', () => {\n                // return without duplicates\n                resolve(Array.from(new Set(uniqueKeys)));\n            });\n        });\n    }\n\n    /**\n     * Checks if a given set exists\n     *\n     * @param id - id of the set\n     */\n    async setExists(id: string): Promise<boolean> {\n        if (!this.client) {\n            throw new Error(ERRORS.ERROR_DB_CLOSED);\n        }\n\n        const exists = await this.client.exists(this.setNamespace + id);\n        return !!exists;\n    }\n\n    /**\n     * Migrate all objects to sets\n     *\n     * @returns number of migrated sets\n     */\n    async migrateToSets(): Promise<number> {\n        if (!this.useSets) {\n            return 0;\n        }\n\n        if (!this.client) {\n            throw new Error(ERRORS.ERROR_DB_CLOSED);\n        }\n\n        // to be safe we remove all sets before migration\n        const keys = await this._getKeysViaScan(`${this.setNamespace}object.type.*`);\n        for (const key of keys) {\n            await this.client.del(key);\n        }\n\n        let noMigrated = 0;\n        // get all objs without using view\n        const objs = await this.getObjectList({ startkey: '', endkey: '\\u9999' });\n\n        if (!objs) {\n            return noMigrated;\n        }\n\n        for (const obj of objs.rows) {\n            if (obj.value.type) {\n                // e.g. _design/.. has no type\n                // 1 if added else 0 (mostly always part of the set)\n                const migrated = await this.client.sadd(\n                    `${this.setNamespace}object.type.${obj.value.type}`,\n                    this.objNamespace + obj.id,\n                );\n                noMigrated += migrated;\n            }\n\n            // check for custom\n            if (obj.value.common?.custom) {\n                const migrated = await this.client.sadd(\n                    `${this.setNamespace}object.common.custom`,\n                    this.objNamespace + obj.id,\n                );\n                noMigrated += migrated;\n            }\n        }\n        return noMigrated;\n    }\n\n    /**\n     * Returns the protocol version from DB\n     */\n    getProtocolVersion(): Promise<string | null> {\n        if (!this.client) {\n            throw new Error(ERRORS.ERROR_DB_CLOSED);\n        }\n\n        return this.client.get(`${this.metaNamespace}objects.protocolVersion`);\n    }\n\n    /**\n     * Extend the primary host lock time\n     * Value will expire after ms milliseconds\n     *\n     * @param ms - ms until value expires\n     * @returns 1 if extended else 0\n     */\n    extendPrimaryHostLock(ms: number): Promise<number> {\n        if (!this.client) {\n            throw new Error(ERRORS.ERROR_DB_CLOSED);\n        }\n\n        // we have a host version smaller 3 no one can be primary\n        if (!this.noLegacyMultihost) {\n            return Promise.resolve(0);\n        }\n\n        // try to extend lock\n        return this.client.evalsha([\n            this.scripts.redlock_extend,\n            3,\n            `${this.metaNamespace}objects.primaryHost`,\n            this.hostname,\n            ms,\n        ]);\n    }\n\n    /**\n     * Sets current host as primary if no primary host active\n     * Value will expire after ms milliseconds\n     *\n     * @param ms - ms until value expires\n     * @returns 1 if lock acquired else 0\n     */\n    setPrimaryHost(ms: number): Promise<number> {\n        if (!this.client) {\n            throw new Error(ERRORS.ERROR_DB_CLOSED);\n        }\n\n        // we have a host version smaller 3 no one can be primary\n        if (!this.noLegacyMultihost) {\n            return Promise.resolve(0);\n        }\n\n        // try to acquire lock\n        return this.client.evalsha([\n            this.scripts.redlock_acquire,\n            3,\n            `${this.metaNamespace}objects.primaryHost`,\n            this.hostname,\n            ms,\n        ]);\n    }\n\n    /**\n     * Get name of the primary host\n     */\n    getPrimaryHost(): Promise<string | null> {\n        if (!this.client) {\n            throw new Error(ERRORS.ERROR_DB_CLOSED);\n        }\n\n        // we have a host version smaller 3 no one can be primary\n        if (!this.noLegacyMultihost) {\n            return Promise.resolve('');\n        }\n\n        return this.client.get(`${this.metaNamespace}objects.primaryHost`);\n    }\n\n    /**\n     * Ensure we are no longer the primary host\n     */\n    releasePrimaryHost(): Promise<void> {\n        if (!this.client) {\n            throw new Error(ERRORS.ERROR_DB_CLOSED);\n        }\n\n        if (!this.noLegacyMultihost) {\n            return Promise.resolve();\n        }\n\n        // try to release lock\n        return this.client.evalsha([\n            this.scripts.redlock_release,\n            4,\n            `${this.metaNamespace}objects.primaryHost`,\n            this.hostname,\n            this.settings.connection.options.db,\n            `${this.metaNamespace}objects.primaryHost`,\n        ]);\n    }\n\n    /**\n     * Sets the protocol version to the DB\n     *\n     * @param version - protocol version\n     */\n    async setProtocolVersion(version: number | string): Promise<void> {\n        if (!this.client) {\n            throw new Error(ERRORS.ERROR_DB_CLOSED);\n        }\n\n        version = version.toString();\n        // we can only set a protocol if we actually support it\n        if (this.supportedProtocolVersions.includes(version)) {\n            await this.client.set(`${this.metaNamespace}objects.protocolVersion`, version);\n            await this.client.publish(`${this.metaNamespace}objects.protocolVersion`, version);\n        } else {\n            throw new Error('Cannot set an unsupported protocol version on the current host');\n        }\n    }\n\n    /**\n     * Subscribe to expired events to get expiration of primary host\n     */\n    async subscribePrimaryHost(): Promise<void> {\n        if (this.subSystem) {\n            await this.subSystem.subscribe(`__keyevent@${this.settings.connection.options.db}__:expired`);\n            await this.subSystem.subscribe(`__keyevent@${this.settings.connection.options.db}__:evicted`);\n        }\n    }\n\n    /**\n     * Activates the usage of sets\n     */\n    async activateSets(): Promise<void> {\n        if (!this.client) {\n            throw new Error(ERRORS.ERROR_DB_CLOSED);\n        }\n\n        await this.client.set(`${this.metaNamespace}objects.features.useSets`, '1');\n        this.useSets = true;\n    }\n\n    /**\n     * Deactivates the usage of sets\n     */\n    async deactivateSets(): Promise<void> {\n        if (!this.client) {\n            throw new Error(ERRORS.ERROR_DB_CLOSED);\n        }\n\n        await this.client.set(`${this.metaNamespace}objects.features.useSets`, '0');\n        this.useSets = false;\n    }\n\n    /**\n     * Get value from meta namespace\n     *\n     * @param id redis key\n     */\n    getMeta(id: string): Promise<string | null> {\n        if (!this.client) {\n            throw new Error(ERRORS.ERROR_DB_CLOSED);\n        }\n\n        return this.client.get(this.metaNamespace + id);\n    }\n}\n", "export const __import_meta_url =\n  typeof document === 'undefined' ? new (require('url'.replace('', '')).URL)('file:' + __filename).href :\n    (document.currentScript && document.currentScript.src || new URL('main.js', document.baseURI).href)\n"],
  "mappings": "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",
  "names": ["Redis", "obj", "deepClone", "reconnectCounter", "keys", "objs", "semver", "options", "fileOptions", "user", "dirID", "result", "name", "meta", "err", "pattern", "params", "extend", "path", "fs", "crypto"]
}
