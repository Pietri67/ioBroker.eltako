import type { ACLObject, CheckFileRightsCallback, GetUserGroupPromiseReturn } from '../../lib/objects/objectsUtils.js';
import type { InternalLogger } from '@iobroker/js-controller-common-db/tools';
import type { ConnectionOptions, DbStatus } from '@iobroker/db-base/inMemFileDB';
type ChangeFunction = (id: string, object: ioBroker.Object | null) => void;
type GetUserGroupCallbackNoError = (user: string, groups: string[], acl: ioBroker.ObjectPermissions) => void;
interface RedisConnectionOptions extends ConnectionOptions {
    redisNamespace?: string;
}
export interface ObjectsSettings {
    connected: () => void;
    controller?: boolean;
    primaryHostLost?: () => void;
    disconnected?: () => void;
    change?: ChangeFunction;
    changeUser?: ChangeFunction;
    changeFileUser?: ioBroker.FileChangeHandler;
    autoConnect?: boolean;
    logger: InternalLogger;
    hostname?: string;
    namespace?: string;
    defaultNewAcl?: ACLObject;
    metaNamespace?: string;
    redisNamespace?: string;
    connection: RedisConnectionOptions;
}
interface CallOptions {
    groups?: string[];
    group?: string;
    user?: ioBroker.ObjectIDs.User;
    owner?: ioBroker.ObjectIDs.User;
    ownerGroup?: string;
    acl?: any;
    [other: string]: any;
}
interface WriteFileOptions extends CallOptions {
    mimeType?: string;
}
interface Options {
    /** The user id for database operations */
    user?: string;
    [other: string]: unknown;
}
type CheckFileCallback = (checkFailed: boolean, options?: CallOptions, fileOptions?: {
    notExists: boolean;
}) => void;
export declare class ObjectsInRedisClient {
    private client;
    private readonly fileNamespace;
    private readonly redisNamespace;
    private readonly fileNamespaceL;
    private readonly objNamespace;
    private readonly setNamespace;
    private readonly metaNamespace;
    private readonly objNamespaceL;
    private readonly supportedProtocolVersions;
    private stop;
    private sub;
    private subSystem;
    private settings;
    private readonly preserveSettings;
    private defaultNewAcl;
    private readonly namespace;
    private readonly hostname;
    private scripts;
    private readonly existingMetaObjects;
    private log;
    private activeProtocolVersion?;
    private useSets?;
    private noLegacyMultihost?;
    private readonly userSubscriptions;
    private readonly systemSubscriptions;
    constructor(settings: ObjectsSettings);
    /**
     * Checks if we are allowed to start and sets the protocol version accordingly
     */
    private _determineProtocolVersion;
    connectDb(): void;
    getStatus(): DbStatus;
    /**
     * Checks if given ID is a meta-object, else throws error
     *
     * @param id to check
     * @throws Error if id is invalid
     */
    validateMetaObject(id: string): Promise<void>;
    normalizeFilename(name: string): string;
    /**
     * Sets a buffer to the Redis DB
     *
     * @param id id of the file
     * @param data content, if string is passed it will be converted to a Buffer
     */
    private _setBinaryState;
    /**
     * get buffer of given id from redis
     *
     * @param id - id of the data with namespace prefix
     */
    private _getBinaryState;
    /**
     * deletes binary state of given id from redis db
     *
     * @param id - id to delete, with namespace prefix
     */
    private _delBinaryState;
    getFileId(id: string, name: string, isMeta?: boolean): string;
    checkFile(id: string, name: string, options: CallOptions, flag: any, callback?: CheckFileCallback): Promise<ioBroker.CallbackReturnTypeOf<CheckFileCallback> | void>;
    checkFileRights(id: string, name: string | null, options?: CallOptions | null, flag?: any, callback?: CheckFileRightsCallback): void;
    private _setDefaultAcl;
    setDefaultAcl(defaultNewAcl: ACLObject | null): Promise<void>;
    getUserGroup(user: ioBroker.ObjectIDs.User, callback: GetUserGroupCallbackNoError): Promise<GetUserGroupPromiseReturn> | void;
    private _writeFile;
    writeFile(id: string, name: string, data: any, callback?: ioBroker.ErrorCallback): Promise<void>;
    writeFile(id: string, name: string, data: any, options?: WriteFileOptions | null, callback?: ioBroker.ErrorCallback): Promise<void>;
    writeFileAsync(id: string, name: string, data: any, options?: WriteFileOptions | null): Promise<void>;
    private _readFile;
    readFile(id: string, name: string, options?: CallOptions | null): ioBroker.ReadFilePromise;
    readFile(id: string, name: string, options: CallOptions | null | undefined, callback: ioBroker.ReadFileCallback): void;
    /**
     * Check if given object exists
     *
     * @param id id of the object
     * @param options optional user context
     */
    objectExists(id: string, options?: CallOptions | null): Promise<boolean>;
    /**
     * Check if given file exists
     *
     * @param id id of the namespace
     * @param name name of the file
     * @param options optional user context
     */
    fileExists(id: string, name: string, options?: CallOptions | null): Promise<boolean>;
    private _unlink;
    unlink(id: string, name: string, options: CallOptions | null | undefined, callback?: ioBroker.RmCallback): void;
    unlinkAsync(id: string, name: string, options?: CallOptions): Promise<void>;
    delFile(id: string, name: string, options: CallOptions, callback: ioBroker.ErrorCallback): void;
    delFileAsync(id: string, name: string, options: CallOptions): Promise<void>;
    private _readDir;
    readDir(id: string, name: string, options: CallOptions | null | undefined, callback: ioBroker.ReadDirCallback): void;
    readDirAsync(id: string, name: string, options?: CallOptions): ioBroker.ReadDirPromise;
    private _renameHelper;
    private _rename;
    rename(id: string, oldName: string, newName: string, options?: CallOptions | null, callback?: ioBroker.ErrorCallback): void | Promise<void>;
    renameAsync(id: string, oldName: string, newName: string, options: CallOptions): Promise<void>;
    private _touch;
    touch(id: string, name: string, options: CallOptions | null, callback: ioBroker.ErrorCallback): void;
    touchAsync(id: string, name: string, options: CallOptions): Promise<void>;
    private _rmHelper;
    private _rm;
    rm(id: string, name: string, options: CallOptions | null, callback: ioBroker.RmCallback): void;
    rmAsync(id: string, name: string, options: CallOptions): Promise<void | ioBroker.RmResult[]>;
    mkdir(id: string, dirName?: string, options?: CallOptions | null, callback?: ioBroker.ErrorCallback): void;
    mkdirAsync(id: string, dirName?: string, options?: CallOptions): Promise<void>;
    private _chownFileHelper;
    private _chownFile;
    chownFile(id: string, name: string, options: CallOptions, callback: ioBroker.ChownFileCallback): void;
    chownFileAsync(id: string, name: string, options: CallOptions): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.ChownFileCallback>>;
    /**
     *
     * @param keys Key names to handle
     * @param metas Objects for the keys to handle
     * @param options options
     * @param callback callback function
     */
    private _chmodFileHelper;
    private _chmodFile;
    chmodFile(id: string, name: string, options: CallOptions | null, callback: ioBroker.ChownFileCallback): void;
    chmodFileAsync(id: string, name: string, options: CallOptions): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.ChownFileCallback>>;
    enableFileCache(enabled: boolean, callback?: (err: Error | null | undefined, res: boolean) => void): void;
    enableFileCache(enabled: boolean, options?: CallOptions, callback?: (err: Error | null | undefined, res: boolean) => void): void;
    enableFileCacheAsync(enabled: boolean, options?: CallOptions): Promise<boolean>;
    private _subscribeFile;
    private _unsubscribeFile;
    subscribeUserFile(id: string, pattern: string | string[], options?: CallOptions | null): Promise<void>;
    unsubscribeUserFile(id: string, pattern: string | string[], options?: CallOptions | null): Promise<void>;
    private _subscribe;
    private subscribeConfig;
    subscribe(pattern: string | string[], callback?: ioBroker.ErrorCallback): void;
    subscribe(pattern: string | string[], options?: CallOptions, callback?: ioBroker.ErrorCallback): void;
    subscribeAsync(pattern: string | string[], options?: CallOptions): Promise<void>;
    subscribeUser(pattern: string | string[], callback?: ioBroker.ErrorCallback): void;
    subscribeUser(pattern: string | string[], options?: CallOptions | null, callback?: ioBroker.ErrorCallback): void;
    subscribeUserAsync(pattern: string | string[], options: CallOptions): Promise<void>;
    private _unsubscribe;
    private unsubscribeConfig;
    unsubscribe(pattern: string | string[], callback?: ioBroker.ErrorCallback): void;
    unsubscribe(pattern: string | string[], options?: CallOptions | null, callback?: ioBroker.ErrorCallback): void;
    unsubscribeAsync(pattern: string | string[], options: CallOptions): Promise<void>;
    unsubscribeUser(pattern: string | string[], options?: CallOptions | null, callback?: ioBroker.ErrorCallback): void;
    unsubscribeUserAsync(pattern: string | string[], options: CallOptions): Promise<void>;
    private _objectHelper;
    private _chownObject;
    chownObject(pattern: string, options: CallOptions, callback?: ioBroker.ChownObjectCallback): void | Promise<void>;
    chownObjectAsync(pattern: string, options: CallOptions): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.ChownObjectCallback>>;
    private _chmodObject;
    chmodObject(pattern: string, options: CallOptions | null, callback?: ioBroker.ChownObjectCallback): void | Promise<void>;
    chmodObjectAsync(pattern: string, options: CallOptions): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.ChownObjectCallback>>;
    private _getObject;
    getObject<T extends string>(id: T, options: Options | undefined | null, callback: ioBroker.GetObjectCallback<T>): void;
    getObject<T extends string>(id: T, options?: Options | null): ioBroker.GetObjectPromise<T>;
    getObject<T extends string>(id: T, callback: ioBroker.GetObjectCallback<T>): void;
    /**
     *
     * @param id
     * @param options
     * @deprecated use `getObject` without callback instead
     */
    getObjectAsync<T extends string>(id: T, options?: Record<string, any> | null): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.GetObjectCallback<T>>>;
    private _getKeys;
    getKeys(pattern: string, options: CallOptions | null | undefined, callback: ioBroker.GetKeysCallback, dontModify?: boolean): void;
    getKeys(pattern: string, callback: ioBroker.GetKeysCallback): void;
    getKeys(pattern: string, options?: CallOptions | null, callback?: undefined, dontModify?: boolean): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.GetKeysCallback>>;
    getKeysAsync(id: string, options?: CallOptions): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.GetKeysCallback>>;
    private _getObjects;
    getObjects(keys: string[], options?: CallOptions | null): Promise<ioBroker.AnyObject[]>;
    getObjects(keys: string[], callback: (err?: Error | null, objs?: ioBroker.AnyObject[]) => void): void;
    getObjects(keys: string[], options: CallOptions | null, callback: (err?: Error | null, objs?: ioBroker.AnyObject[]) => void, dontModify?: boolean): void;
    getObjectsAsync(keys: string[], options?: CallOptions | null): Promise<ioBroker.AnyObject[]>;
    private _getObjectsByPattern;
    getObjectsByPattern(pattern: string, options: CallOptions | null): Promise<ioBroker.AnyObject[] | void>;
    getObjectsByPattern(pattern: string, options: CallOptions | null, callback: (err?: Error | null, objs?: ioBroker.AnyObject[]) => void): void;
    getObjectsByPatternAsync(pattern: string, options: CallOptions): Promise<ioBroker.AnyObject[] | void>;
    private _setObject;
    setObject<T extends string>(id: T, obj: ioBroker.SettableObject<ioBroker.ObjectIdToObjectType<T>>): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.SetObjectCallback>>;
    setObject<T extends string>(id: T, obj: ioBroker.SettableObject<ioBroker.ObjectIdToObjectType<T>>, callback?: ioBroker.SetObjectCallback): void | Promise<ioBroker.CallbackReturnTypeOf<ioBroker.SetObjectCallback>>;
    setObject<T extends string>(id: T, obj: ioBroker.SettableObject<ioBroker.ObjectIdToObjectType<T>>, options?: CallOptions | null, callback?: ioBroker.SetObjectCallback): void | Promise<ioBroker.CallbackReturnTypeOf<ioBroker.SetObjectCallback>>;
    /**
     *
     * @param id
     * @param obj
     * @param options
     * @deprecated use `setObject` without callback instead
     */
    setObjectAsync(id: string, obj: ioBroker.SettableObject, options?: CallOptions | null): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.SetObjectCallback>>;
    private _delObject;
    delObject(id: string, callback: ioBroker.ErrorCallback): void;
    delObject(id: string, options: CallOptions | null, callback: ioBroker.ErrorCallback): void;
    delObject(id: string, options?: CallOptions | null): Promise<void>;
    delObjectAsync(id: string, options?: CallOptions): Promise<void>;
    /**
     * Function to checks if comparisons will work according to the configured Locale
     */
    isSystemLocaleSupported(): Promise<boolean>;
    private _applyViewFunc;
    private _getObjectView;
    getObjectView<Design extends string = string, Search extends string = string>(design: Design, search: Search, params?: ioBroker.GetObjectViewParams, options?: CallOptions | null): ioBroker.GetObjectViewPromise<ioBroker.InferGetObjectViewItemType<Design, Search>>;
    getObjectView<Design extends string = string, Search extends string = string>(design: Design, search: Search, params: ioBroker.GetObjectViewParams | undefined, options: CallOptions | undefined | null, callback: ioBroker.GetObjectViewCallback<ioBroker.InferGetObjectViewItemType<Design, Search>>): void;
    getObjectView<Design extends string = string, Search extends string = string>(design: Design, search: Search, params: ioBroker.GetObjectViewParams, callback: ioBroker.GetObjectViewCallback<ioBroker.InferGetObjectViewItemType<Design, Search>>): void;
    getObjectViewAsync<Design extends string = string, Search extends string = string>(design: Design, search: Search, params?: ioBroker.GetObjectViewParams, options?: CallOptions): ioBroker.GetObjectViewPromise<ioBroker.InferGetObjectViewItemType<Design, Search>>;
    private _getObjectList;
    getObjectList(params: ioBroker.GetObjectListParams): ioBroker.GetObjectListPromise;
    getObjectList(params: ioBroker.GetObjectListParams, options?: CallOptions | null): ioBroker.GetObjectListPromise;
    getObjectList(params: ioBroker.GetObjectListParams, callback: ioBroker.GetObjectListCallback<ioBroker.Object>): void;
    getObjectList<T extends ioBroker.GetObjectListCallback<ioBroker.Object>>(params: ioBroker.GetObjectListParams, options?: CallOptions | null, callback?: T): T extends ioBroker.GetObjectListCallback<ioBroker.Object> ? void : ioBroker.GetObjectListPromise;
    getObjectListAsync(params: ioBroker.GetObjectListParams, options?: CallOptions): ioBroker.GetObjectListPromise;
    private _extendObject;
    extendObject<T extends string>(id: T, obj: ioBroker.PartialObject<ioBroker.ObjectIdToObjectType<T, 'write'>>, options?: ioBroker.ExtendObjectOptions | null): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.ExtendObjectCallback>>;
    extendObject<T extends string>(id: T, obj: ioBroker.PartialObject<ioBroker.ObjectIdToObjectType<T, 'write'>>, options?: ioBroker.ExtendObjectOptions | null, callback?: ioBroker.ExtendObjectCallback): void | Promise<ioBroker.CallbackReturnTypeOf<ioBroker.ExtendObjectCallback>>;
    extendObjectAsync(id: string, obj: Partial<ioBroker.AnyObject>, options?: ioBroker.ExtendObjectOptions): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.ExtendObjectCallback>>;
    /**
     * Returns the object id if found
     *
     * @param idOrName
     * @param type
     * @param options
     * @param callback
     */
    private _findObject;
    findObject(idOrName: string, type: string | null, options: CallOptions | null, callback: ioBroker.FindObjectCallback): void;
    findObject(idOrName: string, type: string | null, callback: ioBroker.FindObjectCallback): void;
    findObject(idOrName: string, type?: string | null, options?: CallOptions | null): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.FindObjectCallback>>;
    addPreserveSettings(settings: string[] | string): void;
    private _destroyDBHelper;
    private _destroyDB;
    destroyDB(options: CallOptions | null | undefined, callback: ioBroker.ErrorCallback): void;
    destroyDBAsync(options?: CallOptions): Promise<void>;
    destroy(): Promise<void>;
    loadLuaScripts(): Promise<void>;
    /**
     * Get all keys matching a pattern using redis SCAN command, duplicates are filtered out
     *
     * @param pattern - pattern to match, e. g. io.hm-rpc.0*
     * @param count - count argument used by redis SCAN, default is 250
     */
    private _getKeysViaScan;
    /**
     * Checks if a given set exists
     *
     * @param id - id of the set
     */
    setExists(id: string): Promise<boolean>;
    /**
     * Migrate all objects to sets
     *
     * @returns number of migrated sets
     */
    migrateToSets(): Promise<number>;
    /**
     * Returns the protocol version from DB
     */
    getProtocolVersion(): Promise<string | null>;
    /**
     * Extend the primary host lock time
     * Value will expire after ms milliseconds
     *
     * @param ms - ms until value expires
     * @returns 1 if extended else 0
     */
    extendPrimaryHostLock(ms: number): Promise<number>;
    /**
     * Sets current host as primary if no primary host active
     * Value will expire after ms milliseconds
     *
     * @param ms - ms until value expires
     * @returns 1 if lock acquired else 0
     */
    setPrimaryHost(ms: number): Promise<number>;
    /**
     * Get name of the primary host
     */
    getPrimaryHost(): Promise<string | null>;
    /**
     * Ensure we are no longer the primary host
     */
    releasePrimaryHost(): Promise<void>;
    /**
     * Sets the protocol version to the DB
     *
     * @param version - protocol version
     */
    setProtocolVersion(version: number | string): Promise<void>;
    /**
     * Subscribe to expired events to get expiration of primary host
     */
    subscribePrimaryHost(): Promise<void>;
    /**
     * Activates the usage of sets
     */
    activateSets(): Promise<void>;
    /**
     * Deactivates the usage of sets
     */
    deactivateSets(): Promise<void>;
    /**
     * Get value from meta namespace
     *
     * @param id redis key
     */
    getMeta(id: string): Promise<string | null>;
}
export {};
//# sourceMappingURL=objectsInRedisClient.d.ts.map