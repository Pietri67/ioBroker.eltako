{
  "version": 3,
  "sources": ["../../../src/lib/inMemFileDB.ts"],
  "sourcesContent": ["/**\n *      States DB in memory - Server\n *\n *      Copyright 2013-2024 bluefox <dogafox@gmail.com>\n *\n *      MIT License\n *\n */\n\nimport fs from 'fs-extra';\nimport path from 'node:path';\nimport { tools } from '@iobroker/js-controller-common-db';\nimport type { InternalLogger } from '@iobroker/js-controller-common-db/tools';\nimport { createGzip } from 'node:zlib';\n\n// settings = {\n//    change:    function (id, state) {},\n//    connected: function (nameOfServer) {},\n//    logger: {\n//           silly: function (msg) {},\n//           debug: function (msg) {},\n//           info:  function (msg) {},\n//           warn:  function (msg) {},\n//           error: function (msg) {}\n//    },\n//    connection: {\n//           dataDir: 'relative path'\n//    },\n//    auth: null, //unused\n//    secure: true/false,\n//    certificates: as required by createServer\n//    port: 9000,\n//    host: localhost\n// };\n//\n\nexport interface ConnectionOptions {\n    pass?: string;\n    sentinelName?: string;\n    /** array on sentinel */\n    host: string | string[];\n    /** array on sentinel */\n    port: number | number[];\n    options: Record<string, any>;\n    maxQueue?: number;\n    enhancedLogging?: boolean;\n    backup?: BackupOptions;\n    /** relative path to the data dir */\n    dataDir: string;\n}\n\ntype ChangeFunction = (id: string, state: any) => void;\n\nexport interface DbStatus {\n    type: string;\n    server: boolean;\n}\n\ninterface BackupOptions {\n    /** deactivates backup if true */\n    disabled: boolean;\n    /** minimum number of files */\n    files: number;\n    hours: number;\n    /** minutes */\n    period: number;\n    path: string;\n}\n\nexport interface DbOptions {\n    backupDirName: string;\n    fileName: string;\n}\n\ninterface FileDbSettings {\n    fileDB: DbOptions;\n    jsonlDB: DbOptions;\n    backup: BackupOptions;\n    change?: ChangeFunction;\n    connected: (nameOfServer: string) => void;\n    logger: InternalLogger;\n    connection: ConnectionOptions;\n    /** unused */\n    auth?: null;\n    secure: boolean;\n    /** as required by createServer TODO: if createServer is typed, add type */\n    certificates: any;\n    port: number;\n    host: string;\n    /** logging namespace */\n    namespace?: string;\n}\n\ninterface Subscription {\n    pattern: string;\n    regex: RegExp;\n    options: any;\n}\n\ninterface SubscriptionClient {\n    _subscribe?: Record<string, Subscription[]>;\n}\n\n/**\n * The parent of the class structure, which provides basic JSON storage\n * and general subscription and publish functionality\n */\nexport class InMemoryFileDB {\n    private settings: FileDbSettings;\n    private readonly change: ChangeFunction | undefined;\n    protected dataset: Record<string, any>;\n    private readonly namespace: string;\n    private lastSave: null | number;\n    private stateTimer: NodeJS.Timeout | null;\n    private callbackSubscriptionClient: SubscriptionClient;\n    private readonly dataDir: string;\n    private readonly datasetName: string;\n    private log: InternalLogger;\n    private readonly backupDir: string;\n\n    constructor(settings: FileDbSettings) {\n        this.settings = settings || {};\n\n        this.change = this.settings.change;\n\n        this.dataset = {};\n\n        this.namespace = this.settings.namespace || '';\n        this.lastSave = null;\n        this.callbackSubscriptionClient = {};\n\n        this.settings.backup = this.settings.connection.backup || {\n            disabled: false, // deactivates\n            files: 24, // minimum number of files\n            hours: 48, // hours\n            period: 120, // minutes\n            path: '', // use default path\n        };\n\n        this.dataDir = this.settings.connection.dataDir || tools.getDefaultDataDir();\n        if (!path.isAbsolute(this.dataDir)) {\n            this.dataDir = path.normalize(path.join(tools.getControllerDir(), this.dataDir));\n        }\n        this.dataDir = this.dataDir.replace(/\\\\/g, '/');\n\n        const fileName = this.settings.jsonlDB ? this.settings.jsonlDB.fileName : this.settings.fileDB.fileName;\n        this.datasetName = path.join(this.dataDir, fileName);\n        const parts = path.dirname(this.datasetName);\n        fs.ensureDirSync(parts);\n\n        this.stateTimer = null;\n\n        this.backupDir = this.settings.backup.path || path.join(this.dataDir, this.settings.fileDB.backupDirName);\n\n        this.log = tools.getLogger(this.settings.logger);\n\n        if (!this.settings.backup.disabled) {\n            try {\n                this.initBackupDir();\n            } catch (e) {\n                this.log.error(\n                    `Database backups are disabled, because backup directory could not be initialized: ${e.message}`,\n                );\n                this.log.error(\n                    'This leads to an increased risk of data loss, please check that the configured backup directory is available and restart the controller',\n                );\n                this.settings.backup.disabled = true;\n            }\n        }\n\n        this.log.debug(`${this.namespace} Data File: ${this.datasetName}`);\n    }\n\n    async open(): Promise<void> {\n        // load values from file\n        this.dataset = await this.loadDataset(this.datasetName);\n    }\n\n    /**\n     * Loads a dataset file\n     *\n     * @param datasetName Filename of the file to load\n     * @returns obj read data, normally as object\n     */\n    async loadDatasetFile(datasetName: string): Promise<Record<string, any>> {\n        if (!(await fs.pathExists(datasetName))) {\n            throw new Error(`Database file ${datasetName} does not exists.`);\n        }\n        return fs.readJSON(datasetName);\n    }\n\n    /**\n     * Loads the dataset including pot. Fallback handling\n     *\n     * @param datasetName Filename of the file to load\n     * @returns obj dataset read as object\n     */\n    async loadDataset(datasetName: string): Promise<Record<string, any>> {\n        let ret = {};\n        try {\n            ret = await this.loadDatasetFile(datasetName);\n\n            // loading worked, make sure that \"bak\" File is not broken\n            try {\n                await fs.readJSON(`${datasetName}.bak`);\n            } catch (e) {\n                this.log.info(\n                    `${this.namespace} Rewrite bak file, because error on verify ${datasetName}.bak: ${e.message}`,\n                );\n                try {\n                    const jsonString = JSON.stringify(ret);\n                    await fs.writeFile(`${datasetName}.bak`, jsonString);\n                } catch (e) {\n                    this.log.error(`${this.namespace} Cannot save ${datasetName}.bak: ${e.message}`);\n                }\n            }\n        } catch (err) {\n            this.log.error(`${this.namespace} Cannot load ${datasetName}: ${err.message}. We try last Backup!`);\n\n            try {\n                ret = await this.loadDatasetFile(`${datasetName}.bak`);\n\n                // it worked, lets overwrite old file and store the broken one for pot. forensic check\n                try {\n                    if (await fs.pathExists(datasetName)) {\n                        try {\n                            await fs.move(datasetName, `${datasetName}.broken`, { overwrite: true });\n                        } catch (e) {\n                            this.log.error(\n                                `${this.namespace} Cannot copy the broken file ${datasetName} to ${datasetName}.broken ${e.message}`,\n                            );\n                        }\n                        try {\n                            await fs.writeFile(datasetName, JSON.stringify(ret));\n                        } catch (e) {\n                            this.log.error(\n                                `${this.namespace} Cannot restore backup file as new main ${datasetName}: ${e.message}`,\n                            );\n                        }\n                    }\n                } catch {\n                    // ignore, file does not exist\n                }\n            } catch (err) {\n                this.log.error(\n                    `${this.namespace} Cannot load ${datasetName}.bak: ${err.message}. Continue with empty dataset!`,\n                );\n                this.log.error(\n                    `${this.namespace} If this is no Migration or initial start please restore the last backup from ${this.backupDir}`,\n                );\n            }\n        }\n        return ret;\n    }\n\n    initBackupDir(): void {\n        // Interval in minutes => to milliseconds\n        this.settings.backup.period =\n            this.settings.backup.period === undefined ? 120 : parseInt(String(this.settings.backup.period));\n        if (isNaN(this.settings.backup.period)) {\n            this.settings.backup.period = 120;\n        }\n        // Node.js timeouts overflow after roughly 24 days, defaulting to 1 millisecond, which causes chaos.\n        // If a user configured the backup this way, we use our default of 120 minutes instead.\n        const maxTimeoutMinutes = Math.floor((2 ** 31 - 1) / 60000);\n        if (this.settings.backup.period > maxTimeoutMinutes) {\n            this.log.warn(\n                `${this.namespace} Configured backup period ${this.settings.backup.period} is larger than the supported maximum of ${maxTimeoutMinutes} minutes. Defaulting to 120 minutes.`,\n            );\n            this.settings.backup.period = 120;\n        }\n        this.settings.backup.period *= 60_000;\n\n        this.settings.backup.files =\n            this.settings.backup.files === undefined ? 24 : parseInt(String(this.settings.backup.files));\n        if (isNaN(this.settings.backup.files)) {\n            this.settings.backup.files = 24;\n        }\n\n        this.settings.backup.hours =\n            this.settings.backup.hours === undefined ? 48 : parseInt(String(this.settings.backup.hours));\n        if (isNaN(this.settings.backup.hours)) {\n            this.settings.backup.hours = 48;\n        }\n        // Create backup directory\n        fs.ensureDirSync(this.backupDir);\n    }\n\n    handleSubscribe(client: SubscriptionClient, type: string, pattern: string | string[], cb?: () => void): void;\n    handleSubscribe(\n        client: SubscriptionClient,\n        type: string,\n        pattern: string | string[],\n        options: any,\n        cb?: () => void,\n    ): void;\n\n    handleSubscribe(\n        client: SubscriptionClient,\n        type: string,\n        pattern: string | string[],\n        options: any,\n        cb?: () => void,\n    ): void {\n        if (typeof options === 'function') {\n            cb = options;\n            options = undefined;\n        }\n        client._subscribe = client._subscribe || {};\n        client._subscribe[type] = client._subscribe[type] || [];\n\n        const s = client._subscribe[type];\n\n        if (pattern instanceof Array) {\n            pattern.forEach(pattern => {\n                if (s.find(sub => sub.pattern === pattern)) {\n                    return;\n                }\n\n                s.push({ pattern, regex: new RegExp(tools.pattern2RegEx(pattern)), options });\n            });\n        } else {\n            if (!s.find(sub => sub.pattern === pattern)) {\n                s.push({ pattern, regex: new RegExp(tools.pattern2RegEx(pattern)), options });\n            }\n        }\n\n        typeof cb === 'function' && cb();\n    }\n\n    handleUnsubscribe(\n        client: SubscriptionClient,\n        type: string,\n        pattern: string | string[],\n        cb?: () => void,\n    ): void | Promise<void> {\n        const s = client?._subscribe?.[type];\n        if (s) {\n            const removeEntry = (p: string): void => {\n                const index = s.findIndex(sub => sub.pattern === p);\n                if (index > -1) {\n                    s.splice(index, 1);\n                }\n            };\n\n            if (pattern instanceof Array) {\n                pattern.forEach(p => {\n                    removeEntry(p);\n                });\n            } else {\n                removeEntry(pattern);\n            }\n        }\n\n        return tools.maybeCallback(cb);\n    }\n\n    publishToClients(_client: SubscriptionClient, _type: string, _id: string, _obj: any): number {\n        throw new Error('no communication handling implemented');\n    }\n\n    deleteOldBackupFiles(baseFilename: string): void {\n        // delete files only if settings.backupNumber is not 0\n        let files = fs.readdirSync(this.backupDir);\n        files.sort();\n        const limit = Date.now() - this.settings.backup.hours * 3600000;\n\n        files = files.filter(f => f.endsWith(`${baseFilename}.gz`));\n\n        while (files.length > this.settings.backup.files) {\n            const file = files.shift();\n            if (!file) {\n                continue;\n            }\n            // extract time\n            const ms = new Date(`${file.substring(0, 10)} ${file.substring(11, 16).replace('-', ':')}:00`).getTime();\n            if (limit > ms) {\n                try {\n                    fs.unlinkSync(path.join(this.backupDir, file));\n                } catch (e) {\n                    this.log.error(\n                        `${this.namespace} Cannot delete file \"${path.join(this.backupDir, file)}: ${e.message}`,\n                    );\n                }\n            }\n        }\n    }\n\n    getTimeStr(date: number): string {\n        const dateObj = new Date(date);\n\n        let text = `${dateObj.getFullYear().toString()}-`;\n        let v = dateObj.getMonth() + 1;\n        if (v < 10) {\n            text += '0';\n        }\n        text += `${v.toString()}-`;\n\n        v = dateObj.getDate();\n        if (v < 10) {\n            text += '0';\n        }\n        text += `${v.toString()}_`;\n\n        v = dateObj.getHours();\n        if (v < 10) {\n            text += '0';\n        }\n        text += `${v.toString()}-`;\n\n        v = dateObj.getMinutes();\n        if (v < 10) {\n            text += '0';\n        }\n        text += v.toString();\n\n        return text;\n    }\n\n    /**\n     * Handle saving the dataset incl. backups\n     */\n    async saveState(): Promise<void> {\n        try {\n            const jsonString = await this.saveDataset();\n\n            if (!this.settings.backup.disabled && jsonString) {\n                this.saveBackup(jsonString);\n            }\n        } finally {\n            if (this.stateTimer) {\n                clearTimeout(this.stateTimer);\n                this.stateTimer = null;\n            }\n        }\n    }\n\n    /**\n     * Saves the dataset into File incl. handling of a fallback backup file\n     *\n     * @returns dataset JSON string of the complete dataset to also be stored into a compressed backup file\n     */\n    async saveDataset(): Promise<string> {\n        const jsonString = JSON.stringify(this.dataset);\n\n        try {\n            await fs.writeFile(`${this.datasetName}.new`, jsonString);\n        } catch (e) {\n            this.log.error(`${this.namespace} Cannot save Dataset to ${this.datasetName}.new: ${e.message}`);\n            return jsonString;\n        }\n\n        let bakOk = true;\n        try {\n            if (await fs.pathExists(this.datasetName)) {\n                try {\n                    await fs.move(this.datasetName, `${this.datasetName}.bak`, { overwrite: true });\n                } catch (e) {\n                    bakOk = false;\n                    this.log.error(`${this.namespace} Cannot backup file ${this.datasetName}.bak: ${e.message}`);\n                }\n            } else {\n                bakOk = false;\n            }\n        } catch {\n            bakOk = false;\n            // ignore, file does not exist\n        }\n\n        try {\n            await fs.move(`${this.datasetName}.new`, this.datasetName, { overwrite: true });\n        } catch (e) {\n            this.log.error(\n                `${this.namespace} Cannot move ${this.datasetName}.new to ${this.datasetName}: ${e.message}. Try direct write as fallback`,\n            );\n            try {\n                await fs.writeFile(this.datasetName, jsonString);\n            } catch (e) {\n                this.log.error(`${this.namespace} Cannot directly write Dataset to ${this.datasetName}: ${e.message}`);\n                return jsonString;\n            }\n        }\n\n        if (!bakOk) {\n            // it seems the bak File is not successfully there, write current content again\n            try {\n                await fs.writeFile(`${this.datasetName}.bak`, jsonString);\n            } catch (e) {\n                this.log.error(`${this.namespace} Cannot save ${this.datasetName}.bak: ${e.message}`);\n            }\n        }\n\n        return jsonString;\n    }\n\n    /**\n     * Stores a compressed backup of the DB in definable intervals\n     *\n     * @param jsonString JSON string of the complete dataset to also be stored into a compressed backup file\n     */\n    saveBackup(jsonString: string): void {\n        // save files for the last x hours\n        const now = Date.now();\n\n        // makes backups only if settings.backupInterval is not 0\n        if (this.settings.backup.period && (!this.lastSave || now - this.lastSave > this.settings.backup.period)) {\n            this.lastSave = now;\n            const backFileName = path.join(\n                this.backupDir,\n                `${this.getTimeStr(now)}_${this.settings.fileDB.fileName}.gz`,\n            );\n\n            try {\n                if (!fs.existsSync(backFileName)) {\n                    const output = fs.createWriteStream(backFileName);\n                    output.on('error', err => {\n                        this.log.error(`${this.namespace} Cannot save ${this.datasetName}: ${err.stack}`);\n                    });\n\n                    const compress = createGzip();\n                    /* The following line will pipe everything written into compress to the file stream */\n                    compress.pipe(output);\n                    /* Since we're piped through the file stream, the following line will do:\n                       'Hello World!'->gzip compression->file which is the desired effect */\n                    compress.write(jsonString);\n                    compress.end();\n\n                    // analyse older files\n                    this.deleteOldBackupFiles(this.settings.fileDB.fileName);\n                }\n            } catch (e) {\n                this.log.error(`${this.namespace} Cannot save backup ${backFileName}: ${e.message}`);\n            }\n        }\n    }\n\n    getStatus(): DbStatus {\n        return { type: 'file', server: true };\n    }\n\n    getClients(): Record<string, any> {\n        return {};\n    }\n\n    publishAll(type: string, id: string, obj: any): number {\n        if (id === undefined) {\n            this.log.error(`${this.namespace} Can not publish empty ID`);\n            return 0;\n        }\n\n        const clients = this.getClients();\n        let publishCount = 0;\n\n        if (clients && typeof clients === 'object') {\n            for (const i of Object.keys(clients)) {\n                publishCount += this.publishToClients(clients[i], type, id, obj);\n            }\n        }\n\n        // local subscriptions\n        if (\n            this.change &&\n            this.callbackSubscriptionClient._subscribe &&\n            this.callbackSubscriptionClient._subscribe[type]\n        ) {\n            for (const entry of this.callbackSubscriptionClient._subscribe[type]) {\n                if (entry.regex.test(id)) {\n                    // @ts-expect-error we have checked 3 lines above\n                    setImmediate(() => this.change(id, obj));\n                    break;\n                }\n            }\n        }\n\n        return publishCount;\n    }\n\n    // Destructor of the class. Called by shutting down.\n    async destroy(): Promise<void> {\n        if (this.stateTimer) {\n            clearTimeout(this.stateTimer);\n            await this.saveState();\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": ["path", "fs", "e", "err", "pattern"]
}
