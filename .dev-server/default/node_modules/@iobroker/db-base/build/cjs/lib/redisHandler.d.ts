import type { Socket } from 'node:net';
import { EventEmitter } from 'node:events';
import type { InternalLogger } from '@iobroker/js-controller-common-db/tools';
type NestedArray<T> = T[] | NestedArray<T>[];
interface RedisHandlerOptions {
    log: InternalLogger;
    logScope?: string;
    handleAsBuffers: boolean;
    enhancedLogging?: boolean;
}
interface MultiCallElement {
    responseIds: ResponseId[];
    execCalled: boolean;
    responseCount: number;
    responseMap: Map<ResponseId, Buffer | null>;
    execId?: ResponseId;
}
interface FullMultiCallElement extends MultiCallElement {
    execId: ResponseId;
}
type ResponseId = number | null;
/**
 * Class to handle a redis connection and provide events to react on for
 * all incoming Redis commands
 */
export declare class RedisHandler extends EventEmitter {
    private readonly socket;
    private readonly logScope;
    private readonly handleBuffers;
    private readonly options;
    private readonly log;
    private readonly socketId;
    private initialized;
    private stop;
    private readonly activeMultiCalls;
    private readonly writeQueue;
    private responseId;
    private readonly resp;
    /**
     * Initialize and register all data handlers to send out events on new commands
     *
     * @param socket Network Socket/Connection
     * @param options options objects, currently mainly for logger
     */
    constructor(socket: Socket, options: RedisHandlerOptions);
    /**
     * Handle one incoming command, assign responseId and emit event to be handled
     *
     * @param data Array RESP data
     */
    _handleCommand(data: any[]): void;
    /**
     * Check if the response to a certain command can be send out directly or
     * if it needs to wait till earlier responses are ready
     *
     * @param responseId ID of the response
     * @param data Buffer to send out
     */
    _sendQueued(responseId: ResponseId, data: Buffer): void;
    /**
     * Really write out a response to the network connection
     *
     * @param data Buffer to send out
     */
    _write(data: Buffer): void;
    /**
     * Guard to make sure a response is valid to be sent out
     *
     * @param responseId ID of the response
     * @param data Buffer to send out
     */
    sendResponse(responseId: ResponseId, data: Buffer): void;
    /**
     * Close network connection
     */
    close(): void;
    /**
     * Return if socket/handler active or closed
     *
     * @returns is Handler/Connection active (not closed)
     */
    isActive(): boolean;
    /**
     * Encode RESP's Null value to RESP buffer and send out
     *
     * @param responseId ID of the response
     */
    sendNull(responseId: ResponseId): void;
    /**
     * Encode RESP's Null Array value to RESP buffer and send out
     *
     * @param responseId ID of the response
     */
    sendNullArray(responseId: ResponseId): void;
    /**
     * Encode string to RESP buffer and send out
     *
     * @param responseId ID od the response
     * @param str String to encode
     */
    sendString(responseId: ResponseId, str: string): void;
    /**
     * Encode error object to RESP buffer and send out
     *
     * @param responseId ID of the response
     * @param error Error object with error details to send out
     */
    sendError(responseId: ResponseId, error: Error): void;
    /**
     * Encode integer to RESP buffer and send out
     *
     * @param responseId ID of the response
     * @param num Integer to send out
     */
    sendInteger(responseId: ResponseId, num: number): void;
    /**
     * Encode RESP's bulk string to RESP buffer and send out
     *
     * @param responseId ID of the response
     * @param str String to send out
     */
    sendBulk(responseId: ResponseId, str: string): void;
    /**
     * Encode RESP's bulk buffer to RESP buffer.
     *
     * @param responseId ID of the response
     * @param buf Buffer to send out
     */
    sendBufBulk(responseId: ResponseId, buf: Buffer): void;
    /**
     * Encode an Array depending on the type of the elements
     *
     * @param arr Array to encode
     * @returns Array with Buffers with encoded values
     */
    encodeRespArray(arr: unknown[]): NestedArray<Buffer>;
    /**
     * Encode a array values to buffers and send out
     *
     * @param responseId ID of the response
     * @param arr Array to send out
     */
    sendArray(responseId: ResponseId, arr: any[]): void;
    /**
     * Handles a 'multi' command
     *
     */
    _handleMulti(): void;
    /**
     * Handles an 'exec' command
     *
     * @param responseId ID of the response
     */
    _handleExec(responseId: ResponseId): void;
    /**
     * Builds up the exec response and sends it
     *
     * @param multiObj the multi object to send out
     */
    _sendExecResponse(multiObj: FullMultiCallElement): void;
    /**
     * Handles a multi response
     *
     * @param responseId ID of the response
     * @param index index of the multi call
     * @param buf buffer to include in response
     */
    _handleMultiResponse(responseId: ResponseId, index: number, buf: Buffer): void;
}
export {};
//# sourceMappingURL=redisHandler.d.ts.map