{
  "version": 3,
  "sources": ["../../../src/lib/redisHandler.ts"],
  "sourcesContent": ["import type { Socket } from 'node:net';\n// @ts-expect-error no types\nimport Resp from 'respjs';\nimport { EventEmitter } from 'node:events';\nimport { QUEUED_STR_BUF, OK_STR_BUF } from './constants.js';\nimport type { InternalLogger } from '@iobroker/js-controller-common-db/tools';\n\ntype NestedArray<T> = T[] | NestedArray<T>[];\n\ninterface RedisHandlerOptions {\n    // Logger object\n    log: InternalLogger;\n    // log prefix\n    logScope?: string;\n    // if data should be handled as buffer\n    handleAsBuffers: boolean;\n    // additional debug information\n    enhancedLogging?: boolean;\n}\n\ninterface WriteQueueElement {\n    // response id\n    id: ResponseId;\n    // response data, temporary false if not ready to sent yet\n    data: false | Buffer;\n}\n\ninterface FullWriteQueueElement extends WriteQueueElement {\n    // response data\n    data: Buffer;\n}\n\ninterface MultiCallElement {\n    // all response ids of the multi call\n    responseIds: ResponseId[];\n    // indicator if exec already called\n    execCalled: boolean;\n    // number of responses which are already ready\n    responseCount: number;\n    // all responses as a map in correct order, key is responseId, value is null if no response there yet\n    responseMap: Map<ResponseId, Buffer | null>;\n    // id of the exec response\n    execId?: ResponseId;\n}\n\ninterface FullMultiCallElement extends MultiCallElement {\n    // id of the exec response\n    execId: ResponseId;\n}\n\n// null if send without id\ntype ResponseId = number | null;\n\n/**\n * Class to handle a redis connection and provide events to react on for\n * all incoming Redis commands\n */\nexport class RedisHandler extends EventEmitter {\n    private readonly socket: Socket;\n    private readonly logScope: string;\n    private readonly handleBuffers: boolean;\n    private readonly options: RedisHandlerOptions;\n    private readonly log: InternalLogger;\n    private readonly socketId: string;\n    private initialized: boolean;\n    private stop: boolean;\n    private readonly activeMultiCalls: MultiCallElement[];\n    private readonly writeQueue: WriteQueueElement[];\n    private responseId: number = 0;\n    private readonly resp: any;\n\n    /**\n     * Initialize and register all data handlers to send out events on new commands\n     *\n     * @param socket Network Socket/Connection\n     * @param options options objects, currently mainly for logger\n     */\n    constructor(socket: Socket, options: RedisHandlerOptions) {\n        super();\n\n        options = options || {};\n        this.options = options;\n        this.log = options.log || console;\n        this.logScope = options.logScope || '';\n        if (this.logScope.length) {\n            this.logScope += ' ';\n        }\n        this.socket = socket;\n\n        this.socketId = `${this.logScope + socket.remoteAddress}:${socket.remotePort}`;\n        this.initialized = false;\n        this.stop = false;\n\n        this.activeMultiCalls = [];\n        this.writeQueue = [];\n\n        this.handleBuffers = false;\n        const respOptions: Record<string, any> = {};\n        if (options.handleAsBuffers) {\n            this.handleBuffers = true;\n            respOptions.bufBulk = true;\n        }\n        this.resp = new Resp(respOptions);\n\n        this.resp.on('error', (err: any) => {\n            this.log.error(`${this.socketId} (Init=${this.initialized}) Redis error:${err}`);\n            if (this.initialized) {\n                this.sendError(null, new Error(`PARSER ERROR ${err}`)); // TODO\n            } else {\n                this.close();\n            }\n        });\n\n        this.resp.on('data', (data: any) => this._handleCommand(data));\n\n        socket.on('data', data => {\n            if (this.options.enhancedLogging) {\n                this.log.silly(\n                    `${this.socketId} New Redis request: ${\n                        data.length > 1024\n                            ? `${data\n                                  .toString()\n                                  .replace(/[\\r\\n]+/g, '')\n                                  .substring(0, 100)} -- ${data.length} bytes`\n                            : data.toString().replace(/[\\r\\n]+/g, '')\n                    }`,\n                );\n            }\n            this.resp.write(data);\n        });\n\n        socket.on('error', err => {\n            if (!this.stop) {\n                this.log.debug(`${this.socketId} Redis Socket error: ${err.stack}`);\n            }\n            if (this.socket) {\n                this.socket.destroy();\n            }\n        });\n    }\n\n    /**\n     * Handle one incoming command, assign responseId and emit event to be handled\n     *\n     * @param data Array RESP data\n     */\n    _handleCommand(data: any[]): void {\n        let command = data.splice(0, 1)[0];\n        if (this.handleBuffers) {\n            // Command and pot. first parameter should always be Buffer\n            command = command.toString('utf-8');\n            if (Buffer.isBuffer(data[0])) {\n                data[0] = data[0].toString('utf-8');\n            }\n            // Binary data only relevant for GET and SET in our case\n            if (command !== 'set' && data.length > 1) {\n                for (let i = 1; i < data.length; i++) {\n                    if (Buffer.isBuffer(data[i])) {\n                        data[i] = data[i].toString('utf-8');\n                    }\n                }\n            }\n        }\n\n        if (this.responseId === Number.MAX_VALUE) {\n            this.responseId = 0;\n        }\n        const responseId = ++this.responseId;\n\n        if (this.options.enhancedLogging) {\n            this.log.silly(\n                `${this.socketId} Parser result: id=${responseId}, command=${command}, data=${\n                    JSON.stringify(data).length > 1024\n                        ? `${JSON.stringify(data).substring(0, 100)} -- ${JSON.stringify(data).length} bytes`\n                        : JSON.stringify(data)\n                }`,\n            );\n        }\n\n        if (command === 'multi') {\n            if (this.activeMultiCalls.length && !this.activeMultiCalls[0].execCalled) {\n                // should never happen\n                this.log.warn(`${this.socketId} Conflicting multi call`);\n            }\n            this._handleMulti();\n            return;\n        }\n\n        // multi active and exec not called yet\n        if (this.activeMultiCalls.length && !this.activeMultiCalls[0].execCalled && command !== 'exec') {\n            // store all response ids so we know which need to be in the multi call\n            this.activeMultiCalls[0].responseIds.push(responseId);\n            // add it for the correct order will be overwritten with correct response\n            this.activeMultiCalls[0].responseMap.set(responseId, null);\n        } else {\n            // multi response ids should not be pushed - we will answer combined\n            this.writeQueue.push({ id: responseId, data: false });\n        }\n\n        if (command === 'exec') {\n            this._handleExec(responseId);\n            return;\n        }\n\n        if (command === 'info') {\n            this.initialized = true;\n        }\n\n        if (this.listenerCount(command) !== 0) {\n            setImmediate(() => this.emit(command, data, responseId));\n        } else {\n            this.sendError(responseId, new Error(`${command} NOT SUPPORTED`));\n        }\n    }\n\n    /**\n     * Check if the response to a certain command can be send out directly or\n     * if it needs to wait till earlier responses are ready\n     *\n     * @param responseId ID of the response\n     * @param data Buffer to send out\n     */\n    _sendQueued(responseId: ResponseId, data: Buffer): void {\n        let idx = 0;\n\n        while (this.writeQueue.length && idx < this.writeQueue.length) {\n            // we found the queue entry that matches with the responseId, so store the data so be sent out\n            if (this.writeQueue[idx].id === responseId) {\n                this.writeQueue[idx].data = data;\n                // if we found it not on first index we are done because we can not send it out,\n                // need to wait for index 0 to have a complete answer\n                if (idx > 0) {\n                    break;\n                }\n            }\n            // when data for queue entry 0 are preset (!== false) we can send it, remove the first entry\n            // and check the other entries if they have completed responses too\n            if (idx === 0 && this.writeQueue[idx].data !== false) {\n                const response = this.writeQueue.shift() as FullWriteQueueElement;\n                if (this.options.enhancedLogging) {\n                    this.log.silly(\n                        `${this.socketId} Redis response (${response.id}): ${\n                            response.data.length > 1024\n                                ? `${data.length} bytes`\n                                : response.data.toString().replace(/[\\r\\n]+/g, '')\n                        }`,\n                    );\n                }\n\n                this._write(response.data);\n                // We sended out first queue entry but no further response is ready\n                // and we do not need to check the whole queue, so we are done here\n                if (this.writeQueue.length && this.writeQueue[idx].data === false) {\n                    break;\n                }\n            } else {\n                // we have not found the response on the current index, try next one\n                idx++;\n            }\n        }\n\n        if (idx > 0) {\n            if (this.options.enhancedLogging) {\n                this.log.silly(`${this.socketId} Redis response (${responseId}): Response queued`);\n            }\n        }\n    }\n\n    /**\n     * Really write out a response to the network connection\n     *\n     * @param data Buffer to send out\n     */\n    _write(data: Buffer): void {\n        this.socket.write(data);\n    }\n\n    /**\n     * Guard to make sure a response is valid to be sent out\n     *\n     * @param responseId ID of the response\n     * @param data Buffer to send out\n     */\n    sendResponse(responseId: ResponseId, data: Buffer): void {\n        // handle responses without a specific request like publishing data, so send directly\n        if (responseId === null) {\n            if (this.options.enhancedLogging) {\n                this.log.silly(`${this.socketId} Redis response DIRECT: ${data.toString().replace(/[\\r\\n]+/g, '')}`);\n            }\n            return this._write(data);\n        }\n        if (!responseId) {\n            throw new Error('Invalid implementation: no responseId provided!');\n        }\n        if (!data) {\n            this.log.warn(`${this.socketId} Not able to write ${JSON.stringify(data)}`);\n            data = Resp.encodeError(new Error(`INVALID RESPONSE: ${JSON.stringify(data)}`));\n        }\n\n        setImmediate(() => this._sendQueued(responseId, data));\n    }\n\n    /**\n     * Close network connection\n     */\n    close(): void {\n        this.log.silly(`${this.socketId} close Redis connection`);\n        this.stop = true;\n        this.socket.end();\n    }\n\n    /**\n     * Return if socket/handler active or closed\n     *\n     * @returns is Handler/Connection active (not closed)\n     */\n    isActive(): boolean {\n        return !this.stop;\n    }\n\n    /**\n     * Encode RESP's Null value to RESP buffer and send out\n     *\n     * @param responseId ID of the response\n     */\n    sendNull(responseId: ResponseId): void {\n        for (let i = 0; i < this.activeMultiCalls.length; i++) {\n            if (this.activeMultiCalls[i].responseIds.includes(responseId)) {\n                this._handleMultiResponse(responseId, i, Resp.encodeNull());\n                return;\n            }\n        }\n\n        this.sendResponse(responseId, Resp.encodeNull());\n    }\n\n    /**\n     * Encode RESP's Null Array value to RESP buffer and send out\n     *\n     * @param responseId ID of the response\n     */\n    sendNullArray(responseId: ResponseId): void {\n        for (let i = 0; i < this.activeMultiCalls.length; i++) {\n            if (this.activeMultiCalls[i].responseIds.includes(responseId)) {\n                this._handleMultiResponse(responseId, i, Resp.encodeNullArray());\n                return;\n            }\n        }\n\n        this.sendResponse(responseId, Resp.encodeNullArray());\n    }\n\n    /**\n     * Encode string to RESP buffer and send out\n     *\n     * @param responseId ID od the response\n     * @param str String to encode\n     */\n    sendString(responseId: ResponseId, str: string): void {\n        for (let i = 0; i < this.activeMultiCalls.length; i++) {\n            if (this.activeMultiCalls[i].responseIds.includes(responseId)) {\n                this._handleMultiResponse(responseId, i, Resp.encodeString(str));\n                return;\n            }\n        }\n\n        this.sendResponse(responseId, Resp.encodeString(str));\n    }\n\n    /**\n     * Encode error object to RESP buffer and send out\n     *\n     * @param responseId ID of the response\n     * @param error Error object with error details to send out\n     */\n    sendError(responseId: ResponseId, error: Error): void {\n        this.log.warn(`${this.socketId} Error from InMemDB: ${error.stack}`);\n\n        for (let i = 0; i < this.activeMultiCalls.length; i++) {\n            if (this.activeMultiCalls[i].responseIds.includes(responseId)) {\n                this._handleMultiResponse(responseId, i, Resp.encodeError(error));\n                return;\n            }\n        }\n\n        this.sendResponse(responseId, Resp.encodeError(error));\n    }\n\n    /**\n     * Encode integer to RESP buffer and send out\n     *\n     * @param responseId ID of the response\n     * @param num Integer to send out\n     */\n    sendInteger(responseId: ResponseId, num: number): void {\n        for (let i = 0; i < this.activeMultiCalls.length; i++) {\n            if (this.activeMultiCalls[i].responseIds.includes(responseId)) {\n                this._handleMultiResponse(responseId, i, Resp.encodeInteger(num));\n                return;\n            }\n        }\n\n        this.sendResponse(responseId, Resp.encodeInteger(num));\n    }\n\n    /**\n     * Encode RESP's bulk string to RESP buffer and send out\n     *\n     * @param responseId ID of the response\n     * @param str String to send out\n     */\n    sendBulk(responseId: ResponseId, str: string): void {\n        for (let i = 0; i < this.activeMultiCalls.length; i++) {\n            if (this.activeMultiCalls[i].responseIds.includes(responseId)) {\n                this._handleMultiResponse(responseId, i, Resp.encodeBulk(str));\n                return;\n            }\n        }\n\n        this.sendResponse(responseId, Resp.encodeBulk(str));\n    }\n\n    /**\n     * Encode RESP's bulk buffer to RESP buffer.\n     *\n     * @param responseId ID of the response\n     * @param buf Buffer to send out\n     */\n    sendBufBulk(responseId: ResponseId, buf: Buffer): void {\n        for (let i = 0; i < this.activeMultiCalls.length; i++) {\n            if (this.activeMultiCalls[i].responseIds.includes(responseId)) {\n                this._handleMultiResponse(responseId, i, Resp.encodeBufBulk(buf));\n                return;\n            }\n        }\n\n        this.sendResponse(responseId, Resp.encodeBufBulk(buf));\n    }\n\n    /**\n     * Encode an Array depending on the type of the elements\n     *\n     * @param arr Array to encode\n     * @returns Array with Buffers with encoded values\n     */\n    encodeRespArray(arr: unknown[]): NestedArray<Buffer> {\n        const returnArr: NestedArray<Buffer> = new Array(arr.length);\n        arr.forEach((value, i) => {\n            if (Array.isArray(value)) {\n                returnArr[i] = this.encodeRespArray(value);\n            } else if (Buffer.isBuffer(value)) {\n                returnArr[i] = Resp.encodeBufBulk(value);\n            } else if (value === null) {\n                returnArr[i] = Resp.encodeNull();\n            } else if (typeof value === 'number') {\n                returnArr[i] = Resp.encodeInteger(value);\n            } else {\n                returnArr[i] = Resp.encodeBulk(value);\n            }\n        });\n\n        return returnArr;\n    }\n\n    /**\n     * Encode a array values to buffers and send out\n     *\n     * @param responseId ID of the response\n     * @param arr Array to send out\n     */\n    sendArray(responseId: ResponseId, arr: any[]): void {\n        for (let i = 0; i < this.activeMultiCalls.length; i++) {\n            if (this.activeMultiCalls[i].responseIds.includes(responseId)) {\n                this._handleMultiResponse(responseId, i, Resp.encodeArray(this.encodeRespArray(arr)));\n                return;\n            }\n        }\n\n        this.sendResponse(responseId, Resp.encodeArray(this.encodeRespArray(arr)));\n    }\n\n    /**\n     * Handles a 'multi' command\n     *\n     */\n    _handleMulti(): void {\n        this.activeMultiCalls.unshift({\n            responseIds: [],\n            execCalled: false,\n            responseCount: 0,\n            responseMap: new Map(),\n        });\n    }\n\n    /**\n     * Handles an 'exec' command\n     *\n     * @param responseId ID of the response\n     */\n    _handleExec(responseId: ResponseId): void {\n        if (!this.activeMultiCalls[0]) {\n            this.sendError(responseId, new Error('EXEC without MULTI'));\n            return;\n        }\n\n        this.activeMultiCalls[0].execId = responseId;\n        this.activeMultiCalls[0].execCalled = true;\n\n        // maybe we have all fullfilled yet\n        if (this.activeMultiCalls[0].responseCount === this.activeMultiCalls[0].responseIds.length) {\n            const multiRespObj = this.activeMultiCalls.shift() as FullMultiCallElement;\n            this._sendExecResponse(multiRespObj);\n        }\n    }\n\n    /**\n     * Builds up the exec response and sends it\n     *\n     * @param multiObj the multi object to send out\n     */\n    _sendExecResponse(multiObj: FullMultiCallElement): void {\n        // collect all 'QUEUED' answers\n        const queuedStrArr = new Array(multiObj.responseCount).fill(QUEUED_STR_BUF);\n\n        this._sendQueued(\n            multiObj.execId,\n            Buffer.concat([OK_STR_BUF, ...queuedStrArr, Resp.encodeArray(Array.from(multiObj.responseMap.values()))]),\n        );\n    }\n\n    /**\n     * Handles a multi response\n     *\n     * @param responseId ID of the response\n     * @param index index of the multi call\n     * @param buf buffer to include in response\n     */\n    _handleMultiResponse(responseId: ResponseId, index: number, buf: Buffer): void {\n        this.activeMultiCalls[index].responseMap.set(responseId, buf);\n        this.activeMultiCalls[index].responseCount++;\n        if (\n            this.activeMultiCalls[index].execCalled &&\n            this.activeMultiCalls[index].responseCount === this.activeMultiCalls[index].responseIds.length\n        ) {\n            const multiRespObj = this.activeMultiCalls.splice(index, 1)[0] as FullMultiCallElement;\n            this._sendExecResponse(multiRespObj);\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": ["Resp"]
}
