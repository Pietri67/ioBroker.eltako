"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var statesInRedisClient_exports = {};
__export(statesInRedisClient_exports, {
  StateRedisClient: () => StateRedisClient
});
module.exports = __toCommonJS(statesInRedisClient_exports);
var import_ioredis = __toESM(require("ioredis"), 1);
var import_db_base = require("@iobroker/db-base");
var import_node_util = require("node:util");
function bufferJsonDecoder(key, value) {
  if (import_db_base.tools.isObject(value) && value.type === "Buffer" && value.data && Array.isArray(value.data)) {
    return Buffer.from(value.data);
  }
  return value;
}
class StateRedisClient {
  settings;
  namespaceRedis;
  namespaceRedisL;
  namespaceMsg;
  namespaceLog;
  namespaceSession;
  metaNamespace;
  globalMessageId;
  globalLogId;
  namespace;
  supportedProtocolVersions;
  stop;
  client;
  /** Client for user events */
  sub;
  /** Client for system events */
  subSystem;
  log;
  activeProtocolVersion;
  userSubscriptions;
  /** System level subscriptions value true means messagebox is subscribed */
  systemSubscriptions;
  constructor(settings) {
    this.settings = settings || {};
    this.namespaceRedis = `${this.settings.redisNamespace || "io"}.`;
    this.namespaceRedisL = this.namespaceRedis.length;
    this.namespaceMsg = `${this.settings.namespaceMsg || "messagebox"}.`;
    this.namespaceLog = `${this.settings.namespaceLog || "log"}.`;
    this.namespaceSession = `${this.settings.namespaceSession || "session"}.`;
    this.metaNamespace = `${this.settings.metaNamespace || "meta"}.`;
    this.globalMessageId = Math.round(Math.random() * 1e8);
    this.globalLogId = Math.round(Math.random() * 1e8);
    this.namespace = this.settings.namespace || this.settings.hostname || "";
    this.supportedProtocolVersions = ["4"];
    this.stop = false;
    this.client = null;
    this.sub = null;
    this.subSystem = null;
    this.userSubscriptions = {};
    this.systemSubscriptions = {};
    this.log = import_db_base.tools.getLogger(this.settings.logger);
    if (this.settings.autoConnect !== false) {
      this.connectDb();
    }
  }
  /**
   * Checks if we are allowed to start and sets the protocol version accordingly
   *
   */
  async _determineProtocolVersion() {
    if (!this.client) {
      throw new Error(import_db_base.tools.ERRORS.ERROR_DB_CLOSED);
    }
    let protoVersion;
    try {
      protoVersion = await this.client.get(`${this.metaNamespace}states.protocolVersion`);
    } catch (e) {
      if (e.message.includes("GET-UNSUPPORTED")) {
        return;
      }
    }
    if (!protoVersion) {
      const highestVersion = Math.max(...this.supportedProtocolVersions.map((value) => parseInt(value)));
      await this.setProtocolVersion(highestVersion);
      this.activeProtocolVersion = highestVersion.toString();
      return;
    }
    if (this.supportedProtocolVersions.includes(protoVersion)) {
      this.activeProtocolVersion = protoVersion;
    } else {
      throw new Error(`This host does not support protocol version "${protoVersion}"`);
    }
  }
  connectDb() {
    this.settings.connection = this.settings.connection || {};
    const onChange = this.settings.change;
    const onChangeUser = this.settings.changeUser;
    let ready = false;
    let initError = false;
    let connected = false;
    let reconnectCounter = 0;
    let errorLogged = false;
    this.settings.connection.maxQueue = this.settings.connection.maxQueue || 1e3;
    this.settings.connection.options = this.settings.connection.options || {};
    const retry_max_delay = this.settings.connection.options.retry_max_delay || 5e3;
    const retry_max_count = this.settings.connection.options.retry_max_count || 19;
    this.settings.connection.options.retryStrategy = (reconnectCount) => {
      if (!ready && initError) {
        return new Error("No more tries");
      }
      if (this.stop) {
        return new Error("Client has stopped ... no retries anymore");
      }
      if (ready && reconnectCount >= retry_max_count) {
        return new Error("Stop trying to reconnect");
      }
      if (!ready) {
        return 300;
      }
      return retry_max_delay;
    };
    delete this.settings.connection.options.retry_max_delay;
    this.settings.connection.options.enableReadyCheck = true;
    if (this.settings.connection.port === 0) {
      this.settings.connection.options.path = this.settings.connection.host;
      this.log.debug(`${this.namespace} Redis States: Use File Socket for connection: ${this.settings.connection.options.path}`);
    } else if (Array.isArray(this.settings.connection.host)) {
      this.settings.connection.options.sentinels = this.settings.connection.host.map((redisNode, idx) => ({
        host: redisNode,
        port: Array.isArray(this.settings.connection.port) ? this.settings.connection.port[idx] : this.settings.connection.port
      }));
      this.settings.connection.options.name = this.settings.connection.sentinelName ? this.settings.connection.sentinelName : "mymaster";
      this.log.debug(`${this.namespace} Redis States: Use Sentinel for connection: ${this.settings.connection.options.name}, ${JSON.stringify(this.settings.connection.options.sentinels)}`);
    } else {
      this.settings.connection.options.host = this.settings.connection.host;
      this.settings.connection.options.port = this.settings.connection.port;
      this.log.debug(`${this.namespace} Redis States: Use Redis connection: ${this.settings.connection.options.host}:${this.settings.connection.options.port}`);
    }
    if (this.settings.connection.options.db === void 0) {
      this.settings.connection.options.db = 0;
    }
    if (this.settings.connection.options.family === void 0) {
      this.settings.connection.options.family = 0;
    }
    this.settings.connection.options.password = this.settings.connection.options.auth_pass || this.settings.connection.pass || null;
    this.settings.connection.options.autoResubscribe = false;
    this.settings.connection.options.connectionName = this.namespace.replace(/\s/g, "");
    this.client = new import_ioredis.default(this.settings.connection.options);
    this.client.on("error", (error) => {
      this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} Redis ERROR States: (${this.stop}) ${error.message} / ${error.stack}`);
      if (this.stop) {
        return;
      }
      if (!ready) {
        initError = true;
        if (error.message.startsWith('Protocol error, got "H" as reply type byte.')) {
          this.log.error(`${this.namespace} Could not connect to states database at ${this.settings.connection.options.host}:${this.settings.connection.options.port} (invalid protocol). Please make sure the configured IP and port points to a host running JS-Controller >= 2.0. and that the port is not occupied by other software!`);
        }
        return;
      }
      this.log.error(`${this.namespace} States database error: ${error.message}`);
      errorLogged = true;
    });
    this.client.on("end", () => {
      this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} States-Redis Event end (stop=${this.stop})`);
      if (ready && typeof this.settings.disconnected === "function") {
        this.settings.disconnected();
      }
    });
    this.client.on("connect", () => {
      this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} States-Redis Event connect (stop=${this.stop})`);
      connected = true;
      if (errorLogged) {
        this.log.info(`${this.namespace} Objects database successfully reconnected`);
        errorLogged = false;
      }
    });
    this.client.on("close", () => {
      this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} States-Redis Event close (stop=${this.stop})`);
    });
    this.client.on("reconnecting", () => {
      if (connected && !ready && !initError) {
        reconnectCounter++;
      }
      this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} States-Redis Event reconnect (reconnectCounter=${reconnectCounter}, stop=${this.stop})`);
      if (reconnectCounter > 2) {
        this.log.error(`${this.namespace} The DB port  ${this.settings.connection.options.port} is occupied by something that is not a Redis protocol server. Please check other software running on this port or, if you use iobroker, make sure to update to js-controller 2.0 or higher!`);
        return;
      }
      connected = false;
      initError = false;
    });
    this.client.on("ready", async () => {
      this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} States-Redis Event ready (stop=${this.stop})`);
      if (this.stop || !this.client) {
        return;
      }
      initError = false;
      let initCounter = 0;
      if (!this.subSystem && typeof onChange === "function") {
        initCounter++;
        try {
          await this.client.config("SET", "notify-keyspace-events", "Exe");
        } catch (e) {
          this.log.warn(`${this.namespace} Unable to enable Expiry Keyspace events from Redis Server: ${e.message}`);
        }
        this.log.debug(`${this.namespace} States create System PubSub Client`);
        this.subSystem = new import_ioredis.default(this.settings.connection.options);
        if (typeof onChange === "function") {
          this.subSystem.on("pmessage", (pattern, channel, message) => {
            setImmediate(() => {
              this.log.silly(`${this.namespace} States system redis pmessage ${pattern}/${channel}:${message}`);
              if (channel.startsWith(this.metaNamespace)) {
                if (channel === `${this.metaNamespace}states.protocolVersion` && message !== this.activeProtocolVersion) {
                  if (typeof this.settings.disconnected === "function") {
                    this.log.info(`${this.namespace} States protocol version has changed, disconnecting!`);
                    this.settings.disconnected();
                  }
                }
                return;
              }
              try {
                message = message ? JSON.parse(message, message.includes('"Buffer"') ? bufferJsonDecoder : void 0) : null;
              } catch {
                this.log.warn(`${this.namespace} Cannot parse system pmessage "${message}"`);
                message = null;
              }
              try {
                if (channel.startsWith(this.namespaceRedis) && channel.length > this.namespaceRedisL) {
                  onChange(channel.substring(this.namespaceRedisL), message);
                } else {
                  onChange(channel, message);
                }
              } catch (e) {
                this.log.warn(`${this.namespace} States system pmessage ${channel} ${JSON.stringify(message)} ${e.message}`);
                this.log.warn(`${this.namespace} ${e.stack}`);
              }
            });
          });
        }
        if (typeof onChange === "function" || typeof onChangeUser === "function") {
          this.subSystem.on("message", (channel, message) => setImmediate(() => {
            this.log.silly(`${this.namespace} redis message expired/evicted ${channel}:${message}`);
            try {
              if (channel === `__keyevent@${this.settings.connection.options.db}__:evicted`) {
                this.log.warn(`${this.namespace} Redis has evicted state ${message}. Please check your maxMemory settings for your redis instance!`);
              } else if (channel !== `__keyevent@${this.settings.connection.options.db}__:expired`) {
                this.log.warn(`${this.namespace} Unknown user message ${channel} ${message}`);
                return;
              }
              if (typeof onChange === "function") {
                const found = Object.values(this.systemSubscriptions).find((regex) => regex !== true && regex.test(message));
                found && onChange(message.substring(this.namespaceRedisL), null);
              }
              if (typeof onChangeUser === "function" && this.sub) {
                const found = Object.values(this.userSubscriptions).find((regex) => regex.test(message));
                found && onChangeUser(message.substring(this.namespaceRedisL), null);
              }
            } catch (e) {
              this.log.warn(`${this.namespace} user message ${channel} ${message} ${e.message}`);
              this.log.warn(`${this.namespace} ${e.stack}`);
            }
          }));
        }
        this.subSystem.on("end", () => {
          this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} States-Redis System Event end sub (stop=${this.stop})`);
          ready && typeof this.settings.disconnected === "function" && this.settings.disconnected();
        });
        this.subSystem.on("error", (error) => {
          if (this.stop) {
            return;
          }
          this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} Sub-Client States System No redis connection: ${JSON.stringify(error)}`);
        });
        if (this.settings.connection.enhancedLogging) {
          this.subSystem.on("connect", () => this.log.silly(`${this.namespace} PubSub client States-Redis System Event connect (stop=${this.stop})`));
          this.subSystem.on("close", () => this.log.silly(`${this.namespace} PubSub client States-Redis System Event close (stop=${this.stop})`));
          this.subSystem.on("reconnecting", (reconnectCounter2) => this.log.silly(`${this.namespace} PubSub client States-Redis System Event reconnect (reconnectCounter=${reconnectCounter2}, stop=${this.stop})`));
        }
        this.subSystem.on("ready", async (_error) => {
          try {
            this.subSystem && await this.subSystem.subscribe(`__keyevent@${this.settings.connection.options.db}__:expired`);
          } catch (e) {
            this.log.warn(`${this.namespace} Unable to subscribe to expiry Keyspace events from Redis Server: ${e.message}`);
          }
          try {
            this.subSystem && await this.subSystem.subscribe(`__keyevent@${this.settings.connection.options.db}__:evicted`);
          } catch (e) {
            this.log.warn(`${this.namespace} Unable to subscribe to evicted Keyspace events from Redis Server: ${e.message}`);
          }
          try {
            this.subSystem && await this.subSystem.psubscribe(`${this.metaNamespace}*`);
          } catch (e) {
            this.log.warn(`${this.namespace} Unable to subscribe to meta namespace "${this.metaNamespace}" changes: ${e.message}`);
          }
          if (--initCounter < 1) {
            if (this.settings.connection.port === 0) {
              this.log.debug(`${this.namespace} States ${ready ? "system re" : ""}connected to redis: ${import_db_base.tools.maybeArrayToString(this.settings.connection.host)}`);
            } else {
              this.log.debug(`${this.namespace} States ${ready ? "system re" : ""}connected to redis: ${import_db_base.tools.maybeArrayToString(this.settings.connection.host)}:${import_db_base.tools.maybeArrayToString(this.settings.connection.port)}`);
            }
            !ready && typeof this.settings.connected === "function" && this.settings.connected();
            ready = true;
          }
          if (this.subSystem) {
            for (const sub of Object.keys(this.systemSubscriptions)) {
              try {
                await this.subSystem.psubscribe(sub);
              } catch {
              }
            }
          }
        });
      }
      if (!this.sub && typeof onChangeUser === "function") {
        initCounter++;
        this.log.debug(`${this.namespace} States create User PubSub Client`);
        this.sub = new import_ioredis.default(this.settings.connection.options);
        this.sub.on("pmessage", (pattern, channel, message) => {
          setImmediate(() => {
            this.log.silly(`${this.namespace} States user redis pmessage ${pattern}/${channel}:${message}`);
            try {
              message = message ? JSON.parse(message, message.includes('"Buffer"') ? bufferJsonDecoder : void 0) : null;
            } catch {
              this.log.warn(`${this.namespace} Cannot parse user pmessage "${message}"`);
              message = null;
            }
            try {
              if (channel.startsWith(this.namespaceRedis) && channel.length > this.namespaceRedisL) {
                onChangeUser(channel.substring(this.namespaceRedisL), message);
              } else {
                onChangeUser(channel, message);
              }
            } catch (e) {
              this.log.warn(`${this.namespace} States user pmessage ${channel} ${JSON.stringify(message)} ${e.message}`);
              this.log.warn(`${this.namespace} ${e.stack}`);
            }
          });
        });
        this.sub.on("end", () => {
          this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} States-Redis User Event end sub (stop=${this.stop})`);
          if (ready && typeof this.settings.disconnected === "function") {
            this.settings.disconnected();
          }
        });
        this.sub.on("error", (error) => {
          if (this.stop) {
            return;
          }
          if (this.settings.connection.enhancedLogging) {
            this.log.silly(`${this.namespace} Sub-Client States User No redis connection: ${JSON.stringify(error)}`);
          }
        });
        if (this.settings.connection.enhancedLogging) {
          this.sub.on("connect", () => {
            this.log.silly(`${this.namespace} PubSub client States-Redis User Event connect (stop=${this.stop})`);
          });
          this.sub.on("close", () => {
            this.log.silly(`${this.namespace} PubSub client States-Redis User Event close (stop=${this.stop})`);
          });
          this.sub.on("reconnecting", (reconnectCounter2) => {
            this.log.silly(`${this.namespace} PubSub client States-Redis User Event reconnect (reconnectCounter=${reconnectCounter2}, stop=${this.stop})`);
          });
        }
        this.sub.on("ready", async (_error) => {
          if (!this.sub) {
            return;
          }
          if (--initCounter < 1) {
            if (this.settings.connection.port === 0) {
              this.log.debug(`${this.namespace} States ${ready ? "user re" : ""}connected to redis: ${import_db_base.tools.maybeArrayToString(this.settings.connection.host)}`);
            } else {
              this.log.debug(`${this.namespace} States ${ready ? "user re" : ""}connected to redis: ${import_db_base.tools.maybeArrayToString(this.settings.connection.host)}:${import_db_base.tools.maybeArrayToString(this.settings.connection.port)}`);
            }
            !ready && typeof this.settings.connected === "function" && this.settings.connected();
            ready = true;
          }
          for (const sub of Object.keys(this.userSubscriptions)) {
            try {
              await this.sub.psubscribe(sub);
            } catch {
            }
          }
        });
      }
      try {
        await this._determineProtocolVersion();
      } catch (e) {
        this.log.error(`${this.namespace} ${e.message}`);
        throw new Error("States DB is not allowed to start in the current Multihost environment");
      }
      if (initCounter < 1) {
        if (this.settings.connection.port === 0) {
          this.log.debug(`${this.namespace} States ${ready ? "client re" : ""}connected to redis: ${import_db_base.tools.maybeArrayToString(this.settings.connection.host)}`);
        } else {
          this.log.debug(`${this.namespace} States ${ready ? "client re" : ""}connected to redis: ${import_db_base.tools.maybeArrayToString(this.settings.connection.host)}:${import_db_base.tools.maybeArrayToString(this.settings.connection.port)}`);
        }
        !ready && typeof this.settings.connected === "function" && this.settings.connected();
        ready = true;
      }
    });
  }
  getStatus() {
    return { type: "redis", server: false };
  }
  /**
   * @param id the id of the value. '<this.namespaceRedis>.' will be prepended
   * @param state
   *
   *
   *      an object containing the actual value and some metadata:<br>
   *      setState(id, {'val': val, 'ts': ts, 'ack': ack, 'from': from, 'lc': lc, 'user': user})
   *
   *      if no object is given state is treated as val:<br>
   *      setState(id, val)
   *
   *      <ul><li><b>val</b>  the actual value. Can be any JSON-stringifiable object. If undefined the
   *                          value is kept unchanged.</li>
   *
   *      <li><b>ack</b>  a boolean that can be used to mark a value as confirmed, used in bidirectional systems which
   *                      acknowledge that a value has been successfully set. Will be set to false if undefined.</li>
   *
   *      <li><b>ts</b>   a unix timestamp indicating the last write-operation on the state. Will be set by the
   *                      setState method if undefined.</li>
   *
   *      <li><b>lc</b>   a unix timestamp indicating the last change of the actual value. this should be undefined
   *                      when calling setState, it will be set by the setValue method itself.</li></ul>
   * @param callback will be called when redis confirmed reception of the command
   */
  async setState(id, state, callback) {
    if (!id || typeof id !== "string") {
      return import_db_base.tools.maybeCallbackWithError(callback, `invalid id ${JSON.stringify(id)}`);
    }
    if (!this.client) {
      return import_db_base.tools.maybeCallbackWithError(callback, import_db_base.tools.ERRORS.ERROR_DB_CLOSED);
    }
    if (!import_db_base.tools.isObject(state)) {
      state = {
        val: state
      };
    }
    let expire;
    if (state.expire) {
      expire = state.expire;
      delete state.expire;
    }
    let oldObj;
    try {
      oldObj = await this.client.get(this.namespaceRedis + id);
    } catch (e) {
      this.log.warn(`${this.namespace} get state error: ${e.message}`);
      return import_db_base.tools.maybeCallbackWithRedisError(callback, e, id);
    }
    if (!this.client) {
      return;
    }
    if (!oldObj) {
      oldObj = { val: null };
    } else {
      try {
        oldObj = JSON.parse(oldObj);
      } catch {
        this.log.warn(`${this.namespace} Cannot parse "${oldObj}"`);
        oldObj = { val: null };
      }
    }
    const obj = {};
    if (state.val !== void 0) {
      obj.val = state.val;
    } else {
      obj.val = oldObj.val;
    }
    if (state.ack !== void 0) {
      obj.ack = state.ack === null ? oldObj.ack || false : state.ack;
    } else {
      obj.ack = false;
    }
    if (state.ts !== void 0) {
      obj.ts = state.ts < 9466812e5 ? state.ts * 1e3 : state.ts;
    } else {
      obj.ts = (/* @__PURE__ */ new Date()).getTime();
    }
    if (state.q !== void 0) {
      obj.q = state.q;
    } else {
      obj.q = 0;
    }
    if (typeof state.c === "string" && state.c) {
      obj.c = state.c.substring(0, 512);
    }
    obj.from = state.from;
    if (state.user !== void 0) {
      obj.user = state.user;
    }
    let hasChanged;
    if (state.lc !== void 0) {
      obj.lc = state.lc;
    } else {
      hasChanged = !(0, import_node_util.isDeepStrictEqual)(oldObj.val, obj.val);
      if (!oldObj.lc || hasChanged) {
        obj.lc = obj.ts;
      } else {
        obj.lc = oldObj.lc;
      }
    }
    const objString = JSON.stringify(obj);
    if (expire) {
      try {
        await this.client.setex(this.namespaceRedis + id, expire, objString);
        this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} redis publish ${this.namespaceRedis}${id} ${objString}`);
        await this.client.publish(this.namespaceRedis + id, objString);
        return import_db_base.tools.maybeCallbackWithError(callback, null, id);
      } catch (e) {
        return import_db_base.tools.maybeCallbackWithRedisError(callback, e, id);
      }
    } else {
      try {
        await this.client.set(this.namespaceRedis + id, objString);
        this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} redis publish ${this.namespaceRedis}${id} ${objString}`);
        await this.client.publish(this.namespaceRedis + id, objString);
        return import_db_base.tools.maybeCallbackWithError(callback, null, id);
      } catch (e) {
        return import_db_base.tools.maybeCallbackWithRedisError(callback, e, id);
      }
    }
  }
  /**
   * Promise-version of setState
   *
   * @param id
   * @param state
   * @deprecated use version without `Async` postfix
   */
  setStateAsync(id, state) {
    return new Promise((resolve, reject) => {
      this.setState(id, state, (err, res) => {
        if (err) {
          reject(err);
        } else {
          resolve(res);
        }
      });
    });
  }
  // Used for restore function (do not call it)
  async setRawState(id, state) {
    if (!id || typeof id !== "string") {
      throw new Error(`invalid id ${JSON.stringify(id)}`);
    }
    if (!this.client) {
      throw new Error(import_db_base.tools.ERRORS.ERROR_DB_CLOSED);
    }
    await this.client.set(this.namespaceRedis + id, JSON.stringify(state));
    return id;
  }
  /**
   * Get state from database
   *
   * @param id id of the state
   * @param callback optional callback, leave out and use promise return type
   */
  async getState(id, callback) {
    if (!id || typeof id !== "string") {
      return import_db_base.tools.maybeCallbackWithError(callback, `invalid id ${JSON.stringify(id)}`);
    }
    if (!this.client) {
      return import_db_base.tools.maybeCallbackWithError(callback, import_db_base.tools.ERRORS.ERROR_DB_CLOSED);
    }
    let obj;
    try {
      obj = await this.client.get(this.namespaceRedis + id);
      this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} redis get ${id} ok: ${obj}`);
    } catch (e) {
      this.log.warn(`${this.namespace} redis get ${id}, error - ${e.message}`);
    }
    if (!obj) {
      return import_db_base.tools.maybeCallbackWithError(callback, null, null);
    }
    try {
      obj = JSON.parse(obj);
    } catch {
      this.log.warn(`${this.namespace} Cannot parse "${obj}"`);
      obj = null;
    }
    return import_db_base.tools.maybeCallbackWithError(callback, null, obj);
  }
  /**
   * Promise-version of getState
   *
   * @param id
   */
  getStateAsync(id) {
    return this.getState(id);
  }
  async getStates(keys, callback, dontModify) {
    if (!keys || !Array.isArray(keys)) {
      return import_db_base.tools.maybeCallbackWithError(callback, "no keys");
    }
    if (!keys.length) {
      return import_db_base.tools.maybeCallbackWithError(callback, null, []);
    }
    if (!this.client) {
      return import_db_base.tools.maybeCallbackWithError(callback, import_db_base.tools.ERRORS.ERROR_DB_CLOSED);
    }
    let _keys;
    if (!dontModify) {
      _keys = keys.map((k) => this.namespaceRedis + k);
    } else {
      _keys = keys;
    }
    let obj;
    try {
      obj = await this.client.mget(_keys);
      this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} redis mget ${!obj ? 0 : obj.length} ${_keys.length}`);
    } catch (e) {
      this.log.warn(`${this.namespace} redis mget of ${_keys.length} keys, err: ${e.message}`);
      return import_db_base.tools.maybeCallbackWithRedisError(callback, e, []);
    }
    const result = [];
    obj.forEach((state, i) => {
      try {
        result.push(state ? JSON.parse(state) : null);
      } catch (e) {
        this.log.error(`Parsing error on getStates("${_keys[i]}"), returning "null" for "${state}": ${e.message}`);
        result.push(null);
      }
    });
    return import_db_base.tools.maybeCallbackWithError(callback, null, result);
  }
  /**
   * @param keys - array of keys which will be deleted from db
   * @param callback function to be executed after keys have been deleted
   */
  async _destroyDBHelper(keys, callback) {
    if (!keys || !keys.length) {
      return import_db_base.tools.maybeCallback(callback);
    }
    if (!this.client) {
      return import_db_base.tools.maybeCallbackWithError(callback, import_db_base.tools.ERRORS.ERROR_DB_CLOSED);
    }
    for (const id of keys) {
      try {
        await this.client.del(id);
      } catch {
      }
    }
    return import_db_base.tools.maybeCallback(callback);
  }
  /**
   * @param callback cb function to be executed after DB has been destroyed
   */
  async destroyDB(callback) {
    if (!this.client) {
      return import_db_base.tools.maybeCallbackWithError(callback, import_db_base.tools.ERRORS.ERROR_DB_CLOSED);
    }
    let keys;
    try {
      keys = await this.client.keys(`${this.namespaceRedis}*`);
    } catch {
    }
    return this._destroyDBHelper(keys || [], callback);
  }
  // Destructor of the class. Called by shutting down.
  async destroy() {
    this.stop = true;
    if (this.client) {
      try {
        await this.client.quit();
        this.client.removeAllListeners();
        this.client = null;
      } catch {
      }
    }
    if (this.subSystem) {
      try {
        await this.subSystem.quit();
        this.subSystem.removeAllListeners();
        this.subSystem = null;
      } catch {
      }
    }
    if (this.sub) {
      try {
        await this.sub.quit();
        this.sub.removeAllListeners();
        this.sub = null;
      } catch {
      }
    }
  }
  async delState(id, callback) {
    if (!id || typeof id !== "string") {
      return import_db_base.tools.maybeCallbackWithError(callback, `invalid id ${JSON.stringify(id)}`);
    }
    if (!this.client) {
      return import_db_base.tools.maybeCallbackWithError(callback, import_db_base.tools.ERRORS.ERROR_DB_CLOSED);
    }
    try {
      await this.client.del(this.namespaceRedis + id);
      await this.client.publish(this.namespaceRedis + id, "null");
      this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} redis del ${id}, ok`);
      return import_db_base.tools.maybeCallbackWithError(callback, null, id);
    } catch (e) {
      this.log.warn(`${this.namespace} redis del ${id}, error - ${e.message}`);
      return import_db_base.tools.maybeCallbackWithRedisError(callback, e, id);
    }
  }
  async getKeys(pattern, callback, dontModify) {
    if (!pattern || typeof pattern !== "string") {
      return import_db_base.tools.maybeCallbackWithError(callback, `invalid pattern ${JSON.stringify(pattern)}`);
    }
    if (!this.client) {
      return import_db_base.tools.maybeCallbackWithError(callback, import_db_base.tools.ERRORS.ERROR_DB_CLOSED);
    }
    let obj;
    try {
      obj = await this.client.keys(this.namespaceRedis + pattern);
    } catch (e) {
      return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
    }
    this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} redis keys ${obj.length} ${pattern}`);
    if (obj && !dontModify) {
      const len = this.namespaceRedisL;
      obj = obj.map((el) => el.substring(len));
    }
    return import_db_base.tools.maybeCallbackWithError(callback, null, obj);
  }
  /**
   * @param pattern
   * @param asUser - if true it will be subscribed as user
   * @param callback callback function (optional)
   */
  async subscribe(pattern, asUser, callback) {
    if (!pattern || typeof pattern !== "string") {
      return import_db_base.tools.maybeCallbackWithError(callback, `invalid pattern ${JSON.stringify(pattern)}`);
    }
    if (typeof asUser === "function") {
      callback = asUser;
      asUser = false;
    }
    const subClient = asUser ? this.sub : this.subSystem;
    if (!subClient) {
      return import_db_base.tools.maybeCallbackWithError(callback, import_db_base.tools.ERRORS.ERROR_DB_CLOSED);
    }
    this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} redis psubscribe ${this.namespaceRedis}${pattern}`);
    try {
      await subClient.psubscribe(this.namespaceRedis + pattern);
      if (asUser) {
        this.userSubscriptions[this.namespaceRedis + pattern] = new RegExp(import_db_base.tools.pattern2RegEx(this.namespaceRedis + pattern));
      } else {
        this.systemSubscriptions[this.namespaceRedis + pattern] = new RegExp(import_db_base.tools.pattern2RegEx(this.namespaceRedis + pattern));
      }
      return import_db_base.tools.maybeCallback(callback);
    } catch (e) {
      return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
    }
  }
  /**
   * @param pattern
   * @param callback callback function (optional)
   */
  subscribeUser(pattern, callback) {
    return this.subscribe(pattern, true, callback);
  }
  /**
   * Unsubscribe pattern
   *
   * @param pattern
   * @param asUser - if true it will be unsubscribed as user
   * @param callback
   */
  async unsubscribe(pattern, asUser, callback) {
    if (!pattern || typeof pattern !== "string") {
      return import_db_base.tools.maybeCallbackWithError(callback, `invalid pattern ${JSON.stringify(pattern)}`);
    }
    if (typeof asUser === "function") {
      callback = asUser;
      asUser = false;
    }
    const subClient = asUser ? this.sub : this.subSystem;
    if (!subClient) {
      return import_db_base.tools.maybeCallbackWithRedisError(callback, import_db_base.tools.ERRORS.ERROR_DB_CLOSED);
    }
    this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} redis punsubscribe ${this.namespaceRedis}${pattern}`);
    try {
      await subClient.punsubscribe(this.namespaceRedis + pattern);
      if (asUser) {
        if (this.userSubscriptions[this.namespaceRedis + pattern] !== void 0) {
          delete this.userSubscriptions[this.namespaceRedis + pattern];
        }
      } else {
        if (this.systemSubscriptions[this.namespaceRedis + pattern] !== void 0) {
          delete this.systemSubscriptions[this.namespaceRedis + pattern];
        }
      }
      return import_db_base.tools.maybeCallback(callback);
    } catch (e) {
      return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
    }
  }
  /**
   * @param pattern
   * @param callback callback function (optional)
   */
  unsubscribeUser(pattern, callback) {
    return this.unsubscribe(pattern, true, callback);
  }
  async pushMessage(id, message) {
    if (!id || typeof id !== "string") {
      throw new Error(`invalid id ${JSON.stringify(id)}`);
    }
    if (!this.client) {
      throw new Error(import_db_base.tools.ERRORS.ERROR_DB_CLOSED);
    }
    const fullMessage = { ...message, _id: this.globalMessageId++ };
    if (this.globalMessageId >= 4294967295) {
      this.globalMessageId = 0;
    }
    await this.client.publish(this.namespaceMsg + id, JSON.stringify(fullMessage));
  }
  async subscribeMessage(id, callback) {
    if (!id || typeof id !== "string") {
      return import_db_base.tools.maybeCallbackWithError(callback, `invalid id ${JSON.stringify(id)}`);
    }
    if (!this.subSystem) {
      return import_db_base.tools.maybeCallbackWithError(callback, import_db_base.tools.ERRORS.ERROR_DB_CLOSED);
    }
    if (id.startsWith(".")) {
      id = id.substring(1);
    }
    this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} redis subscribeMessage ${this.namespaceMsg}${id}`);
    try {
      await this.subSystem.psubscribe(this.namespaceMsg + id);
      this.systemSubscriptions[this.namespaceMsg + id] = true;
      return import_db_base.tools.maybeCallback(callback);
    } catch (e) {
      return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
    }
  }
  async unsubscribeMessage(id, callback) {
    if (!id || typeof id !== "string") {
      return import_db_base.tools.maybeCallbackWithError(callback, `invalid id ${JSON.stringify(id)}`);
    }
    if (!this.subSystem) {
      return import_db_base.tools.maybeCallbackWithError(callback, import_db_base.tools.ERRORS.ERROR_DB_CLOSED);
    }
    if (id.startsWith(".")) {
      id = id.substring(1);
    }
    this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} redis unsubscribeMessage ${this.namespaceMsg}${id}`);
    try {
      await this.subSystem.punsubscribe(this.namespaceMsg + id);
      if (this.systemSubscriptions[this.namespaceMsg + id] !== void 0) {
        delete this.systemSubscriptions[this.namespaceMsg + id];
      }
      return import_db_base.tools.maybeCallback(callback);
    } catch (e) {
      return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
    }
  }
  // implementation uses an modified pushLog with internal _id
  async pushLog(id, log, callback) {
    if (!id || typeof id !== "string") {
      return import_db_base.tools.maybeCallbackWithError(callback, `invalid id ${JSON.stringify(id)}`);
    }
    log._id = this.globalLogId++;
    if (this.globalLogId >= 4294967295) {
      this.globalLogId = 0;
    }
    if (this.client) {
      try {
        await this.client.publish(this.namespaceLog + id, JSON.stringify(log));
        return import_db_base.tools.maybeCallbackWithError(callback, null, id);
      } catch (e) {
        return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
      }
    }
  }
  async subscribeLog(id, callback) {
    if (!id || typeof id !== "string") {
      return import_db_base.tools.maybeCallbackWithError(callback, `invalid id ${JSON.stringify(id)}`);
    }
    if (!this.subSystem) {
      return import_db_base.tools.maybeCallbackWithError(callback, import_db_base.tools.ERRORS.ERROR_DB_CLOSED);
    }
    this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} redis subscribeMessage ${this.namespaceLog}${id}`);
    try {
      await this.subSystem.psubscribe(this.namespaceLog + id);
      this.systemSubscriptions[this.namespaceLog + id] = true;
      return import_db_base.tools.maybeCallback(callback);
    } catch (e) {
      return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
    }
  }
  async unsubscribeLog(id, callback) {
    if (!id || typeof id !== "string") {
      return import_db_base.tools.maybeCallbackWithError(callback, `invalid id ${JSON.stringify(id)}`);
    }
    if (!this.subSystem) {
      return import_db_base.tools.maybeCallbackWithError(callback, import_db_base.tools.ERRORS.ERROR_DB_CLOSED);
    }
    this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} redis unsubscribeMessage ${this.namespaceLog}${id}`);
    try {
      await this.subSystem.punsubscribe(this.namespaceLog + id);
      if (this.systemSubscriptions[this.namespaceLog + id] !== void 0) {
        delete this.systemSubscriptions[this.namespaceLog + id];
      }
      return import_db_base.tools.maybeCallback(callback);
    } catch (e) {
      return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
    }
  }
  // TODO: types session obj
  async getSession(id, callback) {
    if (!id || typeof id !== "string") {
      return import_db_base.tools.maybeCallbackWithError(callback, `invalid id ${JSON.stringify(id)}`);
    }
    if (!this.client) {
      return import_db_base.tools.maybeCallbackWithError(callback, import_db_base.tools.ERRORS.ERROR_DB_CLOSED);
    }
    let obj;
    try {
      obj = await this.client.get(this.namespaceSession + id);
    } catch {
    }
    this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} redis get ${id} ${obj}`);
    try {
      obj = obj ? JSON.parse(obj) : null;
    } catch {
      this.log.warn(`${this.namespace} Cannot parse "${obj}"`);
      obj = null;
    }
    return import_db_base.tools.maybeCallback(callback, obj);
  }
  // TODO: types obj
  async setSession(id, expireS, obj, callback) {
    if (!id || typeof id !== "string") {
      return import_db_base.tools.maybeCallbackWithError(callback, `invalid id ${JSON.stringify(id)}`);
    }
    if (!this.client) {
      return import_db_base.tools.maybeCallbackWithError(callback, import_db_base.tools.ERRORS.ERROR_DB_CLOSED);
    }
    try {
      await this.client.setex(this.namespaceSession + id, expireS, JSON.stringify(obj));
      this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} redis setex ${id} ${expireS} ${JSON.stringify(obj)}`);
      return import_db_base.tools.maybeCallback(callback);
    } catch (e) {
      return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
    }
  }
  async destroySession(id, callback) {
    if (!id || typeof id !== "string") {
      return import_db_base.tools.maybeCallbackWithError(callback, `invalid id ${JSON.stringify(id)}`);
    }
    if (!this.client) {
      return import_db_base.tools.maybeCallbackWithError(callback, import_db_base.tools.ERRORS.ERROR_DB_CLOSED);
    }
    id = this.namespaceSession + id;
    this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} redis del ${id}`);
    try {
      await this.client.del(id);
      return import_db_base.tools.maybeCallback(callback);
    } catch (e) {
      return import_db_base.tools.maybeCallbackWithRedisError(callback, e);
    }
  }
  /**
   * Returns the protocol version from DB
   *
   */
  getProtocolVersion() {
    if (!this.client) {
      throw new Error(import_db_base.tools.ERRORS.ERROR_DB_CLOSED);
    }
    return this.client.get(`${this.metaNamespace}states.protocolVersion`);
  }
  /**
   * Sets the protocol version to the DB
   *
   * @param version - protocol version
   */
  async setProtocolVersion(version) {
    if (!this.client) {
      throw new Error(import_db_base.tools.ERRORS.ERROR_DB_CLOSED);
    }
    const versionStr = version.toString();
    if (this.supportedProtocolVersions.includes(versionStr)) {
      await this.client.set(`${this.metaNamespace}states.protocolVersion`, versionStr);
      await this.client.publish(`${this.metaNamespace}states.protocolVersion`, versionStr);
    } else {
      throw new Error("Cannot set an unsupported protocol version on the current host");
    }
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  StateRedisClient
});
//# sourceMappingURL=statesInRedisClient.js.map
