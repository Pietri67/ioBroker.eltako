{
  "version": 3,
  "sources": ["../../../../src/lib/states/statesInRedisClient.ts"],
  "sourcesContent": ["/**\n *      States DB in redis - Client\n *\n *      Copyright 2013-2024 bluefox <dogafox@gmail.com>\n *      Copyright 2013-2014 hobbyquaker\n *\n *      MIT License\n *\n */\n\nimport Redis from 'ioredis';\nimport { tools } from '@iobroker/db-base';\nimport { isDeepStrictEqual } from 'node:util';\nimport type { InternalLogger } from '@iobroker/js-controller-common-db/tools';\nimport type IORedis from 'ioredis';\nimport type { DbStatus, ConnectionOptions } from '@iobroker/db-base/inMemFileDB';\n\ntype JSONDecoderValue = Record<string, any>;\n\n/**\n * Decodes a JSON with buffer value\n *\n * @param key\n * @param value\n */\nfunction bufferJsonDecoder(key: string, value: JSONDecoderValue): Buffer | JSONDecoderValue {\n    if (tools.isObject(value) && value.type === 'Buffer' && value.data && Array.isArray(value.data)) {\n        return Buffer.from(value.data);\n    }\n    return value;\n}\n\ninterface LogObject {\n    /** id of the source instance */\n    from: string;\n    /** log level */\n    severity: string;\n    /** timestamp */\n    ts: number;\n    /** actual content */\n    message: string;\n}\n\ninterface InternalLogObject extends LogObject {\n    /** internal id */\n    _id: number;\n}\n\ntype UserChangeFunction = (id: string, state: ioBroker.State | null) => void;\ntype ChangeFunction = (id: string, state: ioBroker.State | ioBroker.Message | null) => void;\n\nexport interface StatesSettings {\n    connected?: () => void;\n    disconnected?: () => void;\n    changeUser?: UserChangeFunction;\n    change?: ChangeFunction;\n    connection: ConnectionOptions;\n    autoConnect?: boolean;\n    logger?: InternalLogger;\n    hostname?: string;\n    namespace?: string;\n    metaNamespace?: string;\n    namespaceSession?: string;\n    namespaceLog?: string;\n    namespaceMsg?: string;\n    redisNamespace?: string;\n}\n\nexport class StateRedisClient {\n    private settings: StatesSettings;\n    private readonly namespaceRedis: string;\n    private readonly namespaceRedisL: number;\n    namespaceMsg: string;\n    private readonly namespaceLog: string;\n    private readonly namespaceSession: string;\n    private readonly metaNamespace: string;\n    private globalMessageId: number;\n    private globalLogId: number;\n    private readonly namespace: string;\n    private readonly supportedProtocolVersions: string[];\n    private stop: boolean;\n    private client: IORedis.Redis | null;\n    /** Client for user events */\n    private sub: IORedis.Redis | null;\n    /** Client for system events */\n    private subSystem: IORedis.Redis | null;\n    private log: InternalLogger;\n    private activeProtocolVersion?: string;\n    private readonly userSubscriptions: Record<string, RegExp>;\n    /** System level subscriptions value true means messagebox is subscribed */\n    private readonly systemSubscriptions: Record<string, RegExp | true>;\n\n    constructor(settings: StatesSettings) {\n        this.settings = settings || {};\n        this.namespaceRedis = `${this.settings.redisNamespace || 'io'}.`;\n        this.namespaceRedisL = this.namespaceRedis.length;\n        this.namespaceMsg = `${this.settings.namespaceMsg || 'messagebox'}.`;\n        this.namespaceLog = `${this.settings.namespaceLog || 'log'}.`;\n        this.namespaceSession = `${this.settings.namespaceSession || 'session'}.`;\n        this.metaNamespace = `${this.settings.metaNamespace || 'meta'}.`;\n\n        this.globalMessageId = Math.round(Math.random() * 100_000_000);\n        this.globalLogId = Math.round(Math.random() * 100_000_000);\n        this.namespace = this.settings.namespace || this.settings.hostname || '';\n\n        this.supportedProtocolVersions = ['4'];\n\n        this.stop = false;\n        this.client = null;\n        this.sub = null;\n        this.subSystem = null;\n\n        this.userSubscriptions = {};\n        this.systemSubscriptions = {};\n\n        this.log = tools.getLogger(this.settings.logger);\n\n        if (this.settings.autoConnect !== false) {\n            this.connectDb();\n        }\n    }\n\n    /**\n     * Checks if we are allowed to start and sets the protocol version accordingly\n     *\n     */\n    async _determineProtocolVersion(): Promise<void> {\n        if (!this.client) {\n            throw new Error(tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        let protoVersion;\n        try {\n            protoVersion = await this.client.get(`${this.metaNamespace}states.protocolVersion`);\n        } catch (e) {\n            if (e.message.includes('GET-UNSUPPORTED')) {\n                // secondary updated and primary < 4.0\n                return;\n            }\n        }\n\n        if (!protoVersion) {\n            // if no proto version existent yet, we set ours\n            const highestVersion = Math.max(...this.supportedProtocolVersions.map(value => parseInt(value)));\n            await this.setProtocolVersion(highestVersion);\n            this.activeProtocolVersion = highestVersion.toString();\n            return;\n        }\n\n        // check if we can support this version\n        if (this.supportedProtocolVersions.includes(protoVersion)) {\n            this.activeProtocolVersion = protoVersion;\n        } else {\n            throw new Error(`This host does not support protocol version \"${protoVersion}\"`);\n        }\n    }\n\n    connectDb(): void {\n        this.settings.connection = this.settings.connection || {};\n\n        const onChange = this.settings.change; // on change handler\n        const onChangeUser = this.settings.changeUser; // on change handler for User events\n\n        let ready = false;\n        let initError = false;\n        let connected = false;\n        let reconnectCounter = 0;\n        let errorLogged = false;\n\n        // limit max number of log entries in the list\n        this.settings.connection.maxQueue = this.settings.connection.maxQueue || 1000;\n\n        this.settings.connection.options = this.settings.connection.options || {};\n        const retry_max_delay = this.settings.connection.options.retry_max_delay || 5000;\n        const retry_max_count = this.settings.connection.options.retry_max_count || 19;\n        this.settings.connection.options.retryStrategy = (reconnectCount: number) => {\n            if (!ready && initError) {\n                return new Error('No more tries');\n            }\n            if (this.stop) {\n                return new Error('Client has stopped ... no retries anymore');\n            }\n            if (ready && reconnectCount >= retry_max_count) {\n                return new Error('Stop trying to reconnect');\n            }\n            // A function that receives an options object as parameter including the retry attempt,\n            // the total_retry_time indicating how much time passed since the last time connected,\n            // the error why the connection was lost and the number of times_connected in total.\n            // If you return a number from this function, the retry will happen exactly after that\n            // time in milliseconds. If you return a non-number, no further retry will happen and\n            // all offline commands are flushed with errors. Return an error to return that\n            // specific error to all offline commands.\n\n            if (!ready) {\n                return 300;\n            }\n            return retry_max_delay;\n            /*if (options.error.code === 'ECONNREFUSED') {\n                // End reconnecting on a specific error and flush all commands with a individual error\n                return new Error('The server refused the connection');\n            }\n            if (options.total_retry_time > 1000 * 60 * 60) {\n                // End reconnecting after a specific timeout and flush all commands with a individual error\n                return new Error('Retry time exhausted');\n            }\n            if (options.times_connected > 10) {\n                // End reconnecting with built in error\n                return undefined;\n            }\n            // reconnect after\n            return Math.max(options.attempt * 100, 3000);*/\n        };\n        delete this.settings.connection.options.retry_max_delay;\n        this.settings.connection.options.enableReadyCheck = true;\n\n        if (this.settings.connection.port === 0) {\n            // Port = 0 means unix socket\n            // initiate a unix socket connection\n            this.settings.connection.options.path = this.settings.connection.host;\n            this.log.debug(\n                `${this.namespace} Redis States: Use File Socket for connection: ${this.settings.connection.options.path}`,\n            );\n        } else if (Array.isArray(this.settings.connection.host)) {\n            // Host is an array means we use a sentinel\n            this.settings.connection.options.sentinels = this.settings.connection.host.map((redisNode, idx) => ({\n                host: redisNode,\n                port: Array.isArray(this.settings.connection.port)\n                    ? this.settings.connection.port[idx]\n                    : this.settings.connection.port,\n            }));\n            this.settings.connection.options.name = this.settings.connection.sentinelName\n                ? this.settings.connection.sentinelName\n                : 'mymaster';\n            this.log.debug(\n                `${this.namespace} Redis States: Use Sentinel for connection: ${\n                    this.settings.connection.options.name\n                }, ${JSON.stringify(this.settings.connection.options.sentinels)}`,\n            );\n        } else {\n            this.settings.connection.options.host = this.settings.connection.host;\n            this.settings.connection.options.port = this.settings.connection.port;\n            this.log.debug(\n                `${this.namespace} Redis States: Use Redis connection: ${this.settings.connection.options.host}:${this.settings.connection.options.port}`,\n            );\n        }\n        if (this.settings.connection.options.db === undefined) {\n            this.settings.connection.options.db = 0;\n        }\n        if (this.settings.connection.options.family === undefined) {\n            this.settings.connection.options.family = 0;\n        }\n        this.settings.connection.options.password =\n            this.settings.connection.options.auth_pass || this.settings.connection.pass || null;\n        this.settings.connection.options.autoResubscribe = false; // We do our own resubscribe because other sometimes not work\n        // REDIS does not allow whitespaces, we have some because of pid\n        this.settings.connection.options.connectionName = this.namespace.replace(/\\s/g, '');\n\n        this.client = new Redis(this.settings.connection.options);\n\n        this.client.on('error', error => {\n            this.settings.connection.enhancedLogging &&\n                this.log.silly(\n                    `${this.namespace} Redis ERROR States: (${this.stop}) ${error.message} / ${error.stack}`,\n                );\n            if (this.stop) {\n                return;\n            }\n            if (!ready) {\n                initError = true;\n                // Seems we have a socket.io server\n                if (error.message.startsWith('Protocol error, got \"H\" as reply type byte.')) {\n                    this.log.error(\n                        `${this.namespace} Could not connect to states database at ${this.settings.connection.options.host}:${this.settings.connection.options.port} (invalid protocol). Please make sure the configured IP and port points to a host running JS-Controller >= 2.0. and that the port is not occupied by other software!`,\n                    );\n                }\n                return;\n            }\n            this.log.error(`${this.namespace} States database error: ${error.message}`);\n            errorLogged = true;\n        });\n\n        this.client.on('end', () => {\n            this.settings.connection.enhancedLogging &&\n                this.log.silly(`${this.namespace} States-Redis Event end (stop=${this.stop})`);\n            if (ready && typeof this.settings.disconnected === 'function') {\n                this.settings.disconnected();\n            }\n        });\n\n        this.client.on('connect', () => {\n            this.settings.connection.enhancedLogging &&\n                this.log.silly(`${this.namespace} States-Redis Event connect (stop=${this.stop})`);\n            connected = true;\n            if (errorLogged) {\n                this.log.info(`${this.namespace} Objects database successfully reconnected`);\n                errorLogged = false;\n            }\n        });\n\n        this.client.on('close', () => {\n            this.settings.connection.enhancedLogging &&\n                this.log.silly(`${this.namespace} States-Redis Event close (stop=${this.stop})`);\n            //if (ready && typeof this.settings.disconnected === 'function') this.settings.disconnected();\n        });\n\n        this.client.on('reconnecting', () => {\n            if (connected && !ready && !initError) {\n                reconnectCounter++;\n            }\n            this.settings.connection.enhancedLogging &&\n                this.log.silly(\n                    `${this.namespace} States-Redis Event reconnect (reconnectCounter=${reconnectCounter}, stop=${this.stop})`,\n                );\n            if (reconnectCounter > 2) {\n                // fallback logic for nodejs <10\n                this.log.error(\n                    `${this.namespace} The DB port  ${this.settings.connection.options.port} is occupied by something that is not a Redis protocol server. Please check other software running on this port or, if you use iobroker, make sure to update to js-controller 2.0 or higher!`,\n                );\n                return;\n            }\n            connected = false;\n            initError = false;\n        });\n\n        this.client.on('ready', async () => {\n            this.settings.connection.enhancedLogging &&\n                this.log.silly(`${this.namespace} States-Redis Event ready (stop=${this.stop})`);\n            if (this.stop || !this.client) {\n                return;\n            }\n            initError = false;\n\n            let initCounter = 0;\n            if (!this.subSystem && typeof onChange === 'function') {\n                initCounter++;\n                try {\n                    await this.client.config('SET', 'notify-keyspace-events', 'Exe'); // enable Expiry/Evicted events in server\n                } catch (e) {\n                    this.log.warn(\n                        `${this.namespace} Unable to enable Expiry Keyspace events from Redis Server: ${e.message}`,\n                    );\n                }\n\n                this.log.debug(`${this.namespace} States create System PubSub Client`);\n                this.subSystem = new Redis(this.settings.connection.options);\n\n                if (typeof onChange === 'function') {\n                    this.subSystem.on('pmessage', (pattern, channel, message) => {\n                        setImmediate(() => {\n                            this.log.silly(\n                                `${this.namespace} States system redis pmessage ${pattern}/${channel}:${message}`,\n                            );\n\n                            if (channel.startsWith(this.metaNamespace)) {\n                                if (\n                                    channel === `${this.metaNamespace}states.protocolVersion` &&\n                                    message !== this.activeProtocolVersion\n                                ) {\n                                    if (typeof this.settings.disconnected === 'function') {\n                                        // protocol version has changed, restart controller\n                                        this.log.info(\n                                            `${this.namespace} States protocol version has changed, disconnecting!`,\n                                        );\n                                        this.settings.disconnected();\n                                    }\n                                }\n                                return;\n                            }\n\n                            try {\n                                message = message\n                                    ? JSON.parse(message, message.includes('\"Buffer\"') ? bufferJsonDecoder : undefined)\n                                    : null;\n                            } catch {\n                                this.log.warn(`${this.namespace} Cannot parse system pmessage \"${message}\"`);\n                                message = null;\n                            }\n\n                            try {\n                                if (channel.startsWith(this.namespaceRedis) && channel.length > this.namespaceRedisL) {\n                                    onChange(channel.substring(this.namespaceRedisL), message);\n                                } else {\n                                    onChange(channel, message);\n                                }\n                            } catch (e) {\n                                this.log.warn(\n                                    `${this.namespace} States system pmessage ${channel} ${JSON.stringify(message)} ${\n                                        e.message\n                                    }`,\n                                );\n                                this.log.warn(`${this.namespace} ${e.stack}`);\n                            }\n                        });\n                    });\n                }\n                if (typeof onChange === 'function' || typeof onChangeUser === 'function') {\n                    // subscribe on key expired or evicted (auto removed because of memory full) message\n                    this.subSystem.on('message', (channel, message) =>\n                        setImmediate(() => {\n                            this.log.silly(`${this.namespace} redis message expired/evicted ${channel}:${message}`);\n                            try {\n                                if (channel === `__keyevent@${this.settings.connection.options.db}__:evicted`) {\n                                    this.log.warn(\n                                        `${this.namespace} Redis has evicted state ${message}. Please check your maxMemory settings for your redis instance!`,\n                                    );\n                                } else if (channel !== `__keyevent@${this.settings.connection.options.db}__:expired`) {\n                                    this.log.warn(`${this.namespace} Unknown user message ${channel} ${message}`);\n                                    return;\n                                }\n                                if (typeof onChange === 'function') {\n                                    // Find deleted states and notify user\n                                    const found = Object.values(this.systemSubscriptions).find(\n                                        regex => regex !== true && regex.test(message),\n                                    );\n                                    found && onChange(message.substring(this.namespaceRedisL), null);\n                                }\n                                if (typeof onChangeUser === 'function' && this.sub) {\n                                    // Find deleted states and notify user\n                                    const found = Object.values(this.userSubscriptions).find(regex =>\n                                        regex.test(message),\n                                    );\n                                    found && onChangeUser(message.substring(this.namespaceRedisL), null);\n                                }\n                            } catch (e) {\n                                this.log.warn(`${this.namespace} user message ${channel} ${message} ${e.message}`);\n                                this.log.warn(`${this.namespace} ${e.stack}`);\n                            }\n                        }),\n                    );\n                }\n                this.subSystem.on('end', () => {\n                    this.settings.connection.enhancedLogging &&\n                        this.log.silly(`${this.namespace} States-Redis System Event end sub (stop=${this.stop})`);\n                    ready && typeof this.settings.disconnected === 'function' && this.settings.disconnected();\n                });\n\n                this.subSystem.on('error', error => {\n                    if (this.stop) {\n                        return;\n                    }\n                    this.settings.connection.enhancedLogging &&\n                        this.log.silly(\n                            `${this.namespace} Sub-Client States System No redis connection: ${JSON.stringify(error)}`,\n                        );\n                });\n\n                if (this.settings.connection.enhancedLogging) {\n                    this.subSystem.on('connect', () =>\n                        this.log.silly(\n                            `${this.namespace} PubSub client States-Redis System Event connect (stop=${this.stop})`,\n                        ),\n                    );\n\n                    this.subSystem.on('close', () =>\n                        this.log.silly(\n                            `${this.namespace} PubSub client States-Redis System Event close (stop=${this.stop})`,\n                        ),\n                    );\n\n                    this.subSystem.on('reconnecting', reconnectCounter =>\n                        this.log.silly(\n                            `${this.namespace} PubSub client States-Redis System Event reconnect (reconnectCounter=${reconnectCounter}, stop=${this.stop})`,\n                        ),\n                    );\n                }\n\n                this.subSystem.on('ready', async _error => {\n                    try {\n                        this.subSystem &&\n                            (await this.subSystem.subscribe(\n                                `__keyevent@${this.settings.connection.options.db}__:expired`,\n                            ));\n                    } catch (e) {\n                        this.log.warn(\n                            `${this.namespace} Unable to subscribe to expiry Keyspace events from Redis Server: ${e.message}`,\n                        );\n                    }\n\n                    try {\n                        this.subSystem &&\n                            (await this.subSystem.subscribe(\n                                `__keyevent@${this.settings.connection.options.db}__:evicted`,\n                            ));\n                    } catch (e) {\n                        this.log.warn(\n                            `${this.namespace} Unable to subscribe to evicted Keyspace events from Redis Server: ${e.message}`,\n                        );\n                    }\n\n                    // subscribe to meta changes\n                    try {\n                        this.subSystem && (await this.subSystem.psubscribe(`${this.metaNamespace}*`));\n                    } catch (e) {\n                        this.log.warn(\n                            `${this.namespace} Unable to subscribe to meta namespace \"${this.metaNamespace}\" changes: ${e.message}`,\n                        );\n                    }\n\n                    if (--initCounter < 1) {\n                        if (this.settings.connection.port === 0) {\n                            this.log.debug(\n                                `${this.namespace} States ${\n                                    ready ? 'system re' : ''\n                                }connected to redis: ${tools.maybeArrayToString(this.settings.connection.host)}`,\n                            );\n                        } else {\n                            this.log.debug(\n                                `${this.namespace} States ${\n                                    ready ? 'system re' : ''\n                                }connected to redis: ${tools.maybeArrayToString(\n                                    this.settings.connection.host,\n                                )}:${tools.maybeArrayToString(this.settings.connection.port)}`,\n                            );\n                        }\n                        !ready && typeof this.settings.connected === 'function' && this.settings.connected();\n                        ready = true;\n                    }\n\n                    if (this.subSystem) {\n                        for (const sub of Object.keys(this.systemSubscriptions)) {\n                            try {\n                                await this.subSystem.psubscribe(sub);\n                            } catch {\n                                //ignore\n                            }\n                        }\n                    }\n                });\n            }\n\n            if (!this.sub && typeof onChangeUser === 'function') {\n                initCounter++;\n\n                this.log.debug(`${this.namespace} States create User PubSub Client`);\n                this.sub = new Redis(this.settings.connection.options);\n\n                this.sub.on('pmessage', (pattern, channel, message) => {\n                    setImmediate(() => {\n                        this.log.silly(`${this.namespace} States user redis pmessage ${pattern}/${channel}:${message}`);\n\n                        try {\n                            message = message\n                                ? JSON.parse(message, message.includes('\"Buffer\"') ? bufferJsonDecoder : undefined)\n                                : null;\n                        } catch {\n                            this.log.warn(`${this.namespace} Cannot parse user pmessage \"${message}\"`);\n                            message = null;\n                        }\n\n                        try {\n                            if (channel.startsWith(this.namespaceRedis) && channel.length > this.namespaceRedisL) {\n                                onChangeUser(channel.substring(this.namespaceRedisL), message);\n                            } else {\n                                onChangeUser(channel, message);\n                            }\n                        } catch (e) {\n                            this.log.warn(\n                                `${this.namespace} States user pmessage ${channel} ${JSON.stringify(message)} ${\n                                    e.message\n                                }`,\n                            );\n                            this.log.warn(`${this.namespace} ${e.stack}`);\n                        }\n                    });\n                });\n\n                this.sub.on('end', () => {\n                    this.settings.connection.enhancedLogging &&\n                        this.log.silly(`${this.namespace} States-Redis User Event end sub (stop=${this.stop})`);\n                    if (ready && typeof this.settings.disconnected === 'function') {\n                        this.settings.disconnected();\n                    }\n                });\n\n                this.sub.on('error', error => {\n                    if (this.stop) {\n                        return;\n                    }\n                    if (this.settings.connection.enhancedLogging) {\n                        this.log.silly(\n                            `${this.namespace} Sub-Client States User No redis connection: ${JSON.stringify(error)}`,\n                        );\n                    }\n                });\n\n                if (this.settings.connection.enhancedLogging) {\n                    this.sub.on('connect', () => {\n                        this.log.silly(\n                            `${this.namespace} PubSub client States-Redis User Event connect (stop=${this.stop})`,\n                        );\n                    });\n\n                    this.sub.on('close', () => {\n                        this.log.silly(\n                            `${this.namespace} PubSub client States-Redis User Event close (stop=${this.stop})`,\n                        );\n                    });\n\n                    this.sub.on('reconnecting', reconnectCounter => {\n                        this.log.silly(\n                            `${this.namespace} PubSub client States-Redis User Event reconnect (reconnectCounter=${reconnectCounter}, stop=${this.stop})`,\n                        );\n                    });\n                }\n\n                this.sub.on('ready', async _error => {\n                    if (!this.sub) {\n                        // client gone while ready emitted, can maybe not happen but ts is happy\n                        return;\n                    }\n\n                    if (--initCounter < 1) {\n                        if (this.settings.connection.port === 0) {\n                            this.log.debug(\n                                `${this.namespace} States ${\n                                    ready ? 'user re' : ''\n                                }connected to redis: ${tools.maybeArrayToString(this.settings.connection.host)}`,\n                            );\n                        } else {\n                            this.log.debug(\n                                `${this.namespace} States ${\n                                    ready ? 'user re' : ''\n                                }connected to redis: ${tools.maybeArrayToString(\n                                    this.settings.connection.host,\n                                )}:${tools.maybeArrayToString(this.settings.connection.port)}`,\n                            );\n                        }\n                        !ready && typeof this.settings.connected === 'function' && this.settings.connected();\n                        ready = true;\n                    }\n\n                    for (const sub of Object.keys(this.userSubscriptions)) {\n                        try {\n                            await this.sub.psubscribe(sub);\n                        } catch {\n                            // ignore\n                        }\n                    }\n                });\n            }\n\n            try {\n                await this._determineProtocolVersion();\n            } catch (e) {\n                this.log.error(`${this.namespace} ${e.message}`);\n                throw new Error('States DB is not allowed to start in the current Multihost environment');\n            }\n\n            if (initCounter < 1) {\n                if (this.settings.connection.port === 0) {\n                    this.log.debug(\n                        `${this.namespace} States ${\n                            ready ? 'client re' : ''\n                        }connected to redis: ${tools.maybeArrayToString(this.settings.connection.host)}`,\n                    );\n                } else {\n                    this.log.debug(\n                        `${this.namespace} States ${\n                            ready ? 'client re' : ''\n                        }connected to redis: ${tools.maybeArrayToString(\n                            this.settings.connection.host,\n                        )}:${tools.maybeArrayToString(this.settings.connection.port)}`,\n                    );\n                }\n                !ready && typeof this.settings.connected === 'function' && this.settings.connected();\n                ready = true;\n            }\n        });\n    }\n\n    getStatus(): DbStatus {\n        return { type: 'redis', server: false };\n    }\n\n    setState(id: string, state: ioBroker.SettableState | ioBroker.StateValue): Promise<string>;\n\n    /** @deprecated migrate to promisified version (without callback) */\n    setState(\n        id: string,\n        state: ioBroker.SettableState | ioBroker.StateValue,\n        callback: (err: Error | null | undefined, id: string) => void,\n    ): Promise<void>;\n\n    /**\n     * @param id the id of the value. '<this.namespaceRedis>.' will be prepended\n     * @param state\n     *\n     *\n     *      an object containing the actual value and some metadata:<br>\n     *      setState(id, {'val': val, 'ts': ts, 'ack': ack, 'from': from, 'lc': lc, 'user': user})\n     *\n     *      if no object is given state is treated as val:<br>\n     *      setState(id, val)\n     *\n     *      <ul><li><b>val</b>  the actual value. Can be any JSON-stringifiable object. If undefined the\n     *                          value is kept unchanged.</li>\n     *\n     *      <li><b>ack</b>  a boolean that can be used to mark a value as confirmed, used in bidirectional systems which\n     *                      acknowledge that a value has been successfully set. Will be set to false if undefined.</li>\n     *\n     *      <li><b>ts</b>   a unix timestamp indicating the last write-operation on the state. Will be set by the\n     *                      setState method if undefined.</li>\n     *\n     *      <li><b>lc</b>   a unix timestamp indicating the last change of the actual value. this should be undefined\n     *                      when calling setState, it will be set by the setValue method itself.</li></ul>\n     * @param callback will be called when redis confirmed reception of the command\n     */\n    async setState(\n        id: string,\n        state: ioBroker.SettableState | ioBroker.StateValue,\n        callback?: (err: Error | null | undefined, id: string) => void,\n    ): Promise<string | void> {\n        if (!id || typeof id !== 'string') {\n            return tools.maybeCallbackWithError(callback, `invalid id ${JSON.stringify(id)}`);\n        }\n\n        if (!this.client) {\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        if (!tools.isObject(state)) {\n            state = {\n                val: state,\n            };\n        }\n\n        let expire;\n        if (state.expire) {\n            expire = state.expire;\n            delete state.expire;\n        }\n\n        let oldObj;\n        try {\n            oldObj = await this.client.get(this.namespaceRedis + id);\n        } catch (e) {\n            this.log.warn(`${this.namespace} get state error: ${e.message}`);\n            return tools.maybeCallbackWithRedisError(callback, e, id);\n        }\n        if (!this.client) {\n            return;\n        }\n\n        if (!oldObj) {\n            oldObj = { val: null };\n        } else {\n            try {\n                oldObj = JSON.parse(oldObj);\n            } catch {\n                this.log.warn(`${this.namespace} Cannot parse \"${oldObj}\"`);\n                oldObj = { val: null };\n            }\n        }\n\n        const obj: Partial<ioBroker.State> = {};\n\n        if (state.val !== undefined) {\n            obj.val = state.val;\n        } else {\n            obj.val = oldObj.val;\n        }\n\n        if (state.ack !== undefined) {\n            obj.ack = state.ack === null ? oldObj.ack || false : state.ack;\n        } else {\n            obj.ack = false;\n        }\n\n        if (state.ts !== undefined) {\n            obj.ts = state.ts < 946681200000 ? state.ts * 1000 : state.ts; // if less 2000.01.01 00:00:00\n        } else {\n            obj.ts = new Date().getTime();\n        }\n\n        if (state.q !== undefined) {\n            obj.q = state.q;\n        } else {\n            obj.q = 0;\n        }\n\n        // set comment\n        if (typeof state.c === 'string' && state.c) {\n            obj.c = state.c.substring(0, 512);\n        }\n\n        obj.from = state.from;\n\n        if (state.user !== undefined) {\n            obj.user = state.user;\n        }\n\n        let hasChanged;\n\n        if (state.lc !== undefined) {\n            obj.lc = state.lc;\n        } else {\n            // isDeepStrictEqual works on objects and primitive values\n            hasChanged = !isDeepStrictEqual(oldObj.val, obj.val);\n            if (!oldObj.lc || hasChanged) {\n                obj.lc = obj.ts;\n            } else {\n                obj.lc = oldObj.lc;\n            }\n        }\n\n        const objString = JSON.stringify(obj);\n\n        // set object in redis\n        if (expire) {\n            try {\n                await this.client.setex(this.namespaceRedis + id, expire, objString);\n                // publish event in redis\n                this.settings.connection.enhancedLogging &&\n                    this.log.silly(`${this.namespace} redis publish ${this.namespaceRedis}${id} ${objString}`);\n                await this.client.publish(this.namespaceRedis + id, objString);\n                return tools.maybeCallbackWithError(callback, null, id);\n            } catch (e) {\n                return tools.maybeCallbackWithRedisError(callback, e, id);\n            }\n        } else {\n            try {\n                await this.client.set(this.namespaceRedis + id, objString);\n                // publish event in redis\n                this.settings.connection.enhancedLogging &&\n                    this.log.silly(`${this.namespace} redis publish ${this.namespaceRedis}${id} ${objString}`);\n                await this.client.publish(this.namespaceRedis + id, objString);\n                return tools.maybeCallbackWithError(callback, null, id);\n            } catch (e) {\n                return tools.maybeCallbackWithRedisError(callback, e, id);\n            }\n        }\n    }\n\n    /**\n     * Promise-version of setState\n     *\n     * @param id\n     * @param state\n     * @deprecated use version without `Async` postfix\n     */\n    setStateAsync(id: string, state: ioBroker.SettableState | ioBroker.StateValue): Promise<string> {\n        return new Promise((resolve, reject) => {\n            this.setState(id, state, (err, res) => {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(res);\n                }\n            });\n        });\n    }\n\n    // Used for restore function (do not call it)\n    async setRawState(id: string, state: ioBroker.SettableState): Promise<string> {\n        if (!id || typeof id !== 'string') {\n            throw new Error(`invalid id ${JSON.stringify(id)}`);\n        }\n\n        if (!this.client) {\n            throw new Error(tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        await this.client.set(this.namespaceRedis + id, JSON.stringify(state));\n        return id;\n    }\n\n    getState(id: string): ioBroker.GetStatePromise;\n    getState(\n        id: string,\n        callback?: (err: Error | null | undefined, state?: ioBroker.State | null) => void,\n    ): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.GetStateCallback> | void>;\n\n    /**\n     * Get state from database\n     *\n     * @param id id of the state\n     * @param callback optional callback, leave out and use promise return type\n     */\n    async getState(\n        id: string,\n        callback?: (err: Error | null | undefined, state?: ioBroker.State | null) => void,\n    ): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.GetStateCallback> | void> {\n        if (!id || typeof id !== 'string') {\n            return tools.maybeCallbackWithError(callback, `invalid id ${JSON.stringify(id)}`);\n        }\n\n        if (!this.client) {\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        let obj;\n        try {\n            obj = await this.client.get(this.namespaceRedis + id);\n            this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} redis get ${id} ok: ${obj}`);\n        } catch (e) {\n            this.log.warn(`${this.namespace} redis get ${id}, error - ${e.message}`);\n        }\n\n        if (!obj) {\n            return tools.maybeCallbackWithError(callback, null, null);\n        }\n        try {\n            obj = JSON.parse(obj);\n        } catch {\n            this.log.warn(`${this.namespace} Cannot parse \"${obj}\"`);\n            obj = null;\n        }\n        return tools.maybeCallbackWithError(callback, null, obj);\n    }\n\n    /**\n     * Promise-version of getState\n     *\n     * @param id\n     */\n    getStateAsync(id: string): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.GetStateCallback> | void> {\n        return this.getState(id);\n    }\n\n    getStates(keys: string[], callback?: undefined, dontModify?: boolean): Promise<(ioBroker.State | null)[]>;\n    getStates(\n        keys: string[],\n        callback: (err: Error | undefined | null, states?: (ioBroker.State | null)[]) => void,\n        dontModify?: boolean,\n    ): Promise<void>;\n    getStates(\n        keys: string[],\n        callback: (err: Error | undefined | null, states?: (ioBroker.State | null)[]) => void,\n        dontModify?: boolean,\n    ): Promise<void>;\n\n    async getStates(\n        keys: string[],\n        callback?: (err: Error | undefined | null, states?: (ioBroker.State | null)[]) => void,\n        dontModify?: boolean,\n    ): Promise<(ioBroker.State | null)[] | void> {\n        if (!keys || !Array.isArray(keys)) {\n            return tools.maybeCallbackWithError(callback, 'no keys');\n        }\n        if (!keys.length) {\n            return tools.maybeCallbackWithError(callback, null, []);\n        }\n        if (!this.client) {\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n        let _keys: string[];\n        if (!dontModify) {\n            _keys = keys.map(k => this.namespaceRedis + k);\n        } else {\n            _keys = keys;\n        }\n\n        let obj: (string | null)[];\n        try {\n            obj = await this.client.mget(_keys);\n            this.settings.connection.enhancedLogging &&\n                this.log.silly(`${this.namespace} redis mget ${!obj ? 0 : obj.length} ${_keys.length}`);\n        } catch (e) {\n            this.log.warn(`${this.namespace} redis mget of ${_keys.length} keys, err: ${e.message}`);\n            return tools.maybeCallbackWithRedisError(callback, e, []);\n        }\n        const result: (ioBroker.State | null)[] = [];\n\n        obj.forEach((state, i) => {\n            try {\n                result.push(state ? JSON.parse(state) : null);\n            } catch (e) {\n                this.log.error(\n                    `Parsing error on getStates(\"${_keys[i]}\"), returning \"null\" for \"${state}\": ${e.message}`,\n                );\n                result.push(null);\n            }\n        });\n\n        return tools.maybeCallbackWithError(callback, null, result);\n    }\n\n    /**\n     * @param keys - array of keys which will be deleted from db\n     * @param callback function to be executed after keys have been deleted\n     */\n    async _destroyDBHelper(keys: string[], callback?: ioBroker.ErrorCallback): Promise<void> {\n        if (!keys || !keys.length) {\n            return tools.maybeCallback(callback);\n        }\n        if (!this.client) {\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        for (const id of keys) {\n            try {\n                await this.client.del(id);\n            } catch {\n                // ignore\n            }\n        }\n\n        return tools.maybeCallback(callback);\n    }\n\n    /**\n     * @param callback cb function to be executed after DB has been destroyed\n     */\n    async destroyDB(callback?: ioBroker.ErrorCallback): Promise<void> {\n        if (!this.client) {\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n        let keys;\n        try {\n            keys = await this.client.keys(`${this.namespaceRedis}*`);\n        } catch {\n            //ignore\n        }\n        return this._destroyDBHelper(keys || [], callback);\n    }\n\n    // Destructor of the class. Called by shutting down.\n    async destroy(): Promise<void> {\n        this.stop = true;\n        if (this.client) {\n            try {\n                await this.client.quit();\n                this.client.removeAllListeners();\n                this.client = null;\n            } catch {\n                // ignore error\n            }\n        }\n        if (this.subSystem) {\n            try {\n                await this.subSystem.quit();\n                this.subSystem.removeAllListeners();\n                this.subSystem = null;\n            } catch {\n                // ignore error\n            }\n        }\n        if (this.sub) {\n            try {\n                await this.sub.quit();\n                this.sub.removeAllListeners();\n                this.sub = null;\n            } catch {\n                // ignore error\n            }\n        }\n    }\n\n    async delState(\n        id: string,\n        callback?: ioBroker.DeleteStateCallback,\n    ): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.DeleteStateCallback> | void> {\n        if (!id || typeof id !== 'string') {\n            return tools.maybeCallbackWithError(callback, `invalid id ${JSON.stringify(id)}`);\n        }\n\n        if (!this.client) {\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        try {\n            await this.client.del(this.namespaceRedis + id);\n            await this.client.publish(this.namespaceRedis + id, 'null');\n            this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} redis del ${id}, ok`);\n            return tools.maybeCallbackWithError(callback, null, id);\n        } catch (e) {\n            this.log.warn(`${this.namespace} redis del ${id}, error - ${e.message}`);\n            return tools.maybeCallbackWithRedisError(callback, e, id);\n        }\n    }\n\n    getKeys(\n        pattern: string,\n        callback?: undefined,\n        dontModify?: boolean,\n    ): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.GetKeysCallback>>;\n    getKeys(pattern: string, callback: ioBroker.GetKeysCallback, dontModify?: boolean): Promise<void>;\n\n    async getKeys(\n        pattern: string,\n        callback?: ioBroker.GetKeysCallback,\n        dontModify?: boolean,\n    ): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.GetKeysCallback> | void> {\n        if (!pattern || typeof pattern !== 'string') {\n            return tools.maybeCallbackWithError(callback, `invalid pattern ${JSON.stringify(pattern)}`);\n        }\n\n        if (!this.client) {\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        let obj;\n        try {\n            obj = await this.client.keys(this.namespaceRedis + pattern);\n        } catch (e) {\n            return tools.maybeCallbackWithRedisError(callback, e);\n        }\n        this.settings.connection.enhancedLogging &&\n            this.log.silly(`${this.namespace} redis keys ${obj.length} ${pattern}`);\n        if (obj && !dontModify) {\n            const len = this.namespaceRedisL;\n            obj = obj.map(el => el.substring(len));\n        }\n        return tools.maybeCallbackWithError(callback, null, obj);\n    }\n\n    async subscribe(pattern: string, callback?: ioBroker.ErrorCallback): Promise<void>;\n    async subscribe(pattern: string, asUser: boolean, callback?: ioBroker.ErrorCallback): Promise<void>;\n\n    /**\n     * @param pattern\n     * @param asUser - if true it will be subscribed as user\n     * @param callback callback function (optional)\n     */\n    async subscribe(\n        pattern: string,\n        asUser?: boolean | ioBroker.ErrorCallback,\n        callback?: ioBroker.ErrorCallback,\n    ): Promise<void> {\n        if (!pattern || typeof pattern !== 'string') {\n            return tools.maybeCallbackWithError(callback, `invalid pattern ${JSON.stringify(pattern)}`);\n        }\n\n        if (typeof asUser === 'function') {\n            callback = asUser;\n            asUser = false;\n        }\n        const subClient = asUser ? this.sub : this.subSystem;\n\n        if (!subClient) {\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        this.settings.connection.enhancedLogging &&\n            this.log.silly(`${this.namespace} redis psubscribe ${this.namespaceRedis}${pattern}`);\n        try {\n            await subClient.psubscribe(this.namespaceRedis + pattern);\n            if (asUser) {\n                this.userSubscriptions[this.namespaceRedis + pattern] = new RegExp(\n                    tools.pattern2RegEx(this.namespaceRedis + pattern),\n                );\n            } else {\n                this.systemSubscriptions[this.namespaceRedis + pattern] = new RegExp(\n                    tools.pattern2RegEx(this.namespaceRedis + pattern),\n                );\n            }\n            return tools.maybeCallback(callback);\n        } catch (e) {\n            return tools.maybeCallbackWithRedisError(callback, e);\n        }\n    }\n\n    /**\n     * @param pattern\n     * @param callback callback function (optional)\n     */\n    subscribeUser(pattern: string, callback?: ioBroker.ErrorCallback): Promise<void> {\n        return this.subscribe(pattern, true, callback);\n    }\n\n    async unsubscribe(pattern: string, asUser: boolean, callback?: ioBroker.ErrorCallback): Promise<void>;\n    async unsubscribe(pattern: string, callback?: ioBroker.ErrorCallback): Promise<void>;\n    /**\n     * Unsubscribe pattern\n     *\n     * @param pattern\n     * @param asUser - if true it will be unsubscribed as user\n     * @param callback\n     */\n    async unsubscribe(\n        pattern: string,\n        asUser?: boolean | ioBroker.ErrorCallback,\n        callback?: ioBroker.ErrorCallback,\n    ): Promise<void> {\n        if (!pattern || typeof pattern !== 'string') {\n            return tools.maybeCallbackWithError(callback, `invalid pattern ${JSON.stringify(pattern)}`);\n        }\n        if (typeof asUser === 'function') {\n            callback = asUser;\n            asUser = false;\n        }\n        const subClient = asUser ? this.sub : this.subSystem;\n\n        if (!subClient) {\n            return tools.maybeCallbackWithRedisError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        this.settings.connection.enhancedLogging &&\n            this.log.silly(`${this.namespace} redis punsubscribe ${this.namespaceRedis}${pattern}`);\n        try {\n            await subClient.punsubscribe(this.namespaceRedis + pattern);\n            if (asUser) {\n                if (this.userSubscriptions[this.namespaceRedis + pattern] !== undefined) {\n                    delete this.userSubscriptions[this.namespaceRedis + pattern];\n                }\n            } else {\n                if (this.systemSubscriptions[this.namespaceRedis + pattern] !== undefined) {\n                    delete this.systemSubscriptions[this.namespaceRedis + pattern];\n                }\n            }\n\n            return tools.maybeCallback(callback);\n        } catch (e) {\n            return tools.maybeCallbackWithRedisError(callback, e);\n        }\n    }\n\n    /**\n     * @param pattern\n     * @param callback callback function (optional)\n     */\n    unsubscribeUser(pattern: string, callback?: ioBroker.ErrorCallback): Promise<void> {\n        return this.unsubscribe(pattern, true, callback);\n    }\n\n    async pushMessage(id: string, message: ioBroker.SendableMessage): Promise<void> {\n        if (!id || typeof id !== 'string') {\n            throw new Error(`invalid id ${JSON.stringify(id)}`);\n        }\n\n        if (!this.client) {\n            throw new Error(tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        const fullMessage: ioBroker.Message = { ...message, _id: this.globalMessageId++ };\n\n        if (this.globalMessageId >= 0xffffffff) {\n            this.globalMessageId = 0;\n        }\n\n        await this.client.publish(this.namespaceMsg + id, JSON.stringify(fullMessage));\n    }\n\n    async subscribeMessage(id: string, callback?: ioBroker.ErrorCallback): Promise<void> {\n        if (!id || typeof id !== 'string') {\n            return tools.maybeCallbackWithError(callback, `invalid id ${JSON.stringify(id)}`);\n        }\n\n        if (!this.subSystem) {\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        if (id.startsWith('.')) {\n            id = id.substring(1);\n        }\n        this.settings.connection.enhancedLogging &&\n            this.log.silly(`${this.namespace} redis subscribeMessage ${this.namespaceMsg}${id}`);\n        try {\n            await this.subSystem.psubscribe(this.namespaceMsg + id);\n            this.systemSubscriptions[this.namespaceMsg + id] = true;\n            return tools.maybeCallback(callback);\n        } catch (e) {\n            return tools.maybeCallbackWithRedisError(callback, e);\n        }\n    }\n\n    async unsubscribeMessage(id: string, callback?: ioBroker.ErrorCallback): Promise<void> {\n        if (!id || typeof id !== 'string') {\n            return tools.maybeCallbackWithError(callback, `invalid id ${JSON.stringify(id)}`);\n        }\n\n        if (!this.subSystem) {\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        if (id.startsWith('.')) {\n            id = id.substring(1);\n        }\n        this.settings.connection.enhancedLogging &&\n            this.log.silly(`${this.namespace} redis unsubscribeMessage ${this.namespaceMsg}${id}`);\n        try {\n            await this.subSystem.punsubscribe(this.namespaceMsg + id);\n            if (this.systemSubscriptions[this.namespaceMsg + id] !== undefined) {\n                delete this.systemSubscriptions[this.namespaceMsg + id];\n            }\n            return tools.maybeCallback(callback);\n        } catch (e) {\n            return tools.maybeCallbackWithRedisError(callback, e);\n        }\n    }\n\n    async pushLog(\n        id: string,\n        log: LogObject,\n        callback?: (err: Error | undefined | null, id?: string) => void,\n    ): Promise<string | void>;\n\n    // implementation uses an modified pushLog with internal _id\n    async pushLog(\n        id: string,\n        log: InternalLogObject,\n        callback?: (err: Error | undefined | null, id?: string) => void,\n    ): Promise<string | void> {\n        if (!id || typeof id !== 'string') {\n            return tools.maybeCallbackWithError(callback, `invalid id ${JSON.stringify(id)}`);\n        }\n\n        log._id = this.globalLogId++;\n        if (this.globalLogId >= 0xffffffff) {\n            this.globalLogId = 0;\n        }\n\n        if (this.client) {\n            try {\n                await this.client.publish(this.namespaceLog + id, JSON.stringify(log));\n                return tools.maybeCallbackWithError(callback, null, id);\n            } catch (e) {\n                return tools.maybeCallbackWithRedisError(callback, e);\n            }\n        }\n    }\n\n    async subscribeLog(id: string, callback?: ioBroker.ErrorCallback): Promise<void> {\n        if (!id || typeof id !== 'string') {\n            return tools.maybeCallbackWithError(callback, `invalid id ${JSON.stringify(id)}`);\n        }\n\n        if (!this.subSystem) {\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        this.settings.connection.enhancedLogging &&\n            this.log.silly(`${this.namespace} redis subscribeMessage ${this.namespaceLog}${id}`);\n        try {\n            await this.subSystem.psubscribe(this.namespaceLog + id);\n            this.systemSubscriptions[this.namespaceLog + id] = true;\n            return tools.maybeCallback(callback);\n        } catch (e) {\n            return tools.maybeCallbackWithRedisError(callback, e);\n        }\n    }\n\n    async unsubscribeLog(id: string, callback?: ioBroker.ErrorCallback): Promise<void> {\n        if (!id || typeof id !== 'string') {\n            return tools.maybeCallbackWithError(callback, `invalid id ${JSON.stringify(id)}`);\n        }\n\n        if (!this.subSystem) {\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        this.settings.connection.enhancedLogging &&\n            this.log.silly(`${this.namespace} redis unsubscribeMessage ${this.namespaceLog}${id}`);\n        try {\n            await this.subSystem.punsubscribe(this.namespaceLog + id);\n            if (this.systemSubscriptions[this.namespaceLog + id] !== undefined) {\n                delete this.systemSubscriptions[this.namespaceLog + id];\n            }\n            return tools.maybeCallback(callback);\n        } catch (e) {\n            return tools.maybeCallbackWithRedisError(callback, e);\n        }\n    }\n\n    // TODO: types session obj\n    async getSession(\n        id: string,\n        callback: (err: Error | undefined | null, session?: Record<string, any> | null) => void,\n    ): Promise<Record<string, any> | null | void> {\n        if (!id || typeof id !== 'string') {\n            return tools.maybeCallbackWithError(callback, `invalid id ${JSON.stringify(id)}`);\n        }\n\n        if (!this.client) {\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        let obj;\n        try {\n            obj = await this.client.get(this.namespaceSession + id);\n        } catch {\n            // ignore\n        }\n\n        this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} redis get ${id} ${obj}`);\n        try {\n            obj = obj ? JSON.parse(obj) : null;\n        } catch {\n            this.log.warn(`${this.namespace} Cannot parse \"${obj}\"`);\n            obj = null;\n        }\n        return tools.maybeCallback(callback, obj);\n    }\n\n    // TODO: types obj\n    async setSession(\n        id: string,\n        expireS: number,\n        obj: Record<string, any>,\n        callback?: ioBroker.ErrorCallback,\n    ): Promise<void> {\n        if (!id || typeof id !== 'string') {\n            return tools.maybeCallbackWithError(callback, `invalid id ${JSON.stringify(id)}`);\n        }\n\n        if (!this.client) {\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        try {\n            await this.client.setex(this.namespaceSession + id, expireS, JSON.stringify(obj));\n            this.settings.connection.enhancedLogging &&\n                this.log.silly(`${this.namespace} redis setex ${id} ${expireS} ${JSON.stringify(obj)}`);\n            return tools.maybeCallback(callback);\n        } catch (e) {\n            return tools.maybeCallbackWithRedisError(callback, e);\n        }\n    }\n\n    async destroySession(id: string, callback?: ioBroker.ErrorCallback): Promise<void> {\n        if (!id || typeof id !== 'string') {\n            return tools.maybeCallbackWithError(callback, `invalid id ${JSON.stringify(id)}`);\n        }\n\n        if (!this.client) {\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        id = this.namespaceSession + id;\n        this.settings.connection.enhancedLogging && this.log.silly(`${this.namespace} redis del ${id}`);\n        try {\n            await this.client.del(id);\n            return tools.maybeCallback(callback);\n        } catch (e) {\n            return tools.maybeCallbackWithRedisError(callback, e);\n        }\n    }\n\n    /**\n     * Returns the protocol version from DB\n     *\n     */\n    getProtocolVersion(): Promise<string | null> {\n        if (!this.client) {\n            throw new Error(tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        return this.client.get(`${this.metaNamespace}states.protocolVersion`);\n    }\n\n    /**\n     * Sets the protocol version to the DB\n     *\n     * @param version - protocol version\n     */\n    async setProtocolVersion(version: number): Promise<void> {\n        if (!this.client) {\n            throw new Error(tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        const versionStr = version.toString();\n        // we can only set a protocol if we actually support it\n        if (this.supportedProtocolVersions.includes(versionStr)) {\n            await this.client.set(`${this.metaNamespace}states.protocolVersion`, versionStr);\n            await this.client.publish(`${this.metaNamespace}states.protocolVersion`, versionStr);\n        } else {\n            throw new Error('Cannot set an unsupported protocol version on the current host');\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": ["Redis", "reconnectCounter"]
}
