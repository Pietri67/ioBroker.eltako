{
  "version": 3,
  "sources": ["../../../../src/lib/common/interview.ts"],
  "sourcesContent": ["import rl from 'readline-sync';\nimport fs from 'fs-extra';\n\n/** Regex to limit inputs to yes/no shortcuts */\nconst YES_NO_REGEX = /^[YyNn]?$/;\n\ntype SharedDatabaseOptions = ioBroker.ObjectsDatabaseOptions | ioBroker.StatesDatabaseOptions;\n\ninterface DefaultRedisInterviewOptions<TConfig extends SharedDatabaseOptions> {\n    /** Database type */\n    type: 'objects' | 'states';\n    /** Prefilled config */\n    config: TConfig;\n}\n\n/**\n * The default redis interview shared between objects and states\n *\n * @param options config and type information\n */\nexport async function defaultRedisInterview<TConfig extends SharedDatabaseOptions>(\n    options: DefaultRedisInterviewOptions<TConfig>,\n): Promise<TConfig> {\n    const { type, config } = options;\n\n    let answer = rl.question(`Do you use a TLS connection for your \"${type}\" redis-server? [y/N]:`, {\n        limit: YES_NO_REGEX,\n        defaultInput: 'N',\n    });\n\n    if (answer.toLowerCase() === 'n') {\n        return config;\n    }\n\n    config.options.tls = {};\n\n    answer = rl.question(`Do you use a self-signed certificate for your \"${type}\" redis-server? [y/N]:`, {\n        limit: YES_NO_REGEX,\n        defaultInput: 'N',\n    });\n\n    if (answer.toLowerCase() === 'y') {\n        config.options.tls.rejectUnauthorized = false;\n    }\n\n    do {\n        answer = rl.question(`Please specify the path to your \"${type}\" redis-server \"certificate\" file:`);\n\n        try {\n            const certContent = await fs.readFile(answer, { encoding: 'utf8' });\n            config.options.tls.cert = certContent;\n        } catch (e) {\n            console.warn(`Could not read the \"certificate\" file: ${e.message}`);\n        }\n    } while (!config.options.tls.cert);\n\n    do {\n        answer = rl.question(`Please specify the path to your \"${type}\" redis-server \"key\" file:`);\n\n        try {\n            const keyContent = await fs.readFile(answer, { encoding: 'utf8' });\n            config.options.tls.key = keyContent;\n        } catch (e) {\n            console.warn(`Could not read the \"key\" file: ${e.message}`);\n        }\n    } while (!config.options.tls.key);\n\n    do {\n        answer = rl.question(`Please specify the path to your \"${type}\" redis-server \"CA\" file:`);\n\n        try {\n            const caContent = await fs.readFile(answer, { encoding: 'utf8' });\n            config.options.tls.ca = caContent;\n        } catch (e) {\n            console.warn(`Could not read the \"CA\" file: ${e.message}`);\n        }\n    } while (!config.options.tls.ca);\n\n    return config;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;AAAA,2BAAe;AACf,sBAAe;AAGf,MAAM,eAAe;AAgBrB,eAAsB,sBAClB,SAA8C;AAE9C,QAAM,EAAE,MAAM,OAAM,IAAK;AAEzB,MAAI,SAAS,qBAAAA,QAAG,SAAS,yCAAyC,IAAI,0BAA0B;IAC5F,OAAO;IACP,cAAc;GACjB;AAED,MAAI,OAAO,YAAW,MAAO,KAAK;AAC9B,WAAO;EACX;AAEA,SAAO,QAAQ,MAAM,CAAA;AAErB,WAAS,qBAAAA,QAAG,SAAS,kDAAkD,IAAI,0BAA0B;IACjG,OAAO;IACP,cAAc;GACjB;AAED,MAAI,OAAO,YAAW,MAAO,KAAK;AAC9B,WAAO,QAAQ,IAAI,qBAAqB;EAC5C;AAEA,KAAG;AACC,aAAS,qBAAAA,QAAG,SAAS,oCAAoC,IAAI,oCAAoC;AAEjG,QAAI;AACA,YAAM,cAAc,MAAM,gBAAAC,QAAG,SAAS,QAAQ,EAAE,UAAU,OAAM,CAAE;AAClE,aAAO,QAAQ,IAAI,OAAO;IAC9B,SAAS,GAAG;AACR,cAAQ,KAAK,0CAA0C,EAAE,OAAO,EAAE;IACtE;EACJ,SAAS,CAAC,OAAO,QAAQ,IAAI;AAE7B,KAAG;AACC,aAAS,qBAAAD,QAAG,SAAS,oCAAoC,IAAI,4BAA4B;AAEzF,QAAI;AACA,YAAM,aAAa,MAAM,gBAAAC,QAAG,SAAS,QAAQ,EAAE,UAAU,OAAM,CAAE;AACjE,aAAO,QAAQ,IAAI,MAAM;IAC7B,SAAS,GAAG;AACR,cAAQ,KAAK,kCAAkC,EAAE,OAAO,EAAE;IAC9D;EACJ,SAAS,CAAC,OAAO,QAAQ,IAAI;AAE7B,KAAG;AACC,aAAS,qBAAAD,QAAG,SAAS,oCAAoC,IAAI,2BAA2B;AAExF,QAAI;AACA,YAAM,YAAY,MAAM,gBAAAC,QAAG,SAAS,QAAQ,EAAE,UAAU,OAAM,CAAE;AAChE,aAAO,QAAQ,IAAI,KAAK;IAC5B,SAAS,GAAG;AACR,cAAQ,KAAK,iCAAiC,EAAE,OAAO,EAAE;IAC7D;EACJ,SAAS,CAAC,OAAO,QAAQ,IAAI;AAE7B,SAAO;AACX;",
  "names": ["rl", "fs"]
}
