{
  "version": 3,
  "sources": ["../../../../src/lib/common/tools.ts", "../../../../../../node_modules/@alcalzone/esm2cjs/shims/import.meta.url/shim.js"],
  "sourcesContent": ["import fs from 'fs-extra';\nimport path from 'node:path';\nimport semver from 'semver';\nimport os from 'node:os';\nimport forge from 'node-forge';\nimport deepClone from 'deep-clone';\nimport { type ChildProcessPromise, exec as cpExecAsync } from 'promisify-child-process';\nimport { createInterface } from 'node:readline';\nimport { PassThrough } from 'node:stream';\nimport type { CommandResult, InstallOptions, PackageManager } from '@alcalzone/pak';\nimport { detectPackageManager, packageManagers } from '@alcalzone/pak';\nimport { EXIT_CODES } from '@/lib/common/exitCodes.js';\nimport zlib from 'node:zlib';\nimport { password } from '@/lib/common/password.js';\nimport jwt from 'jsonwebtoken';\nimport axios from 'axios';\nimport crypto from 'node:crypto';\nimport type { ExecOptions } from 'node:child_process';\nimport { exec } from 'node:child_process';\nimport { URLSearchParams } from 'node:url';\nimport events from 'node:events';\nimport { maybeCallbackWithError } from '@/lib/common/maybeCallback.js';\n// @ts-expect-error has no types\nimport extend from 'node.extend';\nimport { setDefaultResultOrder } from 'node:dns';\nimport {\n    applyAliasAutoScaling,\n    applyAliasConvenienceConversion,\n    applyAliasTransformer,\n} from '@/lib/common/aliasProcessing.js';\nimport type * as DiskUsage from 'diskusage';\nimport * as url from 'node:url';\nimport { createRequire } from 'node:module';\nimport type { WithRequired } from '@iobroker/types-dev';\n\n// eslint-disable-next-line unicorn/prefer-module\nconst thisDir = url.fileURLToPath(new URL('.', import.meta.url || `file://${__filename}`));\n// eslint-disable-next-line unicorn/prefer-module\nconst require = createRequire(import.meta.url || `file://${__filename}`);\n\ntype DockerInformation =\n    | {\n          /** If it is a Docker installation */\n          isDocker: boolean;\n          /** If it is the official Docker image */\n          isOfficial: true;\n          /** Semver string for official Docker image */\n          officialVersion: string;\n      }\n    | {\n          /** If it is a Docker installation */\n          isDocker: boolean;\n          /** If it is the official Docker image */\n          isOfficial: false;\n      };\n\nexport interface HostInfo {\n    /** Converted OS for human readability */\n    Platform: NodeJS.Platform | 'docker' | 'Windows' | 'OSX';\n    /** The underlying OS */\n    os: NodeJS.Platform;\n    /** Information about the docker installation */\n    dockerInformation?: DockerInformation;\n    /** Host architecture */\n    Architecture: string;\n    /** Number of CPUs */\n    CPUs: number | null;\n    /** CPU speed */\n    Speed: number | null;\n    /** CPU model */\n    Model: string | null;\n    /** Total RAM of host */\n    RAM: number;\n    /** System uptime in seconds */\n    'System uptime': number;\n    /** Node.JS version */\n    'Node.js': string;\n    /** Current time to compare to local time */\n    time: number;\n    /** Timezone offset to compare to local time */\n    timeOffset: number;\n    /** Number of available adapters */\n    'adapters count': number;\n    /** NPM version */\n    NPM: string;\n}\n\ninterface FormatAliasValueOptions {\n    /** Common attribute of a source object */\n    sourceCommon?: Partial<ioBroker.StateCommon>;\n    /** Common attribute of a target object */\n    targetCommon?: Partial<ioBroker.StateCommon>;\n    /** State to format */\n    state: ioBroker.State | null | undefined;\n    /** Logger used for logging */\n    logger: any;\n    /** Prefix for log messages */\n    logNamespace: string;\n    /** Id of the source object, used for logging */\n    sourceId?: string;\n    /** Id of the target object, used for logging */\n    targetId?: string;\n}\n\n/**\n * Response from DOCKER_INFO_URL\n */\ninterface DockerHubResponse {\n    /** Results, filtered to one entry */\n    results: [\n        {\n            /** Contains the version like v1.5.3 */\n            name: string;\n            /** Timestamp of last update of this image, like 2024-08-29T01:26:32.378554Z */\n            last_updated: string;\n            [other: string]: unknown;\n        },\n    ];\n    [other: string]: unknown;\n}\n\nexport interface DockerImageInformation {\n    /** The official version like v10.0.0 */\n    version: string;\n    /** Time of last image update */\n    lastUpdated: string;\n    /** If the version is newer than the one currently running */\n    isNew: boolean;\n}\n\nexport enum ERRORS {\n    ERROR_NOT_FOUND = 'Not exists',\n    ERROR_EMPTY_OBJECT = 'null object',\n    ERROR_NO_OBJECT = 'no object',\n    ERROR_DB_CLOSED = 'DB closed',\n}\n\nevents.EventEmitter.prototype.setMaxListeners(100);\nlet npmVersion: string;\nlet diskusage: typeof DiskUsage;\n\nconst randomID = Math.round(Math.random() * 10_000_000_000_000); // Used for creation of User-Agent\nconst VENDOR_FILE = '/etc/iob-vendor.json';\n/** This file contains the version string in an official docker image */\nconst OFFICIAL_DOCKER_FILE = '/opt/scripts/.docker_config/.thisisdocker';\n/** URL to fetch information of the latest docker image */\nconst DOCKER_INFO_URL = 'https://hub.docker.com/v2/namespaces/iobroker/repositories/iobroker/tags?page_size=1';\n/** Time the image approx. needs to be built and published to DockerHub */\nconst DOCKER_HUB_BUILD_TIME_MS = 6 * 60 * 60 * 1_000;\n/** Version of official Docker image which started to support UI upgrade */\nconst DOCKER_VERSION_UI_UPGRADE = '8.1.0';\n\nlet lastCalculationOfIps: number;\nlet ownIpArr: string[] = [];\n// Here we define all characters that are forbidden in IDs. Since we want to allow multiple\n// unicode character classes, we do that by OR-ing the character classes and negating the result.\n// Also, we can easily whitelist characters this way.\n//\n// We allow:\n// \u00B7 Ll = lowercase letters\n// \u00B7 Lu = uppercase letters\n// \u00B7 Nd = numbers\n// \u00B7 \".\", \"_\", \"-\" (common in IDs)\n// \u00B7 \"/\" (required for designs)\n// \u00B7 \" :!#$%&()+=@^{}|~\" (for legacy reasons)\n//\n/** All characters that may not appear in an object ID. */\nexport const FORBIDDEN_CHARS = /[^._\\-/ :!#$%&()+=@^{}|~\\p{Ll}\\p{Lu}\\p{Nd}]+/gu;\n\n/**\n * recursively copy values from an old object to new one\n *\n * @param oldObj source object\n * @param newObj destination object\n * @param originalObj optional object for read __no_change__ values\n * @param isNonEdit optional indicator if copy is in nonEdit part\n */\nexport function copyAttributes(\n    oldObj: Record<string, any>,\n    newObj: Record<string, any>,\n    originalObj?: Record<string, any>,\n    isNonEdit?: boolean,\n): void {\n    for (const attr of Object.keys(oldObj)) {\n        if (\n            oldObj[attr] === undefined ||\n            oldObj[attr] === null ||\n            typeof oldObj[attr] !== 'object' ||\n            oldObj[attr] instanceof Array\n        ) {\n            if (oldObj[attr] === '__no_change__' && originalObj && !isNonEdit) {\n                if (originalObj[attr] !== undefined) {\n                    newObj[attr] = deepClone(originalObj[attr]);\n                } else {\n                    console.log(`Attribute ${attr} ignored by copying`);\n                }\n            } else if (oldObj[attr] === '__delete__' && !isNonEdit) {\n                if (newObj[attr] !== undefined) {\n                    delete newObj[attr];\n                }\n            } else {\n                newObj[attr] = oldObj[attr];\n            }\n        } else {\n            newObj[attr] = newObj[attr] || {};\n            copyAttributes(\n                oldObj[attr],\n                newObj[attr],\n                originalObj && originalObj[attr],\n                isNonEdit || attr === 'nonEdit',\n            );\n        }\n    }\n}\n\n/**\n * Checks the flag nonEdit and restores non-changeable values if required\n *\n * @param oldObject source object\n * @param newObject destination object\n */\nexport function checkNonEditable(\n    oldObject: ioBroker.SettableObject | null,\n    newObject: ioBroker.SettableObject,\n): boolean {\n    if (!oldObject) {\n        return true;\n    }\n    if (!oldObject.nonEdit && !newObject.nonEdit) {\n        return true;\n    }\n\n    // if nonEdit is protected with password\n    if (oldObject.nonEdit?.passHash) {\n        // If new Object wants to update the nonEdit information\n        if (newObject.nonEdit?.password) {\n            const hash = crypto.createHash('sha256').update(newObject.nonEdit.password.toString()).digest('base64');\n            if (oldObject.nonEdit.passHash !== hash) {\n                delete newObject.nonEdit;\n                return false;\n            }\n            oldObject.nonEdit = deepClone(newObject.nonEdit);\n            delete oldObject.nonEdit.password;\n            delete newObject.nonEdit.password;\n            oldObject.nonEdit.passHash = hash;\n            newObject.nonEdit.passHash = hash;\n\n            copyAttributes(newObject.nonEdit, newObject, newObject);\n\n            if (newObject.nonEdit.passHash) {\n                delete newObject.nonEdit.passHash;\n            }\n            if (newObject.nonEdit?.password) {\n                delete newObject.nonEdit.password;\n            }\n\n            return true;\n        }\n        newObject.nonEdit = oldObject.nonEdit;\n    } else if (newObject.nonEdit) {\n        oldObject.nonEdit = deepClone(newObject.nonEdit);\n        if (newObject.nonEdit.password) {\n            const hash = crypto.createHash('sha256').update(newObject.nonEdit.password.toString()).digest('base64');\n            delete oldObject.nonEdit.password;\n            delete newObject.nonEdit.password;\n            oldObject.nonEdit.passHash = hash;\n            newObject.nonEdit.passHash = hash;\n        }\n    }\n\n    // restore settings\n    copyAttributes(oldObject.nonEdit!, newObject, oldObject);\n\n    if (newObject.nonEdit?.passHash) {\n        delete newObject.nonEdit.passHash;\n    }\n    if (newObject.nonEdit?.password) {\n        delete newObject.nonEdit.password;\n    }\n    return true;\n}\n\n/**\n * Checks if a version is up-to-date, throws error on invalid version strings\n *\n * @param repoVersion version in repository\n * @param installedVersion the current installed version\n */\nexport function upToDate(repoVersion: string, installedVersion: string): boolean {\n    // Check if the installed version is at least the repo version\n    return semver.gte(installedVersion, repoVersion);\n}\n\n// TODO: this is only here for backward compatibility, if MULTIHOST password was still setup with old decryption\nexport function decryptPhrase(password: string, data: any, callback: (decrypted?: null | string) => void): void {\n    const decipher = crypto.createDecipher('aes192', password);\n\n    try {\n        let decrypted = '';\n        decipher.on('readable', () => {\n            const data = decipher.read();\n            if (data) {\n                decrypted += data.toString('utf8');\n            }\n        });\n        decipher.on('error', error => {\n            console.error(`Cannot decode secret: ${error.message}`);\n            callback(null);\n        });\n\n        decipher.on('end', () => callback(decrypted));\n\n        decipher.write(data, 'hex');\n        decipher.end();\n    } catch (e) {\n        console.error(`Cannot decode secret: ${e.message}`);\n        callback(null);\n    }\n}\n\n/**\n * Checks if multiple host objects exists, without using object views\n *\n * @param objects the objects db\n * @returns true if only one host object exists\n */\nexport async function isSingleHost(objects: any): Promise<boolean> {\n    const res: { rows: ioBroker.GetObjectListItem<ioBroker.HostObject>[] } = await objects.getObjectList({\n        startkey: 'system.host.',\n        endkey: 'system.host.\\u9999',\n    });\n    const hostObjs = res.rows.filter(obj => obj.value && obj.value.type === 'host');\n    return hostObjs.length <= 1; // on setup no host object is there yet\n}\n\n/**\n * Checks if at least one host is running in a Multihost environment\n *\n * @param objects the objects db\n * @param states the states db\n * @returns true if one or more hosts running else false\n */\nexport async function isHostRunning(objects: any, states: any): Promise<boolean> {\n    // do it without an object view for now, TODO: can be reverted if no one downgrades to < 4 (redis-sets)\n    // const res = await objects.getObjectViewAsync('system', 'host', { startkey: '', endkey: '\\u9999' });\n    const res: GetObjectViewResult = await objects.getObjectList({\n        startkey: 'system.host.',\n        endkey: 'system.host.\\u9999',\n    });\n\n    // TODO: this check should be redundant as soon as we go back to the object view approach\n    res.rows = res.rows.filter(obj => obj.value?.type === 'host');\n\n    for (const hostObj of res.rows) {\n        const state: ioBroker.State = await states.getState(`${hostObj.id}.alive`);\n        if (state && state.val) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Checks if ioBroker is installed in a dev environment\n */\nexport function isDevInstallation(): boolean {\n    return fs.pathExistsSync(`${getControllerDir()}/../../packages/controller`);\n}\n\n/** In dev installations with uppercase B to match GitHub repo name - try to get rid of it in the long run */\ntype AppName = 'iobroker' | 'ioBroker';\n\n/**\n * Get the app name either for prod or for dev installation\n */\nfunction getAppName(): AppName {\n    if (isDevInstallation()) {\n        // dev install - GitHub folder is uppercase\n        return 'ioBroker';\n    }\n\n    return 'iobroker';\n}\n\nexport const appNameLowerCase = 'iobroker';\nexport const appName = getAppName();\n\nexport function findIPs(): string[] {\n    if (!lastCalculationOfIps || Date.now() - lastCalculationOfIps > 10000) {\n        lastCalculationOfIps = Date.now();\n        ownIpArr = [];\n        try {\n            const ifaces = os.networkInterfaces();\n            for (const iface of Object.values(ifaces)) {\n                iface?.forEach(details => !details.internal && ownIpArr.push(details.address));\n            }\n        } catch (e) {\n            console.error(`Can not find local IPs: ${e.message}`);\n        }\n    }\n\n    return ownIpArr;\n}\n\nfunction findPath(path: string, url: string): string {\n    if (!url) {\n        return '';\n    }\n    if (url.startsWith('http://') || url.startsWith('https://')) {\n        return url;\n    }\n    if (path.startsWith('http://') || path.startsWith('https://')) {\n        return (path + url).replace(/\\/\\//g, '/').replace('http:/', 'http://').replace('https:/', 'https://');\n    }\n    if (url[0] === '/') {\n        return `${thisDir}/..${url}`;\n    }\n    return `${thisDir}/../${path}${url}`;\n}\n\n/**\n * Get MAC address of this host\n */\nasync function getMac(): Promise<string> {\n    const macRegex = /(?:[a-z0-9]{2}[:-]){5}[a-z0-9]{2}/gi;\n    const zeroRegex = /(?:[0]{2}[:-]){5}[0]{2}/;\n    const command = process.platform.indexOf('win') === 0 ? 'getmac' : 'ifconfig || ip link';\n\n    const { stdout, stderr } = await execAsync(command);\n\n    if (typeof stderr === 'string') {\n        throw new Error(stderr);\n    }\n\n    if (typeof stdout !== 'string') {\n        throw new Error(`Unexpected stdout: ${stdout?.toString()}`);\n    }\n\n    let macAddress;\n    let match;\n    let result = null;\n\n    while (true) {\n        match = macRegex.exec(stdout);\n        if (!match) {\n            break;\n        }\n        macAddress = match[0];\n        if (!zeroRegex.test(macAddress) && !result) {\n            result = macAddress;\n        }\n    }\n\n    if (result === null) {\n        throw new Error(`Could not determine the mac address from:\\n${stdout}`);\n    }\n\n    return result.replace(/-/g, ':').toLowerCase();\n}\n\n/**\n * Fetch the image information of the newest available (official) ioBroker Docker image from DockerHub\n */\nexport async function getNewestDockerImageVersion(): Promise<DockerImageInformation> {\n    const res = await axios.get<DockerHubResponse>(DOCKER_INFO_URL);\n\n    const dockerResult = res.data.results[0];\n    const isNew =\n        new Date(dockerResult.last_updated).getTime() >\n        new Date(process.env.BUILD).getTime() + DOCKER_HUB_BUILD_TIME_MS;\n\n    return { version: dockerResult.name, lastUpdated: dockerResult.last_updated, isNew };\n}\n\n/**\n * Get information of a Docker installation\n */\nexport function getDockerInformation(): DockerInformation {\n    try {\n        const versionString = fs.readFileSync(OFFICIAL_DOCKER_FILE, { encoding: 'utf-8' }).trim();\n        return { isDocker: true, isOfficial: true, officialVersion: versionString };\n    } catch {\n        // ignore error\n    }\n\n    return { isDocker: isDocker(), isOfficial: false };\n}\n\n/**\n * Controller UI upgrade is not supported on Windows and MacOS\n */\nexport function isControllerUiUpgradeSupported(): boolean {\n    const dockerInfo = getDockerInformation();\n\n    if (dockerInfo.isDocker) {\n        if (!dockerInfo.isOfficial) {\n            return false;\n        }\n\n        if (\n            !semver.valid(dockerInfo.officialVersion) ||\n            semver.lt(dockerInfo.officialVersion, DOCKER_VERSION_UI_UPGRADE)\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    return !['win32', 'darwin'].includes(os.platform());\n}\n\n/**\n * Checks if we are running inside a docker container\n */\nexport function isDocker(): boolean {\n    try {\n        // deprecated, works only with docker daemon\n        fs.statSync('/.dockerenv');\n        return true;\n    } catch {\n        // ignore error\n    }\n\n    try {\n        // ioBroker docker image specific, will be created during a build process\n        fs.statSync(OFFICIAL_DOCKER_FILE);\n        return true;\n    } catch {\n        // ignore error\n    }\n\n    try {\n        // check a docker group, works in most cases, but not on arm\n        return fs.readFileSync('/proc/self/cgroup', 'utf8').includes('docker');\n    } catch {\n        return false;\n    }\n}\n\n/**\n * Build unique uuid based on MAC address if possible\n *\n * @param givenMac the given MAC address\n */\nasync function uuid(givenMac?: string): Promise<string> {\n    givenMac = givenMac ?? '';\n    const _isDocker = isDocker();\n\n    // return constant UUID for all CI environments to keep the statistics clean\n    if (require('ci-info').isCI) {\n        return '55travis-pipe-line-cior-githubaction';\n    }\n\n    let mac = givenMac !== null ? givenMac || '' : null;\n    let u;\n\n    if (!_isDocker && mac === '') {\n        const ifaces = os.networkInterfaces();\n\n        // Find first not empty MAC\n        for (const iface of Object.values(ifaces)) {\n            if (iface) {\n                for (const entry of iface) {\n                    if (entry.mac !== '00:00:00:00:00:00') {\n                        mac = entry.mac;\n                        break;\n                    }\n                }\n            }\n\n            if (mac) {\n                break;\n            }\n        }\n    }\n\n    if (!_isDocker && mac === '') {\n        const mac = await getMac();\n        return uuid(mac);\n    }\n\n    if (!_isDocker && mac) {\n        const md5sum = crypto.createHash('md5');\n        md5sum.update(mac);\n        mac = md5sum.digest('hex');\n        u = `${mac.substring(0, 8)}-${mac.substring(8, 12)}-${mac.substring(12, 16)}-${mac.substring(16, 20)}-${mac.substring(20)}`;\n    } else {\n        // Returns a RFC4122 compliant v4 UUID https://gist.github.com/LeverOne/1308368 (DO WTF YOU WANT TO PUBLIC LICENSE)\n        let a: any;\n        let b;\n        b = a = '';\n        while (a++ < 36) {\n            b += (a * 51) & 52 ? (a ^ 15 ? 8 ^ (Math.random() * (a ^ 20 ? 16 : 4)) : 4).toString(16) : '-';\n        }\n        u = b;\n    }\n\n    return u;\n}\n\n/**\n * Update the installation UUID\n *\n * @param newUuid the new UUID to set\n * @param _objects the objects DB instance\n */\nasync function updateUuid(newUuid: string, _objects: any): Promise<string> {\n    let _uuid = await uuid('');\n    _uuid = newUuid || _uuid;\n    // Add vendor prefix to UUID\n    if (fs.existsSync(VENDOR_FILE)) {\n        try {\n            const vendor = await fs.readJSON(VENDOR_FILE);\n            if (vendor.vendor?.uuidPrefix?.length === 2 && !_uuid.startsWith(vendor.vendor.uuidPrefix)) {\n                _uuid = vendor.vendor.uuidPrefix + _uuid;\n            }\n        } catch {\n            console.error(`Cannot parse ${VENDOR_FILE}`);\n        }\n    }\n\n    try {\n        await _objects.setObject('system.meta.uuid', {\n            type: 'meta',\n            common: {\n                name: 'uuid',\n                type: 'uuid',\n            },\n            ts: new Date().getTime(),\n            from: `system.host.${getHostName()}.tools`,\n            native: {\n                uuid: _uuid,\n            },\n        });\n    } catch (e) {\n        throw new Error(`Object system.meta.uuid cannot be updated: ${e.message}`);\n    }\n\n    const obj: ioBroker.Object = await _objects.getObject('system.meta.uuid');\n\n    if (obj.native.uuid !== _uuid) {\n        console.error('object system.meta.uuid cannot be updated: write protected');\n    } else {\n        console.log(`object system.meta.uuid created: ${_uuid}`);\n    }\n\n    return _uuid;\n}\n\n/**\n * Generates a new uuid if non-existing\n *\n * @param objects - objects DB\n * @returns uuid if successfully created/updated\n */\nexport async function createUuid(objects: any): Promise<void | string> {\n    const userObj: ioBroker.UserObject = await objects.getObject('system.user.admin');\n    if (!userObj) {\n        await new Promise<void>(resolve => {\n            // Default Password for user 'admin' is application name in lower case\n            password(appName).hash(null, null, async (err, res) => {\n                err && console.error(err);\n\n                // Create user here and not in io-package.js because of hash password\n                await objects.setObject('system.user.admin', {\n                    type: 'user',\n                    common: {\n                        name: 'admin',\n                        password: res,\n                        dontDelete: true,\n                        enabled: true,\n                    },\n                    ts: new Date().getTime(),\n                    from: `system.host.${getHostName()}.tools`,\n                    native: {},\n                });\n\n                console.log('object system.user.admin created');\n                resolve();\n            });\n        });\n    }\n\n    const obj: ioBroker.Object = await objects.getObject('system.meta.uuid');\n    if (!obj?.native?.uuid) {\n        // generate new UUID\n        return updateUuid('', objects);\n    }\n\n    const PROBLEM_UUIDS = [\n        'ab265f4a-67f9-a46a-c0b2-61e4b95cefe5',\n        '7abd3182-d399-f7bd-da19-9550d8babede',\n        'deb6f2a8-fe69-5491-0a50-a9f9b8f3419c',\n        'ec66c85e-fc36-f6f9-f1c9-f5a2882d23c7',\n        'e6203b03-f5f4-253a-e4f6-b295fc543ab7',\n        'd659fa3d-7ef9-202a-ea23-acd0aff67b24',\n    ];\n\n    // check if COMMON invalid docker uuid\n    if (!PROBLEM_UUIDS.includes(obj.native.uuid)) {\n        return;\n    }\n\n    // Read vis license\n    const licObj: ioBroker.Object = objects.getObject('system.adapter.vis.0');\n    if (!licObj || !licObj.native || !licObj.native.license) {\n        return updateUuid('', objects);\n    }\n    // decode obj.native.license\n    let data;\n    try {\n        data = jwt.decode(licObj.native.license);\n    } catch {\n        data = null;\n    }\n\n    if (!data || typeof data === 'string' || !data.uuid) {\n        // generate new UUID\n        return updateUuid('', objects);\n    }\n    if (data.uuid !== obj.native.uuid) {\n        return updateUuid(data.correct ? data.uuid : '', objects);\n    }\n    // Show error\n    console.warn(`Your iobroker.vis license must be updated. Please contact info@iobroker.net to get a new license!`);\n    console.warn(`Provide following information in email: ${data.email}, invoice: ${data.invoice}`);\n}\n\n/**\n * Download file to tmp or return file name directly\n *\n * @param urlOrPath\n * @param fileName\n * @param callback\n */\nexport async function getFile(urlOrPath: string, fileName: string, callback: (file?: string) => void): Promise<void> {\n    // If object was read\n    if (\n        urlOrPath.substring(0, 'http://'.length) === 'http://' ||\n        urlOrPath.substring(0, 'https://'.length) === 'https://'\n    ) {\n        const tmpFile = `${thisDir}/../tmp/${fileName || `${Math.floor(Math.random() * 0xffffffe)}.zip`}`;\n\n        try {\n            // Add some information to user-agent, like chrome, IE and Firefox do\n            const res = await axios.get(urlOrPath, {\n                responseType: 'stream',\n                headers: {\n                    'User-Agent': `${appName}, RND: ${randomID}, N: ${process.version}`,\n                    'Accept-Encoding': 'gzip',\n                },\n            });\n\n            res.data.pipe(fs.createWriteStream(tmpFile)).on('close', () => {\n                console.log(`downloaded ${tmpFile}`);\n                callback && callback(tmpFile);\n            });\n        } catch (e) {\n            console.log(`Cannot download \"${tmpFile}\": ${e.message}`);\n            callback && callback(tmpFile);\n        }\n    } else {\n        try {\n            if (fs.existsSync(urlOrPath)) {\n                callback && callback(urlOrPath);\n            } else if (fs.existsSync(`${thisDir}/../${urlOrPath}`)) {\n                callback && callback(`${thisDir}/../${urlOrPath}`);\n            } else if (fs.existsSync(`${thisDir}/../tmp/${urlOrPath}`)) {\n                callback && callback(`${thisDir}/../tmp/${urlOrPath}`);\n            } else {\n                console.log(`File not found: ${urlOrPath}`);\n                process.exit(EXIT_CODES.FILE_NOT_FOUND);\n            }\n        } catch (err) {\n            console.log(`File \"${urlOrPath}\" could no be read: ${err.message}`);\n            process.exit(EXIT_CODES.FILE_NOT_FOUND);\n        }\n    }\n}\n\n// Return content of the json file. Download it or read directly\nexport async function getJson(\n    urlOrPath: string,\n    agent: string,\n    callback: (sources?: Record<string, any> | null, urlOrPath?: string | null) => void,\n): Promise<void> {\n    if (typeof agent === 'function') {\n        callback = agent;\n        agent = '';\n    }\n    agent = agent || '';\n\n    let sources = {};\n    // If object was read\n    if (urlOrPath && typeof urlOrPath === 'object') {\n        if (callback) {\n            callback(urlOrPath);\n        }\n    } else if (!urlOrPath) {\n        console.log('Empty url!');\n        if (callback) {\n            callback(null);\n        }\n    } else {\n        if (\n            urlOrPath.substring(0, 'http://'.length) === 'http://' ||\n            urlOrPath.substring(0, 'https://'.length) === 'https://'\n        ) {\n            try {\n                const res = await axios.get(urlOrPath, {\n                    headers: { 'Accept-Encoding': 'gzip', timeout: 10000, 'User-Agent': agent },\n                });\n\n                if (res.status !== 200 || !res.data) {\n                    throw new Error(`Invalid response, body: ${res.data}, status code: ${res.status}`);\n                }\n\n                sources = res.data;\n\n                if (callback) {\n                    callback(sources, urlOrPath);\n                }\n            } catch (e) {\n                console.warn(`Cannot download json from ${urlOrPath}. Error: ${e.message}`);\n                if (callback) {\n                    callback(null, urlOrPath);\n                }\n                return;\n            }\n        } else {\n            if (fs.existsSync(urlOrPath)) {\n                try {\n                    sources = fs.readJSONSync(urlOrPath);\n                } catch (e) {\n                    console.log(`Cannot parse json file from ${urlOrPath}. Error: ${e.message}`);\n                    if (callback) {\n                        callback(null, urlOrPath);\n                    }\n                    return;\n                }\n                if (callback) {\n                    callback(sources, urlOrPath);\n                }\n            } else if (fs.existsSync(`${thisDir}/../${urlOrPath}`)) {\n                try {\n                    sources = fs.readJSONSync(`${thisDir}/../${urlOrPath}`);\n                } catch (e) {\n                    console.log(`Cannot parse json file from ${thisDir}/../${urlOrPath}. Error: ${e.message}`);\n                    if (callback) {\n                        callback(null, urlOrPath);\n                    }\n                    return;\n                }\n                if (callback) {\n                    callback(sources, urlOrPath);\n                }\n            } else if (fs.existsSync(`${thisDir}/../tmp/${urlOrPath}`)) {\n                try {\n                    sources = fs.readJSONSync(`${thisDir}/../tmp/${urlOrPath}`);\n                } catch (e) {\n                    console.log(`Cannot parse json file from ${thisDir}/../tmp/${urlOrPath}. Error: ${e.message}`);\n                    if (callback) {\n                        callback(null, urlOrPath);\n                    }\n                    return;\n                }\n                if (callback) {\n                    callback(sources, urlOrPath);\n                }\n            } else {\n                if (callback) {\n                    callback(null, urlOrPath);\n                }\n            }\n        }\n    }\n}\n\n/**\n * Return content of the json file. Download it or read directly\n *\n * @param urlOrPath URL where the json file could be found\n * @param agent optional agent identifier like \"Windows Chrome 12.56\"\n * @returns json object\n */\nexport async function getJsonAsync(urlOrPath: string, agent?: string): Promise<Record<string, any> | null> {\n    agent = agent || '';\n\n    let sources = {};\n    // If object was read\n    if (urlOrPath && typeof urlOrPath === 'object') {\n        return urlOrPath;\n    } else if (!urlOrPath) {\n        console.log('Empty url!');\n        return null;\n    }\n    if (urlOrPath.startsWith('http://') || urlOrPath.startsWith('https://')) {\n        try {\n            const result = await axios(urlOrPath, {\n                timeout: 10000,\n                headers: { 'User-Agent': agent },\n                validateStatus: status => status !== 200,\n            });\n            return result.data;\n        } catch (e) {\n            console.warn(`Cannot download json from ${urlOrPath}. Error: ${e.message}`);\n            return null;\n        }\n    } else {\n        if (fs.existsSync(urlOrPath)) {\n            try {\n                sources = fs.readJSONSync(urlOrPath);\n            } catch (e) {\n                console.warn(`Cannot parse json file from ${urlOrPath}. Error: ${e.message}`);\n                return null;\n            }\n            return sources;\n        } else if (fs.existsSync(`${thisDir}/../${urlOrPath}`)) {\n            try {\n                sources = fs.readJSONSync(`${thisDir}/../${urlOrPath}`);\n            } catch (e) {\n                console.warn(`Cannot parse json file from ${thisDir}/../${urlOrPath}. Error: ${e.message}`);\n                return null;\n            }\n            return sources;\n        } else if (fs.existsSync(`${thisDir}/../tmp/${urlOrPath}`)) {\n            try {\n                sources = fs.readJSONSync(`${thisDir}/../tmp/${urlOrPath}`);\n            } catch (e) {\n                console.log(`Cannot parse json file from ${thisDir}/../tmp/${urlOrPath}. Error: ${e.message}`);\n                return null;\n            }\n            return sources;\n        }\n        return null;\n    }\n}\n\n/**\n * Scans directory for adapters and adds information to list\n *\n * @param dirName name of the directory to scan\n * @param list prefilled list to extend adapters too\n * @param regExp regexp to check matching files\n */\nfunction scanDirectory(dirName: string, list: Record<string, AdapterInformation>, regExp: RegExp): void {\n    if (fs.existsSync(dirName)) {\n        let dirs;\n        try {\n            dirs = fs.readdirSync(dirName);\n        } catch (e) {\n            console.log(`Cannot read or parse ${dirName}: ${e.message}`);\n            return;\n        }\n        for (let i = 0; i < dirs.length; i++) {\n            try {\n                const fullPath = path.join(dirName, dirs[i]);\n                const fileIoName = path.join(fullPath, 'io-package.json');\n                const fileName = path.join(fullPath, 'package.json');\n                if (regExp.test(dirs[i]) && fs.existsSync(fileIoName)) {\n                    const ioPackage = fs.readJSONSync(fileIoName);\n                    const package_ = fs.existsSync(fileName) ? fs.readJSONSync(fileName) : {};\n                    const localIcon = ioPackage.common.icon\n                        ? `/adapter/${dirs[i].substring(appName.length + 1)}/${ioPackage.common.icon}`\n                        : '';\n\n                    list[ioPackage.common.name] = {\n                        controller: ioPackage.common.controller || false,\n                        version: ioPackage.common.version,\n                        icon: ioPackage.common.extIcon || localIcon,\n                        localIcon,\n                        title: ioPackage.common.title, // deprecated 2021.04.18 BF\n                        titleLang: ioPackage.common.titleLang,\n                        desc: ioPackage.common.desc,\n                        platform: ioPackage.common.platform,\n                        keywords: ioPackage.common.keywords,\n                        readme: ioPackage.common.readme,\n                        type: ioPackage.common.type,\n                        license: ioPackage.common.license\n                            ? ioPackage.common.license\n                            : package_.licenses && package_.licenses.length\n                              ? package_.licenses[0].type\n                              : '',\n                        licenseUrl: package_.licenses && package_.licenses.length ? package_.licenses[0].url : '',\n                    };\n                }\n            } catch (e) {\n                console.log(`Cannot read or parse ${thisDir}/../node_modules/${dirs[i]}/io-package.json: ${e.message}`);\n            }\n        }\n    }\n}\n\ninterface Multilingual {\n    en: string;\n    de?: string;\n    ru?: string;\n    pt?: string;\n    nl?: string;\n    fr?: string;\n    it?: string;\n    es?: string;\n    pl?: string;\n    uk?: string;\n    'zh-cn'?: string;\n}\n\nexport interface AdapterInformation {\n    /** this flag is only true for the js-controller */\n    controller: boolean;\n    /** adapter version */\n    version: string;\n    /** path to icon of the adapter */\n    icon: string;\n    /** path to local icon of the adater */\n    localIcon?: string;\n    /** title of the adapter */\n    title: string;\n    /** title of the adapter in multiple languages */\n    titleLang: Multilingual;\n    /** description of the adapter in multiple languages */\n    desc: Multilingual;\n    /** platform of the adapter */\n    platform: 'Javascript/Node.js';\n    /** keywords of the adapter */\n    keywords: string[];\n    /** path to readme file */\n    readme: string;\n    /** The installed adapter version, not existing on controller */\n    runningVersion?: string;\n    /** type of the adapter */\n    type: string;\n    /** license of the adapter */\n    license: string;\n    /** url to license information */\n    licenseUrl?: string;\n}\n\n/**\n * Get a list of all installed adapters and controller version on this host\n *\n * @param hostRunningVersion Version of the running js-controller, will be included in the returned information if provided\n * @returns object containing information about installed host\n */\nexport function getInstalledInfo(hostRunningVersion?: string): Record<string, AdapterInformation> {\n    const result: Record<string, AdapterInformation> = {};\n    const fullPath = getControllerDir();\n\n    if (!fullPath) {\n        console.error('Could not determine controller directory on getInstalledInfo.');\n        return result;\n    }\n\n    // Get info about host\n    let ioPackage;\n    try {\n        ioPackage = fs.readJSONSync(path.join(fullPath, 'io-package.json'));\n    } catch (e) {\n        console.error(`Cannot get installed host information: ${e.message}`);\n    }\n    const package_ = fs.existsSync(path.join(fullPath, 'package.json'))\n        ? fs.readJSONSync(path.join(fullPath, 'package.json'))\n        : {};\n    const regExp = new RegExp(`^${appName}\\\\.`, 'i');\n\n    if (ioPackage) {\n        // Add controller information\n        result[ioPackage.common.name] = {\n            controller: true,\n            type: ioPackage.common.type,\n            version: ioPackage.common.version,\n            icon: ioPackage.common.extIcon || ioPackage.common.icon,\n            title: ioPackage.common.title, // deprecated 2021.04.18 BF\n            titleLang: ioPackage.common.titleLang,\n            desc: ioPackage.common.desc,\n            platform: ioPackage.common.platform,\n            keywords: ioPackage.common.keywords,\n            readme: ioPackage.common.readme,\n            runningVersion: hostRunningVersion,\n            license: ioPackage.common.license\n                ? ioPackage.common.license\n                : package_.licenses && package_.licenses.length\n                  ? package_.licenses[0].type\n                  : '',\n            licenseUrl: package_.licenses && package_.licenses.length ? package_.licenses[0].url : '',\n        };\n    }\n\n    // collect adapter information\n    scanDirectory(path.join(fullPath, 'node_modules'), result, regExp);\n    scanDirectory(path.join(fullPath, '..'), result, regExp);\n\n    return result;\n}\n\n/**\n * Reads an adapter's npm version\n *\n * @param adapter The adapter to read the npm version from. Null for the root ioBroker packet\n * @param callback\n */\nfunction getNpmVersion(adapter: string, callback?: (err: Error | null, version?: string | null) => void): void {\n    adapter = adapter ? `${appName}.${adapter}` : appName;\n    adapter = adapter.toLowerCase();\n\n    const cliCommand = `npm view ${adapter}@latest version`;\n\n    exec(cliCommand, { timeout: 2000, windowsHide: true }, (error, stdout, _stderr) => {\n        let version;\n        if (error) {\n            // command failed\n            if (typeof callback === 'function') {\n                callback(error);\n                return;\n            }\n        } else if (stdout) {\n            version = semver.valid(stdout.trim());\n        }\n        if (typeof callback === 'function') {\n            callback(null, version);\n        }\n    });\n}\n\nfunction getIoPack(\n    sources: Record<string, any>,\n    name: string,\n    callback: (sources: Record<string, any>, name: string) => void,\n): void {\n    getJson(sources[name].meta, '', ioPack => {\n        const packUrl = sources[name].meta.replace('io-package.json', 'package.json');\n        if (!ioPack) {\n            if (sources._helper) {\n                sources._helper.failCounter.push(name);\n            }\n            if (callback) {\n                callback(sources, name);\n            }\n        } else {\n            setImmediate(() => {\n                getJson(packUrl, '', pack => {\n                    const version = sources[name].version;\n                    const type = sources[name].type;\n                    // If installed from git or something else,\n                    // js-controller is exception, because can be installed from npm and from git\n                    if (sources[name].url && name !== 'js-controller') {\n                        if (ioPack && ioPack.common) {\n                            sources[name] = extend(true, sources[name], ioPack.common);\n\n                            // overwrite type of adapter from repository\n                            if (type) {\n                                sources[name].type = type;\n                            }\n                            if (pack && pack.licenses && pack.licenses.length) {\n                                if (!sources[name].license) {\n                                    sources[name].license = pack.licenses[0].type;\n                                }\n                                if (!sources[name].licenseUrl) {\n                                    sources[name].licenseUrl = pack.licenses[0].url;\n                                }\n                            }\n                        }\n\n                        if (callback) {\n                            callback(sources, name);\n                        }\n                    } else {\n                        if (ioPack && ioPack.common) {\n                            sources[name] = extend(true, sources[name], ioPack.common);\n                            if (pack && pack.licenses && pack.licenses.length) {\n                                if (!sources[name].license) {\n                                    sources[name].license = pack.licenses[0].type;\n                                }\n                                if (!sources[name].licenseUrl) {\n                                    sources[name].licenseUrl = pack.licenses[0].url;\n                                }\n                            }\n                        }\n\n                        // overwrite type of adapter from repository\n                        if (type) {\n                            sources[name].type = type;\n                        }\n\n                        if (version) {\n                            sources[name].version = version;\n                            if (callback) {\n                                callback(sources, name);\n                            }\n                        } else {\n                            if (\n                                sources[name].meta.substring(0, 'http://'.length) === 'http://' ||\n                                sources[name].meta.substring(0, 'https://'.length) === 'https://'\n                            ) {\n                                //installed from npm\n                                getNpmVersion(name, (_err, version) => {\n                                    if (version) {\n                                        sources[name].version = version;\n                                    } else {\n                                        sources[name].version = 'npm error';\n                                    }\n                                    if (callback) {\n                                        callback(sources, name);\n                                    }\n                                });\n                            } else {\n                                if (callback) {\n                                    callback(sources, name);\n                                }\n                            }\n                        }\n                    }\n                });\n            });\n        }\n    });\n}\n\nfunction _getRepositoryFile(\n    sources: Record<string, any>,\n    path: string,\n    callback?: (err?: Error, sources?: Record<string, any>) => void,\n): void {\n    if (!sources._helper) {\n        let count = 0;\n        for (const _name in sources) {\n            if (!Object.prototype.hasOwnProperty.call(sources, _name)) {\n                continue;\n            }\n            count++;\n        }\n        sources._helper = { failCounter: [] };\n\n        sources._helper.timeout = setTimeout(() => {\n            if (sources._helper) {\n                delete sources._helper;\n                for (const __name of Object.keys(sources)) {\n                    if (sources[__name].processed !== undefined) {\n                        delete sources[__name].processed;\n                    }\n                }\n                if (callback) {\n                    callback(new Error(`Timeout by read all package.json (${count}) seconds`), sources);\n                }\n                callback = undefined;\n            }\n        }, count * 1000);\n    }\n\n    for (const name of Object.keys(sources)) {\n        if (sources[name].processed || name === '_helper') {\n            continue;\n        }\n\n        sources[name].processed = true;\n        if (sources[name].url) {\n            sources[name].url = findPath(path, sources[name].url);\n        }\n        if (sources[name].meta) {\n            sources[name].meta = findPath(path, sources[name].meta);\n        }\n        if (sources[name].icon) {\n            sources[name].icon = findPath(path, sources[name].icon);\n        }\n\n        if (!sources[name].name && sources[name].meta) {\n            getIoPack(sources, name, _ignore => {\n                if (sources._helper) {\n                    if (sources._helper.failCounter.length > 10) {\n                        clearTimeout(sources._helper.timeout);\n                        delete sources._helper;\n                        for (const _name of Object.keys(sources)) {\n                            if (sources[_name].processed !== undefined) {\n                                delete sources[_name].processed;\n                            }\n                        }\n                        if (callback) {\n                            callback(new Error('Looks like there is no internet.'), sources);\n                        }\n                        callback = undefined;\n                    } else {\n                        // process next\n                        setImmediate(() => _getRepositoryFile(sources, path, callback));\n                    }\n                }\n            });\n            return;\n        }\n    }\n\n    // all packages are processed\n    if (sources._helper) {\n        let err;\n        if (sources._helper.failCounter.length) {\n            err = new Error(`Following packages cannot be read: ${sources._helper.failCounter.join(', ')}`);\n        }\n        clearTimeout(sources._helper.timeout);\n        delete sources._helper;\n        for (const __name of Object.keys(sources)) {\n            if (sources[__name].processed !== undefined) {\n                delete sources[__name].processed;\n            }\n        }\n        if (callback) {\n            callback(err, sources);\n        }\n        callback = undefined;\n    }\n}\n\nasync function _checkRepositoryFileHash(\n    urlOrPath: string,\n    additionalInfo: Record<string, any>,\n    callback: (err?: null | Error, sources?: Record<string, any> | null, hash?: string | number) => void,\n): Promise<void> {\n    // read hash of file\n    if (urlOrPath.startsWith('http://') || urlOrPath.startsWith('https://')) {\n        urlOrPath = urlOrPath.replace(/\\.json$/, '-hash.json');\n        let json: null | Record<string, any> = null;\n        try {\n            const res = await axios.get(urlOrPath, { headers: { 'Accept-Encoding': 'gzip', timeout: 10000 } });\n            if (!res.data || res.status !== 200) {\n                throw new Error(`Invalid response, body: ${res.data}, status code: ${res.status}`);\n            }\n\n            json = res.data;\n        } catch (e) {\n            console.warn(`Cannot download json from ${urlOrPath}. Error: ${e.message}`);\n        }\n\n        if (json && json.hash) {\n            // The hash download was successful\n            if (additionalInfo && additionalInfo.sources && json.hash === additionalInfo.hash) {\n                // The hash is the same as for the cached sources\n                console.log('hash unchanged, use cached sources');\n                callback(null, additionalInfo.sources, json.hash);\n            } else {\n                // Either we have no sources cached or the hash changed\n                // => force download of new sources\n                console.log('hash changed or no sources cached => force download of new sources');\n                callback(null, null, json.hash);\n            }\n        } else {\n            // Could not download new sources, use the old ones\n            console.log('failed to download new sources, use cached sources');\n            callback(null, additionalInfo.sources, '');\n        }\n    } else {\n        // it is a file and file has not hash\n        callback(null, null, 0);\n    }\n}\n\n/**\n * Get a list of all adapters and controller in some repository file or in /conf/source-dist.json\n *\n * @param urlOrPath URL starting with http:// or https:// or local file link\n * @param additionalInfo destination object\n * @param callback function (err, sources, actualHash) { }\n */\nexport function getRepositoryFile(\n    urlOrPath: string,\n    additionalInfo: Record<string, any>,\n    callback: (err?: Error | null, sources?: Record<string, any>, actualHash?: string | number) => void,\n): void {\n    let sources: Record<string, any> = {};\n    let _path = '';\n\n    if (typeof additionalInfo === 'function') {\n        // @ts-expect-error: fix all fun calls then remove\n        callback = additionalInfo;\n        additionalInfo = {};\n    }\n\n    additionalInfo = additionalInfo || {};\n\n    if (urlOrPath) {\n        const parts = urlOrPath.split('/');\n        _path = `${parts.splice(0, parts.length - 1).join('/')}/`;\n    }\n\n    // If an object was read\n    if (urlOrPath && typeof urlOrPath === 'object') {\n        if (typeof callback === 'function') {\n            callback(null, urlOrPath);\n        }\n    } else if (!urlOrPath) {\n        try {\n            const controllerDir = getControllerDir();\n            if (controllerDir) {\n                sources = fs.readJSONSync(path.join(controllerDir, getDefaultDataDir(), 'sources.json'));\n            }\n        } catch {\n            sources = {};\n        }\n        try {\n            const controllerDir = getControllerDir();\n            if (controllerDir) {\n                const sourcesDist = fs.readJSONSync(path.join(controllerDir, 'conf', 'sources-dist.json'));\n                sources = extend(true, sourcesDist, sources);\n            }\n        } catch {\n            // continue regardless of error\n        }\n\n        for (const s of Object.keys(sources)) {\n            if (additionalInfo[s] && additionalInfo[s].published) {\n                sources[s].published = additionalInfo[s].published;\n            }\n        }\n\n        _getRepositoryFile(sources, _path, err => {\n            if (err) {\n                console.error(`[${new Date().toString()}] ${err.message}`);\n            }\n            if (typeof callback === 'function') {\n                callback(err, sources);\n            }\n        });\n    } else {\n        let agent = '';\n        if (additionalInfo) {\n            // Add some information to user-agent, like chrome, IE and Firefox do\n            agent = `${additionalInfo.name}, RND: ${additionalInfo.randomID || randomID}, Node:${\n                additionalInfo.node\n            }, V:${additionalInfo.controller}`;\n        }\n\n        // load hash of file first to not load the whole 1MB of sources\n        _checkRepositoryFileHash(urlOrPath, additionalInfo, (err, sources, actualSourcesHash) => {\n            if (!err && sources) {\n                // Source file was not changed\n                typeof callback === 'function' && callback(err, sources, actualSourcesHash);\n            } else {\n                getJson(urlOrPath, agent, sources => {\n                    if (sources) {\n                        for (const s of Object.keys(sources)) {\n                            if (additionalInfo[s] && additionalInfo[s].published) {\n                                sources[s].published = additionalInfo[s].published;\n                            }\n                        }\n                        setImmediate(() =>\n                            _getRepositoryFile(sources, _path, err => {\n                                err && console.error(`[${new Date().toString()}] ${err.message}`);\n                                typeof callback === 'function' && callback(err, sources, actualSourcesHash);\n                            }),\n                        );\n                    } else {\n                        // return cached sources, because no sources found\n                        console.log(\n                            `failed to download new sources, ${\n                                additionalInfo.sources ? 'use cached sources' : 'no cached sources available'\n                            }`,\n                        );\n                        return maybeCallbackWithError(\n                            callback,\n                            `Cannot read \"${urlOrPath}\"`,\n                            additionalInfo.sources,\n                            '',\n                        );\n                    }\n                });\n            }\n        });\n    }\n}\n\nexport interface RepositoryFile {\n    json: ioBroker.RepositoryJson;\n    changed: boolean;\n    hash: string;\n}\n\n/**\n * Read on repository\n *\n * @param url URL starting with http:// or https:// or local file link\n * @param hash actual hash\n * @param force Force repository update despite on hash\n * @param _actualRepo Actual repository JSON content\n */\nexport async function getRepositoryFileAsync(\n    url: string,\n    hash?: string,\n    force?: boolean,\n    _actualRepo?: ioBroker.RepositoryJson | null,\n): Promise<RepositoryFile> {\n    let _hash;\n    let data;\n\n    if (url.startsWith('http://') || url.startsWith('https://')) {\n        try {\n            _hash = await axios({ url: url.replace(/\\.json$/, '-hash.json'), timeout: 10_000 });\n        } catch {\n            // ignore missing hash file\n        }\n\n        if (_actualRepo && !force && hash && _hash?.data && _hash.data.hash === hash) {\n            data = _actualRepo;\n        } else {\n            const agent = `${appName}, RND: ${randomID}, Node:${process.version}, V:${\n                require('@iobroker/js-controller-common/package.json').version\n            }`;\n            try {\n                data = await axios({\n                    url,\n                    timeout: 10_000,\n                    headers: { 'User-Agent': agent },\n                });\n                data = data.data;\n            } catch (e) {\n                throw new Error(`Cannot download repository file from \"${url}\": ${e.message}`);\n            }\n        }\n    } else {\n        if (fs.existsSync(url)) {\n            try {\n                data = JSON.parse(fs.readFileSync(url).toString('utf8'));\n            } catch (e) {\n                throw new Error(`Error: Cannot read or parse file \"${url}\": ${e}`);\n            }\n        } else {\n            throw new Error(`Error: Cannot find file \"${url}\"`);\n        }\n    }\n\n    return {\n        json: data,\n        changed: _hash?.data ? hash !== _hash.data.hash : true,\n        hash: _hash && _hash.data ? _hash.data.hash : '',\n    };\n}\n\n/**\n * Sends the given object to the diagnosis server\n *\n * @param obj - diagnosis object\n */\nexport async function sendDiagInfo(obj: Record<string, any>): Promise<void> {\n    const objStr = JSON.stringify(obj);\n    console.log(`Send diag info: ${objStr}`);\n    const params = new URLSearchParams();\n    params.append('data', objStr);\n    const config = {\n        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n        timeout: 4000,\n    };\n\n    try {\n        await axios.post(`http://download.${appName}.net/diag.php`, params, config);\n    } catch (e) {\n        console.log(`Cannot send diag info: ${e.message}`);\n    }\n}\n\n/**\n * Finds the adapter directory of a given adapter\n *\n * @param adapter name of the adapter, e.g., hm-rpc\n * @returns path to adapter directory or null if no directory found\n */\nexport function getAdapterDir(adapter: string): string | null {\n    // snip off 'iobroker.'\n    if (adapter.toLowerCase().startsWith(`${appNameLowerCase}.`)) {\n        adapter = adapter.substring(appName.length + 1);\n    }\n    // snip off instance id\n    if (/\\.\\d+$/.test(adapter)) {\n        adapter = adapter.slice(0, adapter.lastIndexOf('.'));\n    }\n\n    const possibilities = [`${appName.toLowerCase()}.${adapter}/package.json`, `${appName}.${adapter}/package.json`];\n\n    let adapterPath;\n    for (const possibility of possibilities) {\n        // special case to not read adapters from js-controller/node_module/adapter and check first in parent directory\n        if (fs.existsSync(path.join(getControllerDir(), '..', possibility))) {\n            adapterPath = path.join(getControllerDir(), '..', possibility);\n        } else if (fs.existsSync(path.join(getControllerDir(), 'node_modules', possibility))) {\n            adapterPath = path.join(getControllerDir(), 'node_modules', possibility);\n        } else {\n            try {\n                adapterPath = require.resolve(possibility);\n            } catch {\n                // not found\n            }\n        }\n        if (adapterPath) {\n            break;\n        }\n    }\n\n    if (!adapterPath) {\n        return null; // inactive\n    }\n    const parts = path.normalize(adapterPath).split(/[\\\\/]/g);\n    parts.pop();\n    return parts.join('/');\n}\n\n/**\n * Returns the hostname of this host\n */\nexport function getHostName(): string {\n    if (process.env.IOB_HOSTNAME) {\n        return process.env.IOB_HOSTNAME;\n    }\n\n    try {\n        const configName = getConfigFileName();\n        const config = fs.readJSONSync(configName);\n        return config.system?.hostname || os.hostname();\n    } catch {\n        return os.hostname();\n    }\n}\n\n/**\n * Read version of system npm\n *\n * @param callback return result\n *        <pre><code>\n *            function (err, version) {\n *              adapter.log.debug('NPM version is: ' + version);\n *            }\n *        </code></pre>\n */\nfunction getSystemNpmVersion(callback?: (err?: Error, version?: string | null) => void): void {\n    const { exec } = require('node:child_process');\n\n    // remove local node_modules\\.bin dir from a path\n    // or we potentially get a wrong npm version\n    const newEnv = Object.assign({}, process.env);\n    // @ts-expect-error TODO\n    newEnv.PATH = (newEnv.PATH || newEnv.Path || newEnv.path)\n        .split(path.delimiter)\n        .filter(dir => {\n            dir = dir.toLowerCase();\n            return !dir.includes('iobroker') || !dir.includes(path.join('node_modules', '.bin'));\n        })\n        .join(path.delimiter);\n    try {\n        let timeout: NodeJS.Timeout | null = setTimeout(() => {\n            timeout = null;\n            if (callback) {\n                callback(new Error('timeout'));\n                callback = undefined;\n            }\n        }, 10_000);\n\n        exec(\n            'npm -v',\n            { encoding: 'utf8', env: newEnv, windowsHide: true },\n            (error: any, stdout: string | undefined | null) => {\n                //, stderr) {\n                if (timeout) {\n                    clearTimeout(timeout);\n                    timeout = null;\n                }\n                if (stdout) {\n                    stdout = semver.valid(stdout.trim());\n                }\n                if (callback) {\n                    callback(error, stdout);\n                    callback = undefined;\n                }\n            },\n        );\n    } catch (e) {\n        if (callback) {\n            callback(e);\n            callback = undefined;\n        }\n    }\n}\n\nconst getSystemNpmVersionAsync = promisify(getSystemNpmVersion);\n\nexport interface InstallNodeModuleOptions {\n    // Whether the `--unsafe-perm` flag should be used\n    unsafePerm?: boolean;\n    // Whether to include `stderr` in the output and increase the loglevel to include more than errors\n    debug?: boolean;\n    // Which directory to work in. If none is given, this defaults to ioBroker's root directory.\n    cwd?: string;\n}\n\n/**\n *\n * Figure out which package manager is in charge, but with a fallback to npm.\n *\n * @param cwd Which directory to work in. If none is given, this defaults to ioBroker's root directory.\n */\nexport async function detectPackageManagerWithFallback(cwd?: string): Promise<PackageManager> {\n    try {\n        // For the first attempt, use pak's default of requiring a lockfile. This makes sure we find ioBroker's root dir\n        return await detectPackageManager(\n            typeof cwd === 'string'\n                ? // If a cwd was provided, use it\n                  { cwd }\n                : // Otherwise, try to find the ioBroker root dir\n                  {\n                      cwd: (isDevServerInstallation() && require.main?.path) || thisDir,\n                      setCwdToPackageRoot: true,\n                  },\n        );\n    } catch {\n        // Lockfile is not found, use default to avoid picking up a wrong package manager\n        // like a globally installed yarn\n    }\n\n    // Since we have no lockfile to rely on, assume the root dir is 2 levels above js-controller\n    const ioBrokerRootDir = getRootDir();\n    // And fallback to npm\n    const pak = new packageManagers.npm();\n    pak.cwd = cwd || ioBrokerRootDir;\n    return pak;\n}\n\n/**\n * Installs a node module using npm or a similar package manager\n *\n * @param npmUrl Which node module to install\n * @param options Options for the installation\n */\nexport async function installNodeModule(\n    npmUrl: string,\n    options: InstallNodeModuleOptions = {},\n): Promise<CommandResult> {\n    // Figure out which package manager is in charge (probably npm at this point)\n    const pak = await detectPackageManagerWithFallback(options.cwd);\n    // By default, don't print all the stuff the package manager spits out\n    if (!options.debug) {\n        pak.loglevel = 'error';\n    }\n\n    // And install the module\n    const installOpts: WithRequired<InstallOptions, 'additionalArgs'> = {\n        additionalArgs: [],\n    };\n\n    // Set up streams to pass the command output through\n    if (options.debug) {\n        const stdall = new PassThrough();\n        pak.stdall = stdall;\n        pipeLinewise(stdall, process.stdout);\n        installOpts.additionalArgs.push('--foreground-scripts');\n    } else {\n        const stdout = new PassThrough();\n        pak.stdout = stdout;\n        pipeLinewise(stdout, process.stdout);\n    }\n\n    if (options.unsafePerm) {\n        installOpts.additionalArgs.push('--unsafe-perm');\n    }\n\n    return pak.install([npmUrl], installOpts);\n}\n\nexport interface UninstallNodeModuleOptions {\n    // Whether to include `stderr` in the output and increase the loglevel to include more than errors\n    debug?: boolean;\n    // Which directory to work in. If none is given, this defaults to ioBroker's root directory.\n    cwd?: string;\n}\n\n/**\n * Uninstalls a node module using npm or a similar package manager\n *\n * @param packageName Which node module to uninstall\n * @param options Options for the installation\n */\nexport async function uninstallNodeModule(\n    packageName: string,\n    options: UninstallNodeModuleOptions = {},\n): Promise<CommandResult> {\n    // Figure out which package manager is in charge (probably npm at this point)\n    const pak = await detectPackageManagerWithFallback(options.cwd);\n    // By default, don't print all the stuff the package manager spits out\n    if (!options.debug) {\n        pak.loglevel = 'error';\n    }\n\n    // Set up streams to pass the command output through\n    if (options.debug) {\n        const stdall = new PassThrough();\n        pak.stdall = stdall;\n        pipeLinewise(stdall, process.stdout);\n    } else {\n        const stdout = new PassThrough();\n        pak.stdout = stdout;\n        pipeLinewise(stdout, process.stdout);\n    }\n\n    return pak.uninstall([packageName]);\n}\n\nexport interface RebuildNodeModulesOptions {\n    // Whether to include `stderr` in the output and increase the loglevel to include more than errors\n    debug?: boolean;\n    // Which directory to work in. If none is given, this defaults to ioBroker's root directory.\n    cwd?: string;\n    // module which should be rebuilt\n    module?: string;\n}\n\n/**\n * Rebuilds all native node_modules that are dependencies of the project in the current working directory / project root.\n * If `options.cwd` is given, the directory must contain a lockfile.\n *\n * @param options Options for the rebuild\n */\nexport async function rebuildNodeModules(options: RebuildNodeModulesOptions = {}): Promise<CommandResult> {\n    // Figure out which package manager is in charge (probably npm at this point)\n    const pak = await detectPackageManagerWithFallback(options.cwd);\n    // By default, don't print all the stuff the package manager spits out\n    if (!options.debug) {\n        pak.loglevel = 'error';\n    }\n\n    // Set up streams to pass the command output through\n    if (options.debug) {\n        const stdall = new PassThrough();\n        pak.stdall = stdall;\n        pipeLinewise(stdall, process.stdout);\n    } else {\n        const stdout = new PassThrough();\n        pak.stdout = stdout;\n        pipeLinewise(stdout, process.stdout);\n    }\n\n    return pak.rebuild(options.module ? [options.module] : undefined);\n}\n\nexport interface GetDiskInfoResponse {\n    'Disk size': number;\n    'Disk free': number;\n}\n\n/**\n * Read disk free space\n */\nexport async function getDiskInfo(): Promise<GetDiskInfoResponse | null> {\n    const platform = process.platform;\n    if (diskusage) {\n        try {\n            const path = platform === 'win32' ? thisDir.substring(0, 2) : '/';\n            const info = diskusage.checkSync(path);\n            return { 'Disk size': info.total, 'Disk free': info.free };\n        } catch (e) {\n            console.log(e.message);\n        }\n    } else {\n        if (platform === 'win32') {\n            // Caption  FreeSpace     Size\n            // A:\n            // C:       66993807360   214640357376\n            // D:\n            // Y:       116649795584  148368257024\n            // Z:       116649795584  148368257024\n            const disk = thisDir.substring(0, 2).toUpperCase();\n\n            const { stdout } = await execAsync('wmic logicaldisk get size,freespace,caption');\n\n            if (typeof stdout === 'string') {\n                const lines = stdout.split('\\n');\n                const line = lines.find(line => {\n                    const parts = line.split(/\\s+/);\n                    return parts[0].toUpperCase() === disk;\n                });\n                if (line) {\n                    const parts = line.split(/\\s+/);\n                    return {\n                        'Disk size': parseInt(parts[2]),\n                        'Disk free': parseInt(parts[1]),\n                    };\n                }\n            }\n        } else {\n            const { stdout } = await execAsync(`df -k ${getRootDir()}`);\n            //, stderr) {\n            // Filesystem            1K-blocks    Used Available Use% Mounted on\n            // /dev/mapper/vg00-lv01 162544556 9966192 145767152   7% /\n            try {\n                if (typeof stdout === 'string') {\n                    const parts = stdout.split('\\n')[1].split(/\\s+/);\n                    return {\n                        'Disk size': parseInt(parts[1]) * 1024,\n                        'Disk free': parseInt(parts[3]) * 1024,\n                    };\n                }\n            } catch {\n                // continue regardless of error\n            }\n        }\n    }\n\n    return null;\n}\n\nexport interface CertificateInfo {\n    certificateFilename: string | null;\n    /** the certificate itself */\n    certificate: string;\n    /** serial number */\n    serialNumber: string;\n    /** type of signature as text like \"RSA\" */\n    signature: string;\n    /** bits used for encryption key like 2048 */\n    keyLength: number;\n    /** issuer of the certificate */\n    issuer: Record<string, any>;\n    /** subject that is signed */\n    subject: Record<string, any>;\n    /** server name this certificate belong to */\n    dnsNames: {\n        type: number;\n        value: string;\n    }[];\n    /** this certificate can be used for the following purposes */\n    keyUsage: Record<string, any>;\n    /** usable or client, server or ... */\n    extKeyUsage: Record<string, any>;\n    /** certificate validity start datetime */\n    validityNotBefore: Date;\n    /** certificate validity end datetime */\n    validityNotAfter: Date;\n}\n\n/**\n * Returns information about a certificate\n *\n * @param cert\n * @returns certificate information object\n */\nexport function getCertificateInfo(cert: string): null | CertificateInfo {\n    let info: CertificateInfo | null = null;\n\n    if (!cert) {\n        return null;\n    }\n\n    const pki = forge.pki;\n\n    let certFile = null;\n    try {\n        if (typeof cert === 'string' && cert.length < 1024 && fs.existsSync(cert)) {\n            certFile = cert;\n            cert = fs.readFileSync(cert, 'utf8');\n        }\n\n        // cast to any we use some undocumented? the properties below\n        const crt: any = pki.certificateFromPem(cert);\n\n        info = {\n            certificateFilename: certFile,\n            certificate: cert,\n            serialNumber: crt.serialNumber,\n            signature: pki.oids[crt.signatureOid],\n            keyLength: crt.publicKey.n.toString(2).length,\n            issuer: crt.issuer,\n            subject: crt.subject,\n            dnsNames: crt.getExtension('subjectAltName').altNames,\n            keyUsage: crt.getExtension('keyUsage'),\n            extKeyUsage: crt.getExtension('extKeyUsage'),\n            validityNotBefore: crt.validity.notBefore,\n            validityNotAfter: crt.validity.notAfter,\n        };\n\n        // do not return info about values\n        delete info.keyUsage.value;\n        delete info.extKeyUsage.value;\n        return info;\n    } catch {\n        return null;\n    }\n}\n\nexport interface DefaultCertificates {\n    defaultPrivate: string;\n    defaultPublic: string;\n}\n\n/** Maximum time after which cert has to expire - 365 days in ms */\nexport const MAX_CERT_VALIDITY = 365 * 24 * 60 * 60 * 1_000;\n\n/**\n * Returns default SSL certificates (private and public)\n *\n *\n *  The following info will be returned:\n *     - defaultPrivate: private RSA key\n *     - defaultPublic: public certificate\n *\n *        <pre><code>\n *            const certificates = tools.generateDefaultCertificates();\n *        </code></pre>\n */\nexport function generateDefaultCertificates(): DefaultCertificates {\n    const pki = forge.pki;\n    const keys = pki.rsa.generateKeyPair({ bits: 2048, e: 0x10001 });\n    const cert = pki.createCertificate();\n\n    cert.publicKey = keys.publicKey;\n    cert.serialNumber = `0${makeid(17)}`;\n    cert.validity.notBefore = new Date();\n\n    cert.validity.notAfter = new Date(Date.now() + MAX_CERT_VALIDITY);\n\n    const subAttrs = [\n        { name: 'commonName', value: getHostName() },\n        { name: 'organizationName', value: 'ioBroker GmbH' },\n        { shortName: 'OU', value: 'iobroker' },\n    ];\n\n    const issAttrs = [\n        { name: 'commonName', value: 'iobroker' },\n        { name: 'organizationName', value: 'ioBroker GmbH' },\n        { shortName: 'OU', value: 'iobroker' },\n    ];\n\n    cert.setSubject(subAttrs);\n    cert.setIssuer(issAttrs);\n\n    cert.setExtensions([\n        {\n            name: 'basicConstraints',\n            critical: true,\n            cA: false,\n        },\n        {\n            name: 'keyUsage',\n            critical: true,\n            digitalSignature: true,\n            contentCommitment: true,\n            keyEncipherment: true,\n            dataEncipherment: true,\n            keyAgreement: true,\n            keyCertSign: true,\n            cRLSign: true,\n            encipherOnly: true,\n            decipherOnly: true,\n        },\n        {\n            name: 'subjectAltName',\n            altNames: [\n                {\n                    type: 2,\n                    value: os.hostname(),\n                },\n            ],\n        },\n        {\n            name: 'subjectKeyIdentifier',\n        },\n        {\n            name: 'extKeyUsage',\n            serverAuth: true,\n            clientAuth: true,\n            codeSigning: false,\n            emailProtection: false,\n            timeStamping: false,\n        },\n        {\n            name: 'authorityKeyIdentifier',\n        },\n    ]);\n\n    cert.sign(keys.privateKey, forge.md.sha256.create());\n\n    const pem_pkey = pki.privateKeyToPem(keys.privateKey);\n    const pem_cert = pki.certificateToPem(cert);\n\n    return {\n        defaultPrivate: pem_pkey,\n        defaultPublic: pem_cert,\n    };\n}\n\nfunction makeid(length: number): string {\n    let result = '';\n    const characters = 'abcdef0123456789';\n    const charactersLength = characters.length;\n    for (let i = 0; i < length; i++) {\n        result += characters.charAt(Math.floor(Math.random() * charactersLength));\n    }\n    return result;\n}\n\n/**\n * Collects information about host and available adapters\n *\n *  Following info will be collected:\n *    - available adapters\n *    - node.js --version\n *    - npm --version\n *\n * @param objects db\n */\nexport async function getHostInfo(objects: any): Promise<HostInfo> {\n    if (!diskusage) {\n        try {\n            diskusage = require('diskusage');\n        } catch {\n            // ignore\n        }\n    }\n\n    const systemConfig: ioBroker.OtherObject = await objects.getObjectAsync('system.config');\n    const systemRepos: ioBroker.OtherObject = await objects.getObjectAsync('system.repositories');\n\n    // Check if repositories exist\n    const allRepos: Record<string, any> = {};\n    if (systemRepos?.native?.repositories && systemConfig) {\n        const repos: string[] = Array.isArray(systemConfig.common.activeRepo)\n            ? systemConfig.common.activeRepo\n            : [systemConfig.common.activeRepo];\n        repos\n            .filter(repo => systemRepos.native.repositories[repo] && systemRepos.native.repositories[repo].json)\n            .forEach(repo => Object.assign(allRepos, systemRepos.native.repositories[repo].json));\n    }\n\n    if (!npmVersion) {\n        try {\n            npmVersion = await getSystemNpmVersionAsync();\n        } catch (e) {\n            console.error(`Cannot get NPM version: ${e.message}`);\n        }\n    }\n\n    const cpus = os.cpus();\n    const dateObj = new Date();\n\n    const data: HostInfo = {\n        Platform: isDocker() ? 'docker' : os.platform(),\n        os: process.platform,\n        Architecture: os.arch(),\n        CPUs: cpus && Array.isArray(cpus) ? cpus.length : null,\n        Speed: cpus && Array.isArray(cpus) ? cpus[0].speed : null,\n        Model: cpus && Array.isArray(cpus) ? cpus[0].model : null,\n        RAM: os.totalmem(),\n        'System uptime': Math.round(os.uptime()),\n        'Node.js': process.version,\n        time: dateObj.getTime(),\n        timeOffset: dateObj.getTimezoneOffset(),\n        NPM: npmVersion,\n        'adapters count': Object.keys(allRepos).length,\n    };\n\n    if (data.Platform === 'win32') {\n        data.Platform = 'Windows';\n    } else if (data.Platform === 'darwin') {\n        data.Platform = 'OSX';\n    }\n\n    if (data.Platform === 'docker') {\n        data.dockerInformation = getDockerInformation();\n    }\n\n    try {\n        const info = await getDiskInfo();\n        if (info) {\n            Object.assign(data, info);\n        }\n    } catch (e) {\n        console.error(`Cannot get disk information: ${e.message}`);\n    }\n\n    return data;\n}\n\n/**\n * Finds the controller root directory\n *\n * @returns absolute path to controller dir without ending slash\n */\nexport function getControllerDir(): string {\n    const possibilities = ['iobroker.js-controller', 'ioBroker.js-controller'];\n    for (const pkg of possibilities) {\n        try {\n            // package.json is guaranteed to be in the module root folder\n            // so once that is resolved, take the dirname and we're done\n            const possiblePath = require.resolve(`${pkg}/package.json`);\n\n            if (fs.existsSync(possiblePath)) {\n                return path.dirname(possiblePath);\n            }\n        } catch {\n            /* not found */\n        }\n    }\n\n    // Also check in the current check dir (along with iobroker.js-controller sub-dirs)\n    let checkPath = path.join(thisDir, '..', '..');\n\n    possibilities.unshift('');\n\n    while (true) {\n        for (const pkg of possibilities) {\n            try {\n                const possiblePath = path.join(checkPath, pkg);\n\n                if (fs.existsSync(path.join(possiblePath, `${appNameLowerCase}.js`))) {\n                    return possiblePath;\n                }\n            } catch {\n                // not found, continue with next possibility\n            }\n        }\n\n        // Controller isn't found here - go to the parent dir\n        const newPath = path.dirname(checkPath);\n        if (newPath === checkPath) {\n            // We already reached the root dir, abort\n            break;\n        }\n        checkPath = newPath;\n    }\n\n    throw new Error('Could not determine controller directory');\n}\n\n/**\n * Get the root dir of the ioBroker installation\n */\nexport function getRootDir(): string {\n    return path.join(getControllerDir(), '..', '..');\n}\n\n/** Returns whether the current process is executed via dev-server */\nexport function isDevServerInstallation(): boolean {\n    return !!require.main?.path.includes(`${path.sep}.dev-server${path.sep}`);\n}\n\n/**\n * All paths are returned always relative to /node_modules/' + appName + '.js-controller\n * the result has always \"/\" as last symbol\n */\nexport function getDefaultDataDir(): string {\n    // Allow overriding the data directory with an environment variable\n    let envDataDir = process.env[`${appName.toUpperCase()}_DATA_DIR`];\n    if (envDataDir) {\n        if (path.isAbsolute(envDataDir)) {\n            envDataDir = path.relative(getControllerDir(), envDataDir);\n        }\n        return envDataDir;\n    }\n\n    if (isDevInstallation()) {\n        // dev install\n        return './data/';\n    }\n\n    return path.join('..', '..', `${appNameLowerCase}-data/`);\n}\n\n/**\n * Returns the path of the config file\n */\nexport function getConfigFileName(): string {\n    // Allow overriding the config file location with an environment variable\n    let envDataDir = process.env[`${appName.toUpperCase()}_DATA_DIR`];\n    if (envDataDir) {\n        if (!path.isAbsolute(envDataDir)) {\n            envDataDir = path.join(getControllerDir(), envDataDir);\n        }\n        return path.join(envDataDir, `${appNameLowerCase}.json`);\n    }\n\n    const controllerDir = getControllerDir();\n    const fallbackConfigFile = path.join(controllerDir, 'data', `${appNameLowerCase}.json`);\n    const isDevInstall = isDevInstallation();\n\n    if (isDevInstall) {\n        const devConfigFile = path.join(controllerDir, 'conf', `${appNameLowerCase}.json`);\n\n        if (fs.existsSync(devConfigFile)) {\n            return devConfigFile;\n        } else if (fs.existsSync(fallbackConfigFile)) {\n            return fallbackConfigFile;\n        }\n    }\n\n    const prodConfigFile = path.join(getRootDir(), `${appNameLowerCase}-data`, `${appNameLowerCase}.json`);\n\n    if (!fs.existsSync(prodConfigFile) && isDevInstall) {\n        return fallbackConfigFile;\n    }\n\n    return prodConfigFile;\n}\n\n/**\n * Puts all values from an `arguments` object into an array, starting at the given index\n *\n * @param argsObj An `arguments` object as passed to a function\n * @param startIndex The optional index to start taking the arguments from\n */\nfunction sliceArgs(argsObj: IArguments, startIndex = 0): any[] {\n    if (startIndex === null || startIndex === undefined) {\n        startIndex = 0;\n    }\n    const ret = [];\n    for (let i = startIndex; i < argsObj.length; i++) {\n        ret.push(argsObj[i]);\n    }\n    return ret;\n}\n\n/**\n * Promisifies a function which returns an error as the first argument in its callback\n *\n * @param fn The function to promisify\n * @param context (optional) The context (value of `this` to bind the function to)\n * @param returnArgNames (optional) If the callback contains multiple arguments,\n * you can combine them into one object by passing the names as an array.\n * Otherwise, the Promise will resolve with an array\n */\nexport function promisify(\n    fn: (...args: any[]) => void,\n    context?: any,\n    returnArgNames?: string[],\n): (...args: any[]) => Promise<any> {\n    return function () {\n        // eslint-disable-next-line prefer-rest-params\n        const args = sliceArgs(arguments);\n        // @ts-expect-error we cannot know the type of `this`\n        context = context || this;\n        // eslint-disable-next-line no-async-promise-executor\n        return new Promise<void | Record<string, any> | any[]>(async (resolve, reject) => {\n            try {\n                // await this to allow streamlining errors not passed via callback by async methods\n                // eslint-disable-next-line @typescript-eslint/await-thenable\n                await fn.apply(\n                    context,\n                    args.concat([\n                        function (error: string | Error, result: any) {\n                            if (error) {\n                                return reject(error instanceof Error ? error : new Error(error));\n                            }\n                            // decide on how we want to return the callback arguments\n                            switch (arguments.length) {\n                                case 1: // only an error was given\n                                    return resolve(); // Promise<void>\n                                case 2: // a single value (result) was returned\n                                    return resolve(result);\n                                default: {\n                                    // multiple values should be returned\n                                    let ret: Record<string, any> | any[];\n                                    // eslint-disable-next-line prefer-rest-params\n                                    const extraArgs = sliceArgs(arguments, 1);\n                                    if (returnArgNames && returnArgNames.length === extraArgs.length) {\n                                        // we can build an object\n                                        ret = {};\n                                        for (let i = 0; i < returnArgNames.length; i++) {\n                                            ret[returnArgNames[i]] = extraArgs[i];\n                                        }\n                                    } else {\n                                        // we return the raw array\n                                        ret = extraArgs;\n                                    }\n                                    return resolve(ret);\n                                }\n                            }\n                        },\n                    ]),\n                );\n            } catch (e) {\n                reject(e as Error);\n            }\n        });\n    };\n}\n\n/**\n * Promisifies a function which does not provide an error as the first argument in its callback\n *\n * @param fn The function to promisify\n * @param context (optional) The context (value of `this` to bind the function to)\n * @param returnArgNames (optional) If the callback contains multiple arguments,\n * you can combine them into one object by passing the names as an array.\n * Otherwise, the Promise will resolve with an array\n */\nexport function promisifyNoError(\n    fn: (...args: any[]) => void,\n    context?: any,\n    returnArgNames?: string[],\n): (...args: any[]) => Promise<any> {\n    return function () {\n        // eslint-disable-next-line prefer-rest-params\n        const args = sliceArgs(arguments);\n        // @ts-expect-error we cannot know the type of `this`\n        context = context || this;\n        return new Promise<void | Record<string, any> | any[]>((resolve, _reject) => {\n            fn.apply(\n                context,\n                args.concat([\n                    function (result: any) {\n                        // decide on how we want to return the callback arguments\n                        switch (arguments.length) {\n                            case 0: // no arguments were given\n                                return resolve(); // Promise<void>\n                            case 1: // a single value (result) was returned\n                                return resolve(result);\n                            default: {\n                                // multiple values should be returned\n                                let ret: Record<string, any> | any[];\n                                // eslint-disable-next-line prefer-rest-params\n                                const extraArgs = sliceArgs(arguments, 0);\n                                if (returnArgNames && returnArgNames.length === extraArgs.length) {\n                                    // we can build an object\n                                    ret = {};\n                                    for (let i = 0; i < returnArgNames.length; i++) {\n                                        ret[returnArgNames[i]] = extraArgs[i];\n                                    }\n                                } else {\n                                    // we return the raw array\n                                    ret = extraArgs;\n                                }\n                                return resolve(ret);\n                            }\n                        }\n                    },\n                ]),\n            );\n        });\n    };\n}\n\nasync function _setQualityForStates(states: any, keys: string[], quality: number): Promise<void> {\n    for (const key of keys) {\n        try {\n            await states.setState(key, { ack: null, q: quality });\n        } catch {\n            // ignore\n        }\n    }\n}\n\nexport function setQualityForInstance(objects: any, states: any, namespace: string, q: number): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n        objects.getObjectView(\n            'system',\n            'state',\n            {\n                startkey: `${namespace}.`,\n                endkey: `${namespace}.\\u9999`,\n                include_docs: false,\n            },\n            (err: Error | null, _states?: GetObjectViewResult<ioBroker.StateObject>) => {\n                if (err) {\n                    reject(err);\n                } else {\n                    let keys: string[] = [];\n                    if (_states?.rows) {\n                        for (const row of _states.rows) {\n                            const id = row.id;\n                            // if instance still active, but a device is offline\n                            if (!(q & 0x10) && id.match(/\\.info\\.connection$/)) {\n                                continue;\n                            }\n                            keys.push(id);\n                        }\n                    }\n                    // read all values for IDs\n                    states.getStates(keys, async (_err: Error | null, values: Record<string, ioBroker.State>) => {\n                        // Get only states, that have ack = true\n                        keys = keys.filter((_id, i) => values[i] && values[i].ack);\n                        // update quality code of the states to new one\n                        await _setQualityForStates(states, keys, q);\n                        resolve();\n                    });\n                }\n            },\n        );\n    });\n}\n\n/**\n * Converts ioB pattern into regex.\n *\n * @param pattern - Regex string to use it in new RegExp(pattern)\n */\nexport function pattern2RegEx(pattern: string): string {\n    pattern = (pattern || '').toString();\n\n    if (!isValidPattern(pattern)) {\n        throw new Error(`The pattern \"${pattern}\" is not a valid ID pattern`);\n    }\n\n    const startsWithWildcard = pattern[0] === '*';\n    const endsWithWildcard = pattern[pattern.length - 1] === '*';\n\n    pattern = pattern.replace(/[-/\\\\^$+?.()|[\\]{}]/g, '\\\\$&').replace(/\\*/g, '.*');\n\n    return (startsWithWildcard ? '' : '^') + pattern + (endsWithWildcard ? '' : '$');\n}\n\n/**\n * Checks if a pattern is valid\n *\n * @param pattern\n * @pattern pattern to check for validity\n */\nexport function isValidPattern(pattern: string): boolean {\n    pattern = pattern.replace(/\\*/g, '');\n\n    return !FORBIDDEN_CHARS.test(pattern);\n}\n\n/**\n * Generates a stack trace that can be added to log outputs to trace their source\n *\n * @param [wrapperName] The wrapper function after which the stack trace should begin\n */\nfunction captureStackTrace(wrapperName: string): string {\n    if (typeof wrapperName !== 'string') {\n        wrapperName = 'captureStackTrace';\n    }\n\n    const ret = new Error();\n    if (ret.stack) {\n        let foundSelf = false;\n        const lines = ret.stack.split('\\n').filter(line => {\n            // keep all lines after this function's\n            if (foundSelf) {\n                return true;\n            }\n            if (line.includes(wrapperName)) {\n                foundSelf = true;\n            }\n            return false;\n        });\n        return lines.join('\\n');\n    }\n    return '';\n}\n\n/**\n * Appends the stack trace generated by `captureStackTrace` to the given string\n *\n * @param str - The string to append the stack trace to\n */\nexport function appendStackTrace(str: string): string {\n    // Convert anything that isn't a string into a string\n    if (typeof str !== 'string') {\n        str = String(str);\n    }\n    if (!str.endsWith('\\n')) {\n        str += '\\n';\n    }\n    return str + captureStackTrace('appendStackTrace');\n}\n\n/**\n * Encrypt the password/value with given key\n *\n * @param key - Secret key\n * @param value - value to encrypt\n */\nfunction encryptLegacy(key: string, value: string): string {\n    let result = '';\n    for (let i = 0; i < value.length; i++) {\n        result += String.fromCharCode(key[i % key.length].charCodeAt(0) ^ value.charCodeAt(i));\n    }\n    return result;\n}\n\n/**\n * Decrypt the password/value with given key\n *\n * @param key - Secret key\n * @param value - value to decrypt\n */\nfunction decryptLegacy(key: string, value: string): string {\n    let result = '';\n    for (let i = 0; i < value.length; i++) {\n        result += String.fromCharCode(key[i % key.length].charCodeAt(0) ^ value.charCodeAt(i));\n    }\n    return result;\n}\n\n/**\n * encrypts a value by a given key via AES-192-CBC\n *\n * @param key - Secret key\n * @param value - value to decrypt\n */\nexport function encrypt(key: string, value: string): string {\n    if (!/^[0-9a-f]{48}$/.test(key)) {\n        // key length is not matching for AES-192-CBC or key is no valid hex - fallback to old encryption\n        return encryptLegacy(key, value);\n    }\n\n    const iv = crypto.randomBytes(16);\n    const cipher = crypto.createCipheriv('aes-192-cbc', Buffer.from(key, 'hex'), iv);\n\n    const encrypted = Buffer.concat([cipher.update(value), cipher.final()]);\n\n    return `$/aes-192-cbc:${iv.toString('hex')}:${encrypted.toString('hex')}`;\n}\n\n/**\n * encrypts a value by a given key via AES-192-CBC\n *\n * @param key - Secret key\n * @param value - value to decrypt\n */\nexport function decrypt(key: string, value: string): string {\n    // if not encrypted as aes-192 or key not a valid 48-digit hex -> fallback\n    if (!value.startsWith(`$/aes-192-cbc:`) || !/^[0-9a-f]{48}$/.test(key)) {\n        return decryptLegacy(key, value);\n    }\n\n    const textParts = value.split(':', 3) as [algorithm: string, iv: string, encryptedText: string];\n    const iv = Buffer.from(textParts[1], 'hex');\n    const encryptedText = Buffer.from(textParts[2], 'hex');\n    const decipher = crypto.createDecipheriv('aes-192-cbc', Buffer.from(key, 'hex'), iv);\n\n    const decrypted = Buffer.concat([decipher.update(encryptedText), decipher.final()]);\n\n    return decrypted.toString();\n}\n\n/**\n * Tests whether the given variable is a real object and not an Array\n *\n * @param it The variable to test\n * @returns true if it is Record<string, any>\n */\nexport function isObject(it: unknown): it is Record<string, any> {\n    // This is necessary because:\n    // typeof null === 'object'\n    // typeof [] === 'object'\n    // [] instanceof Object === true\n    return Object.prototype.toString.call(it) === '[object Object]'; // this code is 25% faster than below one\n    // return it && typeof it === 'object' && !(it instanceof Array);\n}\n\n/**\n * Tests whether the given variable is really an Array\n *\n * @param it The variable to test\n */\nexport function isArray(it: unknown): it is any[] {\n    return Array.isArray(it);\n}\n\n/**\n * Measure the Node.js event loop lag and repeatedly call the provided callback function with the updated results\n *\n * @param ms The number of milliseconds for monitoring\n * @param cb Callback function to call for each new value\n */\nexport function measureEventLoopLag(ms: number, cb: (eventLoopLag?: number) => void): void {\n    let start = hrtime();\n\n    let timeout = setTimeout(check, ms);\n    timeout.unref();\n\n    function check(): void {\n        // workaround for https://github.com/joyent/node/issues/8364\n        clearTimeout(timeout);\n\n        // how much time has actually elapsed in the loop beyond what\n        // setTimeout says is supposed to happen. we use setTimeout to\n        // cover multiple iterations of the event loop, getting a larger\n        // sample of what the process is working on.\n        const t = hrtime();\n\n        // we use Math.max to handle a case where timers are running efficiently\n        // and our callback executes earlier than `ms` due to how timers are\n        // implemented. this is ok. it means we're healthy.\n        cb && cb(Math.max(0, t - start - ms));\n        start = t;\n\n        timeout = setTimeout(check, ms);\n        timeout.unref();\n    }\n\n    function hrtime(): number {\n        const t = process.hrtime();\n        return t[0] * 1e3 + t[1] / 1e6;\n    }\n}\n\n/**\n * This function convert state values by read and write of aliases. Function is synchronous.\n * On errors, null is returned instead\n *\n * @param options\n */\nexport function formatAliasValue(options: FormatAliasValueOptions): ioBroker.State | null {\n    const { sourceCommon, sourceId, targetCommon, targetId, state, logger } = options;\n    const logNamespace = options.logNamespace ? `${options.logNamespace} ` : '';\n\n    if (!state) {\n        return null;\n    }\n    if (state.val === undefined) {\n        state.val = null;\n        return state;\n    }\n\n    if (targetCommon?.alias?.read) {\n        if (!sourceCommon) {\n            logger.error(\n                `${logNamespace}source in \"${targetId}\" does not exist for \"read\" function: \"${targetCommon.alias.read}\"`,\n            );\n            return null;\n        }\n        try {\n            state.val = applyAliasTransformer({\n                transformer: targetCommon.alias.read,\n                firstCommon: targetCommon,\n                secondCommon: sourceCommon,\n                isRead: true,\n                state,\n            });\n        } catch (e) {\n            logger.error(\n                `${logNamespace}Invalid read function for \"${targetId}\": \"${targetCommon.alias.read}\" => ${e.message}`,\n            );\n            return null;\n        }\n    }\n\n    if (sourceCommon?.alias?.write) {\n        if (!targetCommon) {\n            logger.error(\n                `${logNamespace}target for \"${sourceId}\" does not exist for \"write\" function: \"${sourceCommon.alias.write}\"`,\n            );\n            return null;\n        }\n        try {\n            state.val = applyAliasTransformer({\n                transformer: sourceCommon.alias.write,\n                firstCommon: sourceCommon,\n                secondCommon: targetCommon,\n                isRead: false,\n                state,\n            });\n        } catch (e) {\n            logger.error(\n                `${logNamespace}Invalid write function for \"${sourceId}\": \"${sourceCommon.alias.write}\" => ${e.message}`,\n            );\n            return null;\n        }\n    }\n\n    state.val = applyAliasConvenienceConversion({ state, targetCommon });\n    state.val = applyAliasAutoScaling({ state, sourceCommon, targetCommon });\n\n    return state;\n}\n\n/**\n * remove given id from all enums\n *\n * @param objects object to access objects db\n * @param id the object id which will be deleted from enums\n * @param allEnums objects with all enums to use - if not provided all enums will be queried\n * @returns Promise All objects are tried to be updated - reject will happen as soon as one fails with the error of the first fail\n */\nexport async function removeIdFromAllEnums(objects: any, id: string, allEnums?: Record<string, any>): Promise<void> {\n    if (!allEnums) {\n        allEnums = await getAllEnums(objects);\n    }\n\n    let error = null;\n    for (const [enumId, enumObj] of Object.entries(allEnums)) {\n        const idx = enumObj.common.members ? enumObj.common.members.indexOf(id) : -1;\n        if (idx !== -1) {\n            // the id is in the enum now we have to remove it\n            enumObj.common.members.splice(idx, 1);\n            try {\n                await objects.setObjectAsync(enumId, enumObj);\n                // update cache directly to prevent race conditions when sending many delete in a short time\n                allEnums[enumId] = enumObj;\n            } catch (err) {\n                if (!error) {\n                    error = err;\n                }\n            }\n        }\n    }\n    if (error) {\n        throw error;\n    }\n}\n\n/**\n * Parses dependencies to standardized object of form\n *\n * @param dependencies dependencies array or single dependency\n * @returns parsedDeps parsed dependencies\n */\nexport function parseDependencies(\n    dependencies: string[] | Record<string, string>[] | string | Record<string, string> | undefined,\n): Record<string, string> {\n    let adapters: Record<string, string> = {};\n    if (Array.isArray(dependencies)) {\n        dependencies.forEach(rule => {\n            if (typeof rule === 'string') {\n                // No version given, all are okay\n                adapters[rule] = '*';\n            } else if (isObject(rule)) {\n                // can be if an object containing a single adapter or multiple\n                Object.keys(rule)\n                    .filter(adapter => !adapters[adapter])\n                    .forEach(adapter => (adapters[adapter] = rule[adapter]));\n            }\n        });\n    } else if (typeof dependencies === 'string') {\n        // it's a single string without version requirement\n        adapters[dependencies] = '*';\n    } else if (isObject(dependencies)) {\n        // if dependencies is already an object, just use it\n        adapters = dependencies;\n    }\n    return adapters;\n}\n\n/**\n * Validates types of `obj.common` properties and `object.type`, if invalid types are used, an error is thrown.\n * If attributes of `obj.common` are not provided, no error is thrown. obj.type has to be there and has to be valid.\n *\n * @param obj an object which will be validated\n * @param extend (optional) if true checks allow more optional cases for extendObject calls\n * @throws Error if a property has the wrong type or `obj.type` is non-existing\n */\nexport function validateGeneralObjectProperties(obj: any, extend?: boolean): void {\n    if (!obj || (obj.type === undefined && !extend)) {\n        throw new Error(`obj.type has to exist`);\n    }\n\n    if (obj.type !== undefined && typeof obj.type !== 'string') {\n        throw new Error(`obj.type has an invalid type! Expected \"string\", received \"${typeof obj.type}\"`);\n    }\n\n    if (obj.native !== undefined && !isObject(obj.native)) {\n        throw new Error(`obj.native has an invalid type! Expected a \"real object\", received \"${typeof obj.native}\"`);\n    }\n\n    const allowedObjectTypes: ioBroker.ObjectType[] = [\n        'state',\n        'channel',\n        'device',\n        'enum',\n        'host',\n        'adapter',\n        'instance',\n        'meta',\n        'config',\n        'script',\n        'user',\n        'group',\n        'chart',\n        'folder',\n        'schedule',\n        'design',\n    ];\n\n    if (obj.type !== undefined && !allowedObjectTypes.includes(obj.type)) {\n        throw new Error(\n            `obj.type has an invalid value (${obj.type}) but has to be one of ${allowedObjectTypes.join(', ')}`,\n        );\n    }\n\n    // obj.common is optional in general check\n    if (!obj.common) {\n        return;\n    }\n\n    if (obj.common.name !== undefined && typeof obj.common.name !== 'string' && typeof obj.common.name !== 'object') {\n        throw new Error(\n            `obj.common.name has an invalid type! Expected \"string\" or \"object\", received \"${typeof obj.common.name}\"`,\n        );\n    } else if (['adapter'].includes(obj.type) && typeof obj.common.name !== 'string') {\n        // TODO: we need this for group/user too, but have to solve problems described in #1266\n        // for some types, name needs to be a unique string\n        throw new Error(`obj.common.name has an invalid type! Expected \"string\", received \"${typeof obj.common.name}\"`);\n    }\n\n    if (obj.common.type !== undefined) {\n        if (typeof obj.common.type !== 'string') {\n            throw new Error(\n                `obj.common.type has an invalid type! Expected \"string\", received \"${typeof obj.common.type}\"`,\n            );\n        }\n\n        if (obj.type === 'state') {\n            // if an object type indicates a state, check that `common.type` matches\n            const allowedStateTypes = ['number', 'string', 'boolean', 'array', 'object', 'mixed', 'json'];\n            if (!allowedStateTypes.includes(obj.common.type)) {\n                throw new Error(\n                    `obj.common.type has an invalid value (${\n                        obj.common.type\n                    }) but has to be one of ${allowedStateTypes.join(', ')}`,\n                );\n            }\n\n            // ensure that min max only exists for common.type number and is number itself\n            if (obj.common.min !== undefined) {\n                if (typeof obj.common.min !== 'number') {\n                    throw new Error(\n                        `obj.common.min has an invalid type! Expected \"number\", received \"${typeof obj.common.min}\"`,\n                    );\n                }\n\n                if (obj.common.type !== 'number' && obj.common.type !== 'mixed') {\n                    throw new Error(\n                        `obj.common.min is only allowed on obj.common.type \"number\" or \"mixed\", received \"${obj.common.type}\"`,\n                    );\n                }\n            }\n\n            if (obj.common.max !== undefined) {\n                if (typeof obj.common.max !== 'number') {\n                    throw new Error(\n                        `obj.common.max has an invalid type! Expected \"number\", received \"${typeof obj.common.max}\"`,\n                    );\n                }\n\n                if (obj.common.type !== 'number' && obj.common.type !== 'mixed') {\n                    throw new Error(\n                        `obj.common.max is only allowed on obj.common.type \"number\" or \"mixed\", received \"${obj.common.type}\"`,\n                    );\n                }\n\n                if (obj.common.min !== undefined && obj.common.min > obj.common.max) {\n                    throw new Error(\n                        `obj.common.min (${obj.common.min}) needs to be less than or equal to obj.common.max (${obj.common.max})`,\n                    );\n                }\n            }\n\n            // ensure, that default value has correct type\n            if (obj.common.def !== undefined && obj.common.def !== null) {\n                // else do what strictObjectChecks does for val\n                if (\n                    !(\n                        (obj.common.type === 'mixed' && typeof obj.common.def !== 'object') ||\n                        (obj.common.type !== 'object' && obj.common.type === typeof obj.common.def) ||\n                        (obj.common.type === 'array' && typeof obj.common.def === 'string') ||\n                        (obj.common.type === 'json' && typeof obj.common.def === 'string') ||\n                        (obj.common.type === 'object' && typeof obj.common.def === 'string')\n                    )\n                ) {\n                    // types can be 'number', 'string', 'boolean', 'array', 'object', 'mixed', 'json';\n                    // 'array', 'object', 'json' need to be string\n                    if (['object', 'json', 'array'].includes(obj.common.type)) {\n                        throw new Error(\n                            `Default value has to be stringified but received type \"${typeof obj.common.def}\"`,\n                        );\n                    } else {\n                        throw new Error(\n                            `Default value has to be ${\n                                obj.common.type === 'mixed'\n                                    ? `one of type \"string\", \"number\", \"boolean\"`\n                                    : `type \"${obj.common.type}\"`\n                            } but received type \"${typeof obj.common.def}\"`,\n                        );\n                    }\n                }\n            }\n        }\n    }\n\n    if (obj.common.read !== undefined && typeof obj.common.read !== 'boolean') {\n        throw new Error(\n            `obj.common.read has an invalid type! Expected \"boolean\", received \"${typeof obj.common.read}\"`,\n        );\n    }\n\n    if (obj.common.write !== undefined && typeof obj.common.write !== 'boolean') {\n        throw new Error(\n            `obj.common.write has an invalid type! Expected \"boolean\", received \"${typeof obj.common.write}\"`,\n        );\n    }\n\n    if (obj.common.role !== undefined && typeof obj.common.role !== 'string') {\n        throw new Error(`obj.common.role has an invalid type! Expected \"string\", received \"${typeof obj.common.role}\"`);\n    }\n\n    if (obj.common.desc !== undefined && typeof obj.common.desc !== 'string' && typeof obj.common.desc !== 'object') {\n        throw new Error(\n            `obj.common.desc has an invalid type! Expected \"string\" or \"object\", received \"${typeof obj.common.desc}\"`,\n        );\n    }\n\n    if (\n        obj.type === 'state' &&\n        obj.common.custom !== undefined &&\n        obj.common.custom !== null &&\n        !isObject(obj.common.custom)\n    ) {\n        throw new Error(\n            `obj.common.custom has an invalid type! Expected \"object\", received \"${typeof obj.common.custom}\"`,\n        );\n    }\n\n    // common.states needs to be a real object or an array\n    if (\n        obj.common.states !== null && // we allow null for deletion TODO: implement https://github.com/ioBroker/ioBroker.js-controller/issues/1735\n        obj.common.states !== undefined &&\n        !isObject(obj.common.states) &&\n        !Array.isArray(obj.common.states)\n    ) {\n        throw new Error(\n            `obj.common.states has an invalid type! Expected \"object\", received \"${typeof obj.common.states}\"`,\n        );\n    }\n}\n\n/**\n * get all instances of all adapters in the list\n *\n * @param adapters list of adapter names to get instances for\n * @param objects class redis objects\n * @returns array of IDs\n */\nexport async function getAllInstances(adapters: string[], objects: any): Promise<string[]> {\n    const instances: string[] = [];\n\n    for (let i = 0; i < adapters.length; i++) {\n        if (!adapters[i]) {\n            continue;\n        }\n        if (!adapters[i].includes('.')) {\n            const inst = await getInstances(adapters[i], objects, false);\n            for (let j = 0; j < inst.length; j++) {\n                if (!instances.includes(inst[j])) {\n                    instances.push(inst[j]);\n                }\n            }\n        } else {\n            if (!instances.includes(adapters[i])) {\n                instances.push(adapters[i]);\n            }\n        }\n    }\n\n    return instances;\n}\n\n/** Just a helper, as we have no access to DB package and the specific types here */\ntype GetObjectViewResult<TObject extends ioBroker.AnyObject = ioBroker.Object> = Awaited<\n    ioBroker.GetObjectViewPromise<TObject>\n>;\n\n/**\n * Get all existing enums\n *\n * @param objects - objects db\n * @returns Promise\n */\nexport async function getAllEnums(objects: any): Promise<Record<string, ioBroker.EnumObject>> {\n    const allEnums: Record<string, any> = {};\n    const res: GetObjectViewResult<ioBroker.EnumObject> = await objects.getObjectViewAsync('system', 'enum', {\n        startkey: 'enum.',\n        endkey: 'enum.\\u9999',\n    });\n    if (res?.rows) {\n        for (const row of res.rows) {\n            allEnums[row.id] = row.value;\n        }\n    }\n\n    return allEnums;\n}\n\n/**\n * get async all instances of one adapter\n *\n * @param adapter name of the adapter\n * @param objects objects DB\n * @param withObjects return objects instead of only ids\n */\nexport async function getInstances<TWithObjects extends boolean>(\n    adapter: string,\n    objects: any,\n    withObjects: TWithObjects,\n): Promise<TWithObjects extends true ? ioBroker.InstanceObject[] : ioBroker.ObjectIDs.Instance[]> {\n    const arr = await objects.getObjectListAsync({\n        startkey: `system.adapter.${adapter}.`,\n        endkey: `system.adapter.${adapter}.\\u9999`,\n    });\n\n    const instances = [];\n\n    if (arr?.rows) {\n        for (const row of arr.rows) {\n            if (row.value.type !== 'instance') {\n                continue;\n            }\n            if (withObjects) {\n                instances.push(row.value);\n            } else {\n                instances.push(row.value._id);\n            }\n        }\n    }\n\n    return instances;\n}\n\n/**\n * Executes a command asynchronously. On success, the promise resolves with stdout and stderr.\n * On error, the promise rejects with the exit code or signal, as well as stdout and stderr.\n *\n * @param command The command to execute\n * @param execOptions The options for child_process.exec\n * @returns child process promise\n */\nexport function execAsync(command: string, execOptions?: ExecOptions): ChildProcessPromise {\n    const defaultOptions = {\n        // we do not want to show the node.js window on Windows\n        windowsHide: true,\n        // And we want to capture stdout/stderr\n        encoding: 'utf8',\n    };\n\n    return cpExecAsync(command, { ...defaultOptions, ...execOptions });\n}\n\n/**\n * Takes input from one stream and writes it to another as soon as a complete line was read.\n *\n * @param input The stream to read from\n * @param output The stream to write into\n */\nexport function pipeLinewise(input: NodeJS.ReadableStream, output: NodeJS.WritableStream): void {\n    const rl = createInterface({\n        input,\n        crlfDelay: Infinity,\n    });\n    rl.on('line', line => {\n        try {\n            output.write(line + os.EOL);\n        } catch {\n            // ignore\n        }\n    });\n    rl.on('error', () => {\n        /** Ignore Errors */\n    });\n}\n\n/**\n * Checks if an adapter is an ESM module or CJS\n *\n * @param adapter name of the adapter like hm-rpc\n */\nexport async function isAdapterEsmModule(adapter: string): Promise<boolean> {\n    const adapterDir = getAdapterDir(adapter);\n    if (!adapterDir) {\n        throw new Error(`Could not find adapter dir of ${adapter}`);\n    }\n\n    const packJson = await fs.readJSON(path.join(adapterDir, 'package.json'), { encoding: 'utf-8' });\n\n    return packJson.type === 'module';\n}\n\n/**\n * Find the adapter main file as full path\n *\n * @param adapter - adapter name of the adapter, e.g., hm-rpc\n * @returns full file name\n */\nexport async function resolveAdapterMainFile(adapter: string): Promise<string> {\n    const adapterDir = getAdapterDir(adapter);\n    if (!adapterDir) {\n        throw new Error(`Could not find adapter dir of ${adapter}`);\n    }\n\n    const possibleMainFiles = ['main.js', `${adapter}.js`];\n\n    // Add package.json -> main as the 2nd choice\n    try {\n        const pack = JSON.parse(await fs.readFile(path.join(adapterDir, 'package.json'), 'utf8'));\n        if (pack && typeof pack.main === 'string') {\n            possibleMainFiles.unshift(pack.main);\n        }\n    } catch {\n        // Ignore, we have fallback solutions\n    }\n\n    // Add io-package.json -> common.main as the preferred choice\n    try {\n        const ioPack = JSON.parse(await fs.readFile(path.join(adapterDir, 'io-package.json'), 'utf8'));\n        if (ioPack && ioPack.common && typeof ioPack.common.main === 'string') {\n            possibleMainFiles.unshift(ioPack.common.main);\n        }\n    } catch {\n        // Ignore, we have fallback solutions\n    }\n\n    // Try all possible main files\n    for (const mainFile of possibleMainFiles) {\n        const fullFileName = path.join(adapterDir, mainFile);\n        if (await fs.pathExists(fullFileName)) {\n            return fullFileName;\n        }\n    }\n\n    throw new Error(`Could not find main file of ${adapter}`);\n}\n\n/**\n * Returns the default nodeArgs required to execute the main file, e.g., transpile hooks for TypeScript\n *\n * @param mainFile\n * @returns default node args for cli\n */\nexport function getDefaultNodeArgs(mainFile: string): string[] {\n    const ret: string[] = [];\n    // Support executing TypeScript files directly\n    if (mainFile.endsWith('.ts')) {\n        ret.push('-r', '@alcalzone/esbuild-register');\n    }\n    // If JS-controller was started with --preserve-symlinks, do the same for adapters\n    if (process.execArgv.includes('--preserve-symlinks')) {\n        ret.push('--preserve-symlinks-main', '--preserve-symlinks');\n    }\n    return ret;\n}\n\n/**\n * Returns the default paths used to resolve modules using `require.resolve()`\n *\n * @param callerModule The module that wants to resolve another module\n */\nexport function getDefaultRequireResolvePaths(callerModule: NodeModule): string[] {\n    const ret: string[] = [\n        // This is the default for require.resolve\n        ...callerModule.paths,\n    ];\n    // If JS-controller was started with --preserve-symlinks, start looking where the process entry point was\n    if (process.execArgv.includes('--preserve-symlinks') && require.main) {\n        ret.unshift(...require.main.paths);\n    }\n    return ret;\n}\n\n/** This is used for the short GitHub URL format that NPM accepts (<githubname>/<githubrepo>[#<commit-ish>]) */\nconst shortGithubUrlRegex = /^(?<user>[^/]+)\\/(?<repo>[^#]+)(?:#(?<commit>.+))?$/;\n\n/**\n * Tests if the given URL matches the format <githubname>/<githubrepo>[#<commit-ish>]\n *\n * @param url The URL to parse\n */\nexport function isShortGithubUrl(url: string): boolean {\n    return shortGithubUrlRegex.test(url);\n}\n\nexport interface ParsedGithubUrl {\n    user: string;\n    repo: string;\n    commit?: string;\n}\n\n/**\n * Tries to parse a URL in the format <githubname>/<githubrepo>[#<commit-ish>] into its separate parts\n *\n * @param url The URL to parse\n */\nexport function parseShortGithubUrl(url: string): ParsedGithubUrl | null {\n    const match = shortGithubUrlRegex.exec(url);\n    if (!match || !match.groups) {\n        return null;\n    }\n    return {\n        user: match.groups.user,\n        repo: match.groups.repo,\n        commit: match.groups.commit,\n    };\n}\n\n/** This is used to parse the pathname of a GitHub URL */\nconst githubPathnameRegex =\n    /^\\/(?<user>[^/]+)\\/(?<repo>[^/]*?)(?:\\.git)?(?:\\/(?:tree|tarball|archive)\\/(?<commit>.*?)(?:\\.(?:zip|gz|tar\\.gz))?)?$/;\n\n/**\n * Tests if the given pathname matches the format /<githubname>/<githubrepo>[.git][/<tarball|tree|archive>/<commit-ish>[.zip|.gz]]\n *\n * @param pathname The pathname part of a GitHub URL\n */\nexport function isGithubPathname(pathname: string): boolean {\n    return githubPathnameRegex.test(pathname);\n}\n\n/**\n * Tries to a GitHub pathname format /<githubname>/<githubrepo>[.git][/<tarball|tree|archive>/<commit-ish>[.zip|.gz|.tar.gz]] into its separate parts\n *\n * @param pathname The pathname part of a GitHub URL\n */\nexport function parseGithubPathname(pathname: string): ParsedGithubUrl | null {\n    const match = githubPathnameRegex.exec(pathname);\n    if (!match || !match.groups) {\n        return null;\n    }\n    return {\n        user: match.groups.user,\n        repo: match.groups.repo,\n        commit: match.groups.commit,\n    };\n}\n\n/**\n * Removes properties which are given by preserve\n *\n * @param preserve - object which has true entries (or array of selected attributes) for all attributes that should be removed from currObj\n * @param oldObj - old object\n * @param newObj - new object\n */\nexport function removePreservedProperties(\n    preserve: Record<string, any>,\n    oldObj: Record<string, any>,\n    newObj: Record<string, any>,\n): void {\n    for (const prop of Object.keys(preserve)) {\n        if (isObject(preserve[prop]) && isObject(newObj[prop])) {\n            // we have to go one step deeper\n            removePreservedProperties(preserve[prop], oldObj[prop], newObj[prop]);\n        } else if (newObj && newObj[prop] !== undefined && oldObj && oldObj[prop] !== undefined) {\n            // we only need to remove something if it's in the old object and in the new one\n            if (typeof preserve[prop] === 'boolean') {\n                delete newObj[prop];\n            } else if (Array.isArray(preserve[prop])) {\n                // array, only rm selected subattributes instead of whole attribute\n                for (const rmProp of preserve[prop]) {\n                    if (oldObj[prop][rmProp] !== undefined && newObj[prop][rmProp] !== undefined) {\n                        // only delete if conflicting\n                        delete newObj[prop][rmProp];\n                    }\n                }\n            }\n        }\n    }\n}\n\n/**\n * Returns the array of system.adapter.<namespace>.* objects which are created for every instance\n *\n * @param namespace - adapter namespace + id, e.g., hm-rpc.0\n */\nexport function getInstanceIndicatorObjects(namespace: string): ioBroker.StateObject[] {\n    const id = `system.adapter.${namespace}`;\n\n    return [\n        {\n            _id: `${id}.alive`,\n            type: 'state',\n            common: {\n                name: `${namespace} alive`,\n                type: 'boolean',\n                read: true,\n                write: true,\n                role: 'indicator.state',\n            },\n            native: {},\n        },\n        {\n            _id: `${id}.connected`,\n            type: 'state',\n            common: {\n                name: `${namespace} is connected`,\n                type: 'boolean',\n                read: true,\n                write: false,\n                role: 'indicator.state',\n            },\n            native: {},\n        },\n        {\n            _id: `${id}.compactMode`,\n            type: 'state',\n            common: {\n                name: `${namespace}.compactMode`,\n                type: 'boolean',\n                read: true,\n                write: false,\n                role: 'indicator.state',\n            },\n            native: {},\n        },\n        {\n            _id: `${id}.cpu`,\n            type: 'state',\n            common: {\n                name: `${namespace}.cpu`,\n                type: 'number',\n                read: true,\n                write: false,\n                role: 'indicator.state',\n                unit: '% of one core',\n            },\n            native: {},\n        },\n        {\n            _id: `${id}.cputime`,\n            type: 'state',\n            common: {\n                name: `${namespace}.cputime`,\n                type: 'number',\n                read: true,\n                write: false,\n                role: 'indicator.state',\n                unit: 'seconds',\n            },\n            native: {},\n        },\n        {\n            _id: `${id}.memHeapUsed`,\n            type: 'state',\n            common: {\n                name: `${namespace} heap actually Used`,\n                type: 'number',\n                read: true,\n                write: false,\n                role: 'indicator.state',\n                unit: 'MB',\n            },\n            native: {},\n        },\n        {\n            _id: `${id}.memHeapTotal`,\n            type: 'state',\n            common: {\n                name: `${namespace} total Size of the Heap`,\n                read: true,\n                write: false,\n                type: 'number',\n                role: 'indicator.state',\n                unit: 'MB',\n            },\n            native: {},\n        },\n        {\n            _id: `${id}.memRss`,\n            type: 'state',\n            common: {\n                name: `${namespace} resident Set Size`,\n                desc: 'Resident set size',\n                read: true,\n                write: false,\n                type: 'number',\n                role: 'indicator.state',\n                unit: 'MB',\n            },\n            native: {},\n        },\n        {\n            _id: `${id}.uptime`,\n            type: 'state',\n            common: {\n                name: `${namespace} uptime`,\n                type: 'number',\n                read: true,\n                write: false,\n                role: 'indicator.state',\n                unit: 'seconds',\n            },\n            native: {},\n        },\n        {\n            _id: `${id}.inputCount`,\n            type: 'state',\n            common: {\n                name: `${namespace} events input counter`,\n                desc: \"State's inputs in 15 seconds\",\n                type: 'number',\n                read: true,\n                write: false,\n                role: 'state',\n                unit: 'events/15 seconds',\n            },\n            native: {},\n        },\n        {\n            _id: `${id}.outputCount`,\n            type: 'state',\n            common: {\n                name: `${namespace} events output counter`,\n                desc: \"State's outputs in 15 seconds\",\n                type: 'number',\n                read: true,\n                write: false,\n                role: 'state',\n                unit: 'events/15 seconds',\n            },\n            native: {},\n        },\n        {\n            _id: `${id}.eventLoopLag`,\n            type: 'state',\n            common: {\n                name: `${namespace} Node.js event loop lag`,\n                desc: 'Node.js event loop lag in ms averaged over 15 seconds',\n                type: 'number',\n                read: true,\n                write: false,\n                role: 'state',\n                unit: 'ms',\n            },\n            native: {},\n        },\n        {\n            _id: `${id}.sigKill`,\n            type: 'state',\n            common: {\n                name: `${namespace} kill signal`,\n                type: 'number',\n                read: true,\n                write: false,\n                desc: 'Process id that must survive. All other IDs must terminate itself',\n                role: 'state',\n            },\n            native: {},\n        },\n        {\n            _id: `${id}.logLevel`,\n            type: 'state',\n            common: {\n                name: `${namespace} loglevel`,\n                type: 'string',\n                read: true,\n                write: true,\n                desc: 'Loglevel of the adapter. Will be set on start with defined value but can be overridden during runtime',\n                role: 'state',\n            },\n            native: {},\n        },\n    ];\n}\n\nexport type InternalLogger = Omit<ioBroker.Logger, 'level'>;\n\nexport function getLogger(log: any): InternalLogger {\n    if (!log) {\n        log = {\n            silly: function (_msg: string) {\n                /*console.log(msg);*/\n            },\n            debug: function (_msg: string) {\n                /*console.log(msg);*/\n            },\n            info: function (_msg: string) {\n                /*console.log(msg);*/\n            },\n            warn: function (msg: string) {\n                console.log(msg);\n            },\n            error: function (msg: string) {\n                console.log(msg);\n            },\n        };\n    } else if (!log.silly) {\n        log.silly = log.debug;\n    }\n    return log;\n}\n\n/**\n * Set capabilities of the given executable on Linux systems\n *\n * @param execPath - path to the executable for node you can determine it via process.execPath\n * @param capabilities - capabilities to set, e.g. ['cap_net_admin', 'cap_net_bind_service']\n * @param modeEffective - add effective mode\n * @param modePermitted - add permitted mode\n * @param modeInherited - add inherited mode\n */\nexport async function setExecutableCapabilities(\n    execPath: string,\n    capabilities: string[],\n    modeEffective?: boolean,\n    modePermitted?: boolean,\n    modeInherited?: boolean,\n): Promise<void> {\n    // if not linux do nothing and silent exit\n    if (os.platform() !== 'linux') {\n        return;\n    }\n\n    // if Docker and Admin Capabilities should be set check if we are allowed to do that\n    if (isDocker() && capabilities.includes('cap_net_admin')) {\n        try {\n            const systemCaps = fs.readFileSync(`/proc/${process.pid}/status`, 'utf-8');\n            const capBnd = systemCaps.match(/^CapBnd:\\s(.+)$/m);\n            // We found a value in CapBnd line\n            if (capBnd && capBnd[1]) {\n                const { stdout } = await execAsync(`capsh --decode=${capBnd[1]}`);\n                // Stdout looks like \"0x00000000a80425fb=cap_chown,cap_dac_override,...\"\n                if (typeof stdout === 'string' && stdout.startsWith(`0x${capBnd[1]}=`)) {\n                    const capBndArr = stdout.substring(capBnd[1].length + 3).split(',');\n                    // if Admin Capability is not included in System Capabilities, we remove it from an array\n                    if (!capBndArr.includes('cap_net_admin')) {\n                        capabilities = capabilities.filter(c => c !== 'cap_net_admin');\n                    }\n                }\n            }\n        } catch {\n            // Ok, we could not find it out, so update Caps but better without Admin Capability\n            capabilities = capabilities.filter(c => c !== 'cap_net_admin');\n        }\n    }\n\n    if (capabilities.length) {\n        let modes = '';\n        const capabilitiesStr = capabilities.join(',');\n\n        if (modeEffective) {\n            modes += 'e';\n        }\n\n        if (modePermitted) {\n            modes += 'p';\n        }\n\n        if (modeInherited) {\n            modes += 'i';\n        }\n\n        if (modes.length) {\n            modes = `+${modes}`;\n        }\n\n        // if this throws, it needs to be caught outside\n        await execAsync(`sudo setcap ${capabilitiesStr}${modes} ${execPath}`);\n    }\n}\n\n/**\n * Requests the licenses from ioBroker.net\n *\n * @param login Login for ioBroker.net\n * @param password Decoded password for ioBroker.net\n * @returns array of all licenses stored on iobroker.net\n */\nasync function _readLicenses(login: string, password: string): Promise<any[]> {\n    const config = {\n        headers: { Authorization: `Basic ${Buffer.from(`${login}:${password}`).toString('base64')}` },\n        timeout: 4_000,\n    };\n\n    try {\n        const response = await axios.get(`https://iobroker.net:3001/api/v1/licenses`, config);\n        if (response.data?.length) {\n            const now = Date.now();\n            response.data = response.data.filter(\n                (license: { validTill: string | number }) =>\n                    !license.validTill ||\n                    license.validTill === '0000-00-00 00:00:00' ||\n                    new Date(license.validTill).getTime() > now,\n            );\n        }\n\n        return response.data;\n    } catch (err) {\n        if (err.response) {\n            throw new Error((err.response.data && err.response.data.error) || err.response.data || err.response.status);\n        } else if (err.request) {\n            throw new Error('no response');\n        } else {\n            throw err;\n        }\n    }\n}\n\n/**\n * Reads the licenses from iobroker.net\n * Reads the licenses from iobroker.net and if no login/password provided stores it in `system.licenses`\n *\n * @param objects Object store instance\n * @param login Login for ioBroker.net\n * @param password Decoded password for ioBroker.net\n * @returns array of all licenses stored on iobroker.net\n */\nexport async function updateLicenses(objects: any, login: string, password: string): Promise<any[]> {\n    // if login and password provided in the message, just try to read without saving it in system.licenses\n    if (login && password) {\n        return _readLicenses(login, password);\n    }\n    // get actual object\n    const systemLicenses: ioBroker.Object = await objects.getObjectAsync('system.licenses');\n    // If password and login exist\n    if (systemLicenses && systemLicenses.native && systemLicenses.native.password && systemLicenses.native.login) {\n        try {\n            // get the secret to decode the password\n            const systemConfig: ioBroker.Object = await objects.getObjectAsync('system.config');\n\n            // decode the password\n            let password;\n            try {\n                password = decrypt(systemConfig.native.secret, systemLicenses.native.password);\n            } catch (err) {\n                throw new Error(`Cannot decode password: ${err.message}`);\n            }\n\n            // read licenses from iobroker.net\n            const licenses = await _readLicenses(systemLicenses.native.login, password);\n            // save licenses to system.licenses and remember the time.\n            // merge the information together\n            const oldLicenses: any[] = systemLicenses.native.licenses || [];\n            systemLicenses.native.licenses = licenses;\n            oldLicenses.forEach(oldLicense => {\n                if (oldLicense.usedBy) {\n                    const newLicense = licenses.find(item => item.json === oldLicense.json);\n                    if (newLicense) {\n                        newLicense.usedBy = oldLicense.usedBy;\n                    }\n                }\n            });\n\n            systemLicenses.native.readTime = new Date().toISOString();\n\n            // update read time\n            await objects.setObjectAsync('system.licenses', systemLicenses);\n            return licenses;\n        } catch (err) {\n            // if password is invalid\n            if (err.message.includes('Authentication required') || err.message.includes('Cannot decode password:')) {\n                // clear existing licenses if exist\n                if (\n                    systemLicenses &&\n                    systemLicenses.native &&\n                    systemLicenses.native.licenses &&\n                    systemLicenses.native.licenses.length\n                ) {\n                    systemLicenses.native.licenses = [];\n                    systemLicenses.native.readTime = new Date().toISOString();\n                    await objects.setObjectAsync('system.licenses', systemLicenses);\n                }\n            }\n\n            throw err;\n        }\n    } else {\n        // if password or login are empty => clear existing licenses if exist\n        if (\n            systemLicenses &&\n            systemLicenses.native &&\n            systemLicenses.native.licenses &&\n            systemLicenses.native.licenses.length\n        ) {\n            systemLicenses.native.licenses = [];\n            systemLicenses.native.readTime = new Date().toISOString();\n            await objects.setObjectAsync('system.licenses', systemLicenses);\n        }\n        throw new Error('No password or login');\n    }\n}\n\nexport interface GZipFileOptions {\n    // Delete the input file after compression. Default: false.\n    deleteInput?: boolean;\n}\n/**\n * Compresses an input file using GZip and writes it somewhere else\n *\n * @param inputFilename The filename of the input file that should be gzipped\n * @param outputFilename The filename of the output file where the gzipped content should be written to\n * @param options Options for the compression\n */\nexport function compressFileGZip(\n    inputFilename: string,\n    outputFilename: string,\n    options: GZipFileOptions = {},\n): Promise<void> {\n    const { deleteInput = false } = options;\n\n    return new Promise((resolve, reject) => {\n        const input = fs.createReadStream(inputFilename);\n        const output = fs.createWriteStream(outputFilename);\n        const compress = zlib.createGzip();\n        input.on('error', err => {\n            reject(err);\n        });\n        output.on('error', err => {\n            reject(err);\n        });\n        compress.on('error', err => {\n            reject(err);\n        });\n        output.on('close', () => {\n            if (deleteInput) {\n                try {\n                    fs.unlinkSync(inputFilename);\n                } catch {\n                    // Ignore\n                }\n            }\n            resolve();\n        });\n\n        input.pipe(compress).pipe(output);\n    });\n}\n\nexport interface DataDirValidation {\n    /** if data directory is valid */\n    valid: boolean;\n    /** absolute path it resolves too */\n    path: string;\n    /** reason of rejection */\n    reason: string;\n}\n\n/**\n * Validate if the dir, is a valid dataDir\n * Data dirs in node_modules are not allowed, note that dataDirs are relative to js-controller dir or absolute\n *\n * @param dataDir dataDir to check\n */\nexport function validateDataDir(dataDir: string): DataDirValidation {\n    if (!path.isAbsolute(dataDir)) {\n        dataDir = path.normalize(path.join(getControllerDir(), dataDir));\n    }\n\n    const pathParts = dataDir.split(path.sep);\n\n    const isValid = !pathParts.includes('node_modules');\n\n    return {\n        valid: isValid,\n        path: dataDir,\n        reason: isValid ? 'Valid data directory' : 'Data directory is not allowed to point into node_modules folder',\n    };\n}\n\n/**\n * If an array is passed it will be stringified, else the parameter is returned\n *\n * @param maybeArr parameter which will be stringified if it is an array\n */\nexport function maybeArrayToString<T>(maybeArr: T): T extends any[] ? string : T {\n    if (Array.isArray(maybeArr)) {\n        // @ts-expect-error https://github.com/microsoft/TypeScript/issues/33912\n        return JSON.stringify(maybeArr);\n    }\n\n    // @ts-expect-error https://github.com/microsoft/TypeScript/issues/33912\n    return maybeArr;\n}\n\ntype DNSOrder = 'ipv4first' | 'verbatim';\n\n/**\n * Get the configured DNS resolution order\n */\nfunction getDNSResolutionOrder(): DNSOrder {\n    let dnsOrder: DNSOrder = 'ipv4first';\n\n    try {\n        const configName = getConfigFileName();\n        const config: ioBroker.IoBrokerJson = fs.readJSONSync(configName);\n        dnsOrder = config.dnsResolution || dnsOrder;\n    } catch (e) {\n        if (e.code !== 'ENOENT') {\n            console.warn(`Could not determine dns resolution order, fallback to \"ipv4first\": ${e.message}`);\n        }\n    }\n\n    return dnsOrder;\n}\n\n/**\n * Checks if given ip address is matching ipv4 or ipv6 localhost\n *\n * @param ip ipv4 or ipv6 address\n */\nexport function isLocalAddress(ip: string): boolean {\n    const localAddresses = ['::1', '127.0.0.1', 'localhost'];\n\n    return localAddresses.includes(ip);\n}\n\n/**\n * Checks if given ip address is matching ipv4 or ipv6 \"listen all\" address\n *\n * @param ip ipv4 or ipv6 address\n */\nexport function isListenAllAddress(ip: string): boolean {\n    return ip === '0.0.0.0' || ip === '::';\n}\n\n/**\n * Retrieve the localhost address according to the configured DNS resolution strategy\n */\nexport function getLocalAddress(): '127.0.0.1' | '::1' {\n    const dnsOrder = getDNSResolutionOrder();\n\n    return dnsOrder === 'ipv4first' ? '127.0.0.1' : '::1';\n}\n\n/**\n * Get the ip to listen to all addresses according to configured DNS resolution strategy\n */\nexport function getListenAllAddress(): '0.0.0.0' | '::' {\n    const dnsOrder = getDNSResolutionOrder();\n\n    return dnsOrder === 'ipv4first' ? '0.0.0.0' : '::';\n}\n\n/**\n * Ensure that DNS is resolved according to ioBroker config\n */\nexport function ensureDNSOrder(): void {\n    const dnsOrder = getDNSResolutionOrder();\n    setDefaultResultOrder(dnsOrder);\n}\n\n/**\n * Determine if ioBroker is installed as systemd service\n */\nexport async function isIoBrokerInstalledAsSystemd(): Promise<boolean> {\n    try {\n        const res = await execAsync('systemctl status iobroker');\n        return !res.stderr;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * Get a new host object\n *\n * @param oldObj the previous host object\n */\nexport function getHostObject(oldObj?: ioBroker.HostObject | null): ioBroker.HostObject {\n    const hostname = getHostName();\n    const ioPackage = fs.readJSONSync(path.join(getControllerDir(), 'io-package.json'));\n\n    const newObj: ioBroker.HostObject = {\n        _id: `system.host.${hostname}`,\n        type: 'host',\n        common: {\n            name: hostname,\n            title: oldObj?.common?.title || ioPackage.common.title,\n            installedVersion: ioPackage.common.version,\n            platform: ioPackage.common.platform,\n            cmd: `${process.argv[0]} ${`${process.execArgv.join(' ')} `.replace(/--inspect-brk=\\d+ /, '')}${process.argv\n                .slice(1)\n                .join(' ')}`,\n            hostname,\n            address: findIPs(),\n            type: ioPackage.common.name,\n        },\n        native: {\n            process: {\n                title: process.title,\n                versions: process.versions,\n                env: process.env,\n            },\n            os: {\n                hostname: hostname,\n                type: os.type(),\n                platform: os.platform(),\n                arch: os.arch(),\n                release: os.release(),\n                endianness: os.endianness(),\n                tmpdir: os.tmpdir(),\n            },\n            hardware: {\n                cpus: os.cpus(),\n                totalmem: os.totalmem(),\n                networkInterfaces: {},\n            },\n        },\n    };\n\n    if (oldObj?.common?.icon) {\n        newObj.common.icon = oldObj.common.icon;\n    }\n    if (oldObj?.common?.color) {\n        newObj.common.color = oldObj.common.color;\n    }\n    // remove dynamic information\n    if (newObj.native?.hardware?.cpus) {\n        for (const cpu of newObj.native.hardware.cpus) {\n            if (cpu.times) {\n                delete cpu.times;\n            }\n        }\n    }\n    if (oldObj?.native.hardware?.networkInterfaces) {\n        newObj.native.hardware.networkInterfaces = oldObj.native.hardware.networkInterfaces;\n    }\n\n    return newObj;\n}\n\n/**\n * Get file name of the pids file\n *\n * @returns file name of the pids file\n */\nexport function getPidsFileName(): string {\n    return path.join(getControllerDir(), 'pids.txt');\n}\n\n/**\n * Get all ioBroker process ids\n *\n * @returns process ids or empty array if no process running\n */\nexport async function getPids(): Promise<number[]> {\n    let pids: number[] = [];\n\n    try {\n        const pidsContent = await fs.readFile(getPidsFileName(), { encoding: 'utf-8' });\n        pids = JSON.parse(pidsContent);\n    } catch (e) {\n        if (e.code !== 'ENOENT') {\n            throw e;\n        }\n    }\n\n    return pids;\n}\n\n/**\n * Get the controller pid\n *\n * @returns pid if running else undefined\n */\nexport async function getControllerPid(): Promise<number | undefined> {\n    const pids = await getPids();\n    return pids.pop();\n}\n\nexport * from '@/lib/common/maybeCallback.js';\n", "export const __import_meta_url =\n  typeof document === 'undefined' ? new (require('url'.replace('', '')).URL)('file:' + __filename).href :\n    (document.currentScript && document.currentScript.src || new URL('main.js', document.baseURI).href)\n"],
  "mappings": "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",
  "names": ["require", "ERRORS", "events", "deepClone", "crypto", "semver", "password", "data", "fs", "os", "path", "url", "axios", "mac", "jwt", "extend", "version", "sources", "err", "exec", "line", "forge", "cpExecAsync", "zlib"]
}
