{
  "version": 3,
  "sources": ["../../../../src/lib/common/maybeCallback.ts"],
  "sourcesContent": ["// Beware, below be TypeScript dragons!\n\nimport { ERRORS } from '@/lib/common/tools.js';\n\ntype MaybeCbCallback<T extends any[]> = (...args: T) => void;\ntype MaybeCbErrCallback<T extends any[]> = (error: Error | null | undefined, ...args: T) => void;\n\n// Helper type to infer the return type of the maybeCallbackWithError function\n// If the callback is given, the return type is void\n// otherwise, the return type is a Promise whose resolved value type depends on the given arguments, or the error variable\ntype MaybeCbErrReturnType<\n    TCb extends MaybeCbErrCallback<any> | null | undefined,\n    TErr extends Error | string | null | undefined,\n    TArgs extends any[],\n> =\n    TCb extends MaybeCbErrCallback<any>\n        ? void\n        : // If there is an error given, the promise will never resolve\n          TErr extends Error | string\n          ? Promise<never>\n          : // Infer the return type from the arguments\n            Promise<\n                [] extends TArgs\n                    ? void // if ([] === T) void\n                    : [any] extends TArgs\n                      ? TArgs[0] // else if (T has one element) => take first element\n                      : TArgs // else return T entirely\n            >;\n\n// Helper type to infer the callback arguments for the maybeCallbackWithError function\n// If a callback is given, they must match its arguments. Otherwise, they are inferred and default to any[]\ntype MaybeCbErrCallbackParameters<\n    CB extends MaybeCbErrCallback<any> | null | undefined,\n    TErr extends Error | string | null | undefined,\n> =\n    Exclude<CB, undefined | null> extends MaybeCbErrCallback<infer U>\n        ? // If the error argument is given,\n          TErr extends Error | string\n            ? //  don't require arguments, but allow passing them\n              U | []\n            : // Otherwise, require the correct args\n              U\n        : any[];\n\n// Helper type to infer the callback arguments for the maybeCallback function\n// If a callback is given, they must match its arguments. Otherwise, they are inferred and default to any[]\ntype MaybeCbCallbackParameters<CB extends MaybeCbCallback<any> | null | undefined> =\n    Exclude<CB, undefined | null> extends MaybeCbCallback<infer U> ? U : any[];\n\n// Helper type to infer the return type of the maybeCallback function\n// If the callback is given, the return type is void\n// otherwise, the return type is a Promise whose resolved value type depends on the given arguments\ntype MaybeCbReturnType<TCb extends MaybeCbErrCallback<any> | null | undefined, TArgs extends any[]> =\n    TCb extends MaybeCbCallback<any>\n        ? void\n        : // Infer the return type from the arguments\n          Promise<\n              [] extends TArgs\n                  ? void // if ([] === T) void\n                  : [any] extends TArgs\n                    ? TArgs[0] // else if (T has one element) => take first element\n                    : TArgs // else return T entirely\n          >;\n\n// Helper type to lower the inference priority of an argument\ntype NoInfer<T> = T & { [K in keyof T]: T[K] };\n\n// This is the publicly visible signature of maybeCallback. The one below is just internal\n// and makes implementing the function much, much easier (although a bit unsound).\nexport function maybeCallback<\n    // Limit the callback type to a valid callback type\n    TCb extends MaybeCbCallback<any> | null | undefined,\n    // The callback arguments must match the callback args\n    TArgs extends MaybeCbCallbackParameters<TCb> = MaybeCbCallbackParameters<TCb>,\n>(\n    callback: TCb,\n    // Infer the arguments with lower priority than the callback - they need to match it.\n    ...args: NoInfer<TArgs>\n): MaybeCbReturnType<TCb, TArgs>;\n\n/**\n * Checks if the given callback is a function and if so calls it with the given parameter immediately, else a resolved Promise is returned\n *\n * @param callback - callback function to be executed\n * @param args - as many arguments as needed, which will be returned by the callback function or by the Promise\n * @returns if Promise is resolved with multiple arguments, an array is returned\n */\nexport function maybeCallback<T extends any[]>(callback?: MaybeCbCallback<T> | null, ...args: T): Promise<any> | void {\n    if (typeof callback === 'function') {\n        // if function we call it with given param\n        setImmediate(callback, ...args);\n    } else {\n        return Promise.resolve(args.length > 1 ? args : args[0]);\n    }\n}\n\n// This is the publicly visible signature of maybeCallbackWithError. The one below is just internal\n// and makes implementing the function much, much easier (although a bit unsound).\nexport function maybeCallbackWithError<\n    // Limit the callback type to a valid callback type\n    TCb extends MaybeCbErrCallback<any> | null | undefined,\n    // And the error to either an error or sting, or null/undefined\n    TErr extends Error | string | null | undefined,\n    // The callback arguments must match the callback args\n    TArgs extends MaybeCbErrCallbackParameters<TCb, TErr> = MaybeCbErrCallbackParameters<TCb, TErr>,\n>(\n    callback: TCb,\n    error: TErr,\n    // Infer the arguments with lower priority than the callback - they need to match it.\n    ...args: NoInfer<TArgs>\n): MaybeCbErrReturnType<TCb, TErr, TArgs>;\n\n/**\n * Checks if the given callback is a function and if so calls it with the given error and parameter immediately, else a resolved or rejected Promise is returned. Error ERROR_DB_CLOSED are not rejecting the promise\n *\n * @param callback - callback function to be executed\n * @param error - error which will be used by the callback function. If callback is not a function and\n * error is given, a rejected Promise is returned. If error is given, but it is not an instance of Error, it is converted into one.\n * @param args - as many arguments as needed, which will be returned by the callback function or by the Promise\n * @returns if Promise is resolved with multiple arguments, an array is returned\n */\nexport function maybeCallbackWithError<T extends any[]>(\n    callback: MaybeCbErrCallback<T> | null | undefined,\n    error: Error | string | null | undefined,\n    ...args: T\n): Promise<any> | void {\n    if (error !== undefined && error !== null && !(error instanceof Error)) {\n        // if it's not a real Error, we convert it into one\n        error = new Error(error);\n    }\n    const isDbError = error ? error.message === ERRORS.ERROR_DB_CLOSED : false;\n\n    if (typeof callback === 'function') {\n        setImmediate(callback, error, ...args);\n    } else if (error && !isDbError) {\n        return Promise.reject(error);\n    } else {\n        return Promise.resolve(args.length > 1 ? args : args[0]);\n    }\n}\n\n// This is the publicly visible signature of maybeCallbackWithRedisError, which is an exact copy of maybeCallbackWithError's signature.\n// The one below is just internal and makes implementing the function much, much easier (although a bit unsound).\nexport function maybeCallbackWithRedisError<\n    // Limit the callback type to a valid callback type\n    TCb extends MaybeCbErrCallback<any> | null | undefined,\n    // And the error to either an error or sting, or null/undefined\n    TErr extends Error | string | null | undefined,\n    // The callback arguments must match the callback args\n    TArgs extends MaybeCbErrCallbackParameters<TCb, TErr> = MaybeCbErrCallbackParameters<TCb, TErr>,\n>(\n    callback: TCb,\n    error: TErr,\n    // Infer the arguments with lower priority than the callback - they need to match it.\n    ...args: NoInfer<TArgs>\n): MaybeCbErrReturnType<TCb, TErr, TArgs>;\n\n/**\n * Checks if the given callback is a function and if so calls it with the given error and parameter immediately, else a resolved or rejected Promise is returned. Redis-Error \"Connection is closed.\" is converted into ERROR_DB_CLOSED\n *\n * @param callback - callback function to be executed\n * @param error - error which will be used by the callback function. If callback is not a function and\n * error is given, a rejected Promise is returned. If error is given, but it is not an instance of Error, it is converted into one.\n * @param args - as many arguments as needed, which will be returned by the callback function or by the Promise\n * @returns Promise if Promise is resolved with multiple arguments, an array is returned\n */\nexport function maybeCallbackWithRedisError<T extends any[]>(\n    callback: MaybeCbErrCallback<T> | null | undefined,\n    error: Error | string | null | undefined,\n    ...args: T\n): Promise<any> | void {\n    if (error instanceof Error && error.message.includes('Connection is closed')) {\n        error.message = ERRORS.ERROR_DB_CLOSED;\n    }\n    return maybeCallbackWithError(callback, error, ...args);\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;;;;;;;AAEA,mBAAuB;AAqFjB,SAAU,cAA+B,aAAyC,MAAO;AAC3F,MAAI,OAAO,aAAa,YAAY;AAEhC,iBAAa,UAAU,GAAG,IAAI;EAClC,OAAO;AACH,WAAO,QAAQ,QAAQ,KAAK,SAAS,IAAI,OAAO,KAAK,CAAC,CAAC;EAC3D;AACJ;AA2BM,SAAU,uBACZ,UACA,UACG,MAAO;AAEV,MAAI,UAAU,UAAa,UAAU,QAAQ,EAAE,iBAAiB,QAAQ;AAEpE,YAAQ,IAAI,MAAM,KAAK;EAC3B;AACA,QAAM,YAAY,QAAQ,MAAM,YAAY,oBAAO,kBAAkB;AAErE,MAAI,OAAO,aAAa,YAAY;AAChC,iBAAa,UAAU,OAAO,GAAG,IAAI;EACzC,WAAW,SAAS,CAAC,WAAW;AAC5B,WAAO,QAAQ,OAAO,KAAK;EAC/B,OAAO;AACH,WAAO,QAAQ,QAAQ,KAAK,SAAS,IAAI,OAAO,KAAK,CAAC,CAAC;EAC3D;AACJ;AA2BM,SAAU,4BACZ,UACA,UACG,MAAO;AAEV,MAAI,iBAAiB,SAAS,MAAM,QAAQ,SAAS,sBAAsB,GAAG;AAC1E,UAAM,UAAU,oBAAO;EAC3B;AACA,SAAO,uBAAuB,UAAU,OAAO,GAAG,IAAI;AAC1D;",
  "names": []
}
