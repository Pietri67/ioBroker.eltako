"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var aliasProcessing_exports = {};
__export(aliasProcessing_exports, {
  applyAliasAutoScaling: () => applyAliasAutoScaling,
  applyAliasConvenienceConversion: () => applyAliasConvenienceConversion,
  applyAliasTransformer: () => applyAliasTransformer
});
module.exports = __toCommonJS(aliasProcessing_exports);
function applyAliasTransformer(options) {
  const { state, firstCommon, secondCommon, transformer, isRead } = options;
  const prefix = isRead ? "s" : "t";
  const func = new Function("val", "type", "min", "max", `${prefix}Type`, `${prefix}Min`, `${prefix}Max`, `return ${transformer}`);
  return func(state.val, firstCommon.type, firstCommon.min, firstCommon.max, secondCommon.type, secondCommon.min, secondCommon.max);
}
function applyAliasConvenienceConversion(options) {
  const { targetCommon, state } = options;
  if (targetCommon && typeof state.val !== targetCommon.type && state.val !== null) {
    if (targetCommon.type === "boolean") {
      const lowerVal = typeof state.val === "string" ? state.val.toLowerCase() : state.val;
      if (lowerVal === "off" || lowerVal === "aus" || state.val === "0") {
        return false;
      }
      return !!state.val;
    } else if (targetCommon.type === "number" && typeof state.val === "string") {
      return parseFloat(state.val);
    } else if (targetCommon.type === "string") {
      return state.val.toString();
    }
  }
  return state.val;
}
function applyAliasAutoScaling(options) {
  const { state, sourceCommon, targetCommon } = options;
  if ((targetCommon?.alias && !targetCommon.alias.read || sourceCommon?.alias && !sourceCommon.alias.write) && state.val !== null) {
    if (targetCommon && targetCommon.type === "number" && targetCommon.unit === "%" && sourceCommon && sourceCommon.type === "number" && sourceCommon.unit !== "%" && sourceCommon.min !== void 0 && sourceCommon.max !== void 0) {
      return (state.val - sourceCommon.min) / (sourceCommon.max - sourceCommon.min) * 100;
    } else if (sourceCommon && sourceCommon.type === "number" && sourceCommon.unit === "%" && targetCommon && targetCommon.unit !== "%" && targetCommon.type === "number" && targetCommon.min !== void 0 && targetCommon.max !== void 0) {
      return (targetCommon.max - targetCommon.min) * state.val / 100 + targetCommon.min;
    }
  }
  return state.val;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  applyAliasAutoScaling,
  applyAliasConvenienceConversion,
  applyAliasTransformer
});
//# sourceMappingURL=aliasProcessing.js.map
