{
  "version": 3,
  "sources": ["../../../../src/lib/adapter/userInterfaceMessagingController.ts"],
  "sourcesContent": ["import type { Client as StatesInRedisClient } from '@iobroker/db-states-redis';\nimport type { AdapterClass } from '@/lib/adapter/adapter.js';\nimport type {\n    UserInterfaceClientRemoveMessage,\n    UserInterfaceClientSubscribeHandler,\n    UserInterfaceClientSubscribeReturnType,\n    UserInterfaceClientUnsubscribeHandler,\n} from '@/lib/_Types.js';\n\nexport interface HeartbeatTimer {\n    /** The actual timer */\n    timer: NodeJS.Timeout;\n    /** The heartbeat interval */\n    heartbeat: number;\n}\n\nexport interface MessagingControllerOptions {\n    /** The adapter using this messaging controller */\n    adapter: AdapterClass;\n    /** Callback to call if successfully subscribed */\n    subscribeCallback?: UserInterfaceClientSubscribeHandler;\n    /** Callback to call if successfully unsubscribed */\n    unsubscribeCallback?: UserInterfaceClientUnsubscribeHandler;\n}\n\nexport interface SendToClientOptions {\n    /** ID of the client to send the message to, will send to all if omitted */\n    clientId: string;\n    /** Data to send to the client */\n    data: unknown;\n    /** The states db */\n    states: StatesInRedisClient;\n}\n\nexport type SendToAllClientOptions = Omit<SendToClientOptions, 'clientId'>;\n\nexport interface ClientHandler {\n    /** The session id of the client connection */\n    sid: string;\n    /** Name of the subscriber */\n    from: string;\n    /** Individual type which can be specified */\n    type: string;\n}\n\n/**\n * The message has short keys, to save bytes for high-throughput messaging\n */\ninterface UserInterfaceMessage {\n    /** The individual type of the client handler */\n    m: string;\n    /** The session id of the client connection */\n    s: string;\n    /** The actual data */\n    d: unknown;\n}\n\nexport class UserInterfaceMessagingController {\n    /** The adapter using this messaging controller */\n    private readonly adapter: AdapterClass;\n    /** Callback to call if successfully subscribed */\n    private readonly unsubscribeCallback?: UserInterfaceClientUnsubscribeHandler;\n    /** Callback to call if successfully unsubscribed */\n    private readonly subscribeCallback?: UserInterfaceClientSubscribeHandler;\n    /** All currently registered client handlers */\n    private readonly handlers = new Map<string, ClientHandler>();\n    /** Collection of current heartbeat timers */\n    private heartbeatTimers = new Map<string, HeartbeatTimer>();\n    constructor(options: MessagingControllerOptions) {\n        const { adapter, unsubscribeCallback, subscribeCallback } = options;\n\n        this.adapter = adapter;\n        this.unsubscribeCallback = unsubscribeCallback;\n        this.subscribeCallback = subscribeCallback;\n    }\n\n    /**\n     * Send a message to the given clientId\n     *\n     * @param options Data, states and client information\n     */\n    sendToClient(options: SendToClientOptions): Promise<void> {\n        const { states, clientId, data } = options;\n\n        if (!this.handlers.has(clientId)) {\n            throw new Error(`Client \"${clientId}\" is not registered`);\n        }\n\n        const handler = this.handlers.get(clientId)!;\n\n        return states.pushMessage(handler.from, {\n            command: 'im',\n            message: { m: handler.type, s: handler.sid, d: data } satisfies UserInterfaceMessage,\n            from: `system.adapter.${this.adapter.namespace}`,\n        });\n    }\n\n    /**\n     * Send a message to all active clients\n     *\n     * @param options Data and states options\n     */\n    async sendToAllClients(options: SendToAllClientOptions): Promise<void> {\n        const { states, data } = options;\n\n        for (const clientId of Object.keys(this.handlers)) {\n            await this.sendToClient({ clientId, data, states });\n        }\n    }\n\n    /**\n     * Register subscription from new client\n     *\n     * @param msg The subscribe message\n     */\n    async registerClientSubscribeByMessage(\n        msg: ioBroker.Message,\n    ): Promise<UserInterfaceClientSubscribeReturnType | undefined> {\n        if (!this.subscribeCallback) {\n            return;\n        }\n\n        const handler = this.extractHandlerFromMessage(msg);\n        const clientId = this.handlerToId(handler);\n\n        if (this.heartbeatTimers.has(clientId)) {\n            this.heartbeatTimers.get(clientId)!.timer.refresh();\n            return;\n        }\n\n        const resOrAwaitable = this.subscribeCallback({ clientId, message: msg });\n        let res: UserInterfaceClientSubscribeReturnType;\n\n        if (resOrAwaitable instanceof Promise) {\n            res = await resOrAwaitable;\n        } else {\n            res = resOrAwaitable;\n        }\n\n        if (!res.accepted) {\n            return res;\n        }\n\n        this.handlers.set(clientId, handler);\n        if (res.heartbeat) {\n            const timer = setTimeout(() => this.heartbeatExpired(clientId), res.heartbeat);\n            this.heartbeatTimers.set(clientId, { heartbeat: res.heartbeat, timer });\n        }\n\n        return res;\n    }\n\n    /**\n     * Remove a client subscription, issued by message\n     * It contains an array of types which should be unsubscribed\n     *\n     * @param msg The unsubscribe message\n     */\n    removeClientSubscribeByMessage(msg: UserInterfaceClientRemoveMessage): void {\n        const handler = this.extractHandlerFromMessage(msg);\n        const reason = msg.command === 'clientSubscribeError' ? msg.command : msg.message.reason;\n\n        const types = msg.message.type;\n\n        for (const type of types) {\n            const clientId = this.handlerToId({ ...handler, type });\n\n            if (this.heartbeatTimers.has(clientId)) {\n                const timer = this.heartbeatTimers.get(clientId)!;\n\n                clearTimeout(timer.timer);\n                this.heartbeatTimers.delete(clientId);\n            }\n\n            if (!this.handlers.has(clientId)) {\n                return;\n            }\n\n            this.handlers.delete(clientId);\n            if (this.unsubscribeCallback) {\n                this.unsubscribeCallback({ clientId, message: msg, reason });\n            }\n        }\n    }\n\n    /**\n     * Convert handler to id\n     *\n     * @param handler the client handler to creat the id for\n     */\n    private handlerToId(handler: ClientHandler): string {\n        const { sid, type, from } = handler;\n\n        return `${sid}-${from}-${type}`;\n    }\n\n    /**\n     * Extract the client handler from a given message\n     *\n     * @param msg the subscribe or unsubscribe message\n     */\n    private extractHandlerFromMessage(msg: ioBroker.Message): ClientHandler {\n        return { sid: msg.message.sid, from: msg.from, type: msg.message.type };\n    }\n\n    /**\n     * Handle expired heartbeat\n     *\n     * @param clientId the id of the expired client\n     */\n    private heartbeatExpired(clientId: string): void {\n        this.handlers.delete(clientId);\n        this.heartbeatTimers.delete(clientId);\n\n        if (this.unsubscribeCallback) {\n            this.unsubscribeCallback({ clientId, reason: 'timeout' });\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
