"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var adapter_exports = {};
__export(adapter_exports, {
  Adapter: () => Adapter,
  AdapterClass: () => AdapterClass
});
module.exports = __toCommonJS(adapter_exports);
var __import_meta_url = typeof document === "undefined" ? new (require("url".replace("", ""))).URL("file:" + __filename).href : document.currentScript && document.currentScript.src || new URL("main.js", document.baseURI).href;
var import_node_net = __toESM(require("node:net"), 1);
var import_fs_extra = __toESM(require("fs-extra"), 1);
var import_node_os = __toESM(require("node:os"), 1);
var import_jsonwebtoken = __toESM(require("jsonwebtoken"), 1);
var import_node_events = require("node:events");
var import_pidusage = __toESM(require("pidusage"), 1);
var import_deep_clone = __toESM(require("deep-clone"), 1);
var import_plugin_base = require("@iobroker/plugin-base");
var import_semver = __toESM(require("semver"), 1);
var import_node_path = __toESM(require("node:path"), 1);
var import_js_controller_common = require("@iobroker/js-controller-common");
var import_utils = require("../../lib/adapter/utils.js");
var import_node = __toESM(require("node.extend"), 1);
var import_yargs = __toESM(require("yargs/yargs"), 1);
var import_package = __toESM(require("@iobroker/js-controller-adapter/package.json"), 1);
var import_log = require("../../lib/adapter/log.js");
var import_validator = require("./validator.js");
var import_constants = require("../../lib/adapter/constants.js");
var import_userInterfaceMessagingController = require("../../lib/adapter/userInterfaceMessagingController.js");
var import_constants2 = require("@iobroker/js-controller-common-db/constants");
var url = __toESM(require("node:url"), 1);
const controllerVersion = import_package.default.version;
const { FORBIDDEN_CHARS } = import_js_controller_common.tools;
const thisDir = url.fileURLToPath(new URL(".", __import_meta_url || `file://${__filename}`));
import_js_controller_common.tools.ensureDNSOrder();
class AdapterClass extends import_node_events.EventEmitter {
  /** Cache of all deprecations which have already been transmitted */
  reportedDeprecations = /* @__PURE__ */ new Set();
  /** Instance to access states DB */
  #states;
  /** Instance to access objects DB */
  #objects;
  /** States DB constructor */
  States;
  /** Objects DB constructor */
  Objects;
  /** Contents of iobroker.json */
  _config;
  _options;
  startedInCompactMode;
  /** List of instances which want our logs */
  logList = /* @__PURE__ */ new Set();
  aliases = /* @__PURE__ */ new Map();
  aliasPatterns = /* @__PURE__ */ new Set();
  enums = {};
  eventLoopLags = [];
  overwriteLogLevel = false;
  adapterReady = false;
  /** Callbacks from sendTo */
  messageCallbacks = /* @__PURE__ */ new Map();
  /**
   * Contains a live cache of the adapter's states.
   * NOTE: This is only defined if the adapter was initialized with the option states: true.
   */
  oStates;
  /**
   * Contains a live cache of the adapter's objects.
   * NOTE: This is only defined if the adapter was initialized with the option objects: true.
   */
  oObjects;
  _stopInProgress = false;
  _callbackId = 1;
  _firstConnection = true;
  _timers = /* @__PURE__ */ new Set();
  _intervals = /* @__PURE__ */ new Set();
  _delays = /* @__PURE__ */ new Set();
  /** For ease of use the log property is always defined, however it is only available after `ready` has been called. */
  log;
  performStrictObjectChecks;
  _logger;
  _restartScheduleJob;
  _schedule;
  namespaceLog;
  namespace;
  name;
  _systemSecret;
  /** Whether the adapter has already terminated */
  terminated = false;
  /** The cache of usernames */
  usernames = {};
  /** A RegExp to test for forbidden chars in object IDs */
  FORBIDDEN_CHARS = FORBIDDEN_CHARS;
  inputCount = 0;
  outputCount = 0;
  /** The cache of users */
  users = {};
  // todo
  /** The cache of user groups */
  groups = {};
  /** An array of instances, that support auto subscribe */
  autoSubscribe = [];
  defaultHistory = null;
  pluginHandler;
  _reportInterval;
  getPortRunning = null;
  _namespaceRegExp;
  instance;
  // @ts-expect-error decide how to handle it
  _utils;
  /** contents of io-package.json */
  adapterConfig;
  connected;
  adapterDir;
  /** contents of package.json */
  pack;
  /** contents of io-package.json */
  ioPack;
  _initializeTimeout;
  inited;
  /** contents of iobroker.json if required via AdapterOptions */
  systemConfig;
  /** the configured date format of system.config, only available if requested via AdapterOptions `useFormatDate` */
  dateFormat;
  /** if float comma instead of dot is used, only available if requested via AdapterOptions `useFormatDate` */
  isFloatComma;
  /** configured language of system.config, only available if requested via AdapterOptions `useFormatDate` */
  language;
  /** longitude configured in system.config, only available if requested via AdapterOptions `useFormatDate`*/
  longitude;
  /** latitude configured in system.config, only available if requested via AdapterOptions `useFormatDate`*/
  latitude;
  _defaultObjs;
  _aliasObjectsSubscribed;
  config = {};
  host;
  common;
  mboxSubscribed;
  /** Stop the adapter */
  stop;
  version;
  /** Stop the adapter only defined in compact, not for external usage */
  kill;
  processLog;
  /**
   * Start or stop subscribing to log messages
   * The method is only available if logTransporter is active via io-pack or adapter options
   * Note, that stopping will stop after 10 seconds, not immediately
   *
   * @param isActive - if log subscription should be activated or deactivated
   * @param options - options passed to setState e.g. user permissions
   */
  requireLog;
  logOffTimer;
  logRequired;
  patterns;
  statesConnectedTime;
  /** Constants for frequent use in adapters */
  constants = {
    STATE_QUALITY: import_constants.STATE_QUALITY
  };
  /** Features supported by the running instance */
  SUPPORTED_FEATURES = (0, import_utils.getSupportedFeatures)();
  /** Controller for messaging related functionality */
  uiMessagingController;
  constructor(options) {
    super();
    if (typeof options === "string") {
      this._options = { name: options };
    } else {
      this._options = options;
    }
    const configFileName = import_js_controller_common.tools.getConfigFileName();
    if (import_fs_extra.default.pathExistsSync(configFileName)) {
      this._config = import_fs_extra.default.readJsonSync(configFileName);
      this._config.states = this._config.states || { type: "jsonl" };
      this._config.objects = this._config.objects || { type: "jsonl" };
      this._config.states.connectTimeout = Math.max(this._config.states.connectTimeout || 0, 5e3);
      this._config.objects.connectTimeout = Math.max(this._config.objects.connectTimeout || 0, 5e3);
    } else {
      throw new Error(`Cannot find ${configFileName}`);
    }
    if (!this._options) {
      throw new Error("Configuration not set!");
    }
    if (this._options.config && !this._options.config.log) {
      this._options.config.log = this._config.log;
    }
    this._config = this._options.config || this._config;
    this.startedInCompactMode = !!this._options.compact;
    const parsedArgs = (0, import_yargs.default)(process.argv.slice(2)).options({
      loglevel: {
        describe: "Define adapter log level",
        type: "string"
      },
      silent: {
        describe: "If is install run",
        type: "boolean"
      },
      install: {
        describe: "If is install run",
        type: "boolean"
      },
      logs: {
        describe: "If console output desired",
        type: "boolean"
      },
      console: {
        describe: "If console output desired",
        type: "boolean"
      },
      force: {
        describe: "If force start even if disabled",
        type: "boolean"
      },
      debug: {
        describe: "Same as --force combined with --console",
        type: "boolean"
      },
      instance: {
        describe: "Instance id, e.g. 0",
        type: "string"
      }
    }).parseSync();
    if (parsedArgs.loglevel && ["info", "debug", "error", "warn", "silly"].includes(parsedArgs.loglevel)) {
      this._config.log.level = parsedArgs.loglevel;
      this.overwriteLogLevel = true;
    }
    if (parsedArgs.silent || parsedArgs.install) {
      this._config.isInstall = true;
    }
    if (parsedArgs.logs || parsedArgs.console) {
      this._config.consoleOutput = true;
    }
    if (parsedArgs.force) {
      this._config.forceIfDisabled = true;
    }
    if (parsedArgs.debug) {
      this._config.forceIfDisabled = true;
      this._config.consoleOutput = true;
      if (this._config.log.level !== "silly") {
        this._config.log.level = "debug";
        this.overwriteLogLevel = true;
      }
    }
    if (parsedArgs.instance && parseInt(parsedArgs.instance, 10).toString() === parsedArgs.instance) {
      this._config.instance = parseInt(parsedArgs.instance, 10);
    }
    this._config.log.level = this._config.log.level || "info";
    this._config.log.noStdout = !this._config.consoleOutput;
    this.performStrictObjectChecks = this._options.strictObjectChecks !== false;
    this.name = this._options.name;
    if (!this.name) {
      throw new Error("No name of adapter!");
    }
    const instance = parseInt(this._options.compactInstance !== void 0 ? this._options.compactInstance : this._options.instance !== void 0 ? this._options.instance : this._config.instance || 0, 10);
    this.namespace = `${this.name}.${instance}`;
    this.namespaceLog = this.namespace + (this.startedInCompactMode ? " (COMPACT)" : ` (${process.pid})`);
    this._namespaceRegExp = new RegExp(`^${`${this.namespace}.`.replace(/\./g, "\\.")}`);
    this._logger = (0, import_js_controller_common.logger)(this._config.log);
    if (!this._logger.silly) {
      this._logger.silly = this._logger.debug;
    }
    if (this._options.dirname) {
      this.adapterDir = this._options.dirname.replace(/\\/g, "/");
    } else {
      const adapterDir = import_js_controller_common.tools.getAdapterDir(this.name);
      if (!adapterDir) {
        this._logger.error(`${this.namespaceLog} Cannot find directory of adapter ${this.name}`);
        this.terminate(import_js_controller_common.EXIT_CODES.CANNOT_FIND_ADAPTER_DIR);
      }
      this.adapterDir = adapterDir;
    }
    if (import_fs_extra.default.existsSync(`${this.adapterDir}/io-package.json`)) {
      this.ioPack = import_fs_extra.default.readJSONSync(`${this.adapterDir}/io-package.json`);
    } else {
      this._logger.error(`${this.namespaceLog} Cannot find: ${this.adapterDir}/io-package.json`);
      this.terminate(import_js_controller_common.EXIT_CODES.CANNOT_FIND_ADAPTER_DIR);
    }
    this.uiMessagingController = new import_userInterfaceMessagingController.UserInterfaceMessagingController({
      adapter: this,
      subscribeCallback: this._options.uiClientSubscribe,
      unsubscribeCallback: this._options.uiClientUnsubscribe
    });
    this.getPortAsync = import_js_controller_common.tools.promisifyNoError(this.getPort, this);
    this.checkPasswordAsync = import_js_controller_common.tools.promisifyNoError(this.checkPassword, this);
    this.setPasswordAsync = import_js_controller_common.tools.promisify(this.setPassword, this);
    this.checkGroupAsync = import_js_controller_common.tools.promisifyNoError(this.checkGroup, this);
    this.calculatePermissionsAsync = import_js_controller_common.tools.promisifyNoError(this.calculatePermissions, this);
    this.getCertificatesAsync = import_js_controller_common.tools.promisify(this.getCertificates, this);
    this.setObjectAsync = import_js_controller_common.tools.promisify(this.setObject, this);
    this.getAdapterObjectsAsync = import_js_controller_common.tools.promisifyNoError(this.getAdapterObjects, this);
    this.extendObjectAsync = import_js_controller_common.tools.promisify(this.extendObject, this);
    this.setForeignObjectAsync = import_js_controller_common.tools.promisify(this.setForeignObject, this);
    this.extendForeignObjectAsync = import_js_controller_common.tools.promisify(this.extendForeignObject, this);
    this.getObjectAsync = import_js_controller_common.tools.promisify(this.getObject, this);
    this.getObjectViewAsync = import_js_controller_common.tools.promisify(this.getObjectView, this);
    this.getObjectListAsync = import_js_controller_common.tools.promisify(this.getObjectList, this);
    this.getEnumAsync = import_js_controller_common.tools.promisify(this.getEnum, this, ["result", "requestEnum"]);
    this.getEnumsAsync = import_js_controller_common.tools.promisify(this.getEnums, this);
    this.getForeignObjectsAsync = import_js_controller_common.tools.promisify(this.getForeignObjects, this);
    this.findForeignObjectAsync = import_js_controller_common.tools.promisify(this.findForeignObject, this, ["id", "name"]);
    this.getForeignObjectAsync = import_js_controller_common.tools.promisify(this.getForeignObject, this);
    this.delObjectAsync = import_js_controller_common.tools.promisify(this.delObject, this);
    this.delForeignObjectAsync = import_js_controller_common.tools.promisify(this.delForeignObject, this);
    this.subscribeObjectsAsync = import_js_controller_common.tools.promisify(this.subscribeObjects, this);
    this.unsubscribeObjectsAsync = import_js_controller_common.tools.promisify(this.unsubscribeObjects, this);
    this.subscribeForeignObjectsAsync = import_js_controller_common.tools.promisify(this.subscribeForeignObjects, this);
    this.unsubscribeForeignObjectsAsync = import_js_controller_common.tools.promisify(this.unsubscribeForeignObjects, this);
    this.setObjectNotExistsAsync = import_js_controller_common.tools.promisify(this.setObjectNotExists, this);
    this.setForeignObjectNotExistsAsync = import_js_controller_common.tools.promisify(this.setForeignObjectNotExists, this);
    this.createDeviceAsync = import_js_controller_common.tools.promisify(this.createDevice, this);
    this.createChannelAsync = import_js_controller_common.tools.promisify(this.createChannel, this);
    this.createStateAsync = import_js_controller_common.tools.promisify(this.createState, this);
    this.deleteDeviceAsync = import_js_controller_common.tools.promisify(this.deleteDevice, this);
    this.addChannelToEnumAsync = import_js_controller_common.tools.promisify(this.addChannelToEnum, this);
    this.deleteChannelFromEnumAsync = import_js_controller_common.tools.promisify(this.deleteChannelFromEnum, this);
    this.deleteChannelAsync = import_js_controller_common.tools.promisify(this.deleteChannel, this);
    this.deleteStateAsync = import_js_controller_common.tools.promisify(this.deleteState, this);
    this.getDevicesAsync = import_js_controller_common.tools.promisify(this.getDevices, this);
    this.getChannelsOfAsync = import_js_controller_common.tools.promisify(this.getChannelsOf, this);
    this.getChannels = this.getChannelsOf;
    this.getChannelsAsync = this.getChannelsOfAsync;
    this.getStatesOfAsync = import_js_controller_common.tools.promisify(this.getStatesOf, this);
    this.addStateToEnumAsync = import_js_controller_common.tools.promisify(this.addStateToEnum, this);
    this.deleteStateFromEnumAsync = import_js_controller_common.tools.promisify(this.deleteStateFromEnum, this);
    this.chmodFileAsync = import_js_controller_common.tools.promisify(this.chmodFile, this);
    this.chownFileAsync = import_js_controller_common.tools.promisify(this.chownFile, this);
    this.readDirAsync = import_js_controller_common.tools.promisify(this.readDir, this);
    this.unlinkAsync = import_js_controller_common.tools.promisify(this.unlink, this);
    this.delFile = this.unlink;
    this.delFileAsync = this.unlinkAsync;
    this.renameAsync = import_js_controller_common.tools.promisify(this.rename, this);
    this.mkdirAsync = import_js_controller_common.tools.promisify(this.mkdir, this);
    this.readFileAsync = import_js_controller_common.tools.promisify(this.readFile, this, ["file", "mimeType"]);
    this.writeFileAsync = import_js_controller_common.tools.promisify(this.writeFile, this);
    this.fileExistsAsync = import_js_controller_common.tools.promisify(this.fileExists, this);
    this.sendToHostAsync = import_js_controller_common.tools.promisifyNoError(this.sendToHost, this);
    this.setStateAsync = import_js_controller_common.tools.promisify(this.setState, this);
    this.setStateChangedAsync = import_js_controller_common.tools.promisify(this.setStateChanged, this, ["id", "notChanged"]);
    this.setForeignStateAsync = import_js_controller_common.tools.promisify(this.setForeignState, this);
    this.setForeignStateChangedAsync = import_js_controller_common.tools.promisify(this.setForeignStateChanged, this);
    this.getStateAsync = import_js_controller_common.tools.promisify(this.getState, this);
    this.getForeignStateAsync = import_js_controller_common.tools.promisify(this.getForeignState, this);
    this.getHistoryAsync = import_js_controller_common.tools.promisify(this.getHistory, this, ["result", "step", "sessionId"]);
    this.delStateAsync = import_js_controller_common.tools.promisify(this.delState, this);
    this.delForeignStateAsync = import_js_controller_common.tools.promisify(this.delForeignState, this);
    this.getStatesAsync = import_js_controller_common.tools.promisify(this.getStates, this);
    this.getForeignStatesAsync = import_js_controller_common.tools.promisify(this.getForeignStates, this);
    this.subscribeForeignStatesAsync = import_js_controller_common.tools.promisify(this.subscribeForeignStates, this);
    this.unsubscribeForeignStatesAsync = import_js_controller_common.tools.promisify(this.unsubscribeForeignStates, this);
    this.subscribeStatesAsync = import_js_controller_common.tools.promisify(this.subscribeStates, this);
    this.unsubscribeStatesAsync = import_js_controller_common.tools.promisify(this.unsubscribeStates, this);
    this.setExecutableCapabilities = import_js_controller_common.tools.setExecutableCapabilities;
    this._init();
  }
  /**
   * Get the adapter scoped package identifier of a node module
   *
   * @param moduleName name of the node module
   */
  getAdapterScopedPackageIdentifier(moduleName) {
    return (0, import_utils.getAdapterScopedPackageIdentifier)({ moduleName, namespace: this.namespace });
  }
  /**
   * Install specified npm module
   *
   * @param moduleNameOrUrl name of the node module or GitHub url which can be passed to `npm install`
   * @param options version information
   */
  installNodeModule(moduleNameOrUrl, options) {
    import_validator.Validator.assertString(moduleNameOrUrl, "moduleNameOrUrl");
    import_validator.Validator.assertObject(options, "options");
    return this._installNodeModule({ ...options, moduleNameOrUrl });
  }
  async _installNodeModule(options) {
    const { moduleNameOrUrl, version } = options;
    let moduleName = moduleNameOrUrl;
    const isUrl = URL.canParse(moduleNameOrUrl);
    if (isUrl) {
      moduleName = await (0, import_utils.requestModuleNameByUrl)(moduleNameOrUrl);
    }
    const internalModuleName = (0, import_utils.getAdapterScopedPackageIdentifier)({ moduleName, namespace: this.namespace });
    const packageIdentifier = isUrl ? moduleNameOrUrl : `npm:${moduleName}@${version}`;
    return import_js_controller_common.tools.installNodeModule(`${internalModuleName}@${packageIdentifier}`);
  }
  /**
   * List all additional installed node modules from this adapter
   */
  listInstalledNodeModules() {
    return (0, import_utils.listInstalledNodeModules)(this.namespace);
  }
  /**
   * Uninstall specified npm module
   *
   * @param moduleName name of the node module
   */
  uninstallNodeModule(moduleName) {
    import_validator.Validator.assertString(moduleName, "moduleName");
    const internalModuleName = (0, import_utils.getAdapterScopedPackageIdentifier)({ moduleName, namespace: this.namespace });
    return import_js_controller_common.tools.uninstallNodeModule(internalModuleName);
  }
  /**
   * Import a node module which has been installed via `installNodeModule`
   *
   * @param moduleName name of the node module
   * @returns the required node module
   */
  importNodeModule(moduleName) {
    import_validator.Validator.assertString(moduleName, "moduleName");
    const internalModuleName = (0, import_utils.getAdapterScopedPackageIdentifier)({ moduleName, namespace: this.namespace });
    return import(internalModuleName);
  }
  /**
   * Decrypt the password/value with given key
   *
   * @param secretVal to use for decrypt (or value if only one parameter is given)
   * @param value value to decrypt (if secret is provided)
   */
  decrypt(secretVal, value) {
    if (value === void 0) {
      value = secretVal;
      secretVal = this._systemSecret;
    }
    import_validator.Validator.assertString(secretVal, "secretVal");
    import_validator.Validator.assertString(value, "value");
    return import_js_controller_common.tools.decrypt(secretVal, value);
  }
  /**
   * Encrypt the password/value with given key
   *
   * @param secretVal to use for encrypting (or value if only one parameter is given)
   * @param [value] value to encrypt (if secret is provided)
   */
  encrypt(secretVal, value) {
    if (value === void 0) {
      value = secretVal;
      secretVal = this._systemSecret;
    }
    import_validator.Validator.assertString(secretVal, "secretVal");
    import_validator.Validator.assertString(value, "value");
    return import_js_controller_common.tools.encrypt(secretVal, value);
  }
  // unknown guard implementation
  getSession(id, callback) {
    import_validator.Validator.assertString(id, "id");
    import_validator.Validator.assertCallback(callback, "callback");
    return this._getSession({ id, callback });
  }
  // actual implementation
  _getSession(options) {
    if (!this.#states) {
      this._logger.info(`${this.namespaceLog} getSession not processed because States database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(options.callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    this.#states.getSession(options.id, options.callback);
  }
  // unknown implementation guards
  setSession(id, ttl, data, callback) {
    import_validator.Validator.assertString(id, "id");
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    import_validator.Validator.assertNumber(ttl, "ttl");
    import_validator.Validator.assertObject(data, "data");
    return this._setSession({ id, ttl, data, callback });
  }
  // actual implementation
  _setSession(options) {
    if (!this.#states) {
      this._logger.info(`${this.namespaceLog} setSession not processed because States database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(options.callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    this.#states.setSession(options.id, options.ttl, options.data, options.callback);
  }
  destroySession(id, callback) {
    import_validator.Validator.assertString(id, "id");
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    return this._destroySession({ id, callback });
  }
  _destroySession(options) {
    if (!this.#states) {
      this._logger.info(`${this.namespaceLog} destroySession not processed because States database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(options.callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    this.#states.destroySession(options.id, options.callback);
  }
  async _getObjectsByArray(keys, options) {
    try {
      const res = await this.#objects.getObjects(keys, options);
      return res;
    } catch (e) {
      this._logger.error(`Could not get objects by array: ${e.message}`);
      return [];
    }
  }
  /**
   * stops the execution of adapter, but not disables it.
   *
   * Sometimes, the adapter must be stopped if some libraries are missing.
   *
   * @param reason optional termination description
   * @param exitCode optional exit code
   */
  terminate(reason, exitCode) {
    if (this.terminated) {
      return;
    }
    this.terminated = true;
    this.pluginHandler && this.pluginHandler.destroyAll();
    if (this._reportInterval) {
      clearInterval(this._reportInterval);
      this._reportInterval = null;
    }
    if (this._restartScheduleJob) {
      this._restartScheduleJob.cancel();
      this._restartScheduleJob = null;
    }
    let _reason = "Without reason";
    let _exitCode;
    if (typeof reason === "number") {
      exitCode = reason;
      _reason = "Without reason";
    } else if (reason && typeof reason === "string") {
      _reason = reason;
    }
    if (typeof exitCode !== "number") {
      _exitCode = !this._config.isInstall ? import_js_controller_common.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION : import_js_controller_common.EXIT_CODES.NO_ERROR;
    } else {
      _exitCode = exitCode;
    }
    const isNotCritical = _exitCode === import_js_controller_common.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION || _exitCode === import_js_controller_common.EXIT_CODES.START_IMMEDIATELY_AFTER_STOP || _exitCode === import_js_controller_common.EXIT_CODES.NO_ERROR;
    const text = `${this.namespaceLog} Terminated (${import_validator.Validator.getErrorText(_exitCode)}): ${_reason}`;
    if (isNotCritical) {
      this._logger.info(text);
    } else {
      this._logger.warn(text);
    }
    setTimeout(async () => {
      if (this.#states) {
        try {
          await this.#states.destroy();
        } catch {
        }
      }
      if (this.#objects) {
        try {
          await this.#objects.destroy();
        } catch {
        }
      }
      if (this.startedInCompactMode) {
        this.emit("exit", _exitCode, reason);
        this.#states = null;
        this.#objects = null;
      } else {
        process.exit(_exitCode);
      }
    }, 500);
  }
  /**
   * Helper function to find next free port
   *
   * Looks for first free TCP port starting with given one:
   * ```js
   *     adapter.getPort(8081, function (port) {
   *         adapter.log.debug('Following port is free: ' + port);
   *     });
   * ```
   *
   * @param port port number to start the search for free port
   * @param [host] optional hostname for the port search
   * @param callback return result
   *        ```js
   *        function (port) {}
   *        ```
   */
  getPort(port, host, callback) {
    if (!port) {
      throw new Error("adapterGetPort: no port");
    }
    if (typeof host === "function") {
      callback = host;
      host = null;
    }
    if (typeof port === "string") {
      port = parseInt(port, 10);
    }
    let _host;
    if (!host) {
      _host = void 0;
    } else {
      import_validator.Validator.assertString(host, "host");
      _host = host;
    }
    import_validator.Validator.assertNumber(port, "port");
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    return this._getPort({ port, host: _host, callback });
  }
  _getPort(options) {
    this.getPortRunning = options;
    const server = import_node_net.default.createServer();
    try {
      server.listen({ port: options.port, host: options.host }, () => {
        server.once("close", () => {
          return import_js_controller_common.tools.maybeCallback(options.callback, options.port);
        });
        server.close();
      });
      server.on("error", () => {
        setTimeout(() => this.getPort(options.port + 1, options.host, options.callback), 100);
      });
    } catch {
      setImmediate(() => this.getPort(options.port + 1, options.host, options.callback));
    }
  }
  /**
       * Method to check for available Features for adapter development
       *
       * Use it like ...
       * ```js
       *     if (adapter.supportsFeature && adapter.supportsFeature('ALIAS')) {
       *         ...
       *     }
       * ```
  
       * @param featureName the name of the feature to check
       * @returns true/false if the feature is in the list of supported features
       */
  supportsFeature(featureName) {
    if (typeof featureName === "string") {
      return this.SUPPORTED_FEATURES.includes(featureName);
    }
    return false;
  }
  /**
   * validates user and password
   *
   * @param user user name as text
   * @param pw password as text
   * @param [options] optional user context
   * @param callback return result
   *        ```js
   *            function (result) {
   *              if (result) adapter.log.debug('User is valid');
   *            }
   *        ```
   */
  checkPassword(user, pw, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (!callback) {
      throw new Error("checkPassword: no callback");
    }
    import_validator.Validator.assertCallback(callback, "callback");
    import_validator.Validator.assertString(user, "user");
    import_validator.Validator.assertString(pw, "pw");
    if (options !== void 0 && options !== null) {
      import_validator.Validator.assertObject(options, "options");
    }
    return this._checkPassword({ user, pw, options, callback });
  }
  async _checkPassword(options) {
    let { user } = options;
    const { callback, pw } = options;
    if (user && !user.startsWith("system.user.")) {
      if (!this.usernames[user]) {
        try {
          await this._updateUsernameCache();
        } catch (e) {
          this._logger.error(`${this.namespaceLog} ${e.message}`);
        }
        if (!this.usernames[user]) {
          user = `system.user.${user.toString().replace(this.FORBIDDEN_CHARS, "_").replace(/\s/g, "_").replace(/\./g, "_").toLowerCase()}`;
        } else {
          user = this.usernames[user].id;
        }
      } else {
        user = this.usernames[user].id;
      }
    }
    this.getForeignObject(user, options, (err, obj) => {
      if (err || !obj || !obj.common || !obj.common.enabled && user !== import_constants.SYSTEM_ADMIN_USER) {
        return import_js_controller_common.tools.maybeCallback(callback, false, user);
      }
      (0, import_js_controller_common.password)(pw).check(obj.common.password, (err2, res) => {
        return import_js_controller_common.tools.maybeCallback(callback, !!res, user);
      });
    });
  }
  /**
   * This method update the cached values in `this.usernames`
   */
  async _updateUsernameCache() {
    try {
      const obj = await this.getObjectListAsync({ startkey: "system.user.", endkey: "system.user.\u9999" });
      this.usernames = {};
      for (const row of obj.rows) {
        if (row.value.common && typeof row.value.common.name === "string") {
          this.usernames[row.value.common.name] = { id: row.id.replace(FORBIDDEN_CHARS, "_") };
        } else {
          this._logger.warn(`${this.namespaceLog} Invalid username for id "${row.id}"`);
        }
      }
    } catch (e) {
      throw new Error(`Could not update user cache: ${e.message}`);
    }
  }
  /**
   * Return ID of given username
   *
   * @param username - name of the user
   */
  getUserID(username) {
    import_validator.Validator.assertString(username, "username");
    return this._getUserID({ username });
  }
  async _getUserID(options) {
    if (!this.usernames[options.username]) {
      try {
        await this._updateUsernameCache();
        if (!this.usernames[options.username]) {
          return;
        }
      } catch (e) {
        this._logger.error(`${this.namespaceLog} ${e.message}`);
        return;
      }
    }
    return this.usernames[options.username].id;
  }
  /**
   * sets the user's password
   *
   * @param user user name as text
   * @param pw password as text
   * @param [options] optional user context
   * @param [callback] return result
   *        ```js
   *            function (err) {
   *              if (err) adapter.log.error('Cannot set password: ' + err);
   *            }
   *        ```
   */
  setPassword(user, pw, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    import_validator.Validator.assertString(user, "user");
    import_validator.Validator.assertString(pw, "pw");
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    if (options !== void 0 && options !== null) {
      import_validator.Validator.assertObject(options, "options");
    }
    return this._setPassword({ user, pw, options, callback });
  }
  async _setPassword(options) {
    if (options.user && !options.user.startsWith("system.user.")) {
      if (!this.usernames[options.user]) {
        try {
          await this._updateUsernameCache();
        } catch (e) {
          this._logger.error(`${this.namespaceLog} ${e}`);
        }
        if (!this.usernames[options.user]) {
          options.user = `system.user.${options.user.toString().replace(this.FORBIDDEN_CHARS, "_").replace(/\s/g, "_").replace(/\./g, "_").toLowerCase()}`;
        } else {
          options.user = this.usernames[options.user].id;
        }
      } else {
        options.user = this.usernames[options.user].id;
      }
    }
    this.getForeignObject(options.user, options, (err, obj) => {
      if (err || !obj) {
        return import_js_controller_common.tools.maybeCallbackWithError(options.callback, "User does not exist");
      }
      if (!options.pw) {
        this.extendForeignObject(options.user, {
          common: {
            password: ""
          }
        }, options.options || {}, () => {
          return import_js_controller_common.tools.maybeCallback(options.callback);
        });
      } else {
        (0, import_js_controller_common.password)(options.pw).hash(null, null, (err2, res) => {
          if (err2) {
            return import_js_controller_common.tools.maybeCallbackWithError(options.callback, err2);
          }
          this.extendForeignObject(options.user, {
            common: {
              password: res
            }
          }, options.options || {}, () => {
            return import_js_controller_common.tools.maybeCallbackWithError(options.callback, null);
          });
        });
      }
    });
  }
  /**
   * returns if user exists and is in the group
   *
   * This function used mostly internally and the adapter developer do not require it.
   *
   * @param user user name as text
   * @param group group name
   * @param [options] optional user context
   * @param callback return result
   *        ```js
   *            function (result) {
   *              if (result) adapter.log.debug('User exists and in the group');
   *            }
   *        ```
   */
  checkGroup(user, group, options, callback) {
    user = user || "";
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    import_validator.Validator.assertString(user, "user");
    import_validator.Validator.assertString(group, "group");
    if (options !== void 0 && options !== null) {
      import_validator.Validator.assertObject(options, "options");
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    return this._checkGroup({ user, group, options, callback });
  }
  async _checkGroup(options) {
    if (options.user && !options.user.startsWith("system.user.")) {
      if (!this.usernames[options.user]) {
        try {
          await this._updateUsernameCache();
        } catch (e) {
          this._logger.error(`${this.namespaceLog} ${e}`);
        }
        if (!this.usernames[options.user]) {
          options.user = `system.user.${options.user.toString().replace(this.FORBIDDEN_CHARS, "_").replace(/\s/g, "_").replace(/\./g, "_").toLowerCase()}`;
        } else {
          options.user = this.usernames[options.user].id;
        }
      } else {
        options.user = this.usernames[options.user].id;
      }
    }
    if (options.group && !options.group.startsWith("system.group.")) {
      options.group = `system.group.${options.group}`;
    }
    this.getForeignObject(options.user, options, (err, obj) => {
      if (err || !obj) {
        return import_js_controller_common.tools.maybeCallback(options.callback, false);
      }
      this.getForeignObject(options.group, options, (err2, obj2) => {
        if (err2 || !obj2) {
          return import_js_controller_common.tools.maybeCallback(options.callback, false);
        }
        if (obj2.common.members.includes(options.user)) {
          return import_js_controller_common.tools.maybeCallback(options.callback, true);
        }
        return import_js_controller_common.tools.maybeCallback(options.callback, false);
      });
    });
  }
  /**
   * get the user permissions
   *
   * This function used mostly internally and the adapter developer do not require it.
   * The function reads permissions of user's groups (it can be more than one) and merge permissions together
   *
   * @param  user user name as text
   * @param  commandsPermissions object that describes the access rights like
   *     ```js
   *         // static information
   *         var commandsPermissions = {
   *            getObject:          {type: 'object',    operation: 'read'},
   *            getObjects:         {type: 'object',    operation: 'list'},
   *            getObjectView:      {type: 'object',    operation: 'list'},
   *            setObject:          {type: 'object',    operation: 'write'},
   *            subscribeObjects:   {type: 'object',    operation: 'read'},
   *            unsubscribeObjects: {type: 'object',    operation: 'read'},
   *            subscribeFiles:     {type: 'object',    operation: 'read'},
   *            unsubscribeFiles:   {type: 'object',    operation: 'read'},
   *
   *            getStates:          {type: 'state',     operation: 'list'},
   *            getState:           {type: 'state',     operation: 'read'},
   *            setState:           {type: 'state',     operation: 'write'},
   *            getStateHistory:    {type: 'state',     operation: 'read'},
   *            subscribe:          {type: 'state',     operation: 'read'},
   *            unsubscribe:        {type: 'state',     operation: 'read'},
   *            getVersion:         {type: '',          operation: ''},
   *
   *            httpGet:            {type: 'other',     operation: 'http'},
   *            sendTo:             {type: 'other',     operation: 'sendto'},
   *            sendToHost:         {type: 'other',     operation: 'sendto'},
   *
   *            readFile:           {type: 'file',      operation: 'read'},
   *            readFile64:         {type: 'file',      operation: 'read'},
   *            writeFile:          {type: 'file',      operation: 'write'},
   *            writeFile64:        {type: 'file',      operation: 'write'},
   *            unlink:             {type: 'file',      operation: 'delete'},
   *            rename:             {type: 'file',      operation: 'write'},
   *            mkdir:              {type: 'file',      operation: 'write'},
   *            readDir:            {type: 'file',      operation: 'list'},
   *            chmodFile:          {type: 'file',      operation: 'write'},
   *            chownFile:          {type: 'file',      operation: 'write'},
   *
   *            authEnabled:        {type: '',          operation: ''},
   *            disconnect:         {type: '',          operation: ''},
   *            listPermissions:    {type: '',          operation: ''},
   *            getUserPermissions: {type: 'object',    operation: 'read'}
   *         };
   *        ```
   * @param [options] optional user context
   * @param [callback] return result
   *        ```js
   *            function (acl) {
   *              // Access control object for admin looks like:
   *              // {
   *              //    file: {
   *              //         read:       true,
   *              //         write:      true,
   *              //         'delete':   true,
   *              //         create:     true,
   *              //         list:       true
   *              //     },
   *              //     object: {
   *              //         read:       true,
   *              //         write:      true,
   *              //         'delete':   true,
   *              //         list:       true
   *              //     },
   *              //     state: {
   *              //         read:       true,
   *              //         write:      true,
   *              //         'delete':   true,
   *              //         create:     true,
   *              //         list:       true
   *              //     },
   *              //     user: 'admin',
   *              //     users:  {
   *              //         read:       true,
   *              //         write:      true,
   *              //         create:     true,
   *              //         'delete':   true,
   *              //         list:       true
   *              //     },
   *              //     other: {
   *              //         execute:    true,
   *              //         http:       true,
   *              //         sendto:     true
   *              //     },
   *              //     groups: ['administrator'] // can be more than one
   *              // }
   *            }
   *        ```
   */
  calculatePermissions(user, commandsPermissions, options, callback) {
    user = user || "";
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    import_validator.Validator.assertString(user, "user");
    if (!Array.isArray(commandsPermissions)) {
      import_validator.Validator.assertObject(commandsPermissions, "commandsPermissions");
    }
    if (options !== void 0 && options !== null) {
      import_validator.Validator.assertObject(options, "options");
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    return this._calculatePermissions({ user, commandsPermissions, options, callback });
  }
  async _calculatePermissions(options) {
    const { user } = options;
    let userId;
    if (user && !user.startsWith("system.user.")) {
      if (!this.usernames[options.user]) {
        try {
          await this._updateUsernameCache();
        } catch (e) {
          this._logger.error(`${this.namespaceLog} ${e.message}`);
        }
        if (!this.usernames[user]) {
          userId = `system.user.${user.toString().replace(this.FORBIDDEN_CHARS, "_").replace(/\s/g, "_").replace(/\./g, "_").toLowerCase()}`;
        } else {
          userId = this.usernames[user].id;
        }
      } else {
        userId = this.usernames[user].id;
      }
    } else {
      userId = user;
    }
    let acl = { user: userId };
    if (userId === import_constants.SYSTEM_ADMIN_USER) {
      acl.groups = [import_constants.SYSTEM_ADMIN_GROUP];
      for (const commandPermission of Object.values(options.commandsPermissions)) {
        if (!commandPermission.type) {
          continue;
        }
        acl[commandPermission.type] = acl[commandPermission.type] || {};
        acl[commandPermission.type][commandPermission.operation] = true;
      }
      return import_js_controller_common.tools.maybeCallback(options.callback, acl);
    }
    this.getForeignObjects("*", "group", null, options, (err, groups) => {
      acl.groups = [];
      if (groups) {
        for (const g of Object.keys(groups)) {
          if (groups[g]?.common?.members && groups[g].common.members.includes(userId)) {
            acl.groups.push(groups[g]._id);
            if (groups[g]._id === import_constants.SYSTEM_ADMIN_GROUP) {
              acl = {
                file: {
                  read: true,
                  write: true,
                  delete: true,
                  create: true,
                  list: true
                },
                // @ts-expect-error create is missing
                object: {
                  read: true,
                  write: true,
                  delete: true,
                  list: true
                },
                state: {
                  read: true,
                  write: true,
                  delete: true,
                  create: true,
                  list: true
                },
                user: userId,
                users: {
                  read: true,
                  write: true,
                  create: true,
                  delete: true,
                  list: true
                },
                other: {
                  execute: true,
                  http: true,
                  sendto: true
                },
                groups: acl.groups
              };
              break;
            }
            const gAcl = groups[g].common.acl;
            try {
              for (const type of Object.keys(gAcl)) {
                if (type === "user") {
                  acl.users = acl.users || {};
                } else {
                  acl[type] = acl[type] || {};
                }
                for (const op of Object.keys(gAcl[type])) {
                  if (type === "user") {
                    acl.users[op] = acl.users[op] || gAcl.user[op];
                  } else {
                    acl[type][op] = acl[type][op] || gAcl[type][op];
                  }
                }
              }
            } catch (e) {
              this._logger.error(`${this.namespaceLog} Cannot set acl: ${e.message}`);
              this._logger.error(`${this.namespaceLog} Cannot set acl: ${JSON.stringify(gAcl)}`);
              this._logger.error(`${this.namespaceLog} Cannot set acl: ${JSON.stringify(acl)}`);
            }
          }
        }
      }
      return import_js_controller_common.tools.maybeCallback(options.callback, acl);
    });
  }
  /**
   * Stop an instance gracefully
   *
   * @param options information about the stoppage
   */
  async _stop(options = {}) {
    const { isPause, isScheduled, reason } = options;
    let { exitCode, updateAliveState } = options;
    exitCode = exitCode || (isScheduled ? import_js_controller_common.EXIT_CODES.START_IMMEDIATELY_AFTER_STOP : 0);
    if (updateAliveState === void 0) {
      updateAliveState = true;
    }
    if (!this._stopInProgress || this._config.isInstall) {
      this._stopInProgress = true;
      this._reportInterval && clearInterval(this._reportInterval);
      this._reportInterval = null;
      const id = `system.adapter.${this.namespace}`;
      const finishUnload = async () => {
        if (this._timers.size) {
          this._timers.forEach((timer) => clearTimeout(timer));
          this._timers.clear();
        }
        if (this._intervals.size) {
          this._intervals.forEach((interval) => clearInterval(interval));
          this._intervals.clear();
        }
        if (this._delays.size) {
          this._delays.forEach((timer) => clearTimeout(timer));
          this._delays.clear();
        }
        if (this.messageCallbacks.size) {
          this.messageCallbacks.forEach((callbackObj) => clearTimeout(callbackObj.timer));
          this.messageCallbacks.clear();
        }
        if (this.#states && updateAliveState) {
          this.outputCount++;
          await this.#states.setState(`${id}.alive`, { val: false, ack: true, from: id });
          if (!isPause) {
            this._logger.info(`${this.namespaceLog} terminating`);
          }
          this.terminate(reason, exitCode);
        } else {
          if (!isPause) {
            this._logger.info(`${this.namespaceLog} terminating`);
          }
          this.terminate(reason, exitCode);
        }
      };
      if (this.adapterReady) {
        if (typeof this._options.unload === "function") {
          if (this._options.unload.length >= 1) {
            this._options.unload(finishUnload);
          } else {
            const unloadPromise = this._options.unload();
            if (unloadPromise instanceof Promise) {
              try {
                await unloadPromise;
              } finally {
                finishUnload();
              }
            } else {
              this._logger.error(`${this.namespaceLog} Error in ${id}: The unload method must return a Promise if it does not accept a callback!`);
            }
          }
        } else {
          this.emit("unload", finishUnload);
        }
      }
      setTimeout(() => {
        if (this.#states) {
          finishUnload();
          setTimeout(() => {
            if (!isPause) {
              this._logger.info(`${this.namespaceLog} terminating with timeout`);
            }
            this.terminate(exitCode);
          }, 1e3);
        } else {
          if (!isPause) {
            this._logger.info(`${this.namespaceLog} terminating`);
          }
          this.terminate(exitCode);
        }
      }, this.common?.stopTimeout || 500);
    }
  }
  /**
   * Reads the file certificate from a given path and adds a file watcher to restart adapter on cert changes
   * if a cert is passed it is returned as it is
   *
   * @param cert cert or path to cert
   */
  _readFileCertificate(cert) {
    if (typeof cert === "string") {
      try {
        if (cert.length < 1024 && import_fs_extra.default.existsSync(cert)) {
          const certFile = cert;
          cert = import_fs_extra.default.readFileSync(certFile, "utf8");
          import_fs_extra.default.watch(certFile, (eventType, filename) => {
            this._logger.warn(`${this.namespaceLog} New certificate "${filename}" detected. Restart adapter`);
            setTimeout(() => this._stop({ isPause: false, isScheduled: true }), 2e3);
          });
        }
      } catch (e) {
        this._logger.error(`${this.namespaceLog} Could not read certificate from file ${cert}: ${e.message}`);
      }
    }
    return cert;
  }
  /**
   * returns SSL certificates by name
   *
   * This function returns SSL certificates (private key, public cert and chained certificate).
   * Names are defined in the system's configuration in admin, e.g. "defaultPrivate", "defaultPublic".
   * The result can be directly used for creation of https server.
   *
   * @param [publicName] public certificate name
   * @param [privateName] private certificate name
   * @param [chainedName] optional chained certificate name
   * @param callback return result
   *        ```js
   *            function (err, certs, letsEncrypt) {
   *              adapter.log.debug('private key: ' + certs.key);
   *              adapter.log.debug('public cert: ' + certs.cert);
   *              adapter.log.debug('chained cert: ' + certs.ca);
   *            }
   *        ```
   */
  getCertificates(publicName, privateName, chainedName, callback) {
    if (typeof publicName === "function") {
      callback = publicName;
      publicName = void 0;
    }
    if (typeof privateName === "function") {
      callback = privateName;
      privateName = void 0;
    }
    if (typeof chainedName === "function") {
      callback = chainedName;
      chainedName = void 0;
    }
    const config = this.config;
    publicName = publicName || config.certPublic;
    privateName = privateName || config.certPrivate;
    chainedName = chainedName || config.certChained;
    if (publicName !== void 0) {
      import_validator.Validator.assertString(publicName, "publicName");
    }
    if (privateName !== void 0) {
      import_validator.Validator.assertString(privateName, "privateName");
    }
    if (chainedName !== void 0) {
      import_validator.Validator.assertString(chainedName, "chainedName");
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    return this._getCertificates({ publicName, privateName, chainedName, callback });
  }
  async _getCertificates(options) {
    const { publicName, chainedName, privateName, callback } = options;
    let obj;
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} getCertificates not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    try {
      obj = await this.#objects.getObject("system.certificates");
    } catch {
    }
    if (!obj || !obj.native.certificates || !publicName || !privateName || !obj.native.certificates[publicName] || !obj.native.certificates[privateName] || chainedName && !obj.native.certificates[chainedName]) {
      this._logger.error(`${this.namespaceLog} Cannot configure secure web server, because no certificates found: ${publicName}, ${privateName}, ${chainedName}`);
      if (publicName === "defaultPublic" || privateName === "defaultPrivate") {
        this._logger.info(`${this.namespaceLog} Default certificates seem to be configured but missing. You can execute "iobroker cert create" in your shell to create these.`);
      }
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_NOT_FOUND);
    }
    let ca;
    if (chainedName) {
      const chained = this._readFileCertificate(obj.native.certificates[chainedName]).split("-----END CERTIFICATE-----\r\n");
      if (chained.join("").length >= 512) {
        const caArr = [];
        for (const cert of chained) {
          if (cert.replace(/(\r\n|\r|\n)/g, "").trim()) {
            caArr.push(`${cert}-----END CERTIFICATE-----\r
`);
          }
        }
        ca = caArr.join("");
      }
    }
    return import_js_controller_common.tools.maybeCallbackWithError(callback, null, {
      key: this._readFileCertificate(obj.native.certificates[privateName]),
      cert: this._readFileCertificate(obj.native.certificates[publicName]),
      ca
    }, obj.native.letsEncrypt);
  }
  /**
   * Restarts an instance of the adapter.
   *
   */
  restart() {
    if (this.stop) {
      this._logger.warn(`${this.namespaceLog} Restart initiated`);
      this.stop();
    } else {
      this._logger.warn(`${this.namespaceLog} Cannot initiate restart, because this.stop is not defined`);
    }
  }
  /**
   * Updates the adapter config with new values. Only a subset of the configuration has to be provided,
   * since merging with the existing config is done automatically, e.g., like this:
   *
   * `adapter.updateConfig({prop1: "newValue1"})`
   *
   * After updating the configuration, the adapter is automatically restarted.
   *
   * @param newConfig The new config values to be stored
   */
  updateConfig(newConfig) {
    import_validator.Validator.assertObject(newConfig, "newConfig");
    return this._updateConfig({ newConfig });
  }
  async _updateConfig(options) {
    const { newConfig } = options;
    const configObjId = `system.adapter.${this.namespace}`;
    let obj;
    try {
      obj = await this.getForeignObjectAsync(configObjId);
    } catch (e) {
      this._logger.error(`${this.namespaceLog} Updating the adapter config failed: ${e.message}`);
    }
    if (!obj) {
      throw new Error(import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    const oldConfig = obj.native;
    let mergedConfig;
    if ("encryptedNative" in obj && Array.isArray(obj.encryptedNative)) {
      const secret = await this.getSystemSecret();
      (0, import_utils.decryptArray)({ obj: oldConfig, secret, keys: obj.encryptedNative });
      mergedConfig = { ...oldConfig, ...newConfig };
      (0, import_utils.encryptArray)({ obj: mergedConfig, secret, keys: obj.encryptedNative });
    } else {
      mergedConfig = { ...oldConfig, ...newConfig };
    }
    obj.native = mergedConfig;
    return this.setForeignObjectAsync(configObjId, obj);
  }
  /**
   * Disables and stops the adapter instance.
   *
   */
  async disable() {
    const configObjId = `system.adapter.${this.namespace}`;
    let obj;
    try {
      obj = await this.getForeignObjectAsync(configObjId);
    } catch (e) {
      this._logger.error(`${this.namespaceLog} Disabling the adapter instance failed: ${e.message}`);
    }
    if (!obj) {
      throw new Error(import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    obj.common.enabled = false;
    return this.setForeignObjectAsync(configObjId, obj);
  }
  /**
   * Reads the encrypted parameter from config.
   *
   * It returns promise if no callback is provided.
   *
   * @param attribute - attribute name in native configuration part
   * @param [callback] - optional callback
   */
  getEncryptedConfig(attribute, callback) {
    import_validator.Validator.assertString(attribute, "attribute");
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    return this._getEncryptedConfig({ attribute, callback });
  }
  async _getEncryptedConfig(options) {
    const { attribute, callback } = options;
    const value = this.config[attribute];
    if (typeof value === "string") {
      const secret = await this.getSystemSecret();
      return import_js_controller_common.tools.maybeCallbackWithError(callback, null, import_js_controller_common.tools.decrypt(secret, value));
    }
    return import_js_controller_common.tools.maybeCallbackWithError(callback, `Attribute "${attribute}" not found`);
  }
  /**
   * Get the system secret, after retrieved once it will be read from the cache
   */
  async getSystemSecret() {
    if (this._systemSecret !== void 0) {
      return this._systemSecret;
    }
    try {
      const data = await this.getForeignObjectAsync("system.config");
      if (data?.native) {
        this._systemSecret = data.native.secret;
      }
    } catch {
    }
    this._systemSecret = this._systemSecret || import_constants.DEFAULT_SECRET;
    return this._systemSecret;
  }
  /**
   * Same as setTimeout,
   * but it clears the running timers during the unloading process
   * does not work after unload has been called
   *
   * @param cb - timer callback
   * @param timeout - timeout in milliseconds
   * @param args - as many arguments as needed, which will be passed to setTimeout
   * @returns timer id
   */
  setTimeout(cb, timeout, ...args) {
    if (typeof cb !== "function") {
      this._logger.warn(`${this.namespaceLog} setTimeout expected callback to be of type "function", but got "${typeof cb}"`);
      return;
    }
    if (this._stopInProgress) {
      this._logger.warn(`${this.namespaceLog} setTimeout called, but adapter is shutting down`);
      return;
    }
    import_validator.Validator.assertNumber(timeout, "timeout");
    import_validator.Validator.assertTimeout(timeout);
    const timer = setTimeout.call(null, () => {
      this._timers.delete(timer);
      cb(...args);
    }, timeout);
    this._timers.add(timer);
    return timer;
  }
  /**
   * Same as clearTimeout
   * but it checks the running timers on unload
   *
   * @param timer - the timer object
   */
  clearTimeout(timer) {
    if (timer === void 0) {
      return;
    }
    clearTimeout(timer);
    this._timers.delete(timer);
  }
  /**
   * delays the fulfillment of the promise the amount of time.
   * it will not fulfill during and after adapter shutdown
   *
   * @param timeout - timeout in milliseconds
   * @returns promise when timeout is over
   */
  delay(timeout) {
    if (this._stopInProgress) {
      this._logger.warn(`${this.namespaceLog} delay called, but adapter is shutting down`);
    }
    import_validator.Validator.assertNumber(timeout, "timeout");
    return new Promise((resolve) => {
      const timer = setTimeout(() => {
        this._delays.delete(timer);
        if (!this._stopInProgress) {
          resolve();
        }
      }, timeout);
      this._delays.add(timer);
    });
  }
  /**
   * Same as setInterval
   * but it clears the running intervals during the unload process
   * does not work after unload has been called
   *
   * @param cb - interval callback
   * @param timeout - interval in milliseconds
   * @param args - as many arguments as needed, which will be passed to setTimeout
   * @returns interval interval object
   */
  setInterval(cb, timeout, ...args) {
    if (typeof cb !== "function") {
      this._logger.error(`${this.namespaceLog} setInterval expected callback to be of type "function", but got "${typeof cb}"`);
      return;
    }
    if (this._stopInProgress) {
      this._logger.warn(`${this.namespaceLog} setInterval called, but adapter is shutting down`);
      return;
    }
    import_validator.Validator.assertNumber(timeout, "timeout");
    import_validator.Validator.assertTimeout(timeout);
    const id = setInterval(() => cb(...args), timeout);
    this._intervals.add(id);
    return id;
  }
  /**
   * Same as clearInterval
   * but it checks the running intervals on unload
   *
   * @param interval - interval object
   */
  clearInterval(interval) {
    if (interval === void 0) {
      return;
    }
    clearInterval(interval);
    this._intervals.delete(interval);
  }
  /**
   * Creates or overwrites an object in objectDB.
   *
   * This function can create or overwrite objects in objectDB for this adapter.
   * Only Ids that belong to this adapter can be modified. So the function automatically adds "adapter.X." to ID.
   * <b>common</b>, <b>native</b> and <b>type</b> attributes are mandatory, and it will be checked.
   * Additionally, type "state" requires <b>role</b>, <b>type</b> and <b>name</b>, e.g.:
   * ```js
   * {
   *     common: {
   *          name: 'object name',
   *          type: 'number', // string, boolean, object, mixed, array
   *          role: 'value'   // see https://github.com/ioBroker/ioBroker/blob/master/doc/SCHEMA.md#state-commonrole
   *     },
   *     native: {},
   *     type: 'state' // channel, device
   * }
   * ```
   *
   * @param id object ID, that must be overwritten or created.
   * @param obj new object
   * @param [options] optional user context
   * @param [callback] return result
   *        ```js
   *            function (err, obj) {
   *              // obj is {id: id}
   *              if (err) adapter.log.error('Cannot write object: ' + err);
   *            }
   *        ```
   */
  setObject(id, obj, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    import_validator.Validator.assertString(id, "id");
    import_validator.Validator.assertObject(obj, "obj");
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    return this._setObject({ id, obj, options, callback });
  }
  async _setObject(options) {
    if (!this._defaultObjs) {
      this._defaultObjs = (await import("./defaultObjs.js")).createDefaults();
    }
    if (!options.obj) {
      this._logger.error(`${this.namespaceLog} setObject: try to set null object for ${options.id}`);
      return import_js_controller_common.tools.maybeCallbackWithError(options.callback, import_js_controller_common.tools.ERRORS.ERROR_EMPTY_OBJECT);
    }
    if (!import_js_controller_common.tools.isObject(options.obj)) {
      this._logger.error(`${this.namespaceLog} setForeignObject: type of object parameter expected to be an object, but "${typeof options.obj}" provided`);
      return import_js_controller_common.tools.maybeCallbackWithError(options.callback, import_js_controller_common.tools.ERRORS.ERROR_NO_OBJECT);
    }
    if (options.obj.type !== "meta") {
      try {
        this._utils.validateId(options.id, false, null);
      } catch (e) {
        this._logger.error(import_js_controller_common.tools.appendStackTrace(`${this.namespaceLog} ${e.message}`));
        return;
      }
    }
    if (options.obj.type) {
      if (!options.obj.native) {
        this._logger.warn(`${this.namespaceLog} setObject ${options.id} (type=${options.obj.type}) property native missing!`);
        options.obj.native = {};
      }
      if (!options.obj.common) {
        this._logger.warn(`${this.namespaceLog} setObject ${options.id} (type=${options.obj.type}) property common missing!`);
        options.obj.common = {};
      } else if (options.obj.type === "state") {
        if (options.obj.common.role && this._defaultObjs[options.obj.common.role]) {
          options.obj.common = (0, import_node.default)(true, {}, this._defaultObjs[options.obj.common.role], options.obj.common);
        } else if (!options.obj.common.role) {
          this._logger.warn(`${this.namespaceLog} setObject ${options.id} (type=${options.obj.type}) property common.role missing!`);
        }
        if (!options.obj.common.type) {
          this._logger.warn(`${this.namespaceLog} setObject ${options.id} (type=${options.obj.type}) property common.type missing!`);
        }
        if ("custom" in options.obj.common && options.obj.common.custom !== null && !import_js_controller_common.tools.isObject(options.obj.common.custom)) {
          this._logger.error(`${this.namespaceLog} setObject ${options.id} (type=${options.obj.type}) property common.custom is of type ${typeof options.obj.common.custom}, expected object.`);
          return import_js_controller_common.tools.maybeCallbackWithError(options.callback, "common.custom needs to be an object");
        }
      } else if (options.obj.common) {
        if ("custom" in options.obj.common && options.obj.common.custom !== null) {
          this._logger.warn(`${this.namespaceLog} setObject ${options.id} (type=${options.obj.type}) property common.custom must not exist.`);
          delete options.obj.common.custom;
        }
      }
      if (options.obj.common && !Object.prototype.hasOwnProperty.call(options.obj.common, "name")) {
        options.obj.common.name = options.id;
        this._logger.debug(`${this.namespaceLog} setObject ${options.id} (type=${options.obj.type}) property common.name missing, using id as name`);
      }
      options.id = this._utils.fixId(options.id, false);
      if ("children" in options.obj || "parent" in options.obj) {
        this._logger.warn(`${this.namespaceLog} Do not use parent or children for ${options.id}`);
      }
      options.obj.from = options.obj.from || `system.adapter.${this.namespace}`;
      options.obj.user = options.obj.user || (options.options ? options.options.user : "") || import_constants.SYSTEM_ADMIN_USER;
      options.obj.ts = options.obj.ts || Date.now();
      this._setObjectWithDefaultValue(options.id, options.obj, options.options, options.callback);
    } else {
      this._logger.error(`${this.namespaceLog} setObject ${options.id} mandatory property type missing!`);
      return import_js_controller_common.tools.maybeCallbackWithError(options.callback, "mandatory property type missing!");
    }
  }
  /**
   * Helper method for `set[Foreign]Object[NotExists]` that also sets the default value if one is configured
   *
   * @param id of the object
   * @param obj The object to set
   * @param options optional user context
   * @param callback optional callback
   */
  async _setObjectWithDefaultValue(id, obj, options, callback) {
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} setObject not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    try {
      import_js_controller_common.tools.validateGeneralObjectProperties(obj, false);
    } catch (e) {
      await this.reportDeprecation({
        deprecationMessage: `Object ${id} is invalid: ${e.message}`,
        version: "7.0.0"
      });
    }
    try {
      this._utils.validateId(id, true, options);
    } catch (e) {
      return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
    }
    try {
      const result = await this.#objects.setObjectAsync(id, obj, options);
      if (obj.type === "state" && obj.common && obj.common.def !== void 0 && obj.common.def !== null) {
        const state = await this.getForeignStateAsync(id);
        if (!state || state.val === void 0) {
          await this.setForeignStateAsync(id, {
            val: obj.common.def,
            q: this.constants.STATE_QUALITY.SUBSTITUTE_INITIAL_VALUE,
            ack: true
          });
        }
      }
      return import_js_controller_common.tools.maybeCallbackWithError(callback, null, result);
    } catch (e) {
      return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
    }
  }
  /**
   * Get all states, channels and devices of this adapter.
   *
   * @param callback return result
   *        ```js
   *            function (objects) {
   *                for (var id in objects) {
   *                    adapter.log.debug(id);
   *                }
   *            }
   *        ```
   */
  getAdapterObjects(callback) {
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    return this._getAdapterObjects({ callback });
  }
  async _getAdapterObjects(options) {
    const ret = {};
    const addRows = (rows) => {
      if (rows) {
        for (const { id, value } of rows) {
          ret[id] = value;
        }
      }
    };
    if (!this.#objects) {
      return import_js_controller_common.tools.maybeCallback(options.callback, ret);
    }
    const params = {
      startkey: `${this.namespace}.`,
      endkey: `${this.namespace}.\u9999`,
      include_docs: true
    };
    try {
      const folders = await this.#objects.getObjectViewAsync("system", "folder", params);
      if (folders) {
        addRows(folders.rows);
      }
    } catch {
    }
    try {
      const devices = await this.#objects.getObjectViewAsync("system", "device", params);
      if (devices) {
        addRows(devices.rows);
      }
    } catch {
    }
    try {
      const channels = await this.#objects.getObjectViewAsync("system", "channel", params);
      if (channels) {
        addRows(channels.rows);
      }
    } catch {
    }
    try {
      const states = await this.#objects.getObjectViewAsync("system", "state", params);
      if (states) {
        addRows(states.rows);
      }
    } catch {
    }
    return import_js_controller_common.tools.maybeCallback(options.callback, ret);
  }
  /**
   * Extend some object and create it if it does not exist
   *
   * You can change or extend some object. E.g. existing object is:
   * ```js
   * {
   *   common: {
   *     name: 'Adapter name',
   *     desc: 'Description'
   *   },
   *   type: 'state',
   *   native: {
   *     unused: 'text'
   *  }
   * }
   * ```
   *
   * If following object will be passed as argument
   *
   * ```js
   * {
   *   common: {
   *     desc: 'New description',
   *     min: 0,
   *     max: 100
   *   },
   *   native: {
   *     unused: null
   *   }
   * }
   * ```
   *
   * We will get as output:
   * ```js
   * {
   *   common: {
   *     desc: 'New description',
   *     min: 0,
   *     max: 100
   *   },
   *   type: 'state',
   *   native: {}
   * }
   * ```
   *
   * @param id object ID, that must be extended
   * @param obj part that must be extended
   * @param options optional user context
   * @param callback return result
   *        ```js
   *            function (err, obj) {
   *                if (err) adapter.log.error(err);
   *                // obj is {"id": id}
   *            }
   *        ```
   */
  extendObject(id, obj, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    import_validator.Validator.assertString(id, "id");
    if (!obj) {
      this._logger.error(`${this.namespaceLog} extendObject: try to extend null object for ${id}`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_EMPTY_OBJECT);
    }
    if (!import_js_controller_common.tools.isObject(obj)) {
      this._logger.error(`${this.namespaceLog} extendObject: type of object parameter expected to be an object, but ${typeof obj} provided`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_NO_OBJECT);
    }
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    return this._extendObject({ id, obj, options, callback });
  }
  // TODO: the public return type needs to be defined correctly, probably needs to be discussed
  async _extendObject(options) {
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} extendObject not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(options.callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    try {
      import_js_controller_common.tools.validateGeneralObjectProperties(options.obj, true);
    } catch (e) {
      await this.reportDeprecation({
        deprecationMessage: `Object ${options.id} is invalid: ${e.message}`,
        version: "7.0.0"
      });
    }
    try {
      this._utils.validateId(options.id, false, null);
    } catch (e) {
      return import_js_controller_common.tools.maybeCallbackWithError(options.callback, e);
    }
    options.id = this._utils.fixId(options.id, false);
    options.id = this.fixForbiddenCharsInId(options.id);
    if ("children" in options.obj || "parent" in options.obj) {
      this._logger.warn(`${this.namespaceLog} Do not use parent or children for ${options.id}`);
    }
    let oldObj;
    try {
      oldObj = await this.#objects.getObjectAsync(options.id, options.options);
    } catch (e) {
      return import_js_controller_common.tools.maybeCallbackWithError(options.callback, e);
    }
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} extendObject not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(options.callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    if (oldObj && options.options && import_js_controller_common.tools.isObject(options.options.preserve)) {
      import_js_controller_common.tools.removePreservedProperties(options.options.preserve, oldObj, options.obj);
    }
    if (options.obj && (options.obj.common && "members" in options.obj.common || options.obj.native && "repositories" in options.obj.native || options.obj.native && "certificates" in options.obj.native || options.obj.native && "devices" in options.obj.native)) {
      if (!oldObj) {
        this._logger.error(`${this.namespaceLog} Object ${options.id} not exist!`);
        oldObj = {};
      }
      if (options.obj.native && "repositories" in options.obj.native && oldObj.native && oldObj.native.repositories) {
        oldObj.native.repositories = [];
      }
      if (options.obj.common && "members" in options.obj.common && oldObj.common && oldObj.common.members) {
        oldObj.common.members = [];
      }
      if (options.obj.native && "certificates" in options.obj.native && oldObj.native && oldObj.native.certificates) {
        oldObj.native.certificates = [];
      }
      if (options.obj.native && "devices" in options.obj.native && oldObj.native && oldObj.native.devices) {
        oldObj.native.devices = [];
      }
      options.obj.from = options.obj.from || `system.adapter.${this.namespace}`;
      options.obj.user = options.obj.user || (options.options ? options.options.user : "") || import_constants.SYSTEM_ADMIN_USER;
      options.obj.ts = options.obj.ts || Date.now();
      options.obj = (0, import_node.default)(true, oldObj, options.obj);
      return this.#objects.setObject(options.id, options.obj, options.options, options.callback);
    }
    options.obj.from = options.obj.from || `system.adapter.${this.namespace}`;
    options.obj.user = options.obj.user || (options.options ? options.options.user : "") || import_constants.SYSTEM_ADMIN_USER;
    options.obj.ts = options.obj.ts || Date.now();
    if (options.obj.type && options.obj.type === "state" || !options.obj.type && oldObj && oldObj.type === "state") {
      if (options.obj.common && "custom" in options.obj.common && options.obj.common.custom !== null && !import_js_controller_common.tools.isObject(options.obj.common.custom)) {
        this._logger.error(`${this.namespaceLog} extendObject ${options.id} (type=${options.obj.type}) property common.custom is of type ${typeof options.obj.common.custom}, expected object.`);
        return import_js_controller_common.tools.maybeCallbackWithError(options.callback, "common.custom needs to be an object");
      }
    } else {
      if (options.obj.common && "custom" in options.obj.common && options.obj.common.custom !== null) {
        this._logger.warn(`${this.namespaceLog} setObject ${options.id} (type=${options.obj.type}) property common.custom must not exist.`);
        delete options.obj.common.custom;
      }
    }
    if (!oldObj) {
      return this.setForeignObject(options.id, options.obj, options.options, options.callback);
    }
    try {
      const cbObj = await this.#objects.extendObjectAsync(options.id, options.obj, options.options || {});
      let defState;
      if (options.obj.type === "state" || oldObj.type === "state") {
        if (options.obj.common && "def" in options.obj.common && options.obj.common.def !== void 0) {
          defState = options.obj.common.def;
        } else if (oldObj.common && oldObj.common.def !== void 0) {
          defState = oldObj.common.def;
        }
      }
      if (defState !== void 0) {
        let currentStateObj;
        try {
          currentStateObj = await this.getForeignStateAsync(options.id);
        } catch {
        }
        if (!currentStateObj) {
          try {
            await this.setForeignStateAsync(options.id, {
              val: defState,
              q: this.constants.STATE_QUALITY.SUBSTITUTE_INITIAL_VALUE,
              ack: true
            });
          } catch (e) {
            this._logger.info(`${this.namespaceLog} Default value for state "${options.id}" could not be set: ${e.message}`);
          }
        }
      }
      return import_js_controller_common.tools.maybeCallbackWithError(options.callback, null, cbObj);
    } catch (e) {
      return import_js_controller_common.tools.maybeCallbackWithError(options.callback, e);
    }
  }
  /**
   * Same as {@link AdapterClass.setObject}, but for any object.
   *
   * ID must be specified as a full name with adapter namespace. E.g "hm-rpc.0.ABC98989.1.STATE"
   *
   * @param id object ID, that must be overwritten or created.
   * @param obj new object
   * @param options optional user context
   * @param callback return result
   *        ```js
   *            function (err, obj) {
   *              // obj is {id: id}
   *              if (err) adapter.log.error('Cannot write object: ' + err);
   *            }
   *        ```
   */
  setForeignObject(id, obj, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    import_validator.Validator.assertString(id, "id");
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    if (!obj) {
      this._logger.error(`${this.namespaceLog} setForeignObject: try to set null object for ${id}`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_EMPTY_OBJECT);
    }
    if (!import_js_controller_common.tools.isObject(obj)) {
      this._logger.error(`${this.namespaceLog} setForeignObject: type of object parameter expected to be an object, but ${typeof obj} provided`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_NO_OBJECT);
    }
    return this._setForeignObject({ id, obj, options, callback });
  }
  _setForeignObject(_options) {
    const { options, callback, obj } = _options;
    let { id } = _options;
    obj.from = obj.from || `system.adapter.${this.namespace}`;
    obj.user = obj.user || options?.user || import_constants.SYSTEM_ADMIN_USER;
    obj.ts = obj.ts || Date.now();
    id = this.fixForbiddenCharsInId(id);
    if (obj.common && "alias" in obj.common && obj.common.alias.id) {
      if (typeof obj.common.alias.id === "object") {
        try {
          this._utils.validateId(obj.common.alias.id.write, true, null);
          this._utils.validateId(obj.common.alias.id.read, true, null);
        } catch (e) {
          return import_js_controller_common.tools.maybeCallbackWithError(callback, `Alias id is invalid: ${e.message}`);
        }
        if (obj.common.alias.id.write.startsWith(import_constants.ALIAS_STARTS_WITH) || obj.common.alias.id.read.startsWith(import_constants.ALIAS_STARTS_WITH)) {
          return import_js_controller_common.tools.maybeCallbackWithError(callback, "Aliases cannot be used as target for aliases");
        }
      } else {
        try {
          this._utils.validateId(obj.common.alias.id, true, null);
        } catch (e) {
          return import_js_controller_common.tools.maybeCallbackWithError(callback, `Alias id is invalid: ${e.message}`);
        }
        if (obj.common.alias.id.startsWith(import_constants.ALIAS_STARTS_WITH)) {
          return import_js_controller_common.tools.maybeCallbackWithError(callback, "Aliases cannot be used as target for aliases");
        }
      }
    }
    this._setObjectWithDefaultValue(id, obj, options, callback);
  }
  /**
   * Same as {@link AdapterClass.extendObject}, but for any object.
   *
   * ID must be specified as a full name with adapter namespace. E.g "hm-rpc.0.ABC98989.1.STATE"
   *
   * @param id object ID, that must be extended
   * @param obj part that must be extended
   * @param options optional user context, or use attribute preserve e.g. `{preserve: {common: ['name']}}` to preserve common.name
   * @param callback return result
   *        ```js
   *            function (err, obj) {
   *                // obj is {"id": id}
   *                if (err) adapter.log.error(err);
   *            }
   *        ```
   */
  extendForeignObject(id, obj, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    try {
      this._utils.validateId(id, true, null);
    } catch (e) {
      return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
    }
    import_validator.Validator.assertString(id, "id");
    if (!obj) {
      this._logger.error(`${this.namespaceLog} extendForeignObject: try to set null object for ${id}`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_EMPTY_OBJECT);
    }
    import_validator.Validator.assertObject(obj, "obj");
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    return this._extendForeignObjectAsync({
      id: this.fixForbiddenCharsInId(id),
      obj,
      callback,
      options
    });
  }
  async _extendForeignObjectAsync(_options) {
    const { id, callback, options } = _options;
    let { obj } = _options;
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} extendForeignObject not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    let oldObj;
    try {
      oldObj = await this.#objects.getObjectAsync(id, options);
    } catch (e) {
      return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
    }
    if (oldObj && options && import_js_controller_common.tools.isObject(options.preserve)) {
      import_js_controller_common.tools.removePreservedProperties(options.preserve, oldObj, obj);
    }
    if (obj && (obj.common && "members" in obj.common || obj.native && "repositories" in obj.native || obj.native && "certificates" in obj.native || obj.native && "devices" in obj.native)) {
      if (!oldObj) {
        this._logger.error(`${this.namespaceLog} Object ${id} not exist!`);
        oldObj = {};
      }
      if (obj.native && "repositories" in obj.native && oldObj.native && oldObj.native.repositories) {
        oldObj.native.repositories = [];
      }
      if (obj.common && "members" in obj.common && oldObj.common && oldObj.common.members) {
        oldObj.common.members = [];
      }
      if (obj.native && "certificates" in obj.native && oldObj.native && oldObj.native.certificates) {
        oldObj.native.certificates = [];
      }
      if (obj.native && "devices" in obj.native && oldObj.native && oldObj.native.devices) {
        oldObj.native.devices = [];
      }
      obj.from = obj.from || `system.adapter.${this.namespace}`;
      obj.user = obj.user || options?.user || import_constants.SYSTEM_ADMIN_USER;
      obj.ts = obj.ts || Date.now();
      obj = (0, import_node.default)(true, oldObj, obj);
      return this.#objects.setObject(id, obj, options, callback);
    }
    obj.from = obj.from || `system.adapter.${this.namespace}`;
    obj.user = obj.user || options?.user || import_constants.SYSTEM_ADMIN_USER;
    obj.ts = obj.ts || Date.now();
    if (obj.type && obj.type === "state" || !obj.type && oldObj && oldObj.type === "state") {
      if (obj.common && "custom" in obj.common && obj.common.custom !== null && !import_js_controller_common.tools.isObject(obj.common.custom)) {
        this._logger.error(`${this.namespaceLog} extendObject ${id} (type=${obj.type}) property common.custom is of type ${typeof obj.common.custom}, expected object.`);
        return import_js_controller_common.tools.maybeCallbackWithError(callback, "common.custom needs to be an object");
      }
    } else {
      if (obj.common && "custom" in obj.common && obj.common.custom !== null) {
        this._logger.warn(`${this.namespaceLog} setObject ${id} (type=${obj.type}) property common.custom must not exist.`);
        delete obj.common.custom;
      }
    }
    if (!oldObj) {
      return this.setForeignObject(id, obj, options, callback);
    }
    try {
      const cbObj = await this.#objects.extendObjectAsync(id, obj, options || {});
      if (cbObj?.value.type === "state") {
        let defState;
        if (obj.common && "def" in obj.common && obj.common.def !== void 0) {
          defState = obj.common.def;
        } else if (oldObj.common && oldObj.common.def !== void 0) {
          defState = oldObj.common.def;
        }
        if (defState !== void 0) {
          let currentStateObj;
          try {
            currentStateObj = await this.getForeignStateAsync(id);
          } catch {
          }
          if (!currentStateObj) {
            try {
              await this.setForeignStateAsync(id, {
                val: defState,
                q: this.constants.STATE_QUALITY.SUBSTITUTE_INITIAL_VALUE,
                ack: true
              });
            } catch (e) {
              this._logger.info(`${this.namespaceLog} Default value for state "${id}" could not be set: ${e.message}`);
            }
          }
        }
      }
      return import_js_controller_common.tools.maybeCallbackWithError(callback, null, cbObj);
    } catch (e) {
      return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
    }
  }
  /**
   * Checks if an object exists to the given id, id will be fixed first
   *
   * @param id id of the object
   * @param options optional user context
   */
  objectExists(id, options) {
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} objectExists not processed because Objects database not connected`);
      return Promise.resolve();
    }
    import_validator.Validator.assertString(id, "id");
    if (options !== void 0 && options !== null) {
      import_validator.Validator.assertObject(options, "options");
    }
    id = this._utils.fixId(id);
    this._utils.validateId(id, false, null);
    return this.#objects.objectExists(id, options);
  }
  /**
   * Checks if an object exists to the given id
   *
   * @param id id of the object
   * @param options optional user context
   */
  foreignObjectExists(id, options) {
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} foreignObjectExists not processed because Objects database not connected`);
      return Promise.resolve();
    }
    import_validator.Validator.assertString(id, "id");
    if (options !== void 0 && options !== null) {
      import_validator.Validator.assertObject(options, "options");
    }
    this._utils.validateId(id, true, null);
    return this.#objects.objectExists(id, options);
  }
  /**
   * Get object of this instance.
   *
   * It is not required, that ID consists namespace. E.g. to get object of "adapterName.X.myObject", only "myObject" is required as ID.
   *
   * @param id exactly object ID (without namespace)
   * @param options optional user context
   * @param callback return result
   *        ```js
   *            function (err, obj) {
   *              if (err) adapter.log.error('Cannot get object: ' + err);
   *            }
   *        ```
   */
  getObject(id, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    import_validator.Validator.assertCallback(callback, "callback");
    import_validator.Validator.assertString(id, "id");
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} getObject not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    try {
      this._utils.validateId(id, false, null);
    } catch (e) {
      return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
    }
    this.#objects.getObject(this._utils.fixId(id), options, callback);
  }
  /**
   * Read object view from DB.
   *
   * It is required, that ID consists namespace in startkey and endkey. E.g. `{startkey: 'hm-rpc.' + adapter.instance + '.', endkey: 'hm-rpc.' + adapter.instance + '.\u9999'}`
   * to get all objects of the instance.
   *
   * @param design name of the design
   * @param search name of the view
   * @param params object containing startkey: first id to include in result; endkey: last id to include in result
   * @param options additional objects, e.g. for permissions
   * @param callback return result
   *      ```js
   *          function (err, doc) {
   *              if (doc && doc.rows) {
   *                   for (var i = 0; i < doc.rows.length; i++) {
   *                       var id  = doc.rows[i].id;
   *                        var obj = doc.rows[i].value;
   *                        adapter.log.info('Found ' + id + ': ' + JSON.stringify(obj));
   *                   }
   *                           if (!doc.rows.length) adapter.log.info('No objects found.');
   *               } else {
   *                   adapter.log.info('No objects found: ' + err);
   *               }
   *           }
   *           ```
   */
  getObjectView(design, search, params, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = void 0;
    }
    import_validator.Validator.assertString(design, "design");
    import_validator.Validator.assertString(search, "search");
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    params = params || {};
    import_validator.Validator.assertObject(params, "params");
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    return this._getObjectView({ design, search, params, options, callback });
  }
  _getObjectView(_options) {
    const { design, search, params, options, callback } = _options;
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} getObjectView not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    if (design === "system" && !params.startkey && (!params.endkey || params.endkey === "\u9999")) {
      switch (search) {
        case "host":
          params.startkey = "system.host.";
          params.endkey = "system.host.\u9999";
          break;
        case "adapter":
        case "instance":
        case "instanceStats":
          params.startkey = "system.adapter.";
          params.endkey = "system.adapter.\u9999";
          break;
        case "enum":
          params.startkey = "enum.";
          params.endkey = "enum.\u9999";
          break;
        case "script":
          params.startkey = "script.";
          params.endkey = "script.\u9999";
          break;
        case "group":
          params.startkey = "system.group.";
          params.endkey = "system.group.\u9999";
          break;
        case "user":
          params.startkey = "system.user.";
          params.endkey = "system.user.\u9999";
          break;
        case "config":
          params.startkey = "system.";
          params.endkey = "system.\u9999";
          break;
      }
    }
    return this.#objects.getObjectView(design, search, params, options, callback);
  }
  /**
   * Read object list from DB.
   *
   * It is required, that ID consists namespace in startkey and endkey. E.g. `{startkey: 'hm-rpc.' + adapter.instance + '.', endkey: 'hm-rpc.' + adapter.instance + '.\u9999'}`
   * to get all objects of the instance.
   *
   * @param params startkey and endkey information
   * @param options additional options, e.g. for permissions
   * @param callback optional callback
   *      ```js
   *          function (err, res) {
   *              if (res && res.rows) {
   *                   for (var i = 0; i < res.rows.length; i++) {
   *                       var id  = res.rows[i].id;
   *                       var obj = res.rows[i].value;
   *                       adapter.log.info('Found ' + id + ': ' + JSON.stringify(obj));
   *                   }
   *                   if (!res.rows.length) adapter.log.info('No objects found.');
   *              } else {
   *                  adapter.log.info('No objects found: ' + err);
   *              }
   *          }
   *       ```
   */
  getObjectList(params, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    import_validator.Validator.assertObject(params, "params");
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} getObjectList not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    this.#objects.getObjectList(params, options, callback);
  }
  /**
   * Get the enum tree.
   *
   * Get enums of specified tree or all enums if nothing specified as object with values.
   * If getEnum called with no enum specified, all enums will be returned:
   * ```js
   *      adapter.getEnums(function (err, enums, requestEnum) {
   *        // All enums
   *        if (err) adapter.log.error('Cannot get object: ' + err);
   *        for (var e in enums) {
   *           adapter.log.debug('Enum "' + e + '" has following members: ' + enums[e].common.members.join(', '));
   *        }
   *      });
   * ```
   *
   * @param _enum enum name, e.g. 'rooms', 'function' or '' (all enums)
   * @param options optional user context
   * @param callback return result
   *        ```js
   *            function (err, enums, requestEnum) {
   *              // requestEnum is _enum
   *              if (err) adapter.log.error('Cannot get object: ' + err);
   *              for (var e in enums) {
   *                 adapter.log.debug('Enum "' + e + '" has following members: ' + enums[e].common.members.join(', '));
   *              }
   *            }
   *        ```
   */
  getEnum(_enum, options, callback) {
    if (typeof _enum === "function") {
      callback = _enum;
      options = null;
      _enum = "";
    }
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    import_validator.Validator.assertString(_enum, "_enum");
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    return this._getEnum({ _enum, options, callback });
  }
  _getEnum(_options) {
    const { options, callback } = _options;
    let { _enum } = _options;
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} getEnum not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    if (!_enum.startsWith("enum.")) {
      _enum = `enum.${_enum}`;
    }
    const result = {};
    this.#objects.getObjectView("system", "enum", {
      startkey: `${_enum}.`,
      endkey: `${_enum}.\u9999`
    }, options, (err, res) => {
      if (err) {
        return import_js_controller_common.tools.maybeCallbackWithError(callback, err);
      }
      if (res?.rows) {
        for (const row of res.rows) {
          result[row.id] = row.value;
        }
      }
      return import_js_controller_common.tools.maybeCallbackWithError(callback, err, result, _enum);
    });
  }
  /**
   * Read the members of given enums.
   *
   * Get enums of specified tree or all enums if nothing specified as object with values.
   *
   * @param _enumList enum name or names, e.g. ['rooms', 'function']
   * @param options optional user context
   * @param callback return result
   *        ```js
   *            function (err, enums) {
   *              // requestEnum is _enum
   *              if (err) adapter.log.error('Cannot get object: ' + err);
   *              // Result is like
   *              // {
   *              //    "enum.rooms": {
   *              //       "enum.rooms.livingroom": {
   *              //           common: {
   *              //              members: ['ID1', 'ID2']
   *              //           }
   *              //       },
   *              //       "enum.rooms.sleepingroom": {
   *              //           common: {
   *              //              members: ['ID3', 'ID4']
   *              //           }
   *              //       }
   *              //    },
   *              //    "enum.functions": {
   *              //       "enum.rooms.light": {
   *              //           common: {
   *              //              members: ['ID1', 'ID6']
   *              //           }
   *              //       },
   *              //       "enum.rooms.weather": {
   *              //           common: {
   *              //              members: ['ID4', 'ID7']
   *              //           }
   *              //       }
   *              //    }
   *              // }
   *            }
   *        ```
   */
  getEnums(_enumList, options, callback) {
    if (typeof _enumList === "function") {
      callback = _enumList;
      _enumList = void 0;
    }
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    return this._getEnums({ _enumList, options, callback });
  }
  async _getEnums(_options) {
    const { options, callback } = _options;
    let { _enumList } = _options;
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} getEnums not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    const _enums = {};
    if (_enumList) {
      if (typeof _enumList === "string") {
        _enumList = [_enumList];
      }
      const promises = [];
      for (const currEnum of _enumList) {
        promises.push(new Promise((resolve, reject) => this.getEnum(currEnum, options, (err, list, _enum) => {
          if (err) {
            return reject(err);
          } else if (list && _enum) {
            _enums[_enum] = list;
          }
          resolve();
        })));
      }
      try {
        await Promise.all(promises);
        return import_js_controller_common.tools.maybeCallbackWithError(callback, null, _enums);
      } catch (e) {
        return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
      }
    } else {
      this.#objects.getObjectView("system", "enum", {
        startkey: "enum.",
        endkey: "enum.\u9999"
      }, options, (err, res) => {
        if (err) {
          return import_js_controller_common.tools.maybeCallbackWithError(callback, err);
        }
        const result = {};
        if (res?.rows) {
          for (const row of res.rows) {
            const parts = row.id.split(".", 3);
            if (!parts[2]) {
              continue;
            }
            if (!result[`${parts[0]}.${parts[1]}`]) {
              result[`${parts[0]}.${parts[1]}`] = {};
            }
            result[`${parts[0]}.${parts[1]}`][row.id] = row.value;
          }
        }
        return import_js_controller_common.tools.maybeCallbackWithError(callback, err, result);
      });
    }
  }
  /**
   * Get objects by pattern, by specific type and resolve their enums.
   *
   * Get all objects in the system of specified type. E.g.:
   *
   * ```js
   * adapter.getForeignObjects('hm-rega.0.*', 'state', ['rooms', 'functions'], function (err, objs) {
   *   if (err) adapter.log.error('Cannot get object: ' + err);
   *   // objs look like:
   *   // {
   *   //    "hm-rega.0.ABC0000.1.STATE": {
   *   //        common: {...},
   *   //        native: {},
   *   //        type: 'state',
   *   //        enums: {
   *   //           'enums.rooms.livingroom': 'Living room',
   *   //           'enums.functions.light': 'Light'
   *   //       }
   *   //    },
   *   //    "hm-rega.0.ABC0000.2.STATE": {
   *   //        common: {...},
   *   //        native: {},
   *   //        type: 'state',
   *   //        enums: {
   *   //           'enums.rooms.sleepingroom': 'Sleeping room',
   *   //           'enums.functions.window': 'Windows'
   *   //       }
   *   //    }
   * }
   * ```
   *
   * @param pattern object ID/wildcards
   * @param type type of object: 'state', 'channel' or 'device'. Default - 'state'
   * @param enums object ID, that must be overwritten or created.
   * @param options optional user context
   * @param callback return result
   *        ```js
   *            function (err, obj) {
   *              if (err) adapter.log.error('Cannot get object: ' + err);
   *            }
   *        ```
   */
  getForeignObjects(pattern, type, enums, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    if (typeof enums === "function") {
      callback = enums;
      enums = void 0;
    }
    if (typeof type === "function") {
      callback = type;
      type = void 0;
    }
    if (typeof type === "object") {
      options = type;
      type = void 0;
    }
    if (typeof enums === "object" && !Array.isArray(enums)) {
      options = enums;
      enums = void 0;
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    import_validator.Validator.assertPattern(pattern, "pattern");
    if (type !== void 0) {
      import_validator.Validator.assertString(type, "type");
    }
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    return this._getForeignObjects({
      pattern,
      type,
      enums,
      options,
      callback
    });
  }
  async _getForeignObjects(_options) {
    const { options, callback, type, pattern, enums } = _options;
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} getForeignObjects not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    let objs;
    if (Array.isArray(pattern)) {
      try {
        objs = await this.#objects.getObjects(pattern, options);
      } catch (e) {
        return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
      }
    } else {
      let params = {};
      if (pattern && pattern !== "*") {
        params = {
          startkey: pattern.replace(/\*/g, ""),
          endkey: pattern.replace(/\*/g, "\u9999")
        };
      }
      try {
        const res = await this.#objects.getObjectView("system", type || "state", params, options);
        objs = res.rows.map((row) => row.value);
      } catch (e) {
        return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
      }
    }
    let _enums;
    try {
      _enums = await this.getEnumsAsync(enums);
    } catch (e) {
      this._logger.warn(`Cannot get enums on getForeignObjects: ${e.message}`);
    }
    const list = {};
    for (let i = 0; i < objs.length; i++) {
      const obj = objs[i];
      if (!obj) {
        this._logger.debug(`${this.namespaceLog} getEnums(${JSON.stringify(enums)}) returned an enum without a value at index ${i}, obj - ${JSON.stringify(obj)}`);
        continue;
      }
      const id = obj._id;
      list[id] = obj;
      if (_enums && id) {
        const parts = id.split(".");
        parts.splice(parts.length - 1, 1);
        const channel = parts.join(".");
        parts.splice(parts.length - 1, 1);
        const device = parts.join(".");
        list[id].enums = {};
        for (const _enum of Object.values(_enums)) {
          for (const [enumID, enumObj] of Object.entries(_enum)) {
            if (!enumObj?.common?.members) {
              continue;
            }
            if (enumObj.common.members.includes(id) || enumObj.common.members.includes(channel) || enumObj.common.members.includes(device)) {
              list[id].enums[enumID] = enumObj.common.name;
            }
          }
        }
      }
      if (obj && "protectedNative" in obj && Array.isArray(obj.protectedNative) && obj.native && id && id.startsWith("system.adapter.") && !import_constants.NO_PROTECT_ADAPTERS.includes(this.name) && this.name !== id.split(".")[2]) {
        for (const attr of obj.protectedNative) {
          delete obj.native[attr];
        }
      }
    }
    return import_js_controller_common.tools.maybeCallbackWithError(callback, null, list);
  }
  /**
   * Find any object by name or ID.
   *
   * Find object by the exact name or ID.
   *
   * @param id exactly object ID (without namespace)
   * @param type optional common.type of state: 'number', 'string', 'boolean', 'file', ...
   * @param options optional user context
   * @param callback return result
   *        ```js
   *            adapter.findForeignObject('Some name', function (err, id, name) {
   *              if (err) adapter.log.error('Cannot get object: ' + err);
   *              adapter.log.debug('ID of object with name "' + name + '" is "' + id + '"');
   *            }
   *        ```
   */
  findForeignObject(id, type, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    if (typeof type === "function") {
      callback = type;
      type = null;
    }
    import_validator.Validator.assertCallback(callback, "callback");
    if (type !== null) {
      import_validator.Validator.assertString(type, "type");
    }
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} findForeignObject not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    try {
      this._utils.validateId(id, true, null);
    } catch (e) {
      return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
    }
    this.#objects.findObject(id, type, options || {}, callback);
  }
  /**
   * Get any object.
   *
   * ID must be specified with namespace.
   *
   * @param id exactly object ID (with namespace)
   * @param options optional user context
   * @param callback return result
   *        ```js
   *            function (err, obj) {
   *              if (err) adapter.log.error('Cannot get object: ' + err);
   *            }
   *        ```
   */
  getForeignObject(id, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    if (options !== void 0 && options !== null) {
      import_validator.Validator.assertObject(options, "options");
    }
    try {
      this._utils.validateId(id, true, options);
    } catch (e) {
      return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
    }
    return this._getForeignObject({ id, options, callback });
  }
  async _getForeignObject(options) {
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} getForeignObject not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(options.callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    try {
      const obj = await this.#objects.getObjectAsync(options.id, options);
      if (obj && "protectedNative" in obj && Array.isArray(obj.protectedNative) && obj._id && obj._id.startsWith("system.adapter.") && obj.native && !import_constants.NO_PROTECT_ADAPTERS.includes(this.name) && this.name !== obj._id.split(".")[2]) {
        for (const attr of obj.protectedNative) {
          delete obj.native[attr];
        }
      }
      return import_js_controller_common.tools.maybeCallbackWithError(options.callback, null, obj);
    } catch (e) {
      return import_js_controller_common.tools.maybeCallbackWithError(options.callback, e);
    }
  }
  /**
   * Delete an object of this instance.
   *
   * It is not required to provide the adapter namespace, because it will automatically be added.
   * E.g. to delete "adapterName.X.myObject", only "myObject" is required as ID.
   *
   * The corresponding state will be deleted too if the object has type "state".
   *
   * @param id exactly object ID (without namespace)
   * @param options optional user context. E.g. recursive option could be true
   * @param callback return result
   *        ```js
   *            function (err) {
   *              if (err) adapter.log.error('Cannot delete object: ' + err);
   *            }
   *        ```
   */
  delObject(id, options, callback) {
    import_validator.Validator.assertString(id, "id");
    id = this._utils.fixId(id);
    this.delForeignObject(id, options, callback);
  }
  _deleteObjects(tasks, options, cb) {
    if (!tasks || !tasks.length) {
      return import_js_controller_common.tools.maybeCallback(cb);
    }
    const task = tasks.shift();
    this.#objects.delObject(task.id, options, async (err) => {
      if (err) {
        return import_js_controller_common.tools.maybeCallbackWithError(cb, err);
      }
      if (task.state) {
        try {
          await this.delForeignStateAsync(task.id, options);
        } catch (e) {
          this._logger.warn(`${this.namespaceLog} Could not remove state of ${task.id}: ${e.message}`);
        }
      }
      try {
        await import_js_controller_common.tools.removeIdFromAllEnums(this.#objects, task.id, this.enums);
      } catch (e) {
        this._logger.warn(`${this.namespaceLog} Could not remove ${task.id} from enums: ${e.message}`);
      }
      setImmediate(() => this._deleteObjects(tasks, options, cb));
    });
  }
  /**
   * Delete any object.
   *
   * The full ID with namespace must be specified. The corresponding state will be deleted too if the object has type "state".
   *
   * @param id exactly object ID (with namespace)
   * @param options optional user context or `{ recursive: true }` to delete all underlying objects
   * @param callback return result
   *        ```js
   *            function (err) {
   *              if (err) adapter.log.error('Cannot delete object: ' + err);
   *            }
   *        ```
   */
  delForeignObject(id, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    import_validator.Validator.assertString(id, "id");
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    if (options !== void 0 && options !== null) {
      import_validator.Validator.assertObject(options, "options");
    }
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} delForeignObject not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    try {
      this._utils.validateId(id, true, options);
    } catch (e) {
      return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
    }
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    return this._delForeignObject({ id, options, callback });
  }
  _delForeignObject(_options) {
    const { id, options, callback } = _options;
    if (options?.recursive) {
      this.#objects.getObject(id, options, (err, obj) => {
        const tasks = obj && (!obj.common || !obj.common.dontDelete) ? [{ id, state: obj.type === "state" }] : [];
        const selector = { startkey: `${id}.`, endkey: `${id}.\u9999` };
        this.#objects.getObjectList(selector, options, (err2, res) => {
          res && res.rows.forEach((item) => !tasks.find((task) => task.id === item.id) && (!item.value || !item.value.common || !item.value.common.dontDelete) && // exclude objects with dontDelete flag
          tasks.push({ id: item.id, state: item.value && item.value.type === "state" }));
          this._deleteObjects(tasks, options, callback);
        });
      });
    } else {
      this.#objects.getObject(id, options, async (err, obj) => {
        if (err) {
          return import_js_controller_common.tools.maybeCallbackWithError(callback, err);
        } else if (obj) {
          if (obj.common?.dontDelete) {
            return import_js_controller_common.tools.maybeCallbackWithError(callback, new Error("not deletable"));
          }
          try {
            await this.#objects.delObject(obj._id, options);
          } catch (e) {
            return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
          }
          if (obj.type === "state") {
            try {
              await this.delForeignStateAsync(id, options);
            } catch {
            }
          }
          try {
            await import_js_controller_common.tools.removeIdFromAllEnums(this.#objects, id, this.enums);
          } catch (e) {
            return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
          }
        }
        return import_js_controller_common.tools.maybeCallback(callback);
      });
    }
  }
  /**
   * Subscribe for the changes of objects in this instance.
   *
   * @param pattern pattern like 'channel.*' or '*' (all objects of this adapter) - without namespaces
   * @param options optional user context
   * @param callback optional returns result
   *        ```js
   *            function (err) {
   *              if (err) adapter.log.error('Cannot subscribe object: ' + err);
   *            }
   *        ```
   */
  subscribeObjects(pattern, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = void 0;
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    import_validator.Validator.assertPattern(pattern, "pattern");
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} subscribeObjects not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    if (pattern === "*") {
      this.#objects.subscribeUser(`${this.namespace}.*`, options, callback);
    } else {
      const fixedPattern = Array.isArray(pattern) ? pattern : this._utils.fixId(pattern, true);
      this.#objects.subscribeUser(fixedPattern, options, callback);
    }
  }
  /**
   * Unsubscribe on the changes of objects in this instance.
   *
   * @param pattern pattern like 'channel.*' or '*' (all objects) - without namespaces
   * @param options optional user context
   * @param callback optional returns result
   *        ```js
   *            function (err) {
   *              if (err) adapter.log.error('Cannot unsubscribe object: ' + err);
   *            }
   *        ```
   */
  unsubscribeObjects(pattern, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = void 0;
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    import_validator.Validator.assertPattern(pattern, "pattern");
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} unsubscribeObjects not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    if (pattern === "*") {
      this.#objects.unsubscribeUser(`${this.namespace}.*`, options, callback);
    } else {
      const fixedPattern = Array.isArray(pattern) ? pattern : this._utils.fixId(pattern, true);
      this.#objects.unsubscribeUser(fixedPattern, options, callback);
    }
  }
  /**
   * Subscribe for the changes of objects in any instance.
   *
   * @param pattern pattern like 'channel.*' or '*' (all objects) - without namespaces. You can use array of patterns
   * @param options optional user context
   * @param callback optional returns result
   *        ```js
   *            function (err) {
   *              if (err) adapter.log.error('Cannot subscribe object: ' + err);
   *            }
   *        ```
   */
  subscribeForeignObjects(pattern, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = void 0;
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    import_validator.Validator.assertPattern(pattern, "pattern");
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} subscribeForeignObjects not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    this.#objects.subscribeUser(pattern, options, callback);
  }
  /**
   * Unsubscribe for the patterns on all objects.
   *
   * @param pattern pattern like 'channel.*' or '*' (all objects) - without namespaces
   * @param options optional user context
   * @param callback optional returns result
   *        ```js
   *            function (err) {
   *              if (err) adapter.log.error('Cannot unsubscribe object: ' + err);
   *            }
   *        ```
   */
  unsubscribeForeignObjects(pattern, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = void 0;
    }
    if (!pattern) {
      pattern = "*";
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    import_validator.Validator.assertPattern(pattern, "pattern");
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} unsubscribeForeignObjects not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    this.#objects.unsubscribeUser(pattern, options, callback);
  }
  /**
   * Subscribe for the changes of files in specific instance.
   *
   * @param id adapter ID like 'vis-2.0' or 'vis-2.admin'
   * @param pattern pattern like 'channel.*' or '*' (all files) - without namespaces. You can use array of patterns
   * @param options optional user context
   */
  subscribeForeignFiles(id, pattern, options) {
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} subscribeForeignFiles not processed because Objects database not connected`);
      throw new Error(import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    import_validator.Validator.assertString(id, "id");
    import_validator.Validator.assertPattern(pattern, "pattern");
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    return this.#objects.subscribeUserFile(id, pattern, options);
  }
  /**
   * Unsubscribe for the changes of files on specific instance.
   *
   * @param id adapter ID like 'vis-2.0' or 'vis-2.admin'
   * @param pattern pattern like 'channel.*' or '*' (all objects) - without namespaces
   * @param options optional user context
   */
  unsubscribeForeignFiles(id, pattern, options) {
    if (!pattern) {
      pattern = "*";
    }
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} unsubscribeForeignFiles not processed because Objects database not connected`);
      throw new Error(import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    import_validator.Validator.assertString(id, "id");
    import_validator.Validator.assertPattern(pattern, "pattern");
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    return this.#objects.unsubscribeUserFile(id, pattern, options);
  }
  /**
   * Same as {@link AdapterClass.setObject}, but with check if the object exists.
   *
   * Only Ids that belong to this adapter can be modified. So the function automatically adds "adapter.X." to ID.
   * New object will be created only if no object exists with such ID.
   *
   * @param id object ID, that must be overwritten or created.
   * @param obj new object
   * @param options optional user context
   * @param callback return result
   *        ```js
   *            function (err, obj) {
   *              // obj is {id: id}
   *              if (err) adapter.log.error('Cannot write object: ' + err);
   *            }
   *        ```
   */
  setObjectNotExists(id, obj, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    if (options !== void 0 && options !== null) {
      import_validator.Validator.assertObject(options, "options");
    }
    import_validator.Validator.assertObject(obj, "obj");
    try {
      this._utils.validateId(id, false, null);
    } catch (e) {
      return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
    }
    return this._setObjectNotExists({
      id: this.fixForbiddenCharsInId(this._utils.fixId(id)),
      obj,
      options,
      callback
    });
  }
  async _setObjectNotExists(options) {
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} setObjectNotExists not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(options.callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    if ("children" in options.obj || "parent" in options.obj) {
      this._logger.warn(`${this.namespaceLog} Do not use parent or children for ${options.id}`);
    }
    let objExists;
    try {
      objExists = await this.#objects.objectExists(options.id, options.options);
    } catch (e) {
      return import_js_controller_common.tools.maybeCallbackWithError(options.callback, `Could not check object existence of ${options.id}: ${e.message}`);
    }
    if (objExists === false) {
      if (!options.obj.from) {
        options.obj.from = `system.adapter.${this.namespace}`;
      }
      if (!options.obj.user) {
        options.obj.user = (options.options ? options.options.user : "") || import_constants.SYSTEM_ADMIN_USER;
      }
      if (!options.obj.ts) {
        options.obj.ts = Date.now();
      }
      return this._setObjectWithDefaultValue(options.id, options.obj, null, options.callback);
    }
    return import_js_controller_common.tools.maybeCallbackWithError(options.callback, null);
  }
  /**
   * Same as {@link AdapterClass.setForeignObject}, but with check if the object exists.
   *
   * ID must be specified as a full name with adapter namespace. E.g "hm-rpc.0.ABC98989.1.STATE".
   * New object will be created only if no object exists with such ID.
   *
   * @param id object ID, that must be overwritten or created.
   * @param obj new object
   * @param options user context
   * @param callback return result
   *        ```js
   *            function (err, obj) {
   *              // obj is {id: id}
   *              if (err) adapter.log.error('Cannot write object: ' + err);
   *            }
   *        ```
   */
  setForeignObjectNotExists(id, obj, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    import_validator.Validator.assertString(id, "id");
    import_validator.Validator.assertObject(obj, "obj");
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    return this._setForeignObjectNotExists({ id, obj, options, callback });
  }
  async _setForeignObjectNotExists(_options) {
    const { id, obj, options, callback } = _options;
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} setForeignObjectNotExists not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    try {
      this._utils.validateId(id, true, null);
    } catch (e) {
      return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
    }
    let objExists;
    try {
      objExists = await this.#objects.objectExists(id, options || {});
    } catch (e) {
      return import_js_controller_common.tools.maybeCallbackWithError(callback, `Could not check object existence of ${id}: ${e.message}`);
    }
    if (objExists === false) {
      if (!obj.from) {
        obj.from = `system.adapter.${this.namespace}`;
      }
      if (!obj.user) {
        obj.user = options?.user || import_constants.SYSTEM_ADMIN_USER;
      }
      if (!obj.ts) {
        obj.ts = Date.now();
      }
      return this._setObjectWithDefaultValue(id, obj, null, callback);
    }
    return import_js_controller_common.tools.maybeCallbackWithError(callback, null);
  }
  _DCS2ID(device, channel, stateOrPoint) {
    let id = "";
    if (device) {
      id += device;
    }
    if (channel) {
      id += (id ? "." : "") + channel;
    }
    if (typeof stateOrPoint === "string") {
      if (stateOrPoint) {
        id += (id ? "." : "") + stateOrPoint;
      }
    } else if (stateOrPoint === true && id) {
      id += ".";
    }
    return id;
  }
  /**
   * @param deviceName
   * @param common
   * @param _native
   * @param options
   * @param callback
   * @deprecated use `this.extendObject` instead
   */
  createDevice(deviceName, common, _native, options, callback) {
    this._logger.info(`${this.namespaceLog} Method "createDevice" is deprecated and will be removed in js-controller 7.1, use "extendObject/setObjectNotExists" instead`);
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    if (!deviceName) {
      this._logger.error(`${this.namespaceLog} Try to create device with empty name!`);
      return;
    }
    if (typeof _native === "function") {
      callback = _native;
      _native = {};
    }
    if (typeof common === "function") {
      callback = common;
      common = {};
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    import_validator.Validator.assertString(deviceName, "deviceName");
    if (_native !== void 0 && _native !== null) {
      import_validator.Validator.assertObject(_native, "_native");
    }
    return this._createDevice({
      common,
      deviceName,
      _native,
      callback,
      options
    });
  }
  _createDevice(_options) {
    let { common, deviceName, _native } = _options;
    const { callback, options } = _options;
    common = common || {};
    common.name = common.name || deviceName;
    deviceName = deviceName.replace(FORBIDDEN_CHARS, "_").replace(/\./g, "_");
    _native = _native || {};
    this.setObjectNotExists(deviceName, {
      type: "device",
      common,
      native: _native
    }, options, callback);
  }
  /**
   * Name of channel must be in format "channel"
   *
   * @param parentDevice
   * @param channelName
   * @param roleOrCommon
   * @param _native
   * @param options
   * @param callback
   * @deprecated use `this.extendObject` instead
   */
  createChannel(parentDevice, channelName, roleOrCommon, _native, options, callback) {
    this._logger.info(`${this.namespaceLog} Method "createChannel" is deprecated and will be removed in js-controller 7.1, use "extendObject/setObjectNotExists" instead`);
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    if (!channelName) {
      throw new Error("Cannot create a channel without a name!");
    }
    if (typeof _native === "function") {
      callback = _native;
      _native = {};
    }
    if (typeof roleOrCommon === "function") {
      callback = roleOrCommon;
      roleOrCommon = void 0;
    }
    let common = {};
    if (typeof roleOrCommon === "string") {
      common = {
        name: "",
        role: roleOrCommon
      };
    } else if (import_js_controller_common.tools.isObject(roleOrCommon)) {
      common = roleOrCommon;
    }
    import_validator.Validator.assertObject(common, "common");
    import_validator.Validator.assertString(channelName, "channelName");
    import_validator.Validator.assertString(parentDevice, "parentDevice");
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    common.name = common.name || channelName;
    if (parentDevice) {
      parentDevice = parentDevice.replace(FORBIDDEN_CHARS, "_").replace(/\./g, "_");
    }
    channelName = channelName.replace(FORBIDDEN_CHARS, "_").replace(/\./g, "_");
    channelName = this._DCS2ID(parentDevice, channelName);
    _native = _native || {};
    const obj = {
      type: "channel",
      common,
      native: _native
    };
    this.setObjectNotExists(channelName, obj, options, callback);
  }
  /**
   * @param parentDevice
   * @param parentChannel
   * @param stateName
   * @param roleOrCommon
   * @param _native
   * @param options
   * @param callback
   * @deprecated use `this.extendObject` instead
   */
  createState(parentDevice, parentChannel, stateName, roleOrCommon, _native, options, callback) {
    this._logger.info(`${this.namespaceLog} Method "createState" is deprecated and will be removed in js-controller 7.1, use "extendObject/setObjectNotExists" instead`);
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    if (!stateName) {
      throw new Error("Cannot create a state without a name!");
    }
    if (typeof _native === "function") {
      callback = _native;
      _native = {};
    }
    if (typeof roleOrCommon === "function") {
      callback = roleOrCommon;
      roleOrCommon = void 0;
    }
    let common = {};
    if (typeof roleOrCommon === "string") {
      common = {
        read: true,
        write: false,
        name: "",
        role: roleOrCommon
      };
    } else if (import_js_controller_common.tools.isObject(roleOrCommon)) {
      common = roleOrCommon;
    }
    _native = _native || {};
    import_validator.Validator.assertObject(common, "common");
    import_validator.Validator.assertString(stateName, "stateName");
    import_validator.Validator.assertString(parentDevice, "parentDevice");
    import_validator.Validator.assertString(parentChannel, "parentChannel");
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    import_validator.Validator.assertObject(_native, "_native");
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    return this._createState({ parentDevice, parentChannel, callback, stateName, common, _native, options });
  }
  _createState(_options) {
    const { _native, common, callback, options } = _options;
    let { parentChannel, parentDevice, stateName } = _options;
    common.name = common.name || stateName;
    common.read = common.read === void 0 ? true : common.read;
    common.write = common.write === void 0 ? false : common.write;
    if (!common.role) {
      this._logger.error(`${this.namespaceLog} Try to create state ${parentDevice ? `${parentDevice}.` : ""}${parentChannel}.${stateName} without role`);
      return;
    }
    if (parentDevice) {
      parentDevice = parentDevice.replace(FORBIDDEN_CHARS, "_").replace(/\./g, "_");
    }
    if (parentChannel) {
      parentChannel = parentChannel.replace(FORBIDDEN_CHARS, "_").replace(/\./g, "_");
    }
    stateName = stateName.replace(FORBIDDEN_CHARS, "_").replace(/\./g, "_");
    const id = this._utils.fixId({
      device: parentDevice,
      channel: parentChannel,
      state: stateName
    });
    if (common.type !== void 0 && common.type === "number") {
      let min = 0;
      let max = 0;
      let def = 0;
      let err;
      if (common.min !== void 0) {
        min = common.min;
        if (typeof min !== "number") {
          min = parseFloat(min);
          if (isNaN(min)) {
            err = `Wrong type of ${id}.common.min`;
            this._logger.error(`${this.namespaceLog} ${err}`);
            return import_js_controller_common.tools.maybeCallbackWithError(callback, err);
          }
          common.min = min;
        }
      }
      if (common.max !== void 0) {
        max = common.max;
        if (typeof max !== "number") {
          max = parseFloat(max);
          if (isNaN(max)) {
            err = `Wrong type of ${id}.common.max`;
            this._logger.error(`${this.namespaceLog} ${err}`);
            return import_js_controller_common.tools.maybeCallbackWithError(callback, err);
          }
          common.max = max;
        }
      }
      if (common.def !== void 0) {
        def = common.def;
        if (typeof def !== "number") {
          def = parseFloat(def);
          if (isNaN(def)) {
            err = new Error(`Wrong type of ${id}.common.def`);
            this._logger.error(`${this.namespaceLog} ${err.message}`);
            return import_js_controller_common.tools.maybeCallbackWithError(callback, err);
          }
          common.def = def;
        }
      }
      if (common.min !== void 0 && common.max !== void 0 && min > max) {
        common.max = min;
        common.min = max;
      }
      if (common.def !== void 0 && common.min !== void 0 && def < min) {
        common.def = min;
      }
      if (common.def !== void 0 && common.max !== void 0 && def > max) {
        common.def = max;
      }
    }
    this.setObjectNotExists(id, {
      type: "state",
      common,
      native: _native
    }, options, (err) => {
      if (err) {
        return import_js_controller_common.tools.maybeCallbackWithError(callback, err);
      } else if (common.def !== void 0) {
        this.getState(id, null, (err2, state) => {
          if (!state) {
            if (common.defAck !== void 0) {
              this.setState(id, common.def, common.defAck, options, callback);
            } else {
              this.setState(id, common.def, options, callback);
            }
          } else {
            return import_js_controller_common.tools.maybeCallback(callback);
          }
        });
      } else {
        this.getState(id, null, (err2, state) => {
          if (!state) {
            this.setState(id, null, true, options, callback);
          } else {
            return import_js_controller_common.tools.maybeCallback(callback);
          }
        });
      }
    });
  }
  /**
   * Delete device with all its channels and states.
   *
   * @deprecated use `this.delObject` instead
   * @param deviceName is the part of ID like: adapter.instance.<deviceName>
   * @param options optional user context
   * @param callback return result
   *        ```js
   *            function (err) {
   *              if (err) adapter.log.error('Cannot delete device: ' + err);
   *            }
   *        ```
   */
  deleteDevice(deviceName, options, callback) {
    this._logger.info(`${this.namespaceLog} Method "deleteDevice" is deprecated and will be removed in js-controller 7.1, use "delObject" instead`);
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    import_validator.Validator.assertString(deviceName, "deviceName");
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    return this._deleteDevice({ deviceName, callback });
  }
  async _deleteDevice(_options) {
    const { callback } = _options;
    let { deviceName } = _options;
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} deleteDevice not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    deviceName = deviceName.replace(FORBIDDEN_CHARS, "_").replace(/\./g, "_");
    if (!this._namespaceRegExp.test(deviceName)) {
      deviceName = `${this.namespace}.${deviceName}`;
    }
    let obj;
    try {
      obj = await this.getForeignObjectAsync(deviceName);
    } catch (e) {
      return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
    }
    if (!obj || obj.type !== "device") {
      return import_js_controller_common.tools.maybeCallback(callback);
    }
    try {
      await this.delForeignObjectAsync(deviceName, { recursive: true });
    } catch (e) {
      return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
    }
    return import_js_controller_common.tools.maybeCallback(callback);
  }
  addChannelToEnum(enumName, addTo, parentDevice, channelName, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    import_validator.Validator.assertString(enumName, "enumName");
    import_validator.Validator.assertString(addTo, "addTo");
    import_validator.Validator.assertString(parentDevice, "parentDevice");
    import_validator.Validator.assertString(channelName, "channelName");
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    return this._addChannelToEnum({ enumName, addTo, parentDevice, channelName, options, callback });
  }
  _addChannelToEnum(_options) {
    const { addTo, options, callback } = _options;
    let { enumName, parentDevice, channelName } = _options;
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} addChannelToEnum not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    if (parentDevice) {
      if (this._namespaceRegExp.test(parentDevice)) {
        parentDevice = parentDevice.substring(this.namespace.length + 1);
      }
      parentDevice = parentDevice.replace(FORBIDDEN_CHARS, "_").replace(/\./g, "_");
    }
    if (this._namespaceRegExp.test(channelName)) {
      channelName = channelName.substring(this.namespace.length + 1);
    }
    if (parentDevice && channelName.substring(0, parentDevice.length) === parentDevice) {
      channelName = channelName.substring(parentDevice.length + 1);
    }
    channelName = channelName.replace(FORBIDDEN_CHARS, "_").replace(/\./g, "_");
    const objId = `${this.namespace}.${this._DCS2ID(parentDevice, channelName)}`;
    if (addTo.startsWith("enum.")) {
      this.#objects.getObject(addTo, options, (err, obj) => {
        if (err) {
          return import_js_controller_common.tools.maybeCallbackWithError(callback, err);
        } else if (obj) {
          if (!obj.common.members.includes(objId)) {
            obj.common.members.push(objId);
            obj.from = `system.adapter.${this.namespace}`;
            obj.user = options?.user || import_constants.SYSTEM_ADMIN_USER;
            obj.ts = Date.now();
            this.#objects.setObject(obj._id, obj, options, callback);
          } else {
            return import_js_controller_common.tools.maybeCallback(callback);
          }
        }
      });
    } else {
      if (enumName.startsWith("enum.")) {
        enumName = enumName.substring(5);
      }
      this.#objects.getObject(`enum.${enumName}.${addTo}`, options, (err, obj) => {
        if (err) {
          return import_js_controller_common.tools.maybeCallbackWithError(callback, err);
        }
        if (obj) {
          if (!obj.common.members.includes(objId)) {
            obj.common.members.push(objId);
            obj.from = `system.adapter.${this.namespace}`;
            obj.user = options?.user || import_constants.SYSTEM_ADMIN_USER;
            obj.ts = Date.now();
            this.#objects.setObject(obj._id, obj, options, callback);
          } else {
            return import_js_controller_common.tools.maybeCallback(callback);
          }
        } else {
          this.#objects.setObject(`enum.${enumName}.${addTo}`, {
            common: {
              name: addTo,
              members: [objId]
            },
            from: `system.adapter.${this.namespace}`,
            ts: Date.now(),
            type: "enum",
            native: {}
          }, options, callback);
        }
      });
    }
  }
  deleteChannelFromEnum(enumName, parentDevice, channelName, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    import_validator.Validator.assertString(enumName, "enumName");
    import_validator.Validator.assertString(parentDevice, "parentDevice");
    import_validator.Validator.assertString(channelName, "channelName");
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    return this._deleteChannelFromEnum({ enumName, parentDevice, channelName, options, callback });
  }
  _deleteChannelFromEnum(_options) {
    const { options, callback } = _options;
    let { enumName, channelName, parentDevice } = _options;
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} deleteChannelFromEnum not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    if (parentDevice) {
      if (parentDevice.substring(0, this.namespace.length) === this.namespace) {
        parentDevice = parentDevice.substring(this.namespace.length + 1);
      }
      parentDevice = parentDevice.replace(FORBIDDEN_CHARS, "_").replace(/\./g, "_");
    }
    if (channelName && channelName.substring(0, this.namespace.length) === this.namespace) {
      channelName = channelName.substring(this.namespace.length + 1);
    }
    if (parentDevice && channelName && channelName.substring(0, parentDevice.length) === parentDevice) {
      channelName = channelName.substring(parentDevice.length + 1);
    }
    channelName = channelName || "";
    channelName = channelName.replace(FORBIDDEN_CHARS, "_").replace(/\./g, "_");
    const objId = `${this.namespace}.${this._DCS2ID(parentDevice, channelName)}`;
    if (enumName) {
      enumName = `enum.${enumName}.`;
    } else {
      enumName = "enum.";
    }
    this.#objects.getObjectView("system", "enum", {
      startkey: enumName,
      endkey: `${enumName}\u9999`
    }, options, async (err, res) => {
      if (err) {
        return import_js_controller_common.tools.maybeCallbackWithError(callback, err);
      }
      if (res) {
        for (const row of res.rows) {
          try {
            const obj = await this.#objects.getObject(row.id, options);
            if (obj?.common?.members) {
              const pos = obj.common.members.indexOf(objId);
              if (pos !== -1) {
                obj.common.members.splice(pos, 1);
                obj.from = `system.adapter.${this.namespace}`;
                obj.user = options?.user || import_constants.SYSTEM_ADMIN_USER;
                obj.ts = Date.now();
                await this.#objects.setObjectAsync(obj._id, obj, options);
              }
            }
          } catch (e) {
            return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
          }
        }
      }
      return import_js_controller_common.tools.maybeCallback(callback);
    });
  }
  /**
   * Deletes channel and underlying structure
   *
   * @deprecated use `this.delObject` instead
   * @alias deleteChannel
   * @param parentDevice is the part of ID like: adapter.instance.<deviceName>
   * @param channelName is the part of ID like: adapter.instance.<deviceName>.<channelName>
   * @param options optional user context
   * @param callback return result
   *        ```js
   *            function (err) {
   *              if (err) adapter.log.error('Cannot delete device: ' + err);
   *            }
   *        ```
   */
  deleteChannel(parentDevice, channelName, options, callback) {
    this._logger.info(`${this.namespaceLog} Method "deleteChannel" is deprecated and will be removed in js-controller 7.1, use "delObject" instead`);
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    if (typeof channelName === "function") {
      callback = channelName;
      channelName = parentDevice;
      parentDevice = "";
    }
    if (parentDevice && !channelName) {
      channelName = parentDevice;
      parentDevice = "";
    } else if (parentDevice && typeof channelName === "function") {
      callback = channelName;
      channelName = parentDevice;
      parentDevice = "";
    }
    import_validator.Validator.assertString(parentDevice, "parentDevice");
    import_validator.Validator.assertString(channelName, "channelName");
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    return this._deleteChannel({ parentDevice, channelName, callback });
  }
  async _deleteChannel(_options) {
    const { callback } = _options;
    let { channelName, parentDevice } = _options;
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} deleteChannel not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    if (!parentDevice) {
      parentDevice = "";
    }
    if (parentDevice) {
      if (this._namespaceRegExp.test(parentDevice)) {
        parentDevice = parentDevice.substring(this.namespace.length + 1);
      }
      parentDevice = parentDevice.replace(FORBIDDEN_CHARS, "_").replace(/\./g, "_");
    }
    if (channelName && this._namespaceRegExp.test(channelName)) {
      channelName = channelName.substring(this.namespace.length + 1);
    }
    if (parentDevice && channelName && channelName.substring(0, parentDevice.length) === parentDevice) {
      channelName = channelName.substring(parentDevice.length + 1);
    }
    channelName = channelName || "";
    channelName = channelName.replace(FORBIDDEN_CHARS, "_").replace(/\./g, "_");
    channelName = `${this.namespace}.${this._DCS2ID(parentDevice, channelName)}`;
    let obj;
    try {
      obj = await this.getForeignObjectAsync(channelName);
    } catch (e) {
      return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
    }
    if (!obj || obj.type !== "channel") {
      return import_js_controller_common.tools.maybeCallback(callback);
    }
    this._logger.info(`${this.namespaceLog} Delete channel ${channelName}`);
    try {
      await this.delForeignObjectAsync(channelName, { recursive: true });
    } catch (e) {
      return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
    }
    return import_js_controller_common.tools.maybeCallback(callback);
  }
  /**
   * @param parentDevice
   * @param parentChannel
   * @param stateName
   * @param options
   * @param callback
   * @deprecated use `this.delObject` instead
   */
  deleteState(parentDevice, parentChannel, stateName, options, callback) {
    this._logger.info(`${this.namespaceLog} Method "deleteState" is deprecated and will be removed in js-controller 7.1, use "delObject" instead`);
    if (typeof parentChannel === "function" && stateName === void 0) {
      stateName = parentDevice;
      callback = parentChannel;
      parentChannel = "";
      parentDevice = "";
    } else if (parentChannel === void 0 && stateName === void 0) {
      stateName = parentDevice;
      parentDevice = "";
      parentChannel = "";
    } else {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (typeof stateName === "function") {
        callback = stateName;
        stateName = parentChannel;
        parentChannel = parentDevice;
        parentDevice = "";
      }
      if (typeof parentChannel === "function") {
        callback = parentChannel;
        stateName = parentDevice;
        parentChannel = "";
        parentDevice = "";
      }
      if (typeof parentChannel === "function") {
        callback = parentChannel;
        stateName = parentDevice;
        parentChannel = "";
        parentDevice = "";
      }
    }
    parentDevice = parentDevice ?? "";
    parentChannel = parentChannel ?? "";
    stateName = stateName ?? "";
    import_validator.Validator.assertString(parentDevice, "parentDevice");
    import_validator.Validator.assertString(parentChannel, "parentChannel");
    import_validator.Validator.assertString(stateName, "stateName");
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    return this._deleteState({ parentDevice, parentChannel, stateName, options, callback });
  }
  _deleteState(_options) {
    const { callback, options } = _options;
    let { stateName, parentDevice, parentChannel } = _options;
    if (parentDevice) {
      if (this._namespaceRegExp.test(parentDevice)) {
        parentDevice = parentDevice.substring(this.namespace.length + 1);
      }
      parentDevice = parentDevice.replace(FORBIDDEN_CHARS, "_").replace(/\./g, "_");
    }
    if (parentChannel) {
      if (this._namespaceRegExp.test(parentChannel)) {
        parentChannel = parentChannel.substring(this.namespace.length + 1);
      }
      if (parentDevice && parentChannel.substring(0, parentDevice.length) === parentDevice) {
        parentChannel = parentChannel.substring(parentDevice.length + 1);
      }
      parentChannel = parentChannel.replace(FORBIDDEN_CHARS, "_").replace(/\./g, "_");
    }
    if (this._namespaceRegExp.test(stateName)) {
      stateName = stateName.substring(this.namespace.length + 1);
    }
    if (parentDevice && stateName.substring(0, parentDevice.length) === parentDevice) {
      stateName = stateName.substring(parentDevice.length + 1);
    }
    if (parentChannel && stateName.substring(0, parentChannel.length) === parentChannel) {
      stateName = stateName.substring(parentChannel.length + 1);
    }
    stateName = stateName || "";
    stateName = stateName.replace(FORBIDDEN_CHARS, "_").replace(/\./g, "_");
    const _name = this._DCS2ID(parentDevice, parentChannel, stateName);
    this.delObject(_name, options, callback);
  }
  getDevices(options, callback) {
    if (typeof options === "function" && typeof callback === "object") {
      const tmp = callback;
      callback = options;
      options = tmp;
    }
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    import_validator.Validator.assertCallback(callback, "callback");
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    return this._getDevices({ options, callback });
  }
  _getDevices(_options) {
    const { options, callback } = _options;
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} getDevices not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    this.#objects.getObjectView("system", "device", {
      startkey: `${this.namespace}.`,
      endkey: `${this.namespace}.\u9999`
    }, options, (err, obj) => {
      if (err || !obj || !obj.rows || !obj.rows.length) {
        return import_js_controller_common.tools.maybeCallbackWithError(callback, err, err ? void 0 : []);
      }
      const res = [];
      for (const row of obj.rows) {
        if (row.value) {
          res.push(row.value);
        }
      }
      return import_js_controller_common.tools.maybeCallbackWithError(callback, null, res);
    });
  }
  getChannelsOf(parentDevice, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    if (typeof parentDevice === "function") {
      callback = parentDevice;
      parentDevice = void 0;
    }
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    if (parentDevice !== void 0) {
      import_validator.Validator.assertString(parentDevice, "parentDevice");
    }
    return this._getChannelsOf({ parentDevice, options, callback });
  }
  _getChannelsOf(options) {
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} getChannelsOf not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(options.callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    if (!options.parentDevice) {
      options.parentDevice = "";
    }
    if (options.parentDevice && this._namespaceRegExp.test(options.parentDevice)) {
      options.parentDevice = options.parentDevice.substring(this.namespace.length + 1);
    }
    options.parentDevice = options.parentDevice.replace(FORBIDDEN_CHARS, "_").replace(/\./g, "_");
    options.parentDevice = this.namespace + (options.parentDevice ? `.${options.parentDevice}` : "");
    this.#objects.getObjectView("system", "channel", {
      startkey: `${options.parentDevice}.`,
      endkey: `${options.parentDevice}.\u9999`
    }, options.options || {}, (err, obj) => {
      if (err || !obj || !obj.rows || !obj.rows.length) {
        return import_js_controller_common.tools.maybeCallbackWithError(options.callback, err, err ? void 0 : []);
      }
      const res = [];
      for (const row of obj.rows) {
        if (row.value) {
          res.push(row.value);
        }
      }
      return import_js_controller_common.tools.maybeCallbackWithError(options.callback, null, res);
    });
  }
  getStatesOf(parentDevice, parentChannel, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    if (typeof parentDevice === "function") {
      callback = parentDevice;
      parentDevice = null;
      parentChannel = null;
    }
    if (typeof parentChannel === "function") {
      callback = parentChannel;
      parentChannel = null;
    }
    if (!callback) {
      return;
    }
    import_validator.Validator.assertCallback(callback, "callback");
    if (parentDevice !== null && parentDevice !== void 0) {
      import_validator.Validator.assertString(parentDevice, "parentDevice");
    }
    if (parentChannel !== null && parentChannel !== void 0) {
      import_validator.Validator.assertString(parentChannel, "parentChannel");
    }
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    return this._getStatesOf({ parentDevice, parentChannel, options, callback });
  }
  _getStatesOf(_options) {
    const { options, callback } = _options;
    let { parentDevice, parentChannel } = _options;
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} getStatesOf not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    if (!parentDevice) {
      parentDevice = "";
    } else {
      if (this._namespaceRegExp.test(parentDevice)) {
        parentDevice = parentDevice.substring(this.namespace.length + 1);
      }
      parentDevice = parentDevice.replace(FORBIDDEN_CHARS, "_").replace(/\./g, "_");
    }
    if (!parentChannel) {
      parentChannel = "";
    } else if (this._namespaceRegExp.test(parentChannel)) {
      parentChannel = parentChannel.substring(this.namespace.length + 1);
    }
    if (parentDevice && parentChannel && parentChannel.substring(0, parentDevice.length) === parentDevice) {
      parentChannel = parentChannel.substring(parentDevice.length + 1);
    }
    parentChannel = parentChannel.replace(FORBIDDEN_CHARS, "_").replace(/\./g, "_");
    const id = `${this.namespace}.${this._DCS2ID(parentDevice, parentChannel, true)}`;
    this.#objects.getObjectView("system", "state", {
      startkey: id,
      endkey: `${id}\u9999`
    }, options, (err, obj) => {
      if (err || !obj || !obj.rows || !obj.rows.length) {
        return import_js_controller_common.tools.maybeCallbackWithError(callback, err, err ? void 0 : []);
      }
      const res = [];
      let read = 0;
      for (const row of obj.rows) {
        read++;
        this.#objects.getObject(row.id, (err2, subObj) => {
          if (subObj) {
            res.push(subObj);
          }
          if (!--read) {
            return import_js_controller_common.tools.maybeCallbackWithError(callback, null, res);
          }
        });
      }
    });
  }
  addStateToEnum(enumName, addTo, parentDevice, parentChannel, stateName, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    import_validator.Validator.assertString(enumName, "enumName");
    import_validator.Validator.assertString(addTo, "addTo");
    import_validator.Validator.assertString(parentDevice, "parentDevice");
    import_validator.Validator.assertString(parentChannel, "parentChannel");
    import_validator.Validator.assertString(stateName, "stateName");
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    return this._addStateToEnum({ enumName, addTo, parentDevice, parentChannel, stateName, options, callback });
  }
  _addStateToEnum(_options) {
    const { addTo, options, callback } = _options;
    let { enumName, parentDevice, parentChannel, stateName } = _options;
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} addStateToEnum not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    if (parentDevice) {
      if (this._namespaceRegExp.test(parentDevice)) {
        parentDevice = parentDevice.substring(this.namespace.length + 1);
      }
      parentDevice = parentDevice.replace(FORBIDDEN_CHARS, "_").replace(/\./g, "_");
    }
    if (parentChannel) {
      if (this._namespaceRegExp.test(parentChannel)) {
        parentChannel = parentChannel.substring(this.namespace.length + 1);
      }
      if (parentDevice && parentChannel.substring(0, parentDevice.length) === parentDevice) {
        parentChannel = parentChannel.substring(parentDevice.length + 1);
      }
      parentChannel = parentChannel.replace(FORBIDDEN_CHARS, "_").replace(/\./g, "_");
    }
    if (this._namespaceRegExp.test(stateName)) {
      stateName = stateName.substring(this.namespace.length + 1);
    }
    if (parentDevice && stateName.substring(0, parentDevice.length) === parentDevice) {
      stateName = stateName.substring(parentDevice.length + 1);
    }
    if (parentChannel && stateName.substring(0, parentChannel.length) === parentChannel) {
      stateName = stateName.substring(parentChannel.length + 1);
    }
    stateName = stateName.replace(FORBIDDEN_CHARS, "_").replace(/\./g, "_");
    const objId = this._utils.fixId({ device: parentDevice, channel: parentChannel, state: stateName });
    if (addTo.startsWith("enum.")) {
      this.#objects.getObject(addTo, options, (err, obj) => {
        if (err || !obj) {
          return import_js_controller_common.tools.maybeCallbackWithError(callback, err || import_js_controller_common.tools.ERRORS.ERROR_NOT_FOUND);
        }
        if (!obj.common.members.includes(objId)) {
          obj.common.members.push(objId);
          obj.from = `system.adapter.${this.namespace}`;
          obj.user = options?.user || import_constants.SYSTEM_ADMIN_USER;
          obj.ts = Date.now();
          this.#objects.setObject(obj._id, obj, options, callback);
        } else {
          return import_js_controller_common.tools.maybeCallback(callback);
        }
      });
    } else {
      if (enumName.startsWith("enum.")) {
        enumName = enumName.substring(5);
      }
      this.#objects.getObject(`enum.${enumName}.${addTo}`, options, (err, obj) => {
        if (!err && obj) {
          if (!obj.common.members.includes(objId)) {
            obj.common.members.push(objId);
            obj.from = `system.adapter.${this.namespace}`;
            obj.user = options?.user || import_constants.SYSTEM_ADMIN_USER;
            obj.ts = Date.now();
            this.#objects.setObject(obj._id, obj, callback);
          } else {
            return import_js_controller_common.tools.maybeCallback(callback);
          }
        } else {
          if (err) {
            return import_js_controller_common.tools.maybeCallbackWithError(callback, err);
          }
          this.#objects.setObject(`enum.${enumName}.${addTo}`, {
            common: {
              name: addTo,
              members: [objId]
            },
            from: `system.adapter.${this.namespace}`,
            ts: Date.now(),
            type: "enum",
            native: {}
          }, options, callback);
        }
      });
    }
  }
  deleteStateFromEnum(enumName, parentDevice, parentChannel, stateName, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    import_validator.Validator.assertString(enumName, "enumName");
    import_validator.Validator.assertString(parentDevice, "parentDevice");
    import_validator.Validator.assertString(parentChannel, "parentChannel");
    import_validator.Validator.assertString(stateName, "stateName");
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    return this._deleteStateFromEnum({ enumName, parentDevice, parentChannel, stateName, options, callback });
  }
  _deleteStateFromEnum(_options) {
    const { options, callback } = _options;
    let { enumName, parentDevice, parentChannel, stateName } = _options;
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} deleteStateFromEnum not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    if (parentDevice) {
      if (this._namespaceRegExp.test(parentDevice)) {
        parentDevice = parentDevice.substring(this.namespace.length + 1);
      }
      parentDevice = parentDevice.replace(FORBIDDEN_CHARS, "_").replace(/\./g, "_");
    }
    if (parentChannel) {
      if (this._namespaceRegExp.test(parentChannel)) {
        parentChannel = parentChannel.substring(this.namespace.length + 1);
      }
      if (parentDevice && parentChannel.substring(0, parentDevice.length) === parentDevice) {
        parentChannel = parentChannel.substring(parentDevice.length + 1);
      }
      parentChannel = parentChannel.replace(FORBIDDEN_CHARS, "_").replace(/\./g, "_");
    }
    if (this._namespaceRegExp.test(stateName)) {
      stateName = stateName.substring(this.namespace.length + 1);
    }
    if (parentDevice && stateName.substring(0, parentDevice.length) === parentDevice) {
      stateName = stateName.substring(parentDevice.length + 1);
    }
    if (parentChannel && stateName.substring(0, parentChannel.length) === parentChannel) {
      stateName = stateName.substring(parentChannel.length + 1);
    }
    stateName = stateName.replace(FORBIDDEN_CHARS, "_").replace(/\./g, "_");
    const objId = this._utils.fixId(
      {
        device: parentDevice,
        channel: parentChannel,
        state: stateName
      },
      false
      /*, 'state'*/
    );
    if (enumName) {
      enumName = `enum.${enumName}.`;
    } else {
      enumName = "enum.";
    }
    this.#objects.getObjectView("system", "enum", {
      startkey: enumName,
      endkey: `${enumName}\u9999`
    }, options, async (err, res) => {
      if (err || !res) {
        return import_js_controller_common.tools.maybeCallbackWithError(callback, err);
      }
      for (const row of res.rows) {
        try {
          const obj = await this.#objects.getObjectAsync(row.id);
          if (obj && obj.common && obj.common.members) {
            const pos = obj.common.members.indexOf(objId);
            if (pos !== -1) {
              obj.common.members.splice(pos, 1);
              obj.from = `system.adapter.${this.namespace}`;
              obj.user = options?.user || import_constants.SYSTEM_ADMIN_USER;
              obj.ts = Date.now();
              await this.#objects.setObjectAsync(obj._id, obj);
            }
          }
        } catch (e) {
          return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
        }
      }
      return import_js_controller_common.tools.maybeCallback(callback);
    });
  }
  /**
   * Change file access rights
   *
   * This function updates the file access rights
   * ```js
   *      adapter.chmodFile('vis-2.0', '/main/vis-views.json', {mode: 0x644}, function (err, processed) {
   *        if (err) adapter.log.error('Cannot read file: ' + err);
   *        adapter.log.info('New files: ' + JSON.stringify(processed));
   *      });
   * ```
   *
   * @param _adapter adapter name. If the adapter name is null, so the name (not instance) of the current adapter will be taken.
   * @param path path to file without adapter name. E.g., If you want to update "/vis-2.0/main/*", here must be "/main/*" and _adapter must be equal to "vis-2.0".
   * @param options data with mode
   * @param callback return result
   *        ```js
   *            function (err, processedFiles) {
   *                list of processed files with new groups
   *            }
   *        ```
   */
  chmodFile(_adapter, path2, options, callback) {
    if (_adapter === null) {
      _adapter = this.name;
    }
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} chmodFile not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    this.#objects.chmodFile(_adapter, path2, options, callback);
  }
  /**
   * Change a file owner
   *
   * This function updates the file owner and ownerGroup
   * ```js
   *      adapter.chownFile('vis-2.0', '/main/vis-views.json', {owner: 'newOwner', ownerGroup: 'newgroup'}, function (err, processed) {
   *        if (err) adapter.log.error('Cannot read file: ' + err);
   *        adapter.log.info('New files: ' + JSON.stringify(processed));
   *      });
   * ```
   *
   * @param _adapter adapter name. If the adapter name is null, so the name (not instance) of the current adapter will be taken.
   * @param path path to file without adapter name. E.g., If you want to update "/vis-2.0/main/*", here must be "/main/*" and _adapter must be equal to "vis-2.0".
   * @param options data with owner and ownerGroup
   * @param callback return result
   *        ```js
   *            function (err, processedFiles) {
   *                list of processed files with new groups
   *            }
   *        ```
   */
  chownFile(_adapter, path2, options, callback) {
    if (_adapter === null) {
      _adapter = this.name;
    }
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} chownFile not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    this.#objects.chownFile(_adapter, path2, options, callback);
  }
  /**
   * Read directory from DB.
   *
   * This function reads the content of directory from DB for given adapter and path.
   * If getEnum called with no enum specified, all enums will be returned:
   * ```js
   *      adapter.readDir('vis-2.0', '/main/', function (err, filesOrDirs) {
   *        // All enums
   *        if (err) adapter.log.error('Cannot read directory: ' + err);
   *        if (filesOrDirs) {
   *           for (var f = 0; f < filesOrDirs.length; f++) {
   *              adapter.log.debug('Directory main has the following files and dirs: ' + filesOrDirs[f].file + '[dir - ' + filesOrDirs[f].isDir + ']');
   *           }
   *       }
   *      });
   * ```
   *
   * @param _adapter adapter name. If the adapter name is null, so the name (not instance) of the current adapter will be taken.
   * @param path path to directory without adapter name. E.g., If you want to read "/vis-2.0/main/views.json", here must be "/main/views.json" and _adapter must be equal to "vis-2.0".
   * @param options optional user context
   * @param callback return result
   *        ```js
   *            function (err, filesOrDirs) {
   *                // filesOrDirs is array with elements like
   *                // {
   *                //      file:       'views.json,
   *                //      stats:      node.js stats object like https://nodejs.org/api/fs.html#fs_class_fs_stats ,
   *                //      isDir:      true/false,
   *                //      acl:        access control list object,
   *                //      modifiedAt: time when modified,
   *                //      createdAt:  time when created
   *                // }
   *            }
   *        ```
   */
  readDir(_adapter, path2, options, callback) {
    if (_adapter === null) {
      _adapter = this.name;
    }
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    import_validator.Validator.assertCallback(callback, "callback");
    import_validator.Validator.assertString(_adapter, "_adapter");
    import_validator.Validator.assertString(path2, "path");
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} readDir not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    this.#objects.readDir(_adapter, path2, options, callback);
  }
  unlink(_adapter, name, options, callback) {
    if (_adapter === null) {
      _adapter = this.name;
    }
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    import_validator.Validator.assertString(_adapter, "_adapter");
    import_validator.Validator.assertString(name, "name");
    if (options !== void 0 && options !== null) {
      import_validator.Validator.assertObject(options, "options");
    }
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} unlink not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    this.#objects.unlink(_adapter, name, options, callback);
  }
  rename(_adapter, oldName, newName, options, callback) {
    if (_adapter === null) {
      _adapter = this.name;
    }
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    import_validator.Validator.assertString(oldName, "oldName");
    import_validator.Validator.assertString(newName, "newName");
    import_validator.Validator.assertString(_adapter, "_adapter");
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} rename not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    this.#objects.rename(_adapter, oldName, newName, options, callback);
  }
  mkdir(_adapter, dirname, options, callback) {
    if (_adapter === null) {
      _adapter = this.name;
    }
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    import_validator.Validator.assertString(_adapter, "_adapter");
    import_validator.Validator.assertString(dirname, "dirname");
    if (options !== void 0 && options !== null) {
      import_validator.Validator.assertObject(options, "options");
    }
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} mkdir not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    this.#objects.mkdir(_adapter, dirname, options, callback);
  }
  /**
   * Read file from DB.
   *
   * This function reads the content of one file from DB for given adapter and file name.
   * ```js
   *      adapter.readFile('vis-2.0', '/main/vis-views.json', function (err, data) {
   *        // All enums
   *        if (err) adapter.log.error('Cannot read file: ' + err);
   *        adapter.log.info('Content of file is: ' + data);
   *      });
   * ```
   *
   * @param _adapter adapter name. If the adapter name is null, so the name (not instance) of the current adapter will be taken.
   * @param filename path to file without adapter name. E.g., If you want to read "/vis-2.0/main/views.json", here must be "/main/views.json" and _adapter must be equal to "vis-2.0".
   * @param options optional user context
   * @param callback return result
   *        ```js
   *            function (err, data) {
   *                // data is utf8 or binary Buffer depends on the file extension.
   *            }
   *        ```
   */
  readFile(_adapter, filename, options, callback) {
    if (_adapter === null) {
      _adapter = this.name;
    }
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    import_validator.Validator.assertString(_adapter, "_adapter");
    import_validator.Validator.assertString(filename, "filename");
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    import_validator.Validator.assertCallback(callback, "callback");
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} readFile not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    this.#objects.readFile(_adapter, filename, options, callback);
  }
  /**
   * Write file to DB.
   *
   * This function writes the content of one file into DB for given adapter and file name.
   * ```js
   *      adapter.writeFile('vis-2.0', '/main/vis-views.json', data, function (err) {
   *        err && adapter.log.error('Cannot write file: ' + err);
   *      });
   * ```
   *
   * @param _adapter adapter name. If the adapter name is null, so the name (not instance) of the current adapter will be taken.
   * @param filename path to file without adapter name. E.g., If you want to read "/vis-2.0/main/views.json", here must be "/main/views.json" and _adapter must be equal to "vis-2.0".
   * @param data data as UTF8 string or buffer depends on the file extension.
   * @param options optional user context
   * @param callback return result
   *        ```js
   *            function (err) {
   *
   *            }
   *        ```
   */
  writeFile(_adapter, filename, data, options, callback) {
    if (_adapter === null) {
      _adapter = this.name;
    }
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    import_validator.Validator.assertString(_adapter, "_adapter");
    import_validator.Validator.assertString(filename, "filename");
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    if (typeof data !== "string") {
      import_validator.Validator.assertBuffer(data, "data");
    }
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} writeFile not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    return this.#objects.writeFile(_adapter, filename, data, options, callback);
  }
  /**
   * Checks if file exists in DB.
   *
   * @param _adapter adapter name
   * @param filename path to file without adapter name. E.g., If you want to check "/vis-2.0/main/views.json", here must be "/main/views.json" and _adapter must be equal to "vis-2.0".
   * @param options optional user context
   * @param callback cb function if none provided, a promise is returned
   */
  async fileExists(_adapter, filename, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    import_validator.Validator.assertString(_adapter, "_adapter");
    import_validator.Validator.assertString(filename, "filename");
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} fileExists not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    try {
      const exists = await this.#objects.fileExists(_adapter, filename, options);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, null, exists);
    } catch (e) {
      return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
    }
  }
  formatValue(value, decimals, _format) {
    if (typeof decimals !== "number") {
      _format = decimals;
      decimals = 2;
    }
    const format = (
      // @ts-expect-error fix later
      !_format || _format.length !== 2 ? this.isFloatComma === void 0 ? ".," : this.isFloatComma ? ".," : ",." : _format
    );
    if (typeof value !== "number") {
      value = parseFloat(value);
    }
    return isNaN(value) ? "" : (
      // @ts-expect-error fix later
      value.toFixed(decimals).replace(format[0], format[1]).replace(/\B(?=(\d{3})+(?!\d))/g, format[0])
    );
  }
  formatDate(dateObj, isDuration, _format) {
    if (typeof isDuration === "string" && isDuration.toLowerCase() === "duration" || isDuration === true) {
      isDuration = true;
    }
    if (typeof isDuration !== "boolean") {
      _format = isDuration;
      isDuration = false;
    }
    if (!dateObj) {
      return "";
    }
    import_validator.Validator.assertBoolean(isDuration, "isDuration");
    if (_format !== void 0) {
      import_validator.Validator.assertString(_format, "format");
    }
    return this._formatDate({ dateObj, isDuration, _format });
  }
  _formatDate(_options) {
    const { _format, dateObj: _dateObj } = _options;
    let { isDuration } = _options;
    let dateObj;
    if (typeof _dateObj === "string") {
      dateObj = new Date(_dateObj);
    }
    if (typeof _dateObj !== "object") {
      const j = typeof _dateObj === "number" ? _dateObj : parseInt(_dateObj, 10);
      if (j === _dateObj) {
        if (j < 946681200) {
          isDuration = true;
          dateObj = new Date(_dateObj);
        } else {
          dateObj = j < 9466812e5 ? new Date(j * 1e3) : new Date(j);
        }
      } else {
        dateObj = new Date(_dateObj);
      }
    } else {
      dateObj = _dateObj;
    }
    const format = _format || this.dateFormat || "DD.MM.YYYY";
    if (isDuration) {
      dateObj.setMilliseconds(dateObj.getMilliseconds() + dateObj.getTimezoneOffset() * 60 * 1e3);
    }
    const validFormatChars = "YJ\u0413M\u041CDT\u0414hS\u0447m\u043Cs\u0441";
    let s = "";
    let result = "";
    const put = (s2) => {
      let v = "";
      switch (s2) {
        case "YYYY":
        case "JJJJ":
        case "\u0413\u0413\u0413\u0413":
        case "YY":
        case "JJ":
        case "\u0413\u0413":
          v = dateObj.getFullYear();
          if (s2.length === 2) {
            v %= 100;
          }
          if (v <= 9) {
            v = `0${v}`;
          }
          break;
        case "MM":
        case "M":
        case "\u041C\u041C":
        case "\u041C":
          v = dateObj.getMonth() + 1;
          if (v < 10 && s2.length === 2) {
            v = `0${v}`;
          }
          break;
        case "DD":
        case "TT":
        case "D":
        case "T":
        case "\u0414\u0414":
        case "\u0414":
          v = dateObj.getDate();
          if (v < 10 && s2.length === 2) {
            v = `0${v}`;
          }
          break;
        case "hh":
        case "SS":
        case "h":
        case "S":
        case "\u0447\u0447":
        case "\u0447":
          v = dateObj.getHours();
          if (v < 10 && s2.length === 2) {
            v = `0${v}`;
          }
          break;
        case "mm":
        case "m":
        case "\u043C\u043C":
        case "\u043C":
          v = dateObj.getMinutes();
          if (v < 10 && s2.length === 2) {
            v = `0${v}`;
          }
          break;
        case "ss":
        case "s":
        case "cc":
        case "c":
          v = dateObj.getSeconds();
          if (v < 10 && s2.length === 2) {
            v = `0${v}`;
          }
          v = v.toString();
          break;
        case "sss":
        case "\u0441\u0441\u0441":
          v = dateObj.getMilliseconds();
          if (v < 10) {
            v = `00${v}`;
          } else if (v < 100) {
            v = `0${v}`;
          }
          v = v.toString();
      }
      return result += v;
    };
    for (let i = 0; i < format.length; i++) {
      if (validFormatChars.includes(format[i])) {
        s += format[i];
      } else {
        put(s);
        s = "";
        result += format[i];
      }
    }
    put(s);
    return result;
  }
  /**
   * Send message to other adapter instance or all instances of adapter.
   *
   * This function sends a message to specific instance or all instances of some specific adapter.
   * If no instance given (e.g. "pushover"), the callback argument will be ignored. Because normally many responses will come.
   *
   * @param instanceName name of the instance where the message must be sent to. E.g. "pushover.0" or "system.adapter.pushover.0".
   * @param command command name, like "send", "browse", "list". Command is depend on target adapter implementation.
   * @param message object that will be given as argument for request
   * @param callback optional return result
   *        ```js
   *            function (result) {
   *              // result is target adapter specific and can vary from adapter to adapter
   *              if (!result) adapter.log.error('No response received');
   *            }
   *        ```
   * @param options optional options to define a timeout. This allows to get an error callback if no answer received in time (only if target is specific instance)
   */
  sendTo(instanceName, command, message, callback, options) {
    if (typeof message === "function" && typeof callback === "undefined") {
      callback = message;
      message = void 0;
    }
    if (typeof message === "undefined") {
      message = command;
      command = "send";
    }
    import_validator.Validator.assertString(instanceName, "instanceName");
    import_validator.Validator.assertString(command, "command");
    if (!import_js_controller_common.tools.isObject(callback)) {
      import_validator.Validator.assertOptionalCallback(callback, "callback");
    }
    if (options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    return this._sendTo({
      instanceName,
      command,
      message,
      options,
      callback
    });
  }
  /**
   * Async version of sendTo
   * As we have a special case (first arg can be error or result, we need to promisify manually)
   *
   * @param instanceName name of the instance where the message must be sent to. E.g. "pushover.0" or "system.adapter.pushover.0".
   * @param command command name, like "send", "browse", "list". Command is depend on target adapter implementation.
   * @param message object that will be given as argument for request
   * @param options optional options to define a timeout. This allows to get an error callback if no answer received in time (only if target is specific instance)
   */
  sendToAsync(instanceName, command, message, options) {
    return new Promise((resolve, reject) => {
      const callback = (resOrError) => {
        if (resOrError instanceof Error) {
          reject(resOrError);
        }
        resolve(resOrError);
      };
      this.sendTo(instanceName, command, message, callback, options);
    });
  }
  async _sendTo(_options) {
    const { command, message, callback, options } = _options;
    let { instanceName } = _options;
    const obj = {
      command,
      message,
      from: `system.adapter.${this.namespace}`
    };
    if (!instanceName) {
      return import_js_controller_common.tools.maybeCallbackWithError(callback, "No instanceName provided or not a string");
    }
    if (!instanceName.startsWith("system.adapter.")) {
      instanceName = `system.adapter.${instanceName}`;
    }
    if (!this.#states) {
      this._logger.info(`${this.namespaceLog} sendTo not processed because States database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    if (typeof message !== "object") {
      this._logger.silly(`${this.namespaceLog} sendTo "${command}" to ${instanceName} from system.adapter.${this.namespace}: ${message}`);
    } else {
      this._logger.silly(`${this.namespaceLog} sendTo "${command}" to ${instanceName} from system.adapter.${this.namespace}`);
    }
    if (!instanceName.match(/\.[0-9]+$/)) {
      if (!this.#objects) {
        this._logger.info(`${this.namespaceLog} sendTo not processed because Objects database not connected`);
        return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
      }
      try {
        const res = await this.#objects.getObjectView("system", "instance", {
          startkey: `${instanceName}.`,
          endkey: `${instanceName}.\u9999`
        });
        if (res) {
          for (const row of res.rows) {
            try {
              await this.#states.pushMessage(row.id, obj);
            } catch (e) {
              return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
            }
          }
        }
      } catch {
      }
    } else {
      if (callback) {
        if (typeof callback === "function") {
          if (!(0, import_utils.isMessageboxSupported)(this.common) && !this.mboxSubscribed) {
            this.mboxSubscribed = true;
            this.#states.subscribeMessage(`system.adapter.${this.namespace}`);
          }
          obj.callback = {
            message,
            id: this._callbackId++,
            ack: false,
            time: Date.now()
          };
          if (this._callbackId >= 4294967295) {
            this._callbackId = 1;
          }
          const callbackId = obj.callback.id;
          let timer;
          if (options?.timeout) {
            timer = setTimeout(() => {
              const callbackObj = this.messageCallbacks.get(callbackId);
              if (callbackObj) {
                callbackObj.cb(new Error("Timeout exceeded"));
                this.messageCallbacks.delete(callbackId);
              }
            }, options.timeout);
          }
          this.messageCallbacks.set(callbackId, { cb: callback, time: Date.now(), timer });
          const now = Date.now();
          for (const [_id, cb] of this.messageCallbacks) {
            if (now - cb.time > 36e5) {
              this.messageCallbacks.delete(_id);
            }
          }
        } else {
          obj.callback = callback;
          obj.callback.ack = true;
        }
      }
      try {
        await this.#states.pushMessage(instanceName, obj);
      } catch (e) {
        return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
      }
    }
  }
  /**
   * Send message to specific host or to all hosts.
   *
   * This function sends a message to specific host or all hosts.
   * If no host name given (e.g. null), the callback argument will be ignored. Because normally many responses will come.
   *
   * @param hostName name of the host where the message must be sent to. E.g. "myPC" or "system.host.myPC". If argument is null, the message will be sent to all hosts.
   * @param command command name. One of: "cmdExec", "getRepository", "getInstalled", "getVersion", "getDiagData", "getLocationOnDisk", "getDevList", "getLogs", "delLogs", "readDirAsZip", "writeDirAsZip", "readObjectsAsZip", "writeObjectsAsZip", "checkLogging". Commands can be checked in controller.js (function processMessage)
   * @param message object that will be given as argument for request
   * @param callback optional return result
   *        ```js
   *            function (result) {
   *              // result is target adapter specific and can vary from command to command
   *              if (!result) adapter.log.error('No response received');
   *            }
   *        ```
   */
  sendToHost(hostName, command, message, callback) {
    if (typeof message === "undefined") {
      message = command;
      command = "send";
    }
    if (hostName !== null) {
      import_validator.Validator.assertString(hostName, "hostName");
    }
    import_validator.Validator.assertString(command, "command");
    if (!import_js_controller_common.tools.isObject(callback)) {
      import_validator.Validator.assertOptionalCallback(callback, "callback");
    }
    return this._sendToHost({
      hostName,
      command,
      message,
      callback
    });
  }
  async _sendToHost(_options) {
    const { command, message, callback } = _options;
    let { hostName } = _options;
    const obj = { command, message, from: `system.adapter.${this.namespace}` };
    if (!this.#states) {
      this._logger.info(`${this.namespaceLog} sendToHost not processed because States database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    if (hostName && !hostName.startsWith("system.host.")) {
      hostName = `system.host.${hostName}`;
    }
    if (!hostName) {
      if (!this.#objects) {
        this._logger.info(`${this.namespaceLog} sendToHost not processed because Objects database not connected`);
        return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
      }
      this.#objects.getObjectList({
        startkey: "system.host.",
        endkey: `system.host.\u9999`
      }, null, async (err, res) => {
        if (!this.#states) {
          return;
        }
        if (!err && res?.rows.length) {
          for (const row of res.rows) {
            const parts = row.id.split(".");
            if (parts.length === 3) {
              try {
                await this.#states.pushMessage(row.id, obj);
              } catch (e) {
                return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
              }
            }
          }
        }
      });
    } else {
      if (callback) {
        if (typeof callback === "function") {
          if (!(0, import_utils.isMessageboxSupported)(this.common) && !this.mboxSubscribed) {
            this.mboxSubscribed = true;
            this.#states.subscribeMessage(`system.adapter.${this.namespace}`);
          }
          obj.callback = {
            message,
            id: this._callbackId++,
            ack: false,
            time: Date.now()
          };
          if (this._callbackId >= 4294967295) {
            this._callbackId = 1;
          }
          this.messageCallbacks.set(obj.callback.id, { cb: callback, time: Date.now() });
        } else {
          obj.callback = callback;
          obj.callback.ack = true;
        }
      }
      try {
        await this.#states.pushMessage(hostName, obj);
      } catch (e) {
        return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
      }
    }
  }
  /**
   * Send a message to an active UI Client
   *
   * @param options clientId and data options
   */
  sendToUI(options) {
    if (!this.#states) {
      throw new Error(import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    const { clientId, data } = options;
    if (clientId === void 0) {
      return this.uiMessagingController.sendToAllClients({
        data,
        states: this.#states
      });
    }
    import_validator.Validator.assertString(clientId, "clientId");
    return this.uiMessagingController.sendToClient({
      clientId,
      data,
      states: this.#states
    });
  }
  /**
   * Send notification with given scope and category to host of this adapter
   *
   * @param scope - scope to be addressed
   * @param category - to be addressed, if a null message will be checked by regex of given scope
   * @param message - message to be stored/checked
   * @param options - Additional options for the notification, currently `contextData` is supported
   */
  async registerNotification(scope, category, message, options) {
    if (!this.#states) {
      this._logger.info(`${this.namespaceLog} registerNotification not processed because States database not connected`);
      throw new Error(import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    import_validator.Validator.assertString(scope, "scope");
    if (category !== null) {
      import_validator.Validator.assertString(category, "category");
    }
    import_validator.Validator.assertString(message, "message");
    if (options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    const obj = {
      command: "addNotification",
      message: {
        scope,
        category,
        message,
        instance: this.namespace,
        contextData: options?.contextData
      },
      from: `system.adapter.${this.namespace}`
    };
    await this.#states.pushMessage(`system.host.${this.host}`, obj);
  }
  /**
   * Writes value into states DB.
   *
   * This function can write values into states DB for this adapter.
   * Only Ids that belong to this adapter can be modified. So the function automatically adds "adapter.X." to ID.
   * ack, options and callback are optional
   *
   * @param id object ID of the state.
   * @param state simple value or object with attributes.
   *  If state is object and ack exists too as function argument, function argument has priority.
   *  ```js
   *      {
   *          val:    value,
   *          ack:    true|false,       // default - false; is command(false) or status(true)
   *          ts:     timestampMS,      // default - now
   *          q:      qualityAsNumber,  // default - 0 (ok)
   *          from:   origin,           // default - this adapter
   *          c:      comment,          // default - empty
   *          expire: expireInSeconds   // default - 0
   *          lc:     timestampMS       // default - automatic calculation
   *      }
   *  ```
   * @param ack optional is command(false) or status(true)
   * @param options optional user context
   * @param callback optional return error and id
   *        ```js
   *            function (err, id) {
   *              if (err) adapter.log.error('Cannot set value for "' + id + '": ' + err);
   *            }
   *        ```
   */
  setState(id, state, ack, options, callback) {
    if (typeof state === "object" && typeof ack !== "boolean") {
      callback = options;
      options = ack;
      ack = void 0;
    }
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (typeof ack === "function") {
      callback = ack;
      ack = void 0;
    }
    if (!import_js_controller_common.tools.isObject(id)) {
      import_validator.Validator.assertString(id, "id");
    }
    if (ack !== void 0) {
      import_validator.Validator.assertBoolean(ack, "ack");
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    if (options !== void 0 && options !== null) {
      import_validator.Validator.assertObject(options, "options");
    }
    return this._setState({ id, state, ack, options, callback });
  }
  async _setState(_options) {
    const { state, ack, options, callback } = _options;
    const { id } = _options;
    if (!this.#states) {
      this._logger.info(`${this.namespaceLog} setState not processed because States database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} setState not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    try {
      this._utils.validateId(id, false, null);
    } catch (e) {
      return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
    }
    const fixedId = this._utils.fixId(id, false);
    let stateObj;
    if (import_js_controller_common.tools.isObject(state)) {
      try {
        this._utils.validateSetStateObjectArgument(state);
        stateObj = state;
      } catch (e) {
        return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
      }
    } else {
      stateObj = state !== void 0 ? { val: state } : {};
    }
    if (stateObj.val === void 0 && !Object.keys(stateObj).length) {
      return import_js_controller_common.tools.maybeCallbackWithError(callback, "undefined is not a valid state value");
    }
    if (ack !== void 0) {
      stateObj.ack = ack;
    }
    stateObj.from = typeof stateObj.from === "string" && stateObj.from !== "" ? stateObj.from : `system.adapter.${this.namespace}`;
    stateObj.user = options?.user || import_constants.SYSTEM_ADMIN_USER;
    let permCheckRequired = false;
    if (options?.user && options.user !== import_constants.SYSTEM_ADMIN_USER) {
      permCheckRequired = true;
    }
    let obj;
    try {
      if (permCheckRequired) {
        obj = (await this._checkStates(fixedId, options || {}, "setState")).objs[0];
      } else {
        obj = await this.#objects.getObject(fixedId, options);
      }
    } catch (e) {
      return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
    }
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} setForeignState not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    if (this.performStrictObjectChecks) {
      await this._utils.performStrictObjectCheck(fixedId, stateObj);
    }
    if (fixedId.startsWith(import_constants.ALIAS_STARTS_WITH)) {
      if (obj?.common?.alias?.id) {
        const aliasId = import_js_controller_common.tools.isObject(obj.common.alias.id) ? obj.common.alias.id.write : obj.common.alias.id;
        try {
          this._utils.validateId(aliasId, true, null);
        } catch (e) {
          this._logger.warn(`${this.namespaceLog} Error validating alias id of ${fixedId}: ${e.message}`);
          return import_js_controller_common.tools.maybeCallbackWithError(callback, `Error validating alias id of ${fixedId}: ${e.message}`);
        }
        let targetObj;
        try {
          if (permCheckRequired) {
            targetObj = (await this._checkStates(aliasId, options || {}, "setState")).objs[0];
          } else {
            targetObj = await this.#objects.getObject(aliasId, options);
          }
        } catch (e) {
          return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
        }
        if (!this.#states) {
          this._logger.info(`${this.namespaceLog} setForeignState not processed because States database not connected`);
          return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
        }
        this.outputCount++;
        try {
          const res = await this.#states.setState(aliasId, import_js_controller_common.tools.formatAliasValue({
            sourceCommon: obj?.common,
            targetCommon: targetObj?.common,
            state: stateObj,
            logger: this._logger,
            logNamespace: this.namespaceLog,
            sourceId: obj?._id,
            targetId: targetObj?._id
          }));
          return import_js_controller_common.tools.maybeCallbackWithError(callback, null, res);
        } catch (e) {
          return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
        }
      } else {
        this._logger.warn(`${this.namespaceLog} Alias ${fixedId} has no target 2`);
        return import_js_controller_common.tools.maybeCallbackWithError(callback, `Alias ${fixedId} has no target`);
      }
    } else {
      if (!this.#states) {
        this._logger.info(`${this.namespaceLog} setForeignState not processed because States database not connected`);
        return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
      }
      this.outputCount++;
      try {
        const res = await this.#states.setState(fixedId, stateObj);
        return import_js_controller_common.tools.maybeCallbackWithError(callback, null, res);
      } catch (e) {
        return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
      }
    }
  }
  // Cache will be cleared if user or group changes. Important! only if subscribed.
  async _getUserGroups(options) {
    if (this.users[options.user]) {
      options.groups = this.users[options.user].groups;
      options.acl = this.users[options.user].acl;
      return options;
    }
    options.groups = [];
    let userAcl;
    try {
      userAcl = await this.getForeignObjectAsync(options.user, null);
    } catch {
    }
    if (!userAcl) {
      this._logger.error(`${this.namespaceLog} unknown user "${options.user}"`);
      return options;
    }
    let groups;
    try {
      groups = await this.getForeignObjectsAsync("*", "group", null, null);
    } catch {
    }
    if (groups) {
      for (const group of Object.values(groups)) {
        if (group.common.members.includes(options.user)) {
          options.groups.push(group._id);
        }
      }
    }
    this.users[options.user] = {
      groups: options.groups,
      // @ts-expect-error TODO: UserCommon has no acl
      acl: userAcl.common?.acl || {}
    };
    await this._getGroups(options.groups);
    const user = this.users[options.user];
    for (const gName of options.groups) {
      if (!this.groups[gName].common?.acl) {
        continue;
      }
      const group = this.groups[gName];
      if (group.common?.acl?.file) {
        if (!user.acl || !user.acl.file) {
          user.acl = user.acl || {};
          user.acl.file = user.acl.file || {};
          user.acl.file.create = group.common.acl.file.create;
          user.acl.file.read = group.common.acl.file.read;
          user.acl.file.write = group.common.acl.file.write;
          user.acl.file.delete = group.common.acl.file.delete;
          user.acl.file.list = group.common.acl.file.list;
        } else {
          user.acl.file.create = user.acl.file.create || group.common.acl.file.create;
          user.acl.file.read = user.acl.file.read || group.common.acl.file.read;
          user.acl.file.write = user.acl.file.write || group.common.acl.file.write;
          user.acl.file.delete = user.acl.file.delete || group.common.acl.file.delete;
          user.acl.file.list = user.acl.file.list || group.common.acl.file.list;
        }
      }
      if (group.common?.acl?.object) {
        if (!user.acl || !user.acl.object) {
          user.acl = user.acl || {};
          user.acl.object = user.acl.object || {};
          user.acl.object.create = group.common.acl.object.create;
          user.acl.object.read = group.common.acl.object.read;
          user.acl.object.write = group.common.acl.object.write;
          user.acl.object.delete = group.common.acl.object.delete;
          user.acl.object.list = group.common.acl.object.list;
        } else {
          user.acl.object.create = user.acl.object.create || group.common.acl.object.create;
          user.acl.object.read = user.acl.object.read || group.common.acl.object.read;
          user.acl.object.write = user.acl.object.write || group.common.acl.object.write;
          user.acl.object.delete = user.acl.object.delete || group.common.acl.object.delete;
          user.acl.object.list = user.acl.object.list || group.common.acl.object.list;
        }
      }
      if (group.common?.acl?.users) {
        if (!user.acl || !user.acl.users) {
          user.acl = user.acl || {};
          user.acl.users = user.acl.users || {};
          user.acl.users.create = group.common.acl.users.create;
          user.acl.users.read = group.common.acl.users.read;
          user.acl.users.write = group.common.acl.users.write;
          user.acl.users.delete = group.common.acl.users.delete;
          user.acl.users.list = group.common.acl.users.list;
        } else {
          user.acl.users.create = user.acl.users.create || group.common.acl.users.create;
          user.acl.users.read = user.acl.users.read || group.common.acl.users.read;
          user.acl.users.write = user.acl.users.write || group.common.acl.users.write;
          user.acl.users.delete = user.acl.users.delete || group.common.acl.users.delete;
          user.acl.users.list = user.acl.users.list || group.common.acl.users.list;
        }
      }
      if (group.common?.acl?.state) {
        if (!user.acl || !user.acl.state) {
          user.acl = user.acl || {};
          user.acl.state = user.acl.state || {};
          user.acl.state.create = group.common.acl.state.create;
          user.acl.state.read = group.common.acl.state.read;
          user.acl.state.write = group.common.acl.state.write;
          user.acl.state.delete = group.common.acl.state.delete;
          user.acl.state.list = group.common.acl.state.list;
        } else {
          user.acl.state.create = user.acl.state.create || group.common.acl.state.create;
          user.acl.state.read = user.acl.state.read || group.common.acl.state.read;
          user.acl.state.write = user.acl.state.write || group.common.acl.state.write;
          user.acl.state.delete = user.acl.state.delete || group.common.acl.state.delete;
          user.acl.state.list = user.acl.state.list || group.common.acl.state.list;
        }
      }
    }
    options.acl = user.acl;
    return options;
  }
  _checkState(obj, options, command) {
    const limitToOwnerRights = options.limitToOwnerRights === true;
    if (obj?.acl) {
      obj.acl.state = obj.acl.state || obj.acl.object;
      if (obj.acl.state) {
        if (options.user === obj.acl.owner) {
          if (command === "setState" || command === "delState") {
            if (command === "delState" && !options.acl.state.delete) {
              this._logger.warn(`${this.namespaceLog} Permission error for user "${options.user} on "${obj._id}": ${command}`);
              return false;
            } else if (command === "setState" && !options.acl.state.write) {
              this._logger.warn(`${this.namespaceLog} Permission error for user "${options.user} on "${obj._id}": ${command}`);
              return false;
            } else if (!(obj.acl.state & import_constants.ACCESS_USER_WRITE)) {
              this._logger.warn(`${this.namespaceLog} Permission error for user "${options.user} on "${obj._id}": ${command}`);
              return false;
            }
          } else if (command === "getState") {
            if (!(obj.acl.state & import_constants.ACCESS_USER_READ) || !options.acl.state.read) {
              this._logger.warn(`${this.namespaceLog} Permission error for user "${options.user} on "${obj._id}": ${command}`);
              return false;
            }
          } else {
            this._logger.warn(`${this.namespaceLog} Called unknown command on "${obj._id}": ${command}`);
          }
        } else if (options.groups.includes(obj.acl.ownerGroup) && !limitToOwnerRights) {
          if (command === "setState" || command === "delState") {
            if (command === "delState" && !options.acl.state.delete) {
              this._logger.warn(`${this.namespaceLog} Permission error for user "${options.user} on "${obj._id}": ${command}`);
              return false;
            } else if (command === "setState" && !options.acl.state.write) {
              this._logger.warn(`${this.namespaceLog} Permission error for user "${options.user} on "${obj._id}": ${command}`);
              return false;
            } else if (!(obj.acl.state & import_constants.ACCESS_GROUP_WRITE)) {
              this._logger.warn(`${this.namespaceLog} Permission error for user "${options.user} on "${obj._id}": ${command}`);
              return false;
            }
          } else if (command === "getState") {
            if (!(obj.acl.state & import_constants.ACCESS_GROUP_READ) || !options.acl.state.read) {
              this._logger.warn(`${this.namespaceLog} Permission error for user "${options.user} on "${obj._id}": ${command}`);
              return false;
            }
          } else {
            this._logger.warn(`${this.namespaceLog} Called unknown command on "${obj._id}": ${command}`);
          }
        } else if (!limitToOwnerRights) {
          if (command === "setState" || command === "delState") {
            if (command === "delState" && !options.acl.state.delete) {
              this._logger.warn(`${this.namespaceLog} Permission error for user "${options.user} on "${obj._id}": ${command}`);
              return false;
            } else if (command === "setState" && !options.acl.state.write) {
              this._logger.warn(`${this.namespaceLog} Permission error for user "${options.user} on "${obj._id}": ${command}`);
              return false;
            } else if (!(obj.acl.state & import_constants.ACCESS_EVERY_WRITE)) {
              this._logger.warn(`${this.namespaceLog} Permission error for user "${options.user}" on "${obj._id}": ${command}`);
              return false;
            }
          } else if (command === "getState") {
            if (!(obj.acl.state & import_constants.ACCESS_EVERY_READ) || !options.acl.state.read) {
              this._logger.warn(`${this.namespaceLog} Permission error for user "${options.user}"on "${obj._id}" : ${command}`);
              return false;
            }
          } else {
            this._logger.warn(`${this.namespaceLog} Called unknown command on "${obj._id}": ${command}`);
            return false;
          }
        } else {
          this._logger.warn(`${this.namespaceLog} Permissions limited to Owner rights on "${obj._id}"`);
          return false;
        }
      } else if (limitToOwnerRights) {
        this._logger.warn(`${this.namespaceLog} Permissions limited to Owner rights on "${obj._id}"`);
        return false;
      }
    } else if (limitToOwnerRights) {
      this._logger.warn(`${this.namespaceLog} Permissions limited to Owner rights on "${obj._id}"`);
      return false;
    }
    return true;
  }
  async _checkStates(ids, options, command) {
    if (!options.groups) {
      options = await this._getUserGroups(options);
    }
    if (!Array.isArray(ids)) {
      ids = [ids];
    }
    if (options._objects) {
      if (!ids.length) {
        return { ids, objs: [] };
      }
      const objs2 = [];
      for (const obj of options._objects) {
        if (obj && this._checkState(obj, options, command)) {
          objs2.push(obj);
        }
      }
      return { ids, objs: objs2 };
    }
    const objs = [];
    for (const id of ids) {
      let originalChecked;
      if (options.checked !== void 0) {
        originalChecked = options.checked;
      }
      options.checked = true;
      if (!this.#objects) {
        this._logger.info(`${this.namespaceLog} checkStates not processed because Objects database not connected`);
        throw new Error(import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
      }
      const obj = await this.#objects.getObject(id, options);
      objs.push(obj);
      if (originalChecked !== void 0) {
        options.checked = originalChecked;
      } else {
        options.checked = void 0;
      }
      if (!this._checkState(obj, options, command)) {
        throw new Error(import_constants.ERROR_PERMISSION);
      }
    }
    return { ids, objs };
  }
  async _getGroups(ids) {
    for (const id of ids) {
      let obj;
      try {
        obj = await this.getForeignObjectAsync(id);
      } catch {
      }
      if (this.groups[id] === void 0) {
        this.groups[id] = obj || {};
      }
    }
  }
  async _setStateChangedHelper(id, state) {
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} setStateChanged not processed because Objects database not connected`);
      throw new Error(import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    if (id.startsWith(import_constants.ALIAS_STARTS_WITH)) {
      let obj;
      let err;
      try {
        obj = await this.#objects.getObject(id);
      } catch (e) {
        err = e;
      }
      if (obj?.common?.alias?.id) {
        const aliasId = import_js_controller_common.tools.isObject(obj.common.alias.id) ? obj.common.alias.id.write : obj.common.alias.id;
        return this._setStateChangedHelper(aliasId, state);
      }
      this._logger.warn(`${this.namespaceLog} ${err ? err.message : `Alias ${id} has no target 1`}`);
      throw new Error(err ? err.message : `Alias ${id} has no target`);
    } else {
      const oldState = await this.getForeignStateAsync(id, null);
      let differ = false;
      if (!oldState) {
        differ = true;
      } else if (state.val !== oldState.val) {
        differ = true;
      } else if (state.ack !== void 0 && state.ack !== oldState.ack) {
        differ = true;
      } else if (state.q !== void 0 && state.q !== oldState.q) {
        differ = true;
      } else if (state.ts !== void 0 && state.ts !== oldState.ts) {
        differ = true;
      } else if (state.c !== void 0 && state.c !== oldState.c) {
        differ = true;
      } else if (state.expire !== void 0 && state.expire !== oldState.expire) {
        differ = true;
      } else if (state.from !== void 0 && state.from !== oldState.from) {
        differ = true;
      } else if (state.user !== void 0 && state.user !== oldState.user) {
        differ = true;
      }
      if (differ) {
        if (this.performStrictObjectChecks) {
          await this._utils.performStrictObjectCheck(id, state);
        }
        this.outputCount++;
        await this.#states.setState(id, state);
        return { id, notChanged: false };
      }
      return { id, notChanged: true };
    }
  }
  /**
   * Writes value into states DB only if the value really changed.
   *
   * This function can write values into states DB for this adapter.
   * Only Ids that belong to this adapter can be modified. So the function automatically adds "adapter.X." to ID.
   * ack, options and callback are optional
   *
   * @param id object ID of the state.
   * @param state simple value or object with attribues.
   * @param ack optional is command(false) or status(true)
   * @param options optional user context
   * @param callback optional return error, id and notChanged
   *        ```js
   *            function (err, id, notChanged) {
   *              if (err) adapter.log.error('Cannot set value for "' + id + '": ' + err);
   *              if (!notChanged) adapter.log.debug('Value was changed');
   *            }
   *        ```
   */
  setStateChanged(id, state, ack, options, callback) {
    if (typeof state === "object" && typeof ack !== "boolean") {
      callback = options;
      options = ack;
      ack = void 0;
    }
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (typeof ack === "function") {
      callback = ack;
      ack = void 0;
    }
    if (!import_js_controller_common.tools.isObject(id)) {
      import_validator.Validator.assertString(id, "id");
    }
    if (ack !== void 0) {
      import_validator.Validator.assertBoolean(ack, "ack");
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    if (options !== void 0 && options !== null) {
      import_validator.Validator.assertObject(options, "options");
    }
    return this._setStateChanged({ id, state, ack, options, callback });
  }
  async _setStateChanged(_options) {
    const { id, ack, options, callback, state } = _options;
    if (!this.#states) {
      this._logger.info(`${this.namespaceLog} setStateChanged not processed because States database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    try {
      this._utils.validateId(id, false, null);
    } catch (e) {
      return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
    }
    const fixedId = this._utils.fixId(id, false);
    let stateObj;
    if (import_js_controller_common.tools.isObject(state)) {
      try {
        this._utils.validateSetStateObjectArgument(state);
      } catch (e) {
        return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
      }
      stateObj = state;
    } else {
      stateObj = state !== void 0 ? { val: state } : {};
    }
    if (stateObj.val === void 0 && !Object.keys(stateObj).length) {
      return import_js_controller_common.tools.maybeCallbackWithError(callback, "undefined is not a valid state value");
    }
    if (ack !== void 0) {
      stateObj.ack = ack;
    }
    stateObj.from = typeof stateObj.from === "string" && stateObj.from !== "" ? stateObj.from : `system.adapter.${this.namespace}`;
    if (options?.user && options.user !== import_constants.SYSTEM_ADMIN_USER) {
      try {
        await this._checkStates(fixedId, options, "setState");
      } catch (e) {
        return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
      }
      const res2 = await this._setStateChangedHelper(fixedId, stateObj);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, null, res2.id, res2.notChanged);
    }
    const res = await this._setStateChangedHelper(fixedId, stateObj);
    return import_js_controller_common.tools.maybeCallbackWithError(callback, null, res.id, res.notChanged);
  }
  /**
   * Writes value into states DB for any instance.
   *
   * This function can write values into states DB for all instances and system states too.
   * ack, options and callback are optional
   *
   * @param id object ID of the state.
   * @param state simple value or object with attribues.
   *  If state is object, so the ack will be ignored and must be included into object.
   *  ```js
   *      {
   *          val:    value,
   *          ack:    true|false,       // default - false; is command(false) or status(true)
   *          ts:     timestampMS,      // default - now
   *          q:      qualityAsNumber,  // default - 0 (ok)
   *          from:   origin,           // default - this adapter
   *          c:      comment,          // default - empty
   *          expire: expireInSeconds   // default - 0
   *          lc:     timestampMS       // default - automatic calculation
   *      }
   *  ```
   * @param ack optional is command(false) or status(true)
   * @param options optional user context
   * @param callback optional return error and id
   *        ```js
   *            function (err, id) {
   *              if (err) adapter.log.error('Cannot set value for "' + id + '": ' + err);
   *            }
   *        ```
   */
  async setForeignState(id, state, ack, options, callback) {
    if (typeof state === "object" && typeof ack !== "boolean") {
      callback = options;
      options = ack;
      ack = void 0;
    }
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (typeof ack === "function") {
      callback = ack;
      ack = void 0;
    }
    if (!this.#states) {
      this._logger.info(`${this.namespaceLog} setForeignState not processed because States database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} setForeignState not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    try {
      this._utils.validateId(id, true, null);
    } catch (e) {
      return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
    }
    if (import_js_controller_common.tools.isObject(state)) {
      try {
        this._utils.validateSetStateObjectArgument(state);
      } catch (e) {
        return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
      }
    } else {
      state = state !== void 0 ? { val: state } : {};
    }
    if (state.val === void 0 && !Object.keys(state).length) {
      this._logger.info(`${this.namespaceLog} undefined is not a valid state value for id "${id}"`);
    }
    if (ack !== void 0) {
      state.ack = ack;
    }
    state.from = typeof state.from === "string" && state.from !== "" ? state.from : `system.adapter.${this.namespace}`;
    state.user = options?.user || import_constants.SYSTEM_ADMIN_USER;
    if (!id || typeof id !== "string") {
      const warn = id ? `ID can be only string and not "${typeof id}"` : `Empty ID: ${JSON.stringify(state)}`;
      this._logger.warn(`${this.namespaceLog} ${warn}`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, warn);
    }
    id = this.fixForbiddenCharsInId(id);
    if (options?.user && options.user !== import_constants.SYSTEM_ADMIN_USER) {
      let obj;
      try {
        obj = (await this._checkStates(id, options, "setState")).objs[0];
      } catch (e) {
        return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
      }
      if (!this.#states) {
        this._logger.info(`${this.namespaceLog} setForeignState not processed because States database not connected`);
        return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
      }
      if (this.performStrictObjectChecks) {
        await this._utils.performStrictObjectCheck(id, state);
      }
      if (id.startsWith(import_constants.ALIAS_STARTS_WITH)) {
        if (obj?.common?.alias?.id) {
          const aliasId = import_js_controller_common.tools.isObject(obj.common.alias.id) ? obj.common.alias.id.write : obj.common.alias.id;
          try {
            this._utils.validateId(aliasId, true, null);
          } catch (e) {
            this._logger.warn(`${this.namespaceLog} Error validating alias id of ${id}: ${e.message}`);
            return import_js_controller_common.tools.maybeCallbackWithError(callback, `Error validating alias id of ${id}: ${e.message}`);
          }
          let targetObj;
          try {
            targetObj = await this.#objects.getObject(aliasId, {
              ...options,
              user: import_constants.SYSTEM_ADMIN_USER
            });
          } catch (e) {
            return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
          }
          if (!this.#states) {
            this._logger.info(`${this.namespaceLog} setForeignState not processed because States database not connected`);
            return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
          }
          this.outputCount++;
          this.#states.setState(aliasId, import_js_controller_common.tools.formatAliasValue({
            sourceCommon: obj?.common,
            targetCommon: targetObj && targetObj.common,
            state,
            logger: this._logger,
            logNamespace: this.namespaceLog,
            sourceId: obj?._id,
            targetId: targetObj?._id
          }), callback);
        } else {
          this._logger.warn(`${this.namespaceLog} Alias ${id} has no target 3`);
          return import_js_controller_common.tools.maybeCallbackWithError(callback, `Alias ${id} has no target`);
        }
      } else {
        if (!this.#states) {
          this._logger.info(`${this.namespaceLog} setForeignState not processed because States database not connected`);
          return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
        }
        this.outputCount++;
        this.#states.setState(id, state, callback);
      }
    } else {
      if (id.startsWith(import_constants.ALIAS_STARTS_WITH)) {
        if (!this.#objects) {
          this._logger.info(`${this.namespaceLog} setForeignState not processed because Objects database not connected`);
          return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
        }
        const obj = await this.#objects.getObjectAsync(id, options);
        if (obj?.common?.alias?.id) {
          const targetId = import_js_controller_common.tools.isObject(obj.common.alias.id) ? obj.common.alias.id.write : obj.common.alias.id;
          try {
            this._utils.validateId(targetId, true, null);
          } catch (e) {
            this._logger.warn(`${this.namespaceLog} Error validating alias id of ${id}: ${e.message}`);
            return import_js_controller_common.tools.maybeCallbackWithError(callback, `Error validating alias id of ${id}: ${e.message}`);
          }
          if (!this.#objects) {
            this._logger.info(`${this.namespaceLog} setForeignState not processed because Objects database not connected`);
            return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
          }
          const targetObj = await this.#objects.getObject(targetId, {
            ...options,
            user: import_constants.SYSTEM_ADMIN_USER
          });
          if (!this.#states) {
            this._logger.info(`${this.namespaceLog} setForeignState not processed because States database not connected`);
            return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
          }
          this.outputCount++;
          this.#states.setState(targetId, import_js_controller_common.tools.formatAliasValue({
            sourceCommon: obj.common,
            targetCommon: targetObj?.common,
            state,
            logger: this._logger,
            logNamespace: this.namespaceLog,
            sourceId: obj._id,
            targetId: targetObj?._id
          }), callback);
        } else {
          this._logger.warn(`${this.namespaceLog} Alias ${id} has no target 4`);
          return import_js_controller_common.tools.maybeCallbackWithError(callback, `Alias ${id} has no target`);
        }
      } else {
        if (this.performStrictObjectChecks) {
          if (!this.#objects) {
            this._logger.info(`${this.namespaceLog} setForeignState not processed because Objects database not connected`);
            return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
          }
          await this._utils.performStrictObjectCheck(id, state);
        }
        if (!this.#states) {
          this._logger.info(`${this.namespaceLog} setForeignState not processed because States database not connected`);
          return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
        }
        this.outputCount++;
        this.#states.setState(id, state, callback);
      }
    }
  }
  /**
   * Writes value into states DB for any instance, but only if state changed.
   *
   * This function can write values into states DB for all instances and system states too.
   * ack, options and callback are optional
   *
   * @param id object ID of the state.
   * @param state simple value or object with attribues.
   *  If state is object and ack exists too as function argument, function argument has priority.
   *  ```js
   *      {
   *          val:    value,
   *          ack:    true|false,       // default - false; is command(false) or status(true)
   *          ts:     timestampMS,      // default - now
   *          q:      qualityAsNumber,  // default - 0 (ok)
   *          from:   origin,           // default - this adapter
   *          c:      comment,          // default - empty
   *          expire: expireInSeconds   // default - 0
   *          lc:     timestampMS       // default - automatic calculation
   *      }
   *  ```
   * @param ack optional is command(false) or status(true)
   * @param options optional user context
   * @param callback optional return error and id
   *        ```js
   *            function (err, id) {
   *              if (err) adapter.log.error('Cannot set value for "' + id + '": ' + err);
   *            }
   *        ```
   */
  async setForeignStateChanged(id, state, ack, options, callback) {
    if (typeof state === "object" && typeof ack !== "boolean") {
      callback = options;
      options = ack;
      ack = void 0;
    }
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (typeof ack === "function") {
      callback = ack;
      ack = void 0;
    }
    if (!this.#states) {
      this._logger.info(`${this.namespaceLog} setForeignStateChanged not processed because States database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    try {
      this._utils.validateId(id, true, null);
    } catch (e) {
      return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
    }
    if (import_js_controller_common.tools.isObject(state)) {
      try {
        this._utils.validateSetStateObjectArgument(state);
      } catch (e) {
        return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
      }
    } else {
      state = state !== void 0 ? { val: state } : {};
    }
    if (state.val === void 0 && !Object.keys(state).length) {
      this._logger.info(`${this.namespaceLog} undefined is not a valid state value for id "${id}"`);
    }
    if (ack !== void 0) {
      state.ack = ack;
    }
    state.from = typeof state.from === "string" && state.from !== "" ? state.from : `system.adapter.${this.namespace}`;
    state.user = options?.user || import_constants.SYSTEM_ADMIN_USER;
    id = this.fixForbiddenCharsInId(id);
    if (options?.user && options.user !== import_constants.SYSTEM_ADMIN_USER) {
      try {
        await this._checkStates(id, options, "setState");
      } catch (e) {
        return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
      }
      const res2 = await this._setStateChangedHelper(id, state);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, null, res2.id, res2.notChanged);
    }
    const res = await this._setStateChangedHelper(id, state);
    return import_js_controller_common.tools.maybeCallbackWithError(callback, null, res.id, res.notChanged);
  }
  /**
   * Read value from states DB.
   *
   * This function can read values from states DB for this adapter.
   * Only Ids that belong to this adapter can be read. So the function automatically adds "adapter.X." to ID.
   *
   * @param id object ID of the state.
   * @param options optional user context
   * @param callback return result
   *        ```js
   *            function (err, state) {
   *              if (err) adapter.log.error('Cannot read value: ' + err);
   *            }
   *        ```
   *
   *        See possible attributes of the state in @setState explanation
   */
  getState(id, options, callback) {
    if (!import_js_controller_common.tools.isObject(id)) {
      import_validator.Validator.assertString(id, "id");
    }
    const fixedId = this._utils.fixId(id, false);
    return this.getForeignState(fixedId, options, callback);
  }
  /**
   * Read value from states DB for any instance and system state.
   *
   * This function can read values from states DB for all instances and adapters. It expects the full path of object ID.
   *
   * @param id object ID of the state.
   * @param options optional user context
   * @param callback return result
   *        ```js
   *            function (err, state) {
   *              if (err) adapter.log.error('Cannot read value: ' + err);
   *            }
   *        ```
   *
   *        See possible attributes of the state in @setState explanation
   */
  getForeignState(id, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    import_validator.Validator.assertString(id, "id");
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    return this._getForeignState({ id, options, callback });
  }
  async _getForeignState(_options) {
    const { id, options, callback } = _options;
    if (!this.#states) {
      this._logger.info(`${this.namespaceLog} getForeignState not processed because States database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} getForeignState not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    try {
      this._utils.validateId(id, true, options);
    } catch (e) {
      return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
    }
    let permCheckRequired = false;
    if (options?.user && options.user !== import_constants.SYSTEM_ADMIN_USER) {
      permCheckRequired = true;
    }
    let obj;
    try {
      if (permCheckRequired) {
        obj = (await this._checkStates(id, options || {}, "getState")).objs[0];
      } else {
        obj = await this.#objects.getObject(id, options);
      }
    } catch (e) {
      return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
    }
    if (id.startsWith(import_constants.ALIAS_STARTS_WITH)) {
      if (obj?.common?.alias?.id) {
        const aliasId = import_js_controller_common.tools.isObject(obj.common.alias.id) ? obj.common.alias.id.read : obj.common.alias.id;
        try {
          this._utils.validateId(aliasId, true, null);
        } catch (e) {
          this._logger.warn(`${this.namespaceLog} Error validating alias id of ${id}: ${e.message}`);
          return import_js_controller_common.tools.maybeCallbackWithError(callback, `Error validating alias id of ${id}: ${e.message}`);
        }
        if (aliasId) {
          let sourceObj;
          try {
            sourceObj = await this.#objects.getObject(aliasId, {
              ...options,
              user: import_constants.SYSTEM_ADMIN_USER
            });
          } catch (e) {
            return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
          }
          let state;
          if (this.oStates && this.oStates[aliasId]) {
            state = (0, import_deep_clone.default)(this.oStates[aliasId]);
          } else {
            this.inputCount++;
            try {
              state = await this.#states.getState(aliasId);
            } catch (e) {
              return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
            }
          }
          return import_js_controller_common.tools.maybeCallbackWithError(callback, null, import_js_controller_common.tools.formatAliasValue({
            sourceCommon: sourceObj?.common,
            targetCommon: obj.common,
            state,
            logger: this._logger,
            logNamespace: this.namespaceLog,
            sourceId: sourceObj?._id,
            targetId: obj._id
          }));
        }
      } else {
        return import_js_controller_common.tools.maybeCallbackWithError(callback, null, null);
      }
    } else {
      if (this.oStates && this.oStates[id]) {
        return import_js_controller_common.tools.maybeCallbackWithError(callback, null, this.oStates[id]);
      }
      return this.#states.getState(id, callback);
    }
  }
  // find out default history instance
  async _getDefaultHistory() {
    if (!this.defaultHistory) {
      let data;
      try {
        data = await this.getForeignObjectAsync("system.config", null);
      } catch {
      }
      if (data?.common) {
        this.defaultHistory = data.common.defaultHistory;
      }
      if (data?.native) {
        this._systemSecret = data.native.secret;
      }
      if (!this.defaultHistory) {
        let _obj;
        try {
          _obj = await this.#objects.getObjectViewAsync("system", "instance", {
            startkey: "system.adapter.",
            endkey: "system.adapter.\u9999"
          });
        } catch {
        }
        if (_obj?.rows) {
          for (const row of _obj.rows) {
            if (row.value?.common && row.value.common.type === "storage") {
              this.defaultHistory = row.id.substring("system.adapter.".length);
              break;
            }
          }
        }
        if (!this.defaultHistory) {
          this.defaultHistory = "history.0";
        }
      }
    }
  }
  /**
   * Read historian data for states of any instance or system state.
   *
   * This function can read values from history adapters like: history, sql, influxdb. It expects the full path of object ID.
   * Normally only foreign history has interest, so there is no getHistory and getForeignHistory
   *
   * Possible options:
   *
   *  - instance - (optional) name of instance, where to read the historian data, e.g. 'history.0', 'sql.1'. By default, will be taken from system settings.
   *  - start - (optional) time in ms - Date.now()', by default is (now - 1 week)
   *  - end - (optional) time in ms - Date.now()', by default is (now + 5000 seconds)
   *  - step - (optional) used in aggregate (m4, max, min, average, total) step in ms of intervals
   *  - count - number of values if aggregate is 'onchange' or number of intervals if other aggregate method. Count will be ignored if step is set.
   *  - from - if from field should be included in answer
   *  - ack - if ack field should be included in answer
   *  - q - if q field should be included in answer
   *  - addId - if id field should be included in answer
   *  - limit - do not return more entries than limit
   *  - ignoreNull - if null values should be included (false), replaced by last not null value (true) or replaced with 0 (0)
   *  - sessionId - (optional) identifier of request, will be returned back in the answer
   *  - aggregate - aggregate method:
   *      - minmax - used special algorithm. Splice the whole time range in small intervals and find for every interval max, min, start and end values.
   *      - max - Splice the whole time range in small intervals and find for every interval max value and use it for this interval (nulls will be ignored).
   *      - min - Same as max, but take minimal value.
   *      - average - Same as max, but take average value.
   *      - total - Same as max, but calculate total value.
   *      - count - Same as max, but calculate number of values (nulls will be calculated).
   *      - none - No aggregation at all. Only raw values in the given period.
   *
   * @param id object ID of the state.
   * @param options see function description
   * @param callback return result
   *        ```js
   *            function (error, result, step, sessionId) {
   *              if (error) adapter.log.error('Cannot read value: ' + err);
   *            }
   *        ```
   *
   *        See possible attributes of the state in @setState explanation
   */
  getHistory(id, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    import_validator.Validator.assertString(id, "id");
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    import_validator.Validator.assertCallback(callback, "callback");
    return this._getHistory({ id, options, callback });
  }
  // Checked implementation
  async _getHistory(_options) {
    const { id, callback } = _options;
    let { options } = _options;
    try {
      this._utils.validateId(id, true, null);
    } catch (e) {
      return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
    }
    options = options || {};
    options.end = options.end || Date.now() + 5e6;
    if (!options.count && !options.start) {
      options.start = options.start || Date.now() - 6048e5;
    }
    if (!options.instance) {
      if (!this.defaultHistory) {
        await this._getDefaultHistory();
        return this.getHistory(id, options, callback);
      }
      options.instance = this.defaultHistory;
    }
    this.sendTo(options.instance || "history.0", "getHistory", { id, options }, (res) => {
      import_js_controller_common.tools.maybeCallbackWithError(callback, res.error, res.result, res.step, res.sessionId);
    });
  }
  /**
   * Convert ID into object with device's, channel's and state's name.
   *
   * Convert "adapter.instance.D.C.S" in object `{device: D, channel: C, state: S}`
   * Convert ID to `{device: D, channel: C, state: S}`
   *
   * @param id short or long string of ID like "stateID" or "adapterName.0.stateID".
   * @returns parsed ID as an object
   */
  idToDCS(id) {
    if (!id) {
      return null;
    }
    import_validator.Validator.assertString(id, "id");
    const parts = id.split(".");
    if (`${parts[0]}.${parts[1]}` !== this.namespace) {
      this._logger.warn(`${this.namespaceLog} Try to decode id not from this adapter`);
      return null;
    }
    return { device: parts[2], channel: parts[3], state: parts[4] };
  }
  /**
   * Deletes a state of this instance.
   * The object will NOT be deleted. If you want to delete it too, use @delObject instead.
   *
   * It is not required to provice the adapter namespace, because it will automatically be added.
   * E.g. to delete "adapterName.X.myObject", only "myObject" is required as ID.
   *
   * No error is returned if state does not exist.
   *
   * @param id exactly object ID (without namespace)
   * @param options optional user context
   * @param callback return result
   *        ```js
   *            function (err) {
   *              if (err) adapter.log.error('Cannot delete object: ' + err);
   *            }
   *        ```
   */
  delState(id, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    import_validator.Validator.assertString(id, "id");
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    return this._delState({ id, options, callback });
  }
  _delState(_options) {
    const { options, callback } = _options;
    let { id } = _options;
    try {
      this._utils.validateId(id, false, null);
    } catch (e) {
      return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
    }
    id = this._utils.fixId(id);
    return this.delForeignState(id, options, callback);
  }
  /**
   * Deletes a state of any adapter.
   * The object is NOT deleted. If you want to delete it too, use @delForeignObject instead.
   *
   * No error is returned if state does not exist.
   *
   * @param id long string for ID like "adapterName.0.stateID".
   * @param options optional argument to describe the user context
   * @param callback return result
   * ```js
   * function (err) {}
   * ```
   */
  delForeignState(id, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    import_validator.Validator.assertString(id, "id");
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    return this._delForeignState({ id, options, callback });
  }
  async _delForeignState(_options) {
    const { id, options, callback } = _options;
    if (!this.#states) {
      this._logger.info(`${this.namespaceLog} delForeignState not processed because States database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    try {
      this._utils.validateId(id, true, options);
    } catch (e) {
      return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
    }
    if (options?.user && options.user !== import_constants.SYSTEM_ADMIN_USER) {
      try {
        await this._checkStates(id, options, "delState");
      } catch (e) {
        return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
      }
    }
    this.#states.delState(id, callback);
  }
  /**
   * Read all states of this adapter, that pass the pattern
   *
   * Allows to read all states of current adapter according to pattern. To read all states of current adapter use:
   * ```js
   *     adapter.getStates('*', function (err, states) {
   *         for (var id in states) {
   *              adapter.log.debug('"' + id + '" = "' + states[id].val);
   *         }
   *     });
   * ```
   *
   * @param pattern string in form 'adapter.0.*' or like this. It can be an array of IDs too.
   * @param options optional argument to describe the user context
   * @param callback return result
   * ```js
   * function (err, states) {}, where states is an object like {"ID1": {"val": 1, "ack": true}, "ID2": {"val": 2, "ack": false}, ...}
   * ```
   */
  getStates(pattern, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    import_validator.Validator.assertPattern(pattern, "pattern");
    const fixedPattern = Array.isArray(pattern) ? pattern : this._utils.fixId(pattern, true);
    this.getForeignStates(fixedPattern, options, callback);
  }
  async _processStatesSecondary(keys, targetObjs, srcObjs) {
    const arr = await this.#states.getStates(keys);
    const result = {};
    for (let i = 0; i < keys.length; i++) {
      const obj = targetObjs && targetObjs[i];
      if (obj?.common?.alias && srcObjs) {
        const srcObj = srcObjs[i];
        if (srcObj) {
          result[obj._id] = import_js_controller_common.tools.formatAliasValue({
            sourceCommon: srcObj.common,
            targetCommon: obj.common,
            state: arr[i] || null,
            logger: this._logger,
            logNamespace: this.namespaceLog,
            sourceId: srcObj._id,
            targetId: obj._id
          }) || null;
        } else {
          result[obj._id || keys[i]] = arr[i] || null;
        }
      } else {
        result[obj?._id || keys[i]] = arr[i] || null;
      }
    }
    return result;
  }
  /**
   * Ensures, that object information is read, and the alias id is mapped to the source id if an alias is contained in the getStates call
   * The adaption of the actual values is then performed in _processStatesSecondary, to apply alias conversion methods
   *
   * @param keys all ids of the getStates call
   * @param targetObjs the target objects (e.g. alias objects or the actual objects)
   */
  async _processStates(keys, targetObjs) {
    const aliasIndexes = [];
    const aliasIds = [];
    const fullTargetObjs = new Array(keys.length).fill(null);
    keys.forEach((id, idx) => {
      if (id.startsWith(import_constants.ALIAS_STARTS_WITH)) {
        aliasIndexes.push(idx);
        aliasIds.push(id);
      }
    });
    if (aliasIds.length) {
      keys = [...keys];
      if (!targetObjs) {
        targetObjs = await this._getObjectsByArray(aliasIds);
      } else {
        targetObjs = targetObjs.filter((_val, idx) => aliasIndexes.includes(idx));
      }
      for (let i = 0; i < aliasIds.length; i++) {
        const obj = targetObjs[i];
        const aliasIdx = aliasIndexes[i];
        fullTargetObjs[aliasIdx] = obj;
        if (obj?.common?.alias) {
          keys[aliasIdx] = import_js_controller_common.tools.isObject(obj.common.alias.id) && "read" in obj.common.alias.id ? obj.common.alias.id.read : obj.common.alias.id;
        }
      }
      const srcObjs = await this._getObjectsByArray(keys);
      return this._processStatesSecondary(keys, fullTargetObjs, srcObjs);
    }
    return this._processStatesSecondary(keys, null, null);
  }
  /**
   * Read all states of all adapters (and system states), that pass the pattern
   *
   * Allows to read all states of current adapter according to pattern. To read all states of current adapter use:
   * ```js
   *     adapter.getStates('*', function (err, states) {
   *         for (var id in states) {
   *              adapter.log.debug('"' + id + '" = "' + states[id].val);
   *         }
   *     });
   * ```
   *
   * @param pattern string in form 'adapter.0.*' or like this. It can be an array of IDs too.
   * @param options optional argument to describe the user context
   * @param callback return result
   * ```js
   * function (err, states) {}, where states is an object like {"ID1": {"val": 1, "ack": true}, "ID2": {"val": 2, "ack": false}, ...}
   * ```
   */
  getForeignStates(pattern, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (typeof pattern === "function") {
      callback = pattern;
      pattern = "*";
    }
    import_validator.Validator.assertPattern(pattern, "pattern");
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    import_validator.Validator.assertCallback(callback, "callback");
    return this._getForeignStates({ pattern, options: options || {}, callback });
  }
  async _getForeignStates(_options) {
    const { options, pattern, callback } = _options;
    if (!this.#states) {
      this._logger.info(`${this.namespaceLog} getForeignStates not processed because States database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} getForeignStates not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    if (Array.isArray(pattern)) {
      if (options.user && options.user !== import_constants.SYSTEM_ADMIN_USER) {
        try {
          const { objs, ids } = await this._checkStates(pattern, options, "getState");
          const res = await this._processStates(ids, objs);
          return import_js_controller_common.tools.maybeCallbackWithError(callback, null, res);
        } catch (e) {
          return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
        }
      } else {
        const res = await this._processStates(pattern, options?._objects);
        return import_js_controller_common.tools.maybeCallbackWithError(callback, null, res);
      }
    } else {
      let params = {};
      if (pattern && pattern !== "*") {
        params = {
          startkey: pattern.replace(/\*/g, ""),
          endkey: pattern.replace(/\*/g, "\u9999")
        };
      }
      let originalChecked;
      if (options.checked !== void 0) {
        originalChecked = options.checked;
      }
      options.checked = true;
      if (options.user === import_constants.SYSTEM_ADMIN_USER && options.maintenance) {
        try {
          const keys = await this.#states.getKeys(pattern);
          const res = await this._processStatesSecondary(keys || [], null, null);
          return import_js_controller_common.tools.maybeCallbackWithError(callback, null, res);
        } catch (e) {
          return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
        }
      }
      try {
        const res = await this.#objects.getObjectView("system", "state", params, options);
        if (originalChecked !== void 0) {
          options.checked = originalChecked;
        } else {
          options.checked = void 0;
        }
        if (!res) {
          return import_js_controller_common.tools.maybeCallbackWithError(callback, null, {});
        }
        const keys = [];
        const objs = [];
        let regEx;
        try {
          if (pattern !== "*" && pattern[pattern.length - 1] !== "*") {
            regEx = new RegExp(import_js_controller_common.tools.pattern2RegEx(pattern));
          }
          for (const row of res.rows) {
            const id = row.id;
            if (id && (!regEx || regEx.test(id))) {
              keys.push(id);
              objs.push(row.value);
            }
          }
        } catch (e) {
          return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
        }
        options._objects = objs;
        this.getForeignStates(keys, options, callback);
      } catch (e) {
        return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
      }
    }
  }
  /**
   * Add subscription for given alias, if it is not a state it will be ignored
   *
   * @param aliasObj the alias object
   * @param pattern pattern to subscribe for
   */
  async _addAliasSubscribe(aliasObj, pattern) {
    if (aliasObj.type !== "state") {
      return;
    }
    if (!aliasObj.common?.alias?.id) {
      this._logger.warn(`${this.namespaceLog} Alias ${aliasObj._id} has no target 5`);
      throw new Error(`Alias ${aliasObj._id} has no target`);
    }
    const sourceId = import_js_controller_common.tools.isObject(aliasObj.common.alias.id) ? aliasObj.common.alias.id.read : aliasObj.common.alias.id;
    try {
      this._utils.validateId(sourceId, true, null);
    } catch (e) {
      throw new Error(`Error validating alias id of ${aliasObj._id}: ${e.message}`);
    }
    const targetEntry = {
      alias: (0, import_deep_clone.default)(aliasObj.common.alias),
      id: aliasObj._id,
      pattern,
      type: aliasObj.common.type,
      max: aliasObj.common.max,
      min: aliasObj.common.min,
      unit: aliasObj.common.unit
    };
    let aliasDetails;
    if (!this.aliases.has(sourceId)) {
      aliasDetails = { targets: [] };
      this.aliases.set(sourceId, aliasDetails);
    } else {
      aliasDetails = this.aliases.get(sourceId);
    }
    if (!aliasDetails.source) {
      await this.#states.subscribe(sourceId);
      const sourceObj = await this.#objects.getObject(sourceId, { user: import_constants.SYSTEM_ADMIN_USER });
      if (sourceObj?.common && this.aliases.has(sourceObj._id)) {
        aliasDetails.source = {
          min: sourceObj.common.min,
          max: sourceObj.common.max,
          type: sourceObj.common.type,
          unit: sourceObj.common.unit
        };
      }
    }
    aliasDetails.targets.push(targetEntry);
  }
  /**
   * Remove an alias subscribe
   *
   * @param sourceId id of the source object
   * @param aliasObjOrIdx the alias target or the index of the targets array
   */
  async _removeAliasSubscribe(sourceId, aliasObjOrIdx) {
    if (!this.aliases.has(sourceId)) {
      return;
    }
    const alias = this.aliases.get(sourceId);
    const pos = typeof aliasObjOrIdx === "number" ? aliasObjOrIdx : alias.targets.indexOf(aliasObjOrIdx);
    if (pos !== -1) {
      alias.targets.splice(pos, 1);
      if (!alias.targets.length) {
        this.aliases.delete(sourceId);
        await this.#states.unsubscribe(sourceId);
      }
    }
  }
  /**
   * Subscribe for changes on all states of all adapters (and system states), that pass the pattern
   *
   * Allows to Subscribe on changes all states of all instances according to pattern. E.g. to read all states of 'adapterName.X' instance use:
   * ```js
   *     adapter.subscribeForeignStates('adapterName.X.*');
   * ```
   *
   * @param pattern string in form 'adapter.0.*' or like this. It can be an array of IDs too.
   * @param options optional argument to describe the user context
   * @param callback return result ```function (err) {}```
   */
  subscribeForeignStates(pattern, options, callback) {
    pattern = pattern || "*";
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    if (pattern instanceof RegExp) {
      return import_js_controller_common.tools.maybeCallbackWithError(callback, `Regexp is not supported for "subscribeForeignStates", received "${pattern.toString()}"`);
    }
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    import_validator.Validator.assertPattern(pattern, "pattern");
    return this._subscribeForeignStates({ pattern, options, callback });
  }
  async _subscribeForeignStates(_options) {
    const { pattern, options, callback } = _options;
    await this._autoSubscribeOn();
    if (!this.#states) {
      this._logger.info(`${this.namespaceLog} subscribeForeignStates not processed because States database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} subscribeForeignStates not processed because Objects database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    for (const autoSubEntry of this.autoSubscribe) {
      if (typeof pattern === "string" && (pattern === "*" || pattern.startsWith(`${autoSubEntry}.`))) {
        let state;
        try {
          state = await this.#states.getState(`system.adapter.${autoSubEntry}.subscribes`);
        } catch {
        }
        state = state || { val: "{}" };
        state.val = state.val || "{}";
        let subs;
        try {
          subs = JSON.parse(state.val);
        } catch {
          this._logger.error(`${this.namespaceLog} Cannot parse subscribes for "${autoSubEntry}.subscribes"`);
        }
        if (!import_js_controller_common.tools.isObject(subs)) {
          subs = {};
        }
        if (!import_js_controller_common.tools.isObject(subs[pattern])) {
          subs[pattern] = {};
        }
        if (typeof subs[pattern][this.namespace] !== "number") {
          subs[pattern][this.namespace] = 0;
        }
        subs[pattern][this.namespace]++;
        this.outputCount++;
        this.#states.setState(`system.adapter.${autoSubEntry}.subscribes`, JSON.stringify(subs));
      }
    }
    if (Array.isArray(pattern)) {
      const aliasesIds = pattern.map((id) => id.startsWith(import_constants.ALIAS_STARTS_WITH) ? id : null).filter((id) => id);
      const nonAliasesIds = pattern.map((id) => !id.startsWith(import_constants.ALIAS_STARTS_WITH) ? id : null).filter((id) => id);
      for (const aliasPattern of pattern) {
        if ((aliasPattern.startsWith(import_constants.ALIAS_STARTS_WITH) || aliasPattern.includes("*")) && !this.aliasPatterns.has(aliasPattern)) {
          this.aliasPatterns.add(aliasPattern);
        }
      }
      const promises = [];
      if (aliasesIds.length) {
        if (!this._aliasObjectsSubscribed) {
          this._aliasObjectsSubscribed = true;
          this.#objects.subscribe(`${import_constants.ALIAS_STARTS_WITH}*`);
        }
        const aliasObjs = await this._getObjectsByArray(aliasesIds, options);
        for (const aliasObj of aliasObjs) {
          if (aliasObj) {
            promises.push(this._addAliasSubscribe(aliasObj, aliasObj._id));
          }
        }
      }
      if (nonAliasesIds.length) {
        for (const id of nonAliasesIds) {
          promises.push(new Promise((resolve) => this.#states.subscribeUser(id, resolve)));
        }
      }
      try {
        await Promise.all(promises);
      } catch (e) {
        this._logger.error(`${this.namespaceLog} Error on "subscribeForeignStates": ${e.message}`);
      }
      return import_js_controller_common.tools.maybeCallback(callback);
    } else if (pattern.includes("*")) {
      if (pattern === "*" || pattern.startsWith(import_constants.ALIAS_STARTS_WITH)) {
        if (!this._aliasObjectsSubscribed) {
          this._aliasObjectsSubscribed = true;
          this.#objects.subscribe(`${import_constants.ALIAS_STARTS_WITH}*`);
        }
        try {
          const objs = await this.getForeignObjectsAsync(pattern, null, null, options);
          const promises = [];
          if (!this.aliasPatterns.has(pattern)) {
            this.aliasPatterns.add(pattern);
          }
          for (const id of Object.keys(objs)) {
            if (id.startsWith(import_constants.ALIAS_STARTS_WITH)) {
              const aliasObj = objs[id];
              promises.push(this._addAliasSubscribe(aliasObj, pattern));
            }
          }
          try {
            await Promise.all(promises);
          } catch (e) {
            this._logger.error(`${this.namespaceLog} Error on "subscribeForeignStates": ${e.message}`);
          }
          if (!this.#states) {
            this._logger.info(`${this.namespaceLog} subscribeForeignStates not processed because States database not connected`);
            return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
          }
          if (promises.length && pattern !== "*") {
            return import_js_controller_common.tools.maybeCallback(callback);
          }
          this.#states.subscribeUser(pattern, callback);
        } catch (e) {
          this._logger.warn(`${this.namespaceLog} Cannot subscribe to ${pattern}: ${e.message}`);
          return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
        }
      } else {
        this.#states.subscribeUser(pattern, callback);
      }
    } else if (pattern.startsWith(import_constants.ALIAS_STARTS_WITH)) {
      if (!this._aliasObjectsSubscribed) {
        this._aliasObjectsSubscribed = true;
        this.#objects.subscribe(`${import_constants.ALIAS_STARTS_WITH}*`);
      }
      try {
        const aliasObj = await this.#objects.getObject(pattern, options);
        if (aliasObj) {
          await this._addAliasSubscribe(aliasObj, pattern);
          return import_js_controller_common.tools.maybeCallback(callback);
        }
        return import_js_controller_common.tools.maybeCallback(callback);
      } catch (e) {
        this._logger.warn(`${this.namespaceLog} cannot subscribe on alias "${pattern}": ${e.message}`);
      }
    } else {
      this.#states.subscribeUser(pattern, callback);
    }
  }
  /**
   * Unsubscribe for changes for given pattern
   *
   * This function allows to unsubscribe from changes. The pattern must be equal to requested one.
   * ```js
   *     adapter.subscribeForeignStates('adapterName.X.*');
   *     adapter.unsubscribeForeignStates('adapterName.X.abc*'); // This will not work
   *     adapter.unsubscribeForeignStates('adapterName.X.*'); // Valid unsubscribe
   * ```
   *
   * @param pattern string in form 'adapter.0.*'. Must be the same as subscribe.
   * @param options optional argument to describe the user context
   * @param callback return result
   * ```js
   * function (err) {}
   * ```
   */
  unsubscribeForeignStates(pattern, options, callback) {
    pattern = pattern || "*";
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    if (pattern instanceof RegExp) {
      return import_js_controller_common.tools.maybeCallbackWithError(callback, `Regexp is not supported for "unsubscribeForeignStates", received "${pattern.toString()}"`);
    }
    import_validator.Validator.assertPattern(pattern, "pattern");
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    return this._unsubscribeForeignStates({ pattern, options, callback });
  }
  async _unsubscribeForeignStates(_options) {
    const { pattern, callback } = _options;
    if (!this.#states) {
      this._logger.info(`${this.namespaceLog} unsubscrubeForeignStates not processed because States database not connected`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    if (this.autoSubscribe && typeof pattern === "string") {
      for (const autoSub of this.autoSubscribe) {
        if (pattern === "*" || pattern.substring(0, autoSub.length + 1) === `${autoSub}.`) {
          let state;
          try {
            state = await this.#states.getState(`system.adapter.${autoSub}.subscribes`);
          } catch {
          }
          if (!state || !state.val) {
            continue;
          }
          let subs;
          try {
            subs = JSON.parse(state.val);
          } catch {
            this._logger.error(`${this.namespaceLog} Cannot parse subscribes for "${autoSub}.subscribes"`);
            continue;
          }
          if (!import_js_controller_common.tools.isObject(subs) || !import_js_controller_common.tools.isObject(subs[pattern]) || subs[pattern][this.namespace] === void 0) {
            continue;
          }
          if (typeof subs[pattern][this.namespace] === "number") {
            subs[pattern][this.namespace]--;
            if (subs[pattern][this.namespace] <= 0) {
              delete subs[pattern][this.namespace];
            }
          } else {
            delete subs[pattern][this.namespace];
          }
          if (!Object.keys(subs[pattern]).length) {
            delete subs[pattern];
          }
          this.outputCount++;
          this.#states.setState(`system.adapter.${autoSub}.subscribes`, JSON.stringify(subs));
        }
      }
    }
    let aliasPattern;
    const promises = [];
    if (Array.isArray(pattern)) {
      for (const _pattern of pattern) {
        promises.push(this.unsubscribeForeignStatesAsync(_pattern));
      }
    } else if (pattern.includes("*") || pattern.startsWith(import_constants.ALIAS_STARTS_WITH)) {
      if (pattern === "*" || pattern.startsWith(import_constants.ALIAS_STARTS_WITH)) {
        aliasPattern = pattern;
        if (pattern === "*") {
          promises.push(this.#states.unsubscribeUser(pattern));
        }
      } else {
        promises.push(this.#states.unsubscribeUser(pattern));
      }
    } else {
      promises.push(this.#states.unsubscribeUser(pattern));
    }
    if (aliasPattern) {
      this.aliasPatterns.delete(aliasPattern);
      for (const [sourceId, alias] of this.aliases) {
        for (let i = alias.targets.length - 1; i >= 0; i--) {
          if (alias.targets[i].pattern === aliasPattern) {
            promises.push(this._removeAliasSubscribe(sourceId, i));
          }
        }
      }
    }
    await Promise.all(promises);
    if (!this.aliases.size && this._aliasObjectsSubscribed) {
      this._aliasObjectsSubscribed = false;
      this.#objects.unsubscribe(`${import_constants.ALIAS_STARTS_WITH}*`);
    }
    return import_js_controller_common.tools.maybeCallback(callback);
  }
  /**
   * Subscribe for changes on all states of this instance, that pass the pattern
   *
   * Allows to Subscribe on changes all states of current adapter according to pattern. To read all states of current adapter use:
   * ```js
   *     adapter.subscribeStates('*'); // subscribe for all states of this adapter
   * ```
   *
   * @param pattern string in form 'adapter.0.*' or like this. Only string allowed
   * @param options optional argument to describe the user context
   * @param callback optional callback
   */
  subscribeStates(pattern, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    import_validator.Validator.assertPattern(pattern, "pattern");
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    return this._subscribeForeignStates({
      pattern: Array.isArray(pattern) ? pattern : this._utils.fixId(pattern, true),
      options,
      callback
    });
  }
  /**
   * Unsubscribe for changes for given pattern for own states.
   *
   * This function allows to unsubscribe from changes. The pattern must be equal to requested one.
   *
   * ```js
   *     adapter.unsubscribeStates('abc*'); // This will not work
   *     adapter.unsubscribeStates('*');    // Valid unsubscribe
   * ```
   *
   * @param pattern string in form 'adapter.0.*'. Must be the same as subscribe.
   * @param options optional argument to describe the user context
   * @param callback optional callback
   */
  unsubscribeStates(pattern, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    import_validator.Validator.assertPattern(pattern, "pattern");
    import_validator.Validator.assertOptionalCallback(callback, "callback");
    if (options !== null && options !== void 0) {
      import_validator.Validator.assertObject(options, "options");
    }
    return this._unsubscribeForeignStates({
      pattern: Array.isArray(pattern) ? pattern : this._utils.fixId(pattern, true),
      options,
      callback
    });
  }
  /**
   * Return plugin instance
   *
   * @param name name of the plugin to return
   * @returns plugin instance or null if not existent or not isActive
   */
  getPluginInstance(name) {
    if (!this.pluginHandler) {
      return null;
    }
    import_validator.Validator.assertString(name, "name");
    return this.pluginHandler.getPluginInstance(name);
  }
  /**
   * Return plugin configuration
   *
   * @param name name of the plugin to return
   * @returns plugin configuration or null if not existent or not isActive
   */
  getPluginConfig(name) {
    if (!this.pluginHandler) {
      return null;
    }
    import_validator.Validator.assertString(name, "name");
    return this.pluginHandler.getPluginConfig(name);
  }
  async _autoSubscribeOn() {
    if (!this.autoSubscribe && this.#objects) {
      try {
        const res = await this.#objects.getObjectViewAsync("system", "instance", {
          startkey: "system.adapter.",
          endkey: "system.adapter.\u9999"
        });
        this.autoSubscribe = [];
        for (const row of res.rows) {
          if (row.value?.common.subscribable) {
            const _id = row.id.substring(15);
            if (!this.autoSubscribe.includes(_id)) {
              this.autoSubscribe.push(_id);
            }
          }
        }
        await this.#objects.subscribeAsync("system.adapter.*");
      } catch {
      }
    }
  }
  /**
   * This method returns the list of license that can be used by this adapter
   *
   * @param all if return the licenses, that used by other instances (true) or only for this instance (false)
   * @param adapterName Return licenses for specific adapter
   * @returns list of suitable licenses
   */
  async getSuitableLicenses(all, adapterName) {
    const licenses = [];
    try {
      const obj = await this.getForeignObjectAsync("system.licenses");
      const uuidObj = await this.getForeignObjectAsync("system.meta.uuid");
      if (!uuidObj?.native?.uuid) {
        this._logger.warn(`${this.namespaceLog} No UUID found!`);
        return licenses;
      }
      const uuid = uuidObj.native.uuid;
      if (obj?.native?.licenses?.length) {
        const now = Date.now();
        const cert = import_fs_extra.default.readFileSync(import_node_path.default.join(thisDir, "..", "..", "cert", "cloudCert.crt"));
        let adapterObj;
        if (adapterName) {
          try {
            adapterObj = await this.getForeignObjectAsync(`system.adapter.${adapterName}`);
          } catch {
          }
        }
        const version = import_semver.default.major(adapterObj?.common?.version || this.pack.version);
        for (const license of obj.native.licenses) {
          try {
            const decoded = import_jsonwebtoken.default.verify(license.json, cert);
            if (decoded.name && (!decoded.valid_till || decoded.valid_till === "0000-00-00 00:00:00" || new Date(decoded.valid_till).getTime() > now)) {
              if (decoded.name.startsWith(`iobroker.${adapterName || this.name}`) && (all || !license.usedBy || license.usedBy === this.namespace)) {
                if (decoded.version === "&lt;2" || decoded.version === "<2" || decoded.version === "<1" || decoded.version === "<=1") {
                  if (version !== 0 && version !== 1) {
                    const exception = decoded.name === "iobroker.vis" && version === 2 && decoded.uuid;
                    if (!exception) {
                      continue;
                    }
                  }
                } else if (decoded.version && decoded.version !== version) {
                  continue;
                }
                if (decoded.uuid && decoded.uuid !== uuid) {
                  continue;
                }
                if (decoded.invoice !== "free") {
                  const pos = licenses.findIndex((item) => item.invoice === "free");
                  if (pos !== -1) {
                    licenses.splice(pos, 1);
                  }
                }
                licenses.push({ ...license, decoded });
              }
            }
          } catch (e) {
            this._logger.error(`${this.namespaceLog} Cannot decode license "${license.product}": ${e.message}`);
          }
        }
      }
    } catch {
    }
    licenses.sort((a, b) => {
      const aInvoice = a.decoded.invoice !== "free";
      const bInvoice = b.decoded.invoice !== "free";
      if (aInvoice === bInvoice) {
        return 0;
      } else if (aInvoice) {
        return -1;
      } else if (bInvoice) {
        return 1;
      }
      return 0;
    });
    return licenses;
  }
  /**
   * Add given id to log redirect list
   *
   * @param isActive if id should be added or removed
   * @param id the id to add
   */
  logRedirect(isActive, id) {
    if (id === `system.adapter.${this.namespace}`) {
      return;
    }
    if (isActive) {
      if (!this.logList.has(id)) {
        this.logList.add(id);
      }
    } else {
      this.logList.delete(id);
    }
  }
  _reportStatus() {
    if (!this.#states) {
      return;
    }
    const reportStatusExpirySec = Math.floor(this._config.system.statisticsInterval / 1e3) + 10;
    const id = `system.adapter.${this.namespace}`;
    this.#states.setState(`${id}.alive`, {
      val: true,
      ack: true,
      expire: reportStatusExpirySec,
      from: id
    });
    this.outputCount++;
    if (this.connected) {
      this.#states.setState(`${id}.connected`, {
        val: true,
        ack: true,
        expire: reportStatusExpirySec,
        from: id
      });
      this.outputCount++;
    }
    if (!this.startedInCompactMode) {
      (0, import_pidusage.default)(process.pid, (err, stats) => {
        if (!err && this && this.#states && this.#states.setState && stats) {
          this.#states.setState(`${id}.cpu`, {
            ack: true,
            from: id,
            val: Math.round(100 * stats.cpu) / 100,
            expire: reportStatusExpirySec
          });
          this.#states.setState(`${id}.cputime`, {
            ack: true,
            from: id,
            val: stats.ctime / 1e3,
            expire: reportStatusExpirySec
          });
          this.outputCount += 2;
        }
      });
      try {
        const mem = process.memoryUsage();
        this.#states.setState(`${id}.memRss`, {
          val: parseFloat((mem.rss / 1048576).toFixed(2)),
          ack: true,
          from: id,
          expire: reportStatusExpirySec
        });
        this.#states.setState(`${id}.memHeapTotal`, {
          val: parseFloat((mem.heapTotal / 1048576).toFixed(2)),
          ack: true,
          from: id,
          expire: reportStatusExpirySec
        });
        this.#states.setState(`${id}.memHeapUsed`, {
          val: parseFloat((mem.heapUsed / 1048576).toFixed(2)),
          ack: true,
          from: id,
          expire: reportStatusExpirySec
        });
      } catch (e) {
        this._logger.warn(`${this.namespaceLog} Could not query used process memory: ${e.message}`);
      }
      this.outputCount += 3;
      if (this.eventLoopLags.length) {
        const eventLoopLag = Math.ceil(this.eventLoopLags.reduce((a, b) => a + b) / this.eventLoopLags.length);
        this.#states.setState(`${id}.eventLoopLag`, {
          val: eventLoopLag,
          ack: true,
          from: id,
          expire: reportStatusExpirySec
        });
        this.eventLoopLags = [];
        this.outputCount++;
      }
    }
    this.outputCount += 3;
    this.#states.setState(`${id}.uptime`, {
      val: parseInt(process.uptime().toFixed(), 10),
      ack: true,
      from: id,
      expire: reportStatusExpirySec
    });
    this.#states.setState(`${id}.inputCount`, {
      val: this.inputCount,
      ack: true,
      from: id,
      expire: reportStatusExpirySec
    });
    this.#states.setState(`${id}.outputCount`, {
      val: this.outputCount,
      ack: true,
      from: id,
      expire: reportStatusExpirySec
    });
    this.inputCount = 0;
    this.outputCount = 0;
  }
  // debug function to find error with stop logging
  _checkLogging() {
    let logs = [];
    logs.push(`Actual Loglist - ${JSON.stringify(Array.from(this.logList))}`);
    if (!this.#states) {
      return;
    }
    this.#states.getKeys(`${import_constants2.SYSTEM_ADAPTER_PREFIX}*.logging`, (err, keys) => {
      if (keys?.length) {
        if (!this.#states) {
          return;
        }
        this.#states.getStates(keys, (err2, obj) => {
          if (obj) {
            for (let i = 0; i < keys.length; i++) {
              const objPart = obj[i];
              if (objPart) {
                const id = keys[i].substring(0, keys[i].length - ".logging".length);
                if (typeof objPart === "string" && // @ts-expect-error recheck code-wise this should not be possible to have a string
                (objPart.includes('"val":true') || objPart.includes('"val":"true"')) || typeof objPart === "object" && (objPart.val === true || objPart.val === "true")) {
                  logs.push(`Subscriber - ${id} ENABLED`);
                } else {
                  if (logs) {
                    logs.push(`Subscriber - ${id} (disabled)`);
                  } else {
                    this._logger.error(`${this.namespaceLog} LOGINFO: Subscriber - ${id} (disabled)`);
                  }
                }
              }
            }
          }
          if (logs) {
            for (let m = 0; m < logs.length; m++) {
              this._logger.error(`${this.namespaceLog} LOGINFO: ${logs[m]}`);
            }
            logs = null;
          }
        });
      }
    });
  }
  /**
   * Initialize the logging logic
   */
  async _initLogging() {
    if (!this.#states) {
      return;
    }
    let messages = [];
    const ts = this._logger.transports.find((t) => t.name === "NT");
    ts.on("logged", (info) => {
      info.from = this.namespace;
      if (this._options.logTransporter && this.logRequired && !this._stopInProgress) {
        this.emit("log", info);
      }
      if (!this.logList.size) {
        if (messages && !this._options.logTransporter) {
          messages.push(info);
          if (messages.length > this._config.states.maxQueue) {
            messages.splice(0, messages.length - this._config.states.maxQueue);
          }
        }
      } else if (this.#states?.pushLog) {
        for (const instanceId of this.logList) {
          this.#states.pushLog(instanceId, info);
        }
      }
    });
    const keys = await this.#states.getKeys(`${import_constants2.SYSTEM_ADAPTER_PREFIX}*.logging`);
    if (keys?.length) {
      if (!this.#states) {
        return;
      }
      const obj = await this.#states.getStates(keys);
      if (obj) {
        for (let i = 0; i < keys.length; i++) {
          const objPart = obj[i];
          if (!objPart) {
            continue;
          }
          const id = keys[i].substring(0, keys[i].length - ".logging".length);
          if (typeof objPart === "object" && (objPart.val === true || objPart.val === "true")) {
            this.logRedirect(true, id);
          }
        }
        if (this.logList.size && messages?.length && this.#states) {
          for (const message of messages) {
            for (const instanceId of this.logList) {
              this.#states.pushLog(instanceId, message);
            }
          }
        }
      }
      messages = null;
    } else {
      messages = null;
    }
    this._options.logTransporter = this._options.logTransporter || this.ioPack.common.logTransporter;
    if (this._options.logTransporter) {
      this.requireLog = async (isActive, options) => {
        if (!this.#states) {
          return;
        }
        if (this.logRequired !== isActive) {
          this.logRequired = isActive;
          if (!isActive) {
            if (this.logOffTimer) {
              clearTimeout(this.logOffTimer);
            }
            this.logOffTimer = setTimeout(async () => {
              this.logOffTimer = null;
              this._logger.silly(`${this.namespaceLog} Change log subscriber state: FALSE`);
              this.outputCount++;
              if (this.#states) {
                try {
                  await this.setForeignStateAsync(`system.adapter.${this.namespace}.logging`, {
                    val: false,
                    ack: true,
                    from: `system.adapter.${this.namespace}`
                  }, options);
                } catch (e) {
                  this._logger.warn(`${this.namespaceLog} Could not change log subscriber state to "false": ${e.message}`);
                }
              }
            }, 1e4);
          } else {
            if (this.logOffTimer) {
              clearTimeout(this.logOffTimer);
              this.logOffTimer = null;
            } else {
              this._logger.silly(`${this.namespaceLog} Change log subscriber state: true`);
              this.outputCount++;
              try {
                await this.setForeignStateAsync(`system.adapter.${this.namespace}.logging`, {
                  val: true,
                  ack: true,
                  from: `system.adapter.${this.namespace}`
                }, options);
              } catch (e) {
                this._logger.warn(`${this.namespaceLog} Could not change log subscriber state to "true": ${e.message}`);
              }
            }
          }
        }
      };
      this.processLog = (msg) => {
        if (msg && !this._stopInProgress) {
          this.emit("log", msg);
        }
      };
      this.#states.subscribeLog(`system.adapter.${this.namespace}`);
    } else {
      this.requireLog = (isActive) => {
        if (isActive) {
          this._logger.warn(`${this.namespaceLog} requireLog is not supported by this adapter! Please set common.logTransporter to true`);
        }
      };
    }
  }
  // initStates is called from initAdapter
  _initStates(cb) {
    this._logger.silly(`${this.namespaceLog} objectDB connected`);
    this._config.states.maxQueue = this._config.states.maxQueue || 1e3;
    this._initializeTimeout = setTimeout(() => {
      this._initializeTimeout = null;
      if (this._config.isInstall) {
        this._logger.warn(`${this.namespaceLog} no connection to states DB. Terminating.`);
        this.terminate(import_js_controller_common.EXIT_CODES.NO_ERROR);
      } else {
        this._logger.warn(`${this.namespaceLog} slow connection to states DB. Still waiting ...`);
      }
    }, this._config.states.connectTimeout || 2e3);
    if (!this.States) {
      this._logger.warn(`${this.namespaceLog} States DB constructor has not been initialized`);
      this.terminate(import_js_controller_common.EXIT_CODES.NO_ERROR);
    }
    this.#states = new this.States({
      namespace: this.namespaceLog,
      connection: this._config.states,
      connected: async () => {
        if (!this.#states) {
          return;
        }
        this._logger.silly(`${this.namespaceLog} statesDB connected`);
        this.statesConnectedTime = Date.now();
        if (this._initializeTimeout) {
          clearTimeout(this._initializeTimeout);
          this._initializeTimeout = null;
        }
        if (!this._config.isInstall) {
          this.#states.subscribe(`system.adapter.${this.namespace}.sigKill`);
          this.#states.subscribe(`system.adapter.${this.namespace}.logLevel`);
        }
        if (this._options.subscribable) {
          this.#states.subscribe(`system.adapter.${this.namespace}.subscribes`);
          let state;
          try {
            state = await this.#states.getStateAsync(`system.adapter.${this.namespace}.subscribes`);
          } catch {
          }
          if (!state?.val) {
            this.patterns = {};
          } else {
            try {
              this.patterns = JSON.parse(state.val);
              Object.keys(this.patterns).forEach((p) => this.patterns[p].regex = import_js_controller_common.tools.pattern2RegEx(p));
            } catch {
              this.patterns = {};
            }
          }
          return import_js_controller_common.tools.maybeCallback(cb);
        }
        return import_js_controller_common.tools.maybeCallback(cb);
      },
      logger: this._logger,
      change: async (id, stateOrMessage) => {
        this.inputCount++;
        const state = stateOrMessage;
        if (!id || typeof id !== "string") {
          this._logger.warn(`${this.namespaceLog} Invalid id on system state change: ${JSON.stringify(id)}`);
          return;
        }
        if (id === `system.adapter.${this.namespace}.sigKill` && state && state.ts > this.statesConnectedTime && state.from && state.from.startsWith("system.host.")) {
          const sigKillVal = parseInt(state.val);
          if (!isNaN(sigKillVal)) {
            if (this.startedInCompactMode || sigKillVal === -1) {
              this._logger.info(`${this.namespaceLog} Got terminate signal ${sigKillVal === -1 ? "TERMINATE_YOURSELF" : ` TERMINATE ${sigKillVal}`}`);
            } else {
              this._logger.warn(`${this.namespaceLog} Got terminate signal. Checking desired PID: ${sigKillVal} vs own PID ${process.pid}`);
            }
            if (sigKillVal !== process.pid && !this._config.forceIfDisabled) {
              this._stop({
                isPause: false,
                isScheduled: false,
                exitCode: import_js_controller_common.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION,
                updateAliveState: false
              });
              setTimeout(() => this.terminate(import_js_controller_common.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION), 4e3);
            }
          }
        }
        if (id === `system.adapter.${this.namespace}.logLevel`) {
          if (this._config && this._config.log && state && !state.ack) {
            let currentLevel = this._config.log.level;
            if (state.val && state.val !== currentLevel && ["silly", "debug", "info", "warn", "error"].includes(state.val)) {
              this.overwriteLogLevel = true;
              this._config.log.level = state.val;
              for (const transport in this._logger.transports) {
                if (!Object.prototype.hasOwnProperty.call(this._logger.transports, transport)) {
                  continue;
                }
                if (!this._logger.transports[transport]._defaultConfigLoglevel) {
                  this._logger.transports[transport].level = state.val;
                }
              }
              this._logger.info(`${this.namespaceLog} Loglevel changed from "${currentLevel}" to "${state.val}"`);
              currentLevel = state.val;
            } else if (state.val && state.val !== currentLevel) {
              this._logger.info(`${this.namespaceLog} Got invalid loglevel "${state.val}", ignoring`);
            }
            this.outputCount++;
            this.#states && this.#states.setState(`system.adapter.${this.namespace}.logLevel`, {
              val: currentLevel,
              ack: true,
              from: `system.adapter.${this.namespace}`
            });
          }
        }
        if (id === `system.adapter.${this.namespace}.checkLogging`) {
          this._checkLogging();
        }
        if (this._options.subscribable && id === `system.adapter.${this.namespace}.subscribes`) {
          let subs;
          try {
            subs = JSON.parse(state && state.val || "{}");
            Object.keys(subs).forEach((p) => subs[p].regex = import_js_controller_common.tools.pattern2RegEx(p));
          } catch {
            subs = {};
          }
          this.patterns = subs;
          if (!this._stopInProgress) {
            if (typeof this._options.subscribesChange === "function") {
              this._options.subscribesChange(subs);
            } else {
              this.emit("subscribesChange", subs);
            }
          }
        }
        if (id.startsWith(import_constants2.SYSTEM_ADAPTER_PREFIX) && id.endsWith(".logging")) {
          const instance = id.substring(0, id.length - ".logging".length);
          this._logger.silly(`${this.namespaceLog} ${instance}: logging ${state ? state.val : false}`);
          this.logRedirect(state ? !!state.val : false, instance);
        } else if (id === `log.system.adapter.${this.namespace}`) {
          this._options.logTransporter && this.processLog && this.processLog(state);
        } else if (id === `messagebox.system.adapter.${this.namespace}` && state) {
          const obj = state;
          if (obj) {
            let callbackObj;
            if (obj.callback?.id) {
              callbackObj = this.messageCallbacks.get(obj.callback.id);
            }
            if (obj.callback?.ack && obj.callback.id && callbackObj) {
              if (typeof callbackObj.cb === "function") {
                callbackObj.cb(obj.message);
                if (callbackObj.timer) {
                  clearTimeout(callbackObj.timer);
                }
                this.messageCallbacks.delete(obj.callback.id);
              }
              const now = Date.now();
              for (const [_id, callback] of this.messageCallbacks) {
                if (now - callback.time > 36e5) {
                  this.messageCallbacks.delete(_id);
                }
              }
            } else if (!this._stopInProgress) {
              if (obj.command === "clientSubscribe") {
                const res = await this.uiMessagingController.registerClientSubscribeByMessage(obj);
                this.sendTo(obj.from, obj.command, res, obj.callback);
                return;
              }
              if (obj.command === "clientUnsubscribe" || obj.command === "clientSubscribeError") {
                return this.uiMessagingController.removeClientSubscribeByMessage(obj);
              }
              if (this._options.message) {
                this._options.message(obj);
              }
              this.emit("message", obj);
            }
          }
        } else if (id.startsWith(`system.adapter.${this.namespace}.plugins.`) && id.endsWith(".enabled")) {
          if (!state || state.ack) {
            return;
          }
          const pluginStatesIndex = `system.adapter.${this.namespace}.plugins.`.length;
          let nameEndIndex = id.indexOf(".", pluginStatesIndex + 1);
          if (nameEndIndex === -1) {
            nameEndIndex = void 0;
          }
          const pluginName = id.substring(pluginStatesIndex, nameEndIndex);
          if (!this.pluginHandler?.pluginExists(pluginName)) {
            return;
          }
          if (this.pluginHandler.isPluginActive(pluginName) !== state.val) {
            if (state.val) {
              if (!this.pluginHandler.isPluginInstantiated(pluginName)) {
                this.pluginHandler.instantiatePlugin(pluginName, this.pluginHandler.getPluginConfig(pluginName) || {}, thisDir);
                this.pluginHandler.setDatabaseForPlugin(pluginName, this.#objects, this.#states);
                this.pluginHandler.initPlugin(pluginName, this.adapterConfig || {});
              }
            } else {
              if (!this.pluginHandler.destroy(pluginName)) {
                this._logger.info(`${this.namespaceLog} Plugin ${pluginName} could not be disabled. Please restart adapter to disable it.`);
              }
            }
          }
        } else if (!this._stopInProgress && this.adapterReady && this.aliases.has(id)) {
          const alias = this.aliases.get(id);
          const uniqueTargets = /* @__PURE__ */ new Set();
          for (const target of alias.targets) {
            const targetId = target.id;
            if (uniqueTargets.has(targetId)) {
              continue;
            }
            uniqueTargets.add(targetId);
            const source = alias.source;
            const aState = state ? import_js_controller_common.tools.formatAliasValue({
              sourceCommon: source,
              targetCommon: target,
              state: (0, import_deep_clone.default)(state),
              logger: this._logger,
              logNamespace: this.namespaceLog,
              sourceId: id,
              targetId
            }) : null;
            if (aState || !state) {
              if (typeof this._options.stateChange === "function") {
                this._options.stateChange(targetId, aState);
              } else {
                setImmediate(() => this.emit("stateChange", targetId, aState));
              }
            }
          }
        }
      },
      changeUser: (id, state) => {
        this.inputCount++;
        if (!id || typeof id !== "string") {
          this._logger.warn(`${this.namespaceLog} Invalid id on state change: ${JSON.stringify(id)}`);
          return;
        }
        if (this.adapterReady) {
          if (this.oStates) {
            if (!state) {
              delete this.oStates[id];
            } else {
              this.oStates[id] = state;
            }
          }
          if (!this._stopInProgress) {
            if (typeof this._options.stateChange === "function") {
              setImmediate(() => this._options.stateChange(id, state));
            } else {
              setImmediate(() => this.emit("stateChange", id, state));
            }
          }
        }
      },
      disconnected: () => {
        this.connected = false;
        !this.terminated && setTimeout(() => {
          if (this.connected) {
            return;
          }
          this._logger.warn(`${this.namespaceLog} Cannot connect/reconnect to states DB. Terminating`);
          this.terminate(import_js_controller_common.EXIT_CODES.NO_ERROR);
        }, 5e3);
      }
    });
  }
  _initObjects(cb) {
    this._initializeTimeout = setTimeout(() => {
      this._initializeTimeout = null;
      if (this._config.isInstall) {
        this._logger.warn(`${this.namespaceLog} no connection to objects DB. Terminating`);
        this.terminate(import_js_controller_common.EXIT_CODES.NO_ERROR);
      } else {
        this._logger.warn(`${this.namespaceLog} slow connection to objects DB. Still waiting ...`);
      }
    }, this._config.objects.connectTimeout * 2);
    if (!this.Objects) {
      this._logger.warn(`${this.namespaceLog} Objects DB constructor has not been initialized`);
      this.terminate(import_js_controller_common.EXIT_CODES.NO_ERROR);
    }
    this.#objects = new this.Objects({
      namespace: this.namespaceLog,
      connection: this._config.objects,
      logger: this._logger,
      connected: async () => {
        this.connected = true;
        if (this._initializeTimeout) {
          clearTimeout(this._initializeTimeout);
          this._initializeTimeout = null;
        }
        if (!this.#objects) {
          return;
        }
        this.#objects.subscribe("system.user.*");
        this.enums = await import_js_controller_common.tools.getAllEnums(this.#objects);
        this.#objects.subscribe("enum.*");
        if (this._options.useFormatDate) {
          this.#objects.getObject("system.config", (err, data) => {
            if (data?.common) {
              this.dateFormat = data.common.dateFormat;
              this.isFloatComma = data.common.isFloatComma;
              this.language = data.common.language;
              this.longitude = data.common.longitude;
              this.latitude = data.common.latitude;
              this.defaultHistory = data.common.defaultHistory;
            }
            if (data?.native) {
              this._systemSecret = data.native.secret;
            }
            return import_js_controller_common.tools.maybeCallback(cb);
          });
        } else {
          return import_js_controller_common.tools.maybeCallback(cb);
        }
      },
      disconnected: () => {
        this.connected = false;
        !this.terminated && setTimeout(() => {
          if (this.connected) {
            return;
          }
          this._logger.warn(`${this.namespaceLog} Cannot connect/reconnect to objects DB. Terminating`);
          this.terminate(import_js_controller_common.EXIT_CODES.NO_ERROR);
        }, 4e3);
      },
      change: async (id, obj) => {
        if (!id) {
          this._logger.error(`${this.namespaceLog} change ID is empty: ${JSON.stringify(obj)}`);
          return;
        }
        if (id === `system.adapter.${this.namespace}` && obj?.common?.enabled === false) {
          this._logger.info(`${this.namespaceLog} Adapter is disabled => stop`);
          this._stop();
          setTimeout(() => this.terminate(import_js_controller_common.EXIT_CODES.NO_ERROR), 4e3);
          return;
        }
        if (id === "system.config" && obj?.common && (this._options.useFormatDate || this.defaultHistory !== void 0)) {
          this.dateFormat = obj.common.dateFormat;
          this.isFloatComma = obj.common.isFloatComma;
          this.language = obj.common.language;
          this.longitude = obj.common.longitude;
          this.latitude = obj.common.latitude;
          this.defaultHistory = obj.common.defaultHistory;
        }
        if (id.startsWith(import_constants.ALIAS_STARTS_WITH)) {
          let isNewAlias = true;
          for (const [sourceId, alias] of this.aliases) {
            const targetAlias = alias.targets.find((entry) => entry.id === id);
            if (targetAlias) {
              isNewAlias = false;
              if (obj?.common?.alias?.id) {
                const newSourceId = typeof obj.common.alias.id.read === "string" ? obj.common.alias.id.read : obj.common.alias.id;
                if (newSourceId !== sourceId) {
                  await this._removeAliasSubscribe(sourceId, targetAlias);
                  try {
                    await this._addAliasSubscribe(obj, targetAlias.pattern);
                  } catch (e) {
                    this._logger.error(`${this.namespaceLog} Could not add alias subscription: ${e.message}`);
                  }
                } else {
                  targetAlias.min = obj.common.min;
                  targetAlias.max = obj.common.max;
                  targetAlias.type = obj.common.type;
                  targetAlias.alias = (0, import_deep_clone.default)(obj.common.alias);
                }
              } else {
                await this._removeAliasSubscribe(sourceId, targetAlias);
              }
            }
          }
          if (isNewAlias && obj) {
            for (const aliasPattern of this.aliasPatterns) {
              const testPattern = aliasPattern.slice(-1) === "*" ? new RegExp(import_js_controller_common.tools.pattern2RegEx(aliasPattern)) : aliasPattern;
              if (typeof testPattern === "string" && aliasPattern === id || testPattern instanceof RegExp && testPattern.test(id)) {
                try {
                  await this._addAliasSubscribe(obj, id);
                } catch (e) {
                  this._logger.warn(`${this.namespaceLog} Could not add alias subscription: ${e.message}`);
                }
                break;
              }
            }
          }
        }
        if (id.startsWith("system.adapter.")) {
          if (obj?.common?.subscribable) {
            const _id = id.substring(15);
            if (obj.common.enabled) {
              if (!this.autoSubscribe.includes(_id)) {
                this.autoSubscribe.push(_id);
              }
            } else {
              const pos = this.autoSubscribe.indexOf(_id);
              if (pos !== -1) {
                this.autoSubscribe.splice(pos, 1);
              }
            }
          }
        }
        if (id.startsWith("system.user.") || id.startsWith("system.group.")) {
          this.users = {};
          this.groups = {};
          this.usernames = {};
        }
        if (id.startsWith("enum.")) {
          if (!obj) {
            delete this.enums[id];
          } else if (obj.type === "enum") {
            this.enums[id] = obj;
          }
        }
      },
      changeUser: (id, obj) => {
        if (!id) {
          this._logger.error(`${this.namespaceLog} change ID is empty: ${JSON.stringify(obj)}`);
          return;
        }
        if (obj && "protectedNative" in obj && Array.isArray(obj.protectedNative) && obj._id && obj._id.startsWith("system.adapter.") && obj.native && !import_constants.NO_PROTECT_ADAPTERS.includes(this.name) && this.name !== obj._id.split(".")[2]) {
          for (const attr of obj.protectedNative) {
            delete obj.native[attr];
          }
        }
        if (this.adapterReady) {
          if (this.oObjects) {
            if (obj) {
              this.oObjects[id] = obj;
            } else {
              delete this.oObjects[id];
            }
          }
          if (!this._stopInProgress) {
            typeof this._options.objectChange === "function" && // @ts-expect-error
            setImmediate(() => this._options.objectChange(id, obj));
            setImmediate(() => this.emit("objectChange", id, obj));
          }
        }
      },
      changeFileUser: (id, fileName, size) => {
        if (!id) {
          this._logger.error(`${this.namespaceLog} change file name is empty`);
          return;
        }
        if (this.adapterReady && !this._stopInProgress) {
          typeof this._options.fileChange === "function" && setImmediate(() => this._options.fileChange(id, fileName, size));
          setImmediate(() => this.emit("fileChange", id, fileName, size));
        }
      }
    });
  }
  /**
   * Called if states and objects successfully initialized
   */
  async _prepareInitAdapter() {
    if (this.terminated || !this.#objects || !this.#states) {
      return;
    }
    if (this._options.instance !== void 0) {
      return this._initAdapter(this._options);
    }
    const resAlive = await this.#states.getState(`system.adapter.${this.namespace}.alive`);
    const killRes = await this.#states.getState(`system.adapter.${this.namespace}.sigKill`);
    if (killRes?.val !== void 0) {
      killRes.val = parseInt(killRes.val, 10);
    }
    if (!this._config.isInstall && this.startedInCompactMode && killRes && !killRes.ack && killRes.val === -1) {
      this._logger.error(`${this.namespaceLog} ${this.namespace} needs to be stopped because not correctly started in compact mode`);
      this.terminate(import_js_controller_common.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION);
    } else if (!this._config.forceIfDisabled && !this._config.isInstall && !this.startedInCompactMode && killRes && killRes.from?.startsWith("system.host.") && killRes.ack && !isNaN(killRes.val) && killRes.val !== process.pid) {
      this._logger.error(`${this.namespaceLog} ${this.namespace} invalid process id scenario ${killRes.val} vs. own ID ${process.pid}. Stopping`);
      this.terminate(import_js_controller_common.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION);
    } else if (!this._config.isInstall && resAlive && resAlive.val === true && resAlive.ack && !this._config.forceIfDisabled) {
      this._logger.error(`${this.namespaceLog} ${this.namespace} already running`);
      this.terminate(import_js_controller_common.EXIT_CODES.ADAPTER_ALREADY_RUNNING);
    } else {
      let res;
      try {
        res = await this.#objects.getObject(`system.adapter.${this.namespace}`);
      } catch (e) {
        this._logger.error(`${this.namespaceLog} ${this.namespace} Could not get instance object: ${e.message}`);
      }
      if (!res && !this._config.isInstall) {
        this._logger.error(`${this.namespaceLog} ${this.namespace} invalid config`);
        this.terminate(import_js_controller_common.EXIT_CODES.INVALID_ADAPTER_CONFIG);
      } else {
        return this._initAdapter(res);
      }
    }
  }
  /**
   * Initialize the adapter
   *
   * @param adapterConfig the AdapterOptions or the InstanceObject, is null/undefined if it is install process
   */
  async _initAdapter(adapterConfig) {
    await this._initLogging();
    if (!this.pluginHandler) {
      return;
    }
    this.pluginHandler.setDatabaseForPlugins(this.#objects, this.#states);
    await this.pluginHandler.initPlugins(adapterConfig || {});
    if (!this.#states || !this.#objects || this.terminated) {
      return;
    }
    this.#states.subscribe(`system.adapter.${this.namespace}.plugins.*`);
    if (this._options.instance === void 0) {
      if (!adapterConfig || !("common" in adapterConfig) || !adapterConfig.common.enabled) {
        if (adapterConfig && "common" in adapterConfig && adapterConfig.common.enabled !== void 0) {
          !this._config.isInstall && this._logger.error(`${this.namespaceLog} adapter disabled`);
        } else {
          !this._config.isInstall && this._logger.error(`${this.namespaceLog} no config found for adapter`);
        }
        if (!this._config.isInstall && (!process.argv || !this._config.forceIfDisabled)) {
          const id = `system.adapter.${this.namespace}`;
          this.outputCount += 2;
          this.#states.setState(`${id}.alive`, { val: true, ack: true, expire: 30, from: id });
          let done = false;
          this.#states.setState(`${id}.connected`, {
            val: true,
            ack: true,
            expire: 30,
            from: id
          }, () => {
            if (!done) {
              done = true;
              this.terminate(import_js_controller_common.EXIT_CODES.NO_ADAPTER_CONFIG_FOUND);
            }
          });
          setTimeout(() => {
            if (!done) {
              done = true;
              this.terminate(import_js_controller_common.EXIT_CODES.NO_ADAPTER_CONFIG_FOUND);
            }
          }, 1e3);
          return;
        }
      }
      if (!this._config.isInstall && (!adapterConfig || !("_id" in adapterConfig))) {
        this._logger.error(`${this.namespaceLog} invalid config: no _id found`);
        this.terminate(import_js_controller_common.EXIT_CODES.INVALID_ADAPTER_ID);
        return;
      }
      let name;
      let instance;
      if (!this._config.isInstall) {
        const tmp = adapterConfig._id.match(/^system\.adapter\.([a-zA-Z0-9-_]+)\.([0-9]+)$/);
        if (!tmp) {
          this._logger.error(`${this.namespaceLog} invalid config`);
          this.terminate(import_js_controller_common.EXIT_CODES.INVALID_ADAPTER_ID);
          return;
        }
        name = tmp[1];
        instance = parseInt(tmp[2]) || 0;
      } else {
        name = this.name;
        instance = 0;
        adapterConfig = adapterConfig || {
          // @ts-expect-error protectedNative exists on instance objects
          common: { mode: "once", name, protectedNative: [] },
          native: {}
        };
      }
      if (adapterConfig.common.loglevel && !this.overwriteLogLevel) {
        for (const trans of Object.values(this._logger.transports)) {
          if (!trans._defaultConfigLoglevel) {
            trans.level = adapterConfig.common.loglevel;
          }
        }
        this._config.log.level = adapterConfig.common.loglevel;
      }
      this.name = adapterConfig.common.name;
      this.instance = instance;
      this.namespace = `${name}.${instance}`;
      this.namespaceLog = this.namespace + (this.startedInCompactMode ? " (COMPACT)" : ` (${process.pid})`);
      if (!this.startedInCompactMode) {
        process.title = `io.${this.namespace}`;
      }
      this.config = adapterConfig.native;
      this.host = adapterConfig.common.host;
      this.common = adapterConfig.common;
      if (
        // @ts-expect-error
        adapterConfig.common.mode === "schedule" || // @ts-expect-error
        adapterConfig.common.mode === "once"
      ) {
        this.stop = (params) => this._stop({ ...params, isPause: true });
      } else if (this.startedInCompactMode) {
        this.stop = (params) => this._stop({ ...params, isPause: false });
        this.kill = this.stop;
      } else {
        this.stop = (params) => this._stop({ ...params, isPause: false });
      }
      this.#states.subscribe(`${import_constants2.SYSTEM_ADAPTER_PREFIX}*.logging`);
      if (typeof this._options.message === "function" && // @ts-expect-error, we should infer correctly that this is an InstanceObject in this case
      !(0, import_utils.isMessageboxSupported)(adapterConfig.common)) {
        this._logger.error(`${this.namespaceLog} : message handler implemented, but messagebox not enabled. Define common.messagebox in io-package.json for adapter or delete message handler.`);
      } else if ((0, import_utils.isMessageboxSupported)(adapterConfig.common)) {
        this.mboxSubscribed = true;
        this.#states.subscribeMessage(`system.adapter.${this.namespace}`);
      }
    } else {
      this.name = adapterConfig.name || this.name;
      this.instance = adapterConfig.instance || 0;
      this.namespace = `${this.name}.${this.instance}`;
      this.namespaceLog = this.namespace + (this.startedInCompactMode ? " (COMPACT)" : ` (${process.pid})`);
      this.config = adapterConfig.native || {};
      this.common = adapterConfig.common || {};
      this.host = this.common?.host || import_js_controller_common.tools.getHostName() || import_node_os.default.hostname();
    }
    this.adapterConfig = adapterConfig;
    this._utils = new import_validator.Validator(this.#objects, this.#states, this.namespaceLog, this._logger, this.namespace, this._namespaceRegExp);
    this.log = new import_log.Log(this.namespaceLog, this._config.log.level, this._logger);
    await this._createInstancesObjects(adapterConfig);
    if (this._options.objects) {
      this.oObjects = await this.getAdapterObjectsAsync();
      await this.subscribeObjectsAsync("*");
    }
    await this.getSystemSecret();
    const promises = [];
    if (Array.isArray(adapterConfig.encryptedNative)) {
      for (const attr of adapterConfig.encryptedNative) {
        if (typeof this.config[attr] === "string") {
          promises.push(this.getEncryptedConfig(attr).then((decryptedValue) => this.config[attr] = decryptedValue).catch((e) => this._logger.error(`${this.namespaceLog} Can not decrypt attribute ${attr}: ${e.message}`)));
        }
      }
    } else {
      const idx = this.SUPPORTED_FEATURES.indexOf("ADAPTER_AUTO_DECRYPT_NATIVE");
      if (idx !== -1) {
        this.SUPPORTED_FEATURES.splice(idx, 1);
      }
    }
    await Promise.all(promises);
    if (!this.#states) {
      return;
    }
    this.outputCount++;
    this.#states.setState(`system.adapter.${this.namespace}.logLevel`, {
      val: this._config.log.level,
      ack: true,
      from: `system.adapter.${this.namespace}`
    });
    if (this._options.instance === void 0) {
      this.version = this.pack?.version ? this.pack.version : this.ioPack?.common ? this.ioPack.common.version : "unknown";
      const isNpmVersion = (0, import_js_controller_common.isInstalledFromNpm)({
        adapterName: this.name,
        installedFrom: this.ioPack.common.installedFrom
      });
      this._logger.info(`${this.namespaceLog} starting. Version ${this.version} ${!isNpmVersion ? `(non-npm: ${this.ioPack.common.installedFrom}) ` : ""}in ${this.adapterDir}, node: ${process.version}, js-controller: ${controllerVersion}`);
      this._config.system = this._config.system || {};
      this._config.system.statisticsInterval = parseInt(this._config.system.statisticsInterval, 10) || 15e3;
      if (!this._config.isInstall) {
        this._reportInterval = setInterval(() => this._reportStatus(), this._config.system.statisticsInterval);
        this._reportStatus();
        const id = `system.adapter.${this.namespace}`;
        this.#states.setState(`${id}.compactMode`, {
          ack: true,
          from: id,
          val: !!this.startedInCompactMode
        });
        this.outputCount++;
        if (this.startedInCompactMode) {
          this.#states.setState(`${id}.cpu`, { ack: true, from: id, val: 0 });
          this.#states.setState(`${id}.cputime`, { ack: true, from: id, val: 0 });
          this.#states.setState(`${id}.memRss`, { val: 0, ack: true, from: id });
          this.#states.setState(`${id}.memHeapTotal`, { val: 0, ack: true, from: id });
          this.#states.setState(`${id}.memHeapUsed`, { val: 0, ack: true, from: id });
          this.#states.setState(`${id}.eventLoopLag`, { val: 0, ack: true, from: id });
          this.outputCount += 6;
        } else {
          import_js_controller_common.tools.measureEventLoopLag(1e3, (lag) => {
            if (lag) {
              this.eventLoopLags.push(lag);
            }
          });
        }
      }
    }
    if (adapterConfig && "common" in adapterConfig && adapterConfig.common.restartSchedule) {
      try {
        this._schedule = await import("node-schedule");
      } catch {
        this._logger.error(`${this.namespaceLog} Cannot load node-schedule. Scheduled restart is disabled`);
      }
      if (this._schedule) {
        this._logger.debug(`${this.namespaceLog} Schedule restart: ${adapterConfig.common.restartSchedule}`);
        this._restartScheduleJob = this._schedule.scheduleJob(adapterConfig.common.restartSchedule, () => {
          this._logger.info(`${this.namespaceLog} Scheduled restart.`);
          this._stop({ isPause: false, isScheduled: true });
        });
      }
    }
    if (this._options.states) {
      this.getStates("*", null, (err, _states) => {
        if (this._stopInProgress) {
          return;
        }
        this.oStates = _states;
        this.subscribeStates("*");
        if (this._firstConnection) {
          this._firstConnection = false;
          this._callReadyHandler();
        }
        this.adapterReady = true;
      });
    } else if (!this._stopInProgress) {
      this._callReadyHandler();
      this.adapterReady = true;
    }
  }
  /**
   * Calls the ready handler, if it is an install run it calls the install handler instead
   */
  _callReadyHandler() {
    if (this._config.isInstall && (typeof this._options.install === "function" || this.listeners("install").length)) {
      if (typeof this._options.install === "function") {
        this._options.install();
      }
      this.emit("install");
    } else {
      if (typeof this._options.ready === "function") {
        this._options.ready();
      }
      this.emit("ready");
    }
  }
  async _exceptionHandler(err, isUnhandledRejection) {
    if (typeof this._options.error === "function") {
      try {
        const wasHandled = this._options.error(err);
        if (wasHandled === true) {
          return;
        }
      } catch (e) {
        console.error(`Error in adapter error handler: ${e.message}`);
      }
    }
    if (this.getPortRunning && err?.message === "listen EADDRINUSE") {
      const { host, port, callback } = this.getPortRunning;
      this._logger.warn(`${this.namespaceLog} Port ${port}${host ? ` for host ${host}` : ""} is in use. Get next`);
      setImmediate(() => this.getPort(port + 1, host, callback));
      return;
    }
    if (isUnhandledRejection) {
      this._logger.error(`${this.namespaceLog} Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch().`);
    }
    this._logger.error(`${this.namespaceLog} ${isUnhandledRejection ? "unhandled promise rejection" : "uncaught exception"}: ${err ? err.message : err}`);
    if (err && err.stack) {
      this._logger.error(`${this.namespaceLog} ${err.stack}`);
    }
    if (err) {
      const message = err.code ? `Exception-Code: ${err.code}: ${err.message}` : err.message;
      this._logger.error(`${this.namespaceLog} ${message}`);
      try {
        await this.registerNotification("system", null, message);
      } catch {
      }
    }
    try {
      this._stop({
        isPause: false,
        isScheduled: false,
        exitCode: import_js_controller_common.EXIT_CODES.UNCAUGHT_EXCEPTION,
        updateAliveState: false
      });
      setTimeout(() => this.terminate(import_js_controller_common.EXIT_CODES.UNCAUGHT_EXCEPTION), 1e3);
    } catch (e) {
      this._logger.error(`${this.namespaceLog} exception by stop: ${e ? e.message : e}`);
    }
  }
  async _createInstancesObjects(instanceObj) {
    let objs;
    if (instanceObj?.common && !("onlyWWW" in instanceObj.common) && instanceObj.common.mode !== "once") {
      objs = import_js_controller_common.tools.getInstanceIndicatorObjects(this.namespace);
    } else {
      objs = [];
    }
    if (instanceObj && "instanceObjects" in instanceObj) {
      for (const instObj of instanceObj.instanceObjects) {
        const obj = instObj;
        const allowedTopLevelTypes = ["meta", "device"];
        if (!obj || typeof obj._id !== "string" || obj._id === "" && !allowedTopLevelTypes.includes(obj.type)) {
          this._logger.error(`${this.namespaceLog} ${this.namespace} invalid instance object: ${JSON.stringify(obj)}`);
          continue;
        }
        if (!obj._id.startsWith(this.namespace)) {
          obj._id = obj._id === "" ? this.namespace : `${this.namespace}.${obj._id}`;
        }
        if (obj.common?.name) {
          const commonName = obj.common.name;
          if (import_js_controller_common.tools.isObject(commonName)) {
            for (const [lang, value] of Object.entries(commonName)) {
              commonName[lang] = value.replace("%INSTANCE%", this.instance.toString());
            }
          } else {
            obj.common.name = commonName.replace("%INSTANCE%", this.instance.toString());
          }
          if ("desc" in obj.common) {
            const commonDesc = obj.common.desc;
            if (import_js_controller_common.tools.isObject(commonDesc)) {
              for (const [lang, value] of Object.entries(commonDesc)) {
                commonDesc[lang] = value.replace("%INSTANCE%", this.instance.toString());
              }
            } else if (commonDesc) {
              obj.common.desc = commonDesc.replace("%INSTANCE%", this.instance.toString());
            }
          }
          if (obj.type === "state" && obj.common.def !== void 0) {
            try {
              const checkObj = await this.#objects.objectExists(obj._id);
              if (!checkObj) {
                obj.state = obj.common.def;
              }
            } catch (e) {
              this._logger.warn(`${this.namespaceLog} Did not add default (${obj.common.def}) value on creation of ${obj._id}: ${e.message}`);
            }
          }
        }
        objs.push(obj);
      }
    }
    if (instanceObj?.common?.logTransporter) {
      objs.push({
        _id: `system.adapter.${this.namespace}.logging`,
        common: {
          type: "boolean",
          name: "Logging for instance activated",
          role: "indicator.state",
          write: false,
          read: true,
          def: false
        },
        type: "state",
        native: {}
      });
    }
    return new Promise((resolve) => {
      this._extendObjects(objs, resolve);
    });
  }
  async _extendObjects(tasks, callback) {
    if (!tasks || !tasks.length) {
      return import_js_controller_common.tools.maybeCallback(callback);
    }
    const task = tasks.shift();
    const state = task.state;
    if (state !== void 0) {
      delete task.state;
    }
    try {
      import_js_controller_common.tools.validateGeneralObjectProperties(task, true);
    } catch (e) {
      this._logger.error(`${this.namespaceLog} Object ${task._id} is invalid: ${e.message}`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, e);
    }
    if (!this.#objects) {
      this._logger.info(`${this.namespaceLog} extendObjects not processed because Objects database not connected.`);
      return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    const options = { preserve: { common: ["name"], native: true } };
    try {
      await this.extendForeignObjectAsync(task._id, task, options);
    } catch {
    }
    if (state !== void 0) {
      if (!this.#states) {
        this._logger.info(`${this.namespaceLog} extendObjects not processed because States database not connected.`);
        return import_js_controller_common.tools.maybeCallbackWithError(callback, import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
      }
      this.outputCount++;
      this.#states.setState(task._id, {
        val: state,
        from: `system.adapter.${this.namespace}`,
        ack: true
      }, () => setImmediate(() => this._extendObjects(tasks, callback)));
    } else {
      setImmediate(() => this._extendObjects(tasks, callback));
    }
  }
  /**
   * Replaces forbidden chars in an id if present
   * Additionally logs a warning
   *
   * @param id the id which will be replaced
   */
  fixForbiddenCharsInId(id) {
    const mId = id.replace(FORBIDDEN_CHARS, "_");
    if (mId !== id) {
      this._logger.warn(`${this.namespaceLog} Used invalid characters: ${id} changed to ${mId}`);
    }
    return mId;
  }
  /**
   * This method reports deprecations via Sentry (controller own instance) and can only be used internally
   *
   * @param options information about version to remove feature and the log message
   */
  async reportDeprecation(options) {
    if (!this.#states) {
      throw new Error(import_js_controller_common.tools.ERRORS.ERROR_DB_CLOSED);
    }
    const { version, deprecationMessage } = options;
    const additionalMsg = version ? `This will throw an error up from js-controller version ${version}! ` : "Please report to the developer.";
    this._logger.warn(`${this.namespaceLog} ${deprecationMessage} ${additionalMsg}`);
    if (this.reportedDeprecations.has(deprecationMessage)) {
      return;
    }
    this.reportedDeprecations.add(deprecationMessage);
    const obj = {
      command: "sendToSentry",
      message: {
        extraInfo: {
          deprecationMessage,
          adapter: this.name,
          version: this.version
        },
        message: `Deprecation ${this.name}`,
        level: "info"
      },
      from: `system.adapter.${this.namespace}`
    };
    await this.#states.pushMessage(`system.host.${this.host}`, obj);
  }
  /**
   * Initialize the plugin handler for this adapter
   */
  _initPluginHandler() {
    const pluginSettings = {
      scope: "adapter",
      namespace: `system.adapter.${this.namespace}`,
      logNamespace: this.namespaceLog,
      // @ts-expect-error
      log: this._logger,
      iobrokerConfig: this._config,
      // @ts-expect-error
      parentPackage: this.pack,
      controllerVersion
    };
    this.pluginHandler = new import_plugin_base.PluginHandler(pluginSettings);
    try {
      this.pluginHandler.addPlugins(this.ioPack.common.plugins || {}, [this.adapterDir, thisDir]);
    } catch (e) {
      this._logger.error(`Could not add plugins: ${e.message}`);
    }
  }
  /**
   * Initializes the adapter
   */
  async _init() {
    const _initDBs = () => {
      this._initObjects(() => {
        if (this.inited) {
          this._logger.warn(`${this.namespaceLog} Reconnection to DB.`);
          return;
        }
        this.inited = true;
        this._initStates(() => this._prepareInitAdapter());
      });
    };
    if (import_fs_extra.default.existsSync(`${this.adapterDir}/package.json`)) {
      this.pack = import_fs_extra.default.readJSONSync(`${this.adapterDir}/package.json`);
    } else {
      this._logger.info(`${this.namespaceLog} Non npm module. No package.json`);
    }
    if (this._options.systemConfig) {
      this.systemConfig = this._config;
      if (!Object.prototype.hasOwnProperty.call(this.systemConfig, "dataDir")) {
        this.systemConfig.dataDir = import_js_controller_common.tools.getDefaultDataDir();
      }
    }
    if (this._config.states && this._config.states.type) {
      try {
        this.States = (await import(`@iobroker/db-states-${this._config.states.type}`)).Client;
      } catch (e) {
        throw new Error(`Unknown states type: ${this._config.states.type}: ${e.message}`);
      }
    } else {
      this.States = await (0, import_js_controller_common.getStatesConstructor)();
    }
    if (this._config.objects && this._config.objects.type) {
      try {
        this.Objects = (await import(`@iobroker/db-objects-${this._config.objects.type}`)).Client;
      } catch (e) {
        throw new Error(`Unknown objects type: ${this._config.objects.type}: ${e.message}`);
      }
    } else {
      this.Objects = await (0, import_js_controller_common.getObjectsConstructor)();
    }
    const ifaces = import_node_os.default.networkInterfaces();
    const ipArr = [];
    for (const iface of Object.values(ifaces)) {
      if (iface) {
        iface.forEach((details) => !details.internal && ipArr.push(details.address));
      }
    }
    this.namespaceLog = this.namespace + (this.startedInCompactMode ? " (COMPACT)" : ` (${process.pid})`);
    this.inited = false;
    process.once("SIGINT", () => this._stop());
    process.once("SIGTERM", () => this._stop());
    process.once("exit", () => this._stop());
    process.on("uncaughtException", (err) => this._exceptionHandler(err));
    process.on("unhandledRejection", (err) => this._exceptionHandler(err, true));
    this._initPluginHandler();
    _initDBs();
  }
}
const Adapter = new Proxy(AdapterClass, {
  apply(target, thisArg, argArray) {
    return new target(...argArray);
  }
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Adapter,
  AdapterClass
});
//# sourceMappingURL=adapter.js.map
