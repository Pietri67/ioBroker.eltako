"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var validator_exports = {};
__export(validator_exports, {
  Validator: () => Validator
});
module.exports = __toCommonJS(validator_exports);
var import_constants = require("../../lib/adapter/constants.js");
var import_js_controller_common = require("@iobroker/js-controller-common");
class Validator {
  objects;
  states;
  namespaceLog;
  log;
  namespace;
  namespaceRegExp;
  /**
   * Validator for internal adapter.js usage
   *
   * @param objects - Objects DB
   * @param states - States DB
   * @param namespaceLog - Log prefix
   * @param logger - Logger instance
   * @param namespace - the namespace of the adapter
   * @param namespaceRegExp - the namespace RegExp of the adapter `adapter.0`
   */
  constructor(objects, states, namespaceLog, logger, namespace, namespaceRegExp) {
    this.objects = objects;
    this.states = states;
    this.namespaceLog = namespaceLog;
    this.namespace = namespace;
    this.namespaceRegExp = namespaceRegExp;
    this.log = logger;
  }
  /**
   * Performs the strict object check, which includes checking object existence, read-only logic, type and min/max
   * additionally it rounds state values whose objects have a `common.step` attribute defined
   *
   * @param id - id of the state
   * @param state - ioBroker setState object
   */
  async performStrictObjectCheck(id, state) {
    try {
      if (state.val === void 0) {
        return;
      }
      const obj = await this.objects.getObjectAsync(id);
      if (!obj) {
        this.log.warn(`${this.namespaceLog} State "${id}" has no existing object, this might lead to an error in future versions`);
        return;
      }
      if (obj.common?.type) {
        if (!state.ack && obj.common.write === false) {
          this.log.warn(`${this.namespaceLog} Read-only state "${id}" has been written without ack-flag with value "${state.val}"`);
        }
        if (state.val !== null) {
          if (!(obj.common.type === "mixed" && typeof state.val !== "object" || obj.common.type !== "object" && obj.common.type === typeof state.val || obj.common.type === "array" && typeof state.val === "string" || obj.common.type === "json" && typeof state.val === "string" || obj.common.type === "object" && typeof state.val === "string")) {
            if (["object", "json", "array"].includes(obj.common.type)) {
              this.log.info(`${this.namespaceLog} State value to set for "${id}" has to be stringified but received type "${typeof state.val}"`);
            } else {
              this.log.info(`${this.namespaceLog} State value to set for "${id}" has to be ${obj.common.type === "mixed" ? `one of type "string", "number", "boolean"` : `type "${obj.common.type}"`} but received type "${typeof state.val}" `);
            }
          }
          if (typeof state.val === "number") {
            if (typeof obj.common.step === "number" && obj.common.step > 0) {
              const inv = 1 / obj.common.step;
              state.val = Math.round(state.val * inv) / inv;
            }
            if (obj.common.max !== void 0 && state.val > obj.common.max) {
              this.log.warn(`${this.namespaceLog} State value to set for "${id}" has value "${state.val}" greater than max "${obj.common.max}"`);
            }
            if (obj.common.min !== void 0 && state.val < obj.common.min) {
              this.log.warn(`${this.namespaceLog} State value to set for "${id}" has value "${state.val}" less than min "${obj.common.min}"`);
            }
          }
        }
      } else {
        this.log.warn(`${this.namespaceLog} Object of state "${id}" is missing the required property "common.type"`);
      }
    } catch (e) {
      this.log.warn(`${this.namespaceLog} Could not perform strict object check of state ${id}: ${e.message}`);
    }
  }
  /**
   * Checks if a passed ID is valid. Throws an error if id is invalid
   *
   * @param id id to check or object with properties device, channel and state
   * @param isForeignId true&false if the ID is a foreign/full ID or only an "adapter local" id
   * @param options optional
   * @throws Error when id is invalid
   */
  validateId(id, isForeignId, options) {
    if (options && options.maintenance && options.user === import_constants.SYSTEM_ADMIN_USER) {
      return;
    }
    if (!id && id !== 0) {
      throw new Error("The id is empty! Please provide a valid id.");
    }
    const type = typeof id;
    if (!isForeignId && type === "number") {
      this.log.warn(`${this.namespaceLog} The id "${id}" has an invalid type! Expected "string" or "object", received "number".`);
      this.log.warn(`${this.namespaceLog} This will be refused in future versions. Please report this to the developer.`);
    } else if (type !== "string" && !import_js_controller_common.tools.isObject(id)) {
      throw new Error(`The id "${id}" has an invalid type! Expected "string" or "object", received "${type}".`);
    }
    if (import_js_controller_common.tools.isObject(id)) {
      const reqProperties = ["device", "channel", "state"];
      let found = false;
      for (const reqProperty of reqProperties) {
        if (id[reqProperty] !== void 0) {
          if (typeof id[reqProperty] !== "string") {
            throw new Error(`The id's property "${reqProperty}" of "${JSON.stringify(id)}" has an invalid type! Expected "string", received "${typeof id[reqProperty]}".`);
          }
          if (id[reqProperty].includes(".")) {
            throw new Error(`The id's property "${reqProperty}" of "${JSON.stringify(id)}" contains the invalid character "."!`);
          }
          found = true;
        }
      }
      if (!found) {
        throw new Error(`The id "${JSON.stringify(id)}" is an invalid object! Expected at least one of the properties "device", "channel" or "state" to exist.`);
      }
    } else {
      if (type !== "string") {
        throw new Error(`The id "${JSON.stringify(id)}" has an invalid type! Expected "string", received "${type}".`);
      }
      if (id.endsWith(".")) {
        throw new Error(`The id "${id}" is invalid. Ids are not allowed to end in "."`);
      }
    }
  }
  /**
   * Look up the error description for an error code
   *
   * @param code error code
   * @returns error description
   */
  static getErrorText(code) {
    code = code || 0;
    return (import_js_controller_common.EXIT_CODES[code] || code).toString();
  }
  /**
   * Throws if a type is not matching the expected type
   *
   * @param value value to check a type of
   * @param name name of the parameter for logging
   */
  static assertString(value, name) {
    if (typeof value !== "string") {
      throw new Error(`Parameter "${name}" needs to be of type "string" but type "${typeof value}" has been passed`);
    }
  }
  /**
   * Throws if a type is not a pattern
   *
   * @param value value to check a type of
   * @param name name of the parameter for logging
   */
  static assertPattern(value, name) {
    if (typeof value !== "string" && !Array.isArray(value)) {
      throw new Error(`Parameter "${name}" needs to be of type "string" or an array of type "string", "${typeof value}" has been passed`);
    } else if (Array.isArray(value)) {
      for (const entry of value) {
        if (typeof entry !== "string") {
          throw new Error(`Parameter "${name}" needs to be of type "string" or an array of type "string", but the array contains a value of type "${typeof value}"`);
        }
      }
    }
  }
  /**
   * Throws if a type is not matching the expected type
   *
   * @param value value to check a type of
   * @param name name of the parameter for logging
   */
  static assertBoolean(value, name) {
    if (typeof value !== "boolean") {
      throw new Error(`Parameter "${name}" needs to be of type "boolean" but type "${typeof value}" has been passed`);
    }
  }
  /**
   * Throws if a type is not matching the expected type
   *
   * @param value value to check a type of
   * @param name name of the parameter for logging
   */
  static assertNumber(value, name) {
    if (typeof value !== "number") {
      throw new Error(`Parameter "${name}" needs to be of type "number" but type "${typeof value}" has been passed`);
    }
  }
  /**
   * Throws if a type is not matching the expected type
   *
   * @param value value to check a type of
   * @param name name of the parameter for logging
   */
  static assertObject(value, name) {
    if (!import_js_controller_common.tools.isObject(value)) {
      throw new Error(`Parameter "${name}" needs to be a real object but type "${typeof value}" has been passed`);
    }
  }
  /**
   * Throws if a type is not an optional callback
   *
   * @param value value to check a type of
   * @param name name of the parameter for logging
   */
  static assertBuffer(value, name) {
    if (!Buffer.isBuffer(value)) {
      throw new Error(`Parameter "${name}" needs to be a Buffer but type "${typeof value}" has been passed`);
    }
  }
  /**
   * Throws if a type is not an optional callback
   *
   * @param value value to check a type of
   * @param name name of the parameter for logging
   */
  static assertOptionalCallback(value, name) {
    if (value && typeof value !== "function") {
      throw new Error(`Parameter "${name}" needs to be of type "null", "undefined" or "function" but type "${typeof value}" has been passed`);
    }
  }
  /**
   * Throws if a type is not an optional callback
   *
   * @param value value to check a type of
   * @param name name of the parameter for logging
   */
  static assertCallback(value, name) {
    if (typeof value !== "function") {
      throw new Error(`Parameter "${name}" needs to be of type "function" but type "${typeof value}" has been passed`);
    }
  }
  /**
   * Adds the namespace to the ID if it is missing, if an object is passed it will be converted to an id string
   *
   * @param id id which will be fixed
   * @param isPattern if the id is a pattern
   */
  fixId(id, isPattern = false) {
    if (!id) {
      id = "";
    }
    let result = "";
    if (typeof id === "string") {
      result = id;
      if (id !== this.namespace && !this.namespaceRegExp.test(id)) {
        if (!isPattern) {
          result = this.namespace + (id ? `.${id}` : "");
        } else {
          result = `${this.namespace}.${id ? id : ""}`;
        }
      }
    } else if (import_js_controller_common.tools.isObject(id)) {
      result = `${this.namespace}.${id.device ? `${id.device}.` : ""}${id.channel ? `${id.channel}.` : ""}${id.state ? id.state : ""}`;
    }
    return result;
  }
  /**
   * Validates the object-type argument that is passed to setState
   *
   * @param obj object to validate
   */
  validateSetStateObjectArgument(obj) {
    if (!Object.values(obj).some((prop) => prop !== void 0)) {
      throw new Error(`The state contains no properties! At least one property is expected!`);
    }
    const optionalProperties = {
      val: "any",
      ack: "boolean",
      ts: "number",
      q: "number",
      from: "string",
      c: "string",
      expire: "number",
      lc: "number",
      user: "string"
    };
    const forbiddenProperties = Object.keys(obj).filter((k) => !optionalProperties[k]);
    if (forbiddenProperties.length) {
      throw new Error(`The state contains the forbidden properties ${forbiddenProperties.join(", ")}!`);
    }
    for (const [key, type] of Object.entries(optionalProperties)) {
      if (type === "any") {
        continue;
      }
      if (!(key in obj) || obj[key] === void 0) {
        continue;
      }
      if (type !== typeof obj[key]) {
        throw new Error(`The state property "${key}" has the wrong type "${typeof obj[key]}" (should be "${type}")!`);
      }
    }
  }
  /**
   * Validates that the timeout is not exceeding a 32-bit signed integer
   *
   * @param ms milliseconds to validate
   */
  static assertTimeout(ms) {
    if (ms > import_constants.MAX_TIMEOUT) {
      throw new Error(`Timeout (${ms}) is larger than a 32-bit signed integer (${import_constants.MAX_TIMEOUT})`);
    }
    if (ms < 0) {
      throw new Error(`Timeout (${ms}) is smaller than 0`);
    }
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Validator
});
//# sourceMappingURL=validator.js.map
