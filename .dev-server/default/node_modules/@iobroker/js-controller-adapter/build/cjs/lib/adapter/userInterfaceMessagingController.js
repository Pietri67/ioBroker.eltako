"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var userInterfaceMessagingController_exports = {};
__export(userInterfaceMessagingController_exports, {
  UserInterfaceMessagingController: () => UserInterfaceMessagingController
});
module.exports = __toCommonJS(userInterfaceMessagingController_exports);
class UserInterfaceMessagingController {
  /** The adapter using this messaging controller */
  adapter;
  /** Callback to call if successfully subscribed */
  unsubscribeCallback;
  /** Callback to call if successfully unsubscribed */
  subscribeCallback;
  /** All currently registered client handlers */
  handlers = /* @__PURE__ */ new Map();
  /** Collection of current heartbeat timers */
  heartbeatTimers = /* @__PURE__ */ new Map();
  constructor(options) {
    const { adapter, unsubscribeCallback, subscribeCallback } = options;
    this.adapter = adapter;
    this.unsubscribeCallback = unsubscribeCallback;
    this.subscribeCallback = subscribeCallback;
  }
  /**
   * Send a message to the given clientId
   *
   * @param options Data, states and client information
   */
  sendToClient(options) {
    const { states, clientId, data } = options;
    if (!this.handlers.has(clientId)) {
      throw new Error(`Client "${clientId}" is not registered`);
    }
    const handler = this.handlers.get(clientId);
    return states.pushMessage(handler.from, {
      command: "im",
      message: { m: handler.type, s: handler.sid, d: data },
      from: `system.adapter.${this.adapter.namespace}`
    });
  }
  /**
   * Send a message to all active clients
   *
   * @param options Data and states options
   */
  async sendToAllClients(options) {
    const { states, data } = options;
    for (const clientId of Object.keys(this.handlers)) {
      await this.sendToClient({ clientId, data, states });
    }
  }
  /**
   * Register subscription from new client
   *
   * @param msg The subscribe message
   */
  async registerClientSubscribeByMessage(msg) {
    if (!this.subscribeCallback) {
      return;
    }
    const handler = this.extractHandlerFromMessage(msg);
    const clientId = this.handlerToId(handler);
    if (this.heartbeatTimers.has(clientId)) {
      this.heartbeatTimers.get(clientId).timer.refresh();
      return;
    }
    const resOrAwaitable = this.subscribeCallback({ clientId, message: msg });
    let res;
    if (resOrAwaitable instanceof Promise) {
      res = await resOrAwaitable;
    } else {
      res = resOrAwaitable;
    }
    if (!res.accepted) {
      return res;
    }
    this.handlers.set(clientId, handler);
    if (res.heartbeat) {
      const timer = setTimeout(() => this.heartbeatExpired(clientId), res.heartbeat);
      this.heartbeatTimers.set(clientId, { heartbeat: res.heartbeat, timer });
    }
    return res;
  }
  /**
   * Remove a client subscription, issued by message
   * It contains an array of types which should be unsubscribed
   *
   * @param msg The unsubscribe message
   */
  removeClientSubscribeByMessage(msg) {
    const handler = this.extractHandlerFromMessage(msg);
    const reason = msg.command === "clientSubscribeError" ? msg.command : msg.message.reason;
    const types = msg.message.type;
    for (const type of types) {
      const clientId = this.handlerToId({ ...handler, type });
      if (this.heartbeatTimers.has(clientId)) {
        const timer = this.heartbeatTimers.get(clientId);
        clearTimeout(timer.timer);
        this.heartbeatTimers.delete(clientId);
      }
      if (!this.handlers.has(clientId)) {
        return;
      }
      this.handlers.delete(clientId);
      if (this.unsubscribeCallback) {
        this.unsubscribeCallback({ clientId, message: msg, reason });
      }
    }
  }
  /**
   * Convert handler to id
   *
   * @param handler the client handler to creat the id for
   */
  handlerToId(handler) {
    const { sid, type, from } = handler;
    return `${sid}-${from}-${type}`;
  }
  /**
   * Extract the client handler from a given message
   *
   * @param msg the subscribe or unsubscribe message
   */
  extractHandlerFromMessage(msg) {
    return { sid: msg.message.sid, from: msg.from, type: msg.message.type };
  }
  /**
   * Handle expired heartbeat
   *
   * @param clientId the id of the expired client
   */
  heartbeatExpired(clientId) {
    this.handlers.delete(clientId);
    this.heartbeatTimers.delete(clientId);
    if (this.unsubscribeCallback) {
      this.unsubscribeCallback({ clientId, reason: "timeout" });
    }
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  UserInterfaceMessagingController
});
//# sourceMappingURL=userInterfaceMessagingController.js.map
