{
  "version": 3,
  "sources": ["../../../../src/lib/adapter/validator.ts"],
  "sourcesContent": ["import { MAX_TIMEOUT, SYSTEM_ADMIN_USER } from '@/lib/adapter/constants.js';\nimport { tools, EXIT_CODES } from '@iobroker/js-controller-common';\n\ntype Callback = (...args: any[]) => void | Promise<void>;\ntype OptionalCallback = undefined | Callback;\ntype Pattern = string | string[];\n\nexport interface ValidateIdOptions {\n    /** in maintenance mode, we can access invalid ids to delete them, only works with the admin user */\n    maintenance?: boolean;\n    /** User used to check for access rights */\n    user?: string;\n}\n\nexport class Validator {\n    private readonly objects: any;\n    private readonly states: any;\n    private readonly namespaceLog: string;\n    private readonly log: any;\n    private readonly namespace: string;\n    private readonly namespaceRegExp: RegExp;\n\n    /**\n     * Validator for internal adapter.js usage\n     *\n     * @param objects - Objects DB\n     * @param states - States DB\n     * @param namespaceLog - Log prefix\n     * @param logger - Logger instance\n     * @param namespace - the namespace of the adapter\n     * @param namespaceRegExp - the namespace RegExp of the adapter `adapter.0`\n     */\n    constructor(\n        objects: any,\n        states: any,\n        namespaceLog: string,\n        logger: any,\n        namespace: string,\n        namespaceRegExp: RegExp,\n    ) {\n        this.objects = objects;\n        this.states = states;\n        this.namespaceLog = namespaceLog;\n        this.namespace = namespace;\n        this.namespaceRegExp = namespaceRegExp;\n        this.log = logger;\n    }\n\n    /**\n     * Performs the strict object check, which includes checking object existence, read-only logic, type and min/max\n     * additionally it rounds state values whose objects have a `common.step` attribute defined\n     *\n     * @param id - id of the state\n     * @param state - ioBroker setState object\n     */\n    async performStrictObjectCheck(id: string, state: ioBroker.SettableState): Promise<void> {\n        // TODO: in js-c 3.5 (or 2 releases after 3.3) we should let it throw and add tests, maybe we\n        // can already let the non existing object case throw with 3.4 because this is already producing a warning\n        try {\n            if (state.val === undefined) {\n                // only ack etc. is also possible to acknowledge the current value,\n                // if only undefined provided, it should have thrown before\n                return;\n            }\n\n            const obj = await this.objects.getObjectAsync(id);\n            // at first check object existence\n            if (!obj) {\n                this.log.warn(\n                    `${this.namespaceLog} State \"${id}\" has no existing object, this might lead to an error in future versions`,\n                );\n                return;\n            }\n\n            // for a state object, we require common.type to exist\n            if (obj.common?.type) {\n                // check if we are allowed to write (read-only can only be written with ack: true)\n                if (!state.ack && obj.common.write === false) {\n                    this.log.warn(\n                        `${this.namespaceLog} Read-only state \"${id}\" has been written without ack-flag with value \"${state.val}\"`,\n                    );\n                }\n\n                if (state.val !== null) {\n                    // now check if a type is correct, null is always allowed\n                    if (\n                        !(\n                            (obj.common.type === 'mixed' && typeof state.val !== 'object') ||\n                            (obj.common.type !== 'object' && obj.common.type === typeof state.val) ||\n                            (obj.common.type === 'array' && typeof state.val === 'string') ||\n                            (obj.common.type === 'json' && typeof state.val === 'string') ||\n                            (obj.common.type === 'object' && typeof state.val === 'string')\n                        )\n                    ) {\n                        // types can be 'number', 'string', 'boolean', 'array', 'object', 'mixed', 'json';\n                        // 'array', 'object', 'json' need to be string\n                        if (['object', 'json', 'array'].includes(obj.common.type)) {\n                            this.log.info(\n                                `${\n                                    this.namespaceLog\n                                } State value to set for \"${id}\" has to be stringified but received type \"${typeof state.val}\"`,\n                            );\n                        } else {\n                            this.log.info(\n                                `${this.namespaceLog} State value to set for \"${id}\" has to be ${\n                                    obj.common.type === 'mixed'\n                                        ? `one of type \"string\", \"number\", \"boolean\"`\n                                        : `type \"${obj.common.type}\"`\n                                } but received type \"${typeof state.val}\" `,\n                            );\n                        }\n                    }\n\n                    // now round step and check min/max if it's a number\n                    if (typeof state.val === 'number') {\n                        if (typeof obj.common.step === 'number' && obj.common.step > 0) {\n                            // round to next step\n                            const inv = 1 / obj.common.step;\n                            state.val = Math.round(state.val * inv) / inv;\n                        }\n\n                        if (obj.common.max !== undefined && state.val > obj.common.max) {\n                            this.log.warn(\n                                `${this.namespaceLog} State value to set for \"${id}\" has value \"${state.val}\" greater than max \"${obj.common.max}\"`,\n                            );\n                        }\n\n                        if (obj.common.min !== undefined && state.val < obj.common.min) {\n                            this.log.warn(\n                                `${this.namespaceLog} State value to set for \"${id}\" has value \"${state.val}\" less than min \"${obj.common.min}\"`,\n                            );\n                        }\n                    }\n                }\n            } else {\n                this.log.warn(\n                    `${this.namespaceLog} Object of state \"${id}\" is missing the required property \"common.type\"`,\n                );\n            }\n        } catch (e) {\n            this.log.warn(`${this.namespaceLog} Could not perform strict object check of state ${id}: ${e.message}`);\n        }\n    }\n\n    /**\n     * Checks if a passed ID is valid. Throws an error if id is invalid\n     *\n     * @param id id to check or object with properties device, channel and state\n     * @param isForeignId true&false if the ID is a foreign/full ID or only an \"adapter local\" id\n     * @param options optional\n     * @throws Error when id is invalid\n     */\n    validateId(id: any, isForeignId: boolean, options?: ValidateIdOptions | null): asserts id is string {\n        // there is a special maintenance mode to clear the DB from invalid IDs\n        if (options && options.maintenance && options.user === SYSTEM_ADMIN_USER) {\n            return;\n        }\n\n        if (!id && id !== 0) {\n            throw new Error('The id is empty! Please provide a valid id.');\n        }\n\n        const type = typeof id;\n\n        if (!isForeignId && type === 'number') {\n            this.log.warn(\n                `${this.namespaceLog} The id \"${id}\" has an invalid type! Expected \"string\" or \"object\", received \"number\".`,\n            );\n            this.log.warn(\n                `${this.namespaceLog} This will be refused in future versions. Please report this to the developer.`,\n            );\n        } else if (type !== 'string' && !tools.isObject(id)) {\n            throw new Error(`The id \"${id}\" has an invalid type! Expected \"string\" or \"object\", received \"${type}\".`);\n        }\n\n        if (tools.isObject(id)) {\n            // id can be an object, at least one of the following properties has to exist\n            const reqProperties = ['device', 'channel', 'state'];\n            let found = false;\n            for (const reqProperty of reqProperties) {\n                if (id[reqProperty] !== undefined) {\n                    if (typeof id[reqProperty] !== 'string') {\n                        throw new Error(\n                            `The id's property \"${reqProperty}\" of \"${JSON.stringify(\n                                id,\n                            )}\" has an invalid type! Expected \"string\", received \"${typeof id[reqProperty]}\".`,\n                        );\n                    }\n\n                    if (id[reqProperty].includes('.')) {\n                        throw new Error(\n                            `The id's property \"${reqProperty}\" of \"${JSON.stringify(\n                                id,\n                            )}\" contains the invalid character \".\"!`,\n                        );\n                    }\n                    found = true;\n                }\n            }\n            if (!found) {\n                throw new Error(\n                    `The id \"${JSON.stringify(\n                        id,\n                    )}\" is an invalid object! Expected at least one of the properties \"device\", \"channel\" or \"state\" to exist.`,\n                );\n            }\n        } else {\n            if (type !== 'string') {\n                throw new Error(\n                    `The id \"${JSON.stringify(id)}\" has an invalid type! Expected \"string\", received \"${type}\".`,\n                );\n            }\n            if (id.endsWith('.')) {\n                throw new Error(`The id \"${id}\" is invalid. Ids are not allowed to end in \".\"`);\n            }\n        }\n    }\n\n    /**\n     * Look up the error description for an error code\n     *\n     * @param code error code\n     * @returns error description\n     */\n    static getErrorText(code: number): string {\n        code = code || 0;\n        return (EXIT_CODES[code] || code).toString();\n    }\n\n    /**\n     * Throws if a type is not matching the expected type\n     *\n     * @param value value to check a type of\n     * @param name name of the parameter for logging\n     */\n    static assertString(value: unknown, name: string): asserts value is string {\n        if (typeof value !== 'string') {\n            throw new Error(\n                `Parameter \"${name}\" needs to be of type \"string\" but type \"${typeof value}\" has been passed`,\n            );\n        }\n    }\n\n    /**\n     * Throws if a type is not a pattern\n     *\n     * @param value value to check a type of\n     * @param name name of the parameter for logging\n     */\n    static assertPattern(value: unknown, name: string): asserts value is Pattern {\n        if (typeof value !== 'string' && !Array.isArray(value)) {\n            throw new Error(\n                `Parameter \"${name}\" needs to be of type \"string\" or an array of type \"string\", \"${typeof value}\" has been passed`,\n            );\n        } else if (Array.isArray(value)) {\n            for (const entry of value) {\n                if (typeof entry !== 'string') {\n                    throw new Error(\n                        `Parameter \"${name}\" needs to be of type \"string\" or an array of type \"string\", but the array contains a value of type \"${typeof value}\"`,\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Throws if a type is not matching the expected type\n     *\n     * @param value value to check a type of\n     * @param name name of the parameter for logging\n     */\n    static assertBoolean(value: unknown, name: string): asserts value is boolean {\n        if (typeof value !== 'boolean') {\n            throw new Error(\n                `Parameter \"${name}\" needs to be of type \"boolean\" but type \"${typeof value}\" has been passed`,\n            );\n        }\n    }\n\n    /**\n     * Throws if a type is not matching the expected type\n     *\n     * @param value value to check a type of\n     * @param name name of the parameter for logging\n     */\n    static assertNumber(value: unknown, name: string): asserts value is number {\n        if (typeof value !== 'number') {\n            throw new Error(\n                `Parameter \"${name}\" needs to be of type \"number\" but type \"${typeof value}\" has been passed`,\n            );\n        }\n    }\n\n    /**\n     * Throws if a type is not matching the expected type\n     *\n     * @param value value to check a type of\n     * @param name name of the parameter for logging\n     */\n    static assertObject<T extends Record<string, any> = Record<string, any>>(\n        value: unknown,\n        name: string,\n    ): asserts value is T {\n        if (!tools.isObject(value)) {\n            throw new Error(`Parameter \"${name}\" needs to be a real object but type \"${typeof value}\" has been passed`);\n        }\n    }\n\n    /**\n     * Throws if a type is not an optional callback\n     *\n     * @param value value to check a type of\n     * @param name name of the parameter for logging\n     */\n    static assertBuffer(value: unknown, name: string): asserts value is Buffer {\n        if (!Buffer.isBuffer(value)) {\n            throw new Error(`Parameter \"${name}\" needs to be a Buffer but type \"${typeof value}\" has been passed`);\n        }\n    }\n\n    /**\n     * Throws if a type is not an optional callback\n     *\n     * @param value value to check a type of\n     * @param name name of the parameter for logging\n     */\n    static assertOptionalCallback(value: unknown, name: string): asserts value is OptionalCallback {\n        if (value && typeof value !== 'function') {\n            throw new Error(\n                `Parameter \"${name}\" needs to be of type \"null\", \"undefined\" or \"function\" but type \"${typeof value}\" has been passed`,\n            );\n        }\n    }\n\n    /**\n     * Throws if a type is not an optional callback\n     *\n     * @param value value to check a type of\n     * @param name name of the parameter for logging\n     */\n    static assertCallback(value: unknown, name: string): asserts value is Callback {\n        if (typeof value !== 'function') {\n            throw new Error(\n                `Parameter \"${name}\" needs to be of type \"function\" but type \"${typeof value}\" has been passed`,\n            );\n        }\n    }\n\n    /**\n     * Adds the namespace to the ID if it is missing, if an object is passed it will be converted to an id string\n     *\n     * @param id id which will be fixed\n     * @param isPattern if the id is a pattern\n     */\n    fixId(id: string | ioBroker.IdObject, isPattern = false): string {\n        if (!id) {\n            id = '';\n        }\n\n        let result = '';\n        if (typeof id === 'string') {\n            result = id;\n\n            // if not the instance name itself and also not starts with namespace and \".\"\n            if (id !== this.namespace && !this.namespaceRegExp.test(id)) {\n                if (!isPattern) {\n                    result = this.namespace + (id ? `.${id}` : '');\n                } else {\n                    result = `${this.namespace}.${id ? id : ''}`;\n                }\n            }\n        } else if (tools.isObject(id)) {\n            // If ID is an object\n            // Add namespace + device + channel\n            result = `${this.namespace}.${id.device ? `${id.device}.` : ''}${id.channel ? `${id.channel}.` : ''}${\n                id.state ? id.state : ''\n            }`;\n        }\n        return result;\n    }\n\n    /**\n     * Validates the object-type argument that is passed to setState\n     *\n     * @param obj object to validate\n     */\n    validateSetStateObjectArgument(obj: Record<string, any>): void {\n        // Check that we have at least one existing non-undefined property at all, else invalid\n        if (!Object.values(obj).some(prop => prop !== undefined)) {\n            throw new Error(`The state contains no properties! At least one property is expected!`);\n        }\n\n        /*\n        The following object parameters and types are allowed:\n        val:    any,     (optional)\n        ack:    boolean, (optional)\n        ts:     number,  (optional)\n        q:      number,  (optional)\n        from:   string,  (optional)\n        c:      string,  (optional)\n        expire: number   (optional)\n        lc:     number   (optional)\n        user:   string   (optional)\n\n        Everything else is forbidden\n    */\n        const optionalProperties: Record<string, string> = {\n            val: 'any',\n            ack: 'boolean',\n            ts: 'number',\n            q: 'number',\n            from: 'string',\n            c: 'string',\n            expire: 'number',\n            lc: 'number',\n            user: 'string',\n        };\n\n        // Are there any forbidden properties?\n        const forbiddenProperties = Object.keys(obj).filter(k => !optionalProperties[k]);\n        if (forbiddenProperties.length) {\n            throw new Error(`The state contains the forbidden properties ${forbiddenProperties.join(', ')}!`);\n        }\n        // Do all properties have the correct type?\n        for (const [key, type] of Object.entries(optionalProperties)) {\n            // any permits all types\n            if (type === 'any') {\n                continue;\n            }\n            // don't flag optional properties when they don't exist or are undefined\n            if (!(key in obj) || obj[key] === undefined) {\n                continue;\n            }\n            if (type !== typeof obj[key]) {\n                throw new Error(\n                    `The state property \"${key}\" has the wrong type \"${typeof obj[key]}\" (should be \"${type}\")!`,\n                );\n            }\n        }\n    }\n\n    /**\n     * Validates that the timeout is not exceeding a 32-bit signed integer\n     *\n     * @param ms milliseconds to validate\n     */\n    static assertTimeout(ms: number): void {\n        if (ms > MAX_TIMEOUT) {\n            throw new Error(`Timeout (${ms}) is larger than a 32-bit signed integer (${MAX_TIMEOUT})`);\n        }\n\n        if (ms < 0) {\n            throw new Error(`Timeout (${ms}) is smaller than 0`);\n        }\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;;;;;AAAA,uBAA+C;AAC/C,kCAAkC;AAa5B,MAAO,UAAS;EACD;EACA;EACA;EACA;EACA;EACA;;;;;;;;;;;EAYjB,YACI,SACA,QACA,cACA,QACA,WACA,iBAAuB;AAEvB,SAAK,UAAU;AACf,SAAK,SAAS;AACd,SAAK,eAAe;AACpB,SAAK,YAAY;AACjB,SAAK,kBAAkB;AACvB,SAAK,MAAM;EACf;;;;;;;;EASA,MAAM,yBAAyB,IAAY,OAA6B;AAGpE,QAAI;AACA,UAAI,MAAM,QAAQ,QAAW;AAGzB;MACJ;AAEA,YAAM,MAAM,MAAM,KAAK,QAAQ,eAAe,EAAE;AAEhD,UAAI,CAAC,KAAK;AACN,aAAK,IAAI,KACL,GAAG,KAAK,YAAY,WAAW,EAAE,0EAA0E;AAE/G;MACJ;AAGA,UAAI,IAAI,QAAQ,MAAM;AAElB,YAAI,CAAC,MAAM,OAAO,IAAI,OAAO,UAAU,OAAO;AAC1C,eAAK,IAAI,KACL,GAAG,KAAK,YAAY,qBAAqB,EAAE,mDAAmD,MAAM,GAAG,GAAG;QAElH;AAEA,YAAI,MAAM,QAAQ,MAAM;AAEpB,cACI,EACK,IAAI,OAAO,SAAS,WAAW,OAAO,MAAM,QAAQ,YACpD,IAAI,OAAO,SAAS,YAAY,IAAI,OAAO,SAAS,OAAO,MAAM,OACjE,IAAI,OAAO,SAAS,WAAW,OAAO,MAAM,QAAQ,YACpD,IAAI,OAAO,SAAS,UAAU,OAAO,MAAM,QAAQ,YACnD,IAAI,OAAO,SAAS,YAAY,OAAO,MAAM,QAAQ,WAE5D;AAGE,gBAAI,CAAC,UAAU,QAAQ,OAAO,EAAE,SAAS,IAAI,OAAO,IAAI,GAAG;AACvD,mBAAK,IAAI,KACL,GACI,KAAK,YACT,4BAA4B,EAAE,8CAA8C,OAAO,MAAM,GAAG,GAAG;YAEvG,OAAO;AACH,mBAAK,IAAI,KACL,GAAG,KAAK,YAAY,4BAA4B,EAAE,eAC9C,IAAI,OAAO,SAAS,UACd,8CACA,SAAS,IAAI,OAAO,IAAI,GAClC,uBAAuB,OAAO,MAAM,GAAG,IAAI;YAEnD;UACJ;AAGA,cAAI,OAAO,MAAM,QAAQ,UAAU;AAC/B,gBAAI,OAAO,IAAI,OAAO,SAAS,YAAY,IAAI,OAAO,OAAO,GAAG;AAE5D,oBAAM,MAAM,IAAI,IAAI,OAAO;AAC3B,oBAAM,MAAM,KAAK,MAAM,MAAM,MAAM,GAAG,IAAI;YAC9C;AAEA,gBAAI,IAAI,OAAO,QAAQ,UAAa,MAAM,MAAM,IAAI,OAAO,KAAK;AAC5D,mBAAK,IAAI,KACL,GAAG,KAAK,YAAY,4BAA4B,EAAE,gBAAgB,MAAM,GAAG,uBAAuB,IAAI,OAAO,GAAG,GAAG;YAE3H;AAEA,gBAAI,IAAI,OAAO,QAAQ,UAAa,MAAM,MAAM,IAAI,OAAO,KAAK;AAC5D,mBAAK,IAAI,KACL,GAAG,KAAK,YAAY,4BAA4B,EAAE,gBAAgB,MAAM,GAAG,oBAAoB,IAAI,OAAO,GAAG,GAAG;YAExH;UACJ;QACJ;MACJ,OAAO;AACH,aAAK,IAAI,KACL,GAAG,KAAK,YAAY,qBAAqB,EAAE,kDAAkD;MAErG;IACJ,SAAS,GAAG;AACR,WAAK,IAAI,KAAK,GAAG,KAAK,YAAY,mDAAmD,EAAE,KAAK,EAAE,OAAO,EAAE;IAC3G;EACJ;;;;;;;;;EAUA,WAAW,IAAS,aAAsB,SAAkC;AAExE,QAAI,WAAW,QAAQ,eAAe,QAAQ,SAAS,oCAAmB;AACtE;IACJ;AAEA,QAAI,CAAC,MAAM,OAAO,GAAG;AACjB,YAAM,IAAI,MAAM,6CAA6C;IACjE;AAEA,UAAM,OAAO,OAAO;AAEpB,QAAI,CAAC,eAAe,SAAS,UAAU;AACnC,WAAK,IAAI,KACL,GAAG,KAAK,YAAY,YAAY,EAAE,0EAA0E;AAEhH,WAAK,IAAI,KACL,GAAG,KAAK,YAAY,gFAAgF;IAE5G,WAAW,SAAS,YAAY,CAAC,kCAAM,SAAS,EAAE,GAAG;AACjD,YAAM,IAAI,MAAM,WAAW,EAAE,mEAAmE,IAAI,IAAI;IAC5G;AAEA,QAAI,kCAAM,SAAS,EAAE,GAAG;AAEpB,YAAM,gBAAgB,CAAC,UAAU,WAAW,OAAO;AACnD,UAAI,QAAQ;AACZ,iBAAW,eAAe,eAAe;AACrC,YAAI,GAAG,WAAW,MAAM,QAAW;AAC/B,cAAI,OAAO,GAAG,WAAW,MAAM,UAAU;AACrC,kBAAM,IAAI,MACN,sBAAsB,WAAW,SAAS,KAAK,UAC3C,EAAE,CACL,uDAAuD,OAAO,GAAG,WAAW,CAAC,IAAI;UAE1F;AAEA,cAAI,GAAG,WAAW,EAAE,SAAS,GAAG,GAAG;AAC/B,kBAAM,IAAI,MACN,sBAAsB,WAAW,SAAS,KAAK,UAC3C,EAAE,CACL,uCAAuC;UAEhD;AACA,kBAAQ;QACZ;MACJ;AACA,UAAI,CAAC,OAAO;AACR,cAAM,IAAI,MACN,WAAW,KAAK,UACZ,EAAE,CACL,0GAA0G;MAEnH;IACJ,OAAO;AACH,UAAI,SAAS,UAAU;AACnB,cAAM,IAAI,MACN,WAAW,KAAK,UAAU,EAAE,CAAC,uDAAuD,IAAI,IAAI;MAEpG;AACA,UAAI,GAAG,SAAS,GAAG,GAAG;AAClB,cAAM,IAAI,MAAM,WAAW,EAAE,iDAAiD;MAClF;IACJ;EACJ;;;;;;;EAQA,OAAO,aAAa,MAAY;AAC5B,WAAO,QAAQ;AACf,YAAQ,uCAAW,IAAI,KAAK,MAAM,SAAQ;EAC9C;;;;;;;EAQA,OAAO,aAAa,OAAgB,MAAY;AAC5C,QAAI,OAAO,UAAU,UAAU;AAC3B,YAAM,IAAI,MACN,cAAc,IAAI,4CAA4C,OAAO,KAAK,mBAAmB;IAErG;EACJ;;;;;;;EAQA,OAAO,cAAc,OAAgB,MAAY;AAC7C,QAAI,OAAO,UAAU,YAAY,CAAC,MAAM,QAAQ,KAAK,GAAG;AACpD,YAAM,IAAI,MACN,cAAc,IAAI,iEAAiE,OAAO,KAAK,mBAAmB;IAE1H,WAAW,MAAM,QAAQ,KAAK,GAAG;AAC7B,iBAAW,SAAS,OAAO;AACvB,YAAI,OAAO,UAAU,UAAU;AAC3B,gBAAM,IAAI,MACN,cAAc,IAAI,wGAAwG,OAAO,KAAK,GAAG;QAEjJ;MACJ;IACJ;EACJ;;;;;;;EAQA,OAAO,cAAc,OAAgB,MAAY;AAC7C,QAAI,OAAO,UAAU,WAAW;AAC5B,YAAM,IAAI,MACN,cAAc,IAAI,6CAA6C,OAAO,KAAK,mBAAmB;IAEtG;EACJ;;;;;;;EAQA,OAAO,aAAa,OAAgB,MAAY;AAC5C,QAAI,OAAO,UAAU,UAAU;AAC3B,YAAM,IAAI,MACN,cAAc,IAAI,4CAA4C,OAAO,KAAK,mBAAmB;IAErG;EACJ;;;;;;;EAQA,OAAO,aACH,OACA,MAAY;AAEZ,QAAI,CAAC,kCAAM,SAAS,KAAK,GAAG;AACxB,YAAM,IAAI,MAAM,cAAc,IAAI,yCAAyC,OAAO,KAAK,mBAAmB;IAC9G;EACJ;;;;;;;EAQA,OAAO,aAAa,OAAgB,MAAY;AAC5C,QAAI,CAAC,OAAO,SAAS,KAAK,GAAG;AACzB,YAAM,IAAI,MAAM,cAAc,IAAI,oCAAoC,OAAO,KAAK,mBAAmB;IACzG;EACJ;;;;;;;EAQA,OAAO,uBAAuB,OAAgB,MAAY;AACtD,QAAI,SAAS,OAAO,UAAU,YAAY;AACtC,YAAM,IAAI,MACN,cAAc,IAAI,qEAAqE,OAAO,KAAK,mBAAmB;IAE9H;EACJ;;;;;;;EAQA,OAAO,eAAe,OAAgB,MAAY;AAC9C,QAAI,OAAO,UAAU,YAAY;AAC7B,YAAM,IAAI,MACN,cAAc,IAAI,8CAA8C,OAAO,KAAK,mBAAmB;IAEvG;EACJ;;;;;;;EAQA,MAAM,IAAgC,YAAY,OAAK;AACnD,QAAI,CAAC,IAAI;AACL,WAAK;IACT;AAEA,QAAI,SAAS;AACb,QAAI,OAAO,OAAO,UAAU;AACxB,eAAS;AAGT,UAAI,OAAO,KAAK,aAAa,CAAC,KAAK,gBAAgB,KAAK,EAAE,GAAG;AACzD,YAAI,CAAC,WAAW;AACZ,mBAAS,KAAK,aAAa,KAAK,IAAI,EAAE,KAAK;QAC/C,OAAO;AACH,mBAAS,GAAG,KAAK,SAAS,IAAI,KAAK,KAAK,EAAE;QAC9C;MACJ;IACJ,WAAW,kCAAM,SAAS,EAAE,GAAG;AAG3B,eAAS,GAAG,KAAK,SAAS,IAAI,GAAG,SAAS,GAAG,GAAG,MAAM,MAAM,EAAE,GAAG,GAAG,UAAU,GAAG,GAAG,OAAO,MAAM,EAAE,GAC/F,GAAG,QAAQ,GAAG,QAAQ,EAC1B;IACJ;AACA,WAAO;EACX;;;;;;EAOA,+BAA+B,KAAwB;AAEnD,QAAI,CAAC,OAAO,OAAO,GAAG,EAAE,KAAK,UAAQ,SAAS,MAAS,GAAG;AACtD,YAAM,IAAI,MAAM,sEAAsE;IAC1F;AAgBA,UAAM,qBAA6C;MAC/C,KAAK;MACL,KAAK;MACL,IAAI;MACJ,GAAG;MACH,MAAM;MACN,GAAG;MACH,QAAQ;MACR,IAAI;MACJ,MAAM;;AAIV,UAAM,sBAAsB,OAAO,KAAK,GAAG,EAAE,OAAO,OAAK,CAAC,mBAAmB,CAAC,CAAC;AAC/E,QAAI,oBAAoB,QAAQ;AAC5B,YAAM,IAAI,MAAM,+CAA+C,oBAAoB,KAAK,IAAI,CAAC,GAAG;IACpG;AAEA,eAAW,CAAC,KAAK,IAAI,KAAK,OAAO,QAAQ,kBAAkB,GAAG;AAE1D,UAAI,SAAS,OAAO;AAChB;MACJ;AAEA,UAAI,EAAE,OAAO,QAAQ,IAAI,GAAG,MAAM,QAAW;AACzC;MACJ;AACA,UAAI,SAAS,OAAO,IAAI,GAAG,GAAG;AAC1B,cAAM,IAAI,MACN,uBAAuB,GAAG,yBAAyB,OAAO,IAAI,GAAG,CAAC,iBAAiB,IAAI,KAAK;MAEpG;IACJ;EACJ;;;;;;EAOA,OAAO,cAAc,IAAU;AAC3B,QAAI,KAAK,8BAAa;AAClB,YAAM,IAAI,MAAM,YAAY,EAAE,6CAA6C,4BAAW,GAAG;IAC7F;AAEA,QAAI,KAAK,GAAG;AACR,YAAM,IAAI,MAAM,YAAY,EAAE,qBAAqB;IACvD;EACJ;;",
  "names": []
}
