{
  "version": 3,
  "sources": ["../../../../src/lib/adapter/adapter.ts", "../../../../../../node_modules/@alcalzone/esm2cjs/shims/import.meta.url/shim.js"],
  "sourcesContent": ["import net from 'node:net';\nimport fs from 'fs-extra';\nimport os from 'node:os';\nimport jwt from 'jsonwebtoken';\nimport { EventEmitter } from 'node:events';\nimport pidUsage from 'pidusage';\nimport deepClone from 'deep-clone';\nimport { PluginHandler } from '@iobroker/plugin-base';\nimport semver from 'semver';\nimport path from 'node:path';\nimport {\n    getObjectsConstructor,\n    getStatesConstructor,\n    tools,\n    EXIT_CODES,\n    password,\n    logger,\n    isInstalledFromNpm,\n} from '@iobroker/js-controller-common';\nimport {\n    decryptArray,\n    encryptArray,\n    getSupportedFeatures,\n    isMessageboxSupported,\n    getAdapterScopedPackageIdentifier,\n    listInstalledNodeModules,\n    requestModuleNameByUrl,\n} from '@/lib/adapter/utils.js';\n// @ts-expect-error no ts file\nimport extend from 'node.extend';\nimport type { Client as StatesInRedisClient } from '@iobroker/db-states-redis';\nimport type { Client as ObjectsInRedisClient } from '@iobroker/db-objects-redis';\nimport type Winston from 'winston';\nimport type NodeSchedule from 'node-schedule';\nimport yargs from 'yargs/yargs';\n\n// local version is always the same as controller version, since lerna exact: true is used\nimport packJson from '@iobroker/js-controller-adapter/package.json' with { type: 'json' };\n\nconst controllerVersion = packJson.version;\n\nimport { Log } from '@/lib/adapter/log.js';\nimport { Validator } from './validator.js';\n\nconst { FORBIDDEN_CHARS } = tools;\nimport {\n    DEFAULT_SECRET,\n    ALIAS_STARTS_WITH,\n    SYSTEM_ADMIN_USER,\n    SYSTEM_ADMIN_GROUP,\n    ERROR_PERMISSION,\n    ACCESS_EVERY_READ,\n    ACCESS_EVERY_WRITE,\n    ACCESS_GROUP_WRITE,\n    ACCESS_GROUP_READ,\n    ACCESS_USER_WRITE,\n    ACCESS_USER_READ,\n    NO_PROTECT_ADAPTERS,\n    STATE_QUALITY,\n    type SupportedFeature,\n} from '@/lib/adapter/constants.js';\nimport type { PluginHandlerSettings } from '@iobroker/plugin-base/types';\nimport type {\n    AdapterOptions,\n    AliasDetails,\n    CalculatePermissionsCallback,\n    CheckGroupCallback,\n    CheckPasswordCallback,\n    CheckStateCommand,\n    CommandsPermissions,\n    GetCertificatesCallback,\n    GetEncryptedConfigCallback,\n    GetUserGroupsOptions,\n    InternalAddChannelToEnumOptions,\n    InternalAddStateToEnumOptions,\n    InternalCalculatePermissionsOptions,\n    InternalCheckGroupOptions,\n    InternalCheckPasswordOptions,\n    InternalCreateDeviceOptions,\n    InternalCreateStateOptions,\n    InternalDeleteChannelFromEnumOptions,\n    InternalDeleteChannelOptions,\n    InternalDeleteDeviceOptions,\n    InternalDeleteStateFromEnumOptions,\n    InternalDeleteStateOptions,\n    InternalDelObjectOptions,\n    InternalDelStateOptions,\n    InternalDestroySessionOptions,\n    InternalFormatDateOptions,\n    InternalGetAdapterObjectsOptions,\n    InternalGetCertificatesOptions,\n    InternalGetChannelsOfOptions,\n    InternalGetDevicesOptions,\n    InternalGetEncryptedConfigOptions,\n    InternalGetEnumOptions,\n    InternalGetEnumsOptions,\n    InternalGetHistoryOptions,\n    InternalGetObjectOptions,\n    InternalGetObjectsOptions,\n    InternalGetObjectViewOptions,\n    InternalGetPortOptions,\n    InternalGetSessionOptions,\n    InternalGetStateOptions,\n    InternalGetStatesOfOptions,\n    InternalGetStatesOptions,\n    InternalGetUserIDOptions,\n    InternalSendToHostOptions,\n    InternalSendToOptions,\n    InternalSetObjectOptions,\n    InternalSetPasswordOptions,\n    InternalSetSessionOptions,\n    InternalSetStateChangedOptions,\n    InternalSetStateOptions,\n    InternalSubscribeOptions,\n    InternalUpdateConfigOptions,\n    TimeoutCallback,\n    MaybePromise,\n    SetStateChangedResult,\n    CheckStatesResult,\n    Pattern,\n    MessageCallbackObject,\n    SendToOptions,\n    GetCertificatesPromiseReturnType,\n    InternalAdapterConfig,\n    UserInterfaceClientRemoveMessage,\n    SendToUserInterfaceClientOptions,\n    AllPropsUnknown,\n    IoPackageInstanceObject,\n    AliasTargetEntry,\n    InternalReportDeprecationOption,\n    SuitableLicense,\n    InstallNodeModuleOptions,\n    InternalInstallNodeModuleOptions,\n    StopParameters,\n    InternalStopParameters,\n    NotificationOptions,\n} from '@/lib/_Types.js';\nimport { UserInterfaceMessagingController } from '@/lib/adapter/userInterfaceMessagingController.js';\nimport { SYSTEM_ADAPTER_PREFIX } from '@iobroker/js-controller-common-db/constants';\nimport type { CommandResult } from '@alcalzone/pak';\n\nimport * as url from 'node:url';\n// eslint-disable-next-line unicorn/prefer-module\nconst thisDir = url.fileURLToPath(new URL('.', import.meta.url || `file://${__filename}`));\ntools.ensureDNSOrder();\n\n/**\n * Here we define dynamically created methods\n */\nexport interface AdapterClass {\n    on(event: 'stateChange', listener: ioBroker.StateChangeHandler): this;\n    on(event: 'objectChange', listener: ioBroker.ObjectChangeHandler): this;\n    on(event: 'fileChange', listener: ioBroker.FileChangeHandler): this;\n    on(event: 'ready', listener: ioBroker.ReadyHandler): this;\n    on(event: 'install', listener: ioBroker.ReadyHandler): this;\n    on(event: 'unload', listener: ioBroker.UnloadHandler): this;\n    on(event: 'message', listener: ioBroker.MessageHandler): this;\n    /** Only emitted for compact instances */\n    on(event: 'exit', listener: (exitCode: number, reason: string) => Promise<void> | void): this;\n    on(event: 'log', listener: (info: any) => Promise<void> | void): this;\n    /**\n     * Extend an object and create it if it might not exist\n     *\n     * @deprecated use `adapter.extendObject` without a callback instead\n     */\n    extendObjectAsync(\n        id: string,\n        objPart: ioBroker.PartialObject,\n        options?: ioBroker.ExtendObjectOptions,\n    ): ioBroker.SetObjectPromise;\n    /** Set the capabilities of the given executable. Only works on Linux systems. */\n    setExecutableCapabilities(\n        execPath: string,\n        capabilities: string[],\n        modeEffective?: boolean,\n        modePermitted?: boolean,\n        modeInherited?: boolean,\n    ): Promise<void>;\n    /** Extend an object (which might not belong to this adapter) and create it if it might not exist */\n    extendForeignObjectAsync<T extends string>(\n        id: T,\n        objPart: ioBroker.PartialObject<ioBroker.ObjectIdToObjectType<T, 'write'>>,\n        options?: ioBroker.ExtendObjectOptions,\n    ): ioBroker.SetObjectPromise;\n    /** Reads an object from the object db */\n    getObjectAsync(id: string, options?: unknown): ioBroker.GetObjectPromise;\n    /**\n     * Query a predefined object view (similar to SQL stored procedures) and return the results\n     * For a detailed description refer to https://github.com/ioBroker/ioBroker/wiki/Adapter-Development-Documentation#object-fields\n     * or http://guide.couchdb.org/editions/1/en/views.html\n     */\n    getObjectViewAsync<Design extends string = string, Search extends string = string>(\n        design: Design,\n        search: Search,\n        params: ioBroker.GetObjectViewParams | null | undefined,\n        options?: unknown,\n    ): ioBroker.GetObjectViewPromise<ioBroker.InferGetObjectViewItemType<Design, Search>>;\n    /** Returns a list of objects with id between params.startkey and params.endkey */\n    getObjectListAsync(\n        params: ioBroker.GetObjectListParams | null,\n        options?: { sorted?: boolean } | Record<string, any>,\n    ): ioBroker.GetObjectListPromise;\n    /** Returns the enum tree, filtered by the optional enum name */\n    getEnumAsync(name: string, options?: unknown): Promise<{ result: Record<string, any>; requestEnum: string }>;\n    /** Returns the enum tree, filtered by the optional enum name */\n    getEnumsAsync(enumList?: ioBroker.EnumList, options?: unknown): ioBroker.GetEnumsPromise;\n    /** Deletes an object from the object db */\n    delObjectAsync(id: string, options?: ioBroker.DelObjectOptions): Promise<void>;\n    /** Deletes an object (which might not belong to this adapter) from the object db */\n    delForeignObjectAsync(id: string, options?: ioBroker.DelObjectOptions): Promise<void>;\n    /** Subscribe to changes of objects in this instance */\n    subscribeObjectsAsync(pattern: string, options?: unknown): Promise<void>;\n    /** Unsubscribe from changes of objects in this instance */\n    unsubscribeObjectsAsync(pattern: string, options?: unknown): Promise<void>;\n    /** Read a value from the states DB. */\n    getStateAsync(id: string, options?: unknown): ioBroker.GetStatePromise;\n    /** Subscribe to changes of objects (which might not belong to this adapter) */\n    subscribeForeignObjectsAsync(pattern: string | string[], options?: unknown): Promise<void>;\n    /** Unsubscribe from changes of objects (which might not belong to this adapter) */\n    unsubscribeForeignObjectsAsync(pattern: string | string[], options?: unknown): Promise<void>;\n    /** Creates an object in the object db. Existing objects are not overwritten. */\n    setObjectNotExistsAsync(id: string, obj: ioBroker.SettableObject, options?: unknown): ioBroker.SetObjectPromise;\n    /** Creates an object (which might not belong to this adapter) in the object db. Existing objects are not overwritten. */\n    setForeignObjectNotExistsAsync<T extends string>(\n        id: T,\n        obj: ioBroker.SettableObject<ioBroker.ObjectIdToObjectType<T, 'write'>>,\n        options?: unknown,\n    ): ioBroker.SetObjectPromise;\n\n    /** deletes a device, its channels and states */\n    deleteDeviceAsync(deviceName: string, options?: unknown): Promise<void>;\n    addChannelToEnumAsync(\n        enumName: string,\n        addTo: string,\n        parentDevice: string,\n        channelName: string,\n        options?: unknown,\n    ): Promise<void>;\n    deleteChannelFromEnumAsync(\n        enumName: string,\n        parentDevice: string,\n        channelName: string,\n        options?: unknown,\n    ): Promise<void>;\n\n    /** Returns a list of all devices in this adapter instance */\n    getDevicesAsync(options?: unknown): Promise<ioBroker.DeviceObject[]>;\n\n    addStateToEnumAsync(\n        enumName: string,\n        addTo: string,\n        parentDevice: string,\n        parentChannel: string,\n        stateName: string,\n        options?: unknown,\n    ): Promise<void>;\n    deleteStateFromEnumAsync(\n        enumName: string,\n        parentDevice: string,\n        parentChannel: string,\n        stateName: string,\n        options?: unknown,\n    ): Promise<void>;\n    /** Changes access rights of all files in the adapter directory */\n    chmodFileAsync(\n        adapter: string | null,\n        path: string,\n        options: { mode: number | string } | Record<string, any>,\n    ): Promise<{ entries: ioBroker.ChownFileResult[]; id: string }>;\n    // TODO: correct types\n    chownFileAsync(...args: any[]): Promise<any>;\n    /** reads the content of directory from DB for given adapter and path */\n    readDirAsync(adapterName: string | null, path: string, options?: unknown): ioBroker.ReadDirPromise;\n    /** Deletes a given file */\n    unlinkAsync(adapterName: string | null, path: string, options?: unknown): Promise<void>;\n    /** Deletes a given file */\n    delFileAsync(adapterName: string | null, path: string, options?: unknown): Promise<void>;\n    renameAsync(adapterName: string | null, oldName: string, newName: string, options?: unknown): Promise<void>;\n    mkdirAsync(adapterName: string | null, path: string, options?: unknown): Promise<void>;\n    /** reads the content of directory from DB for given adapter and path */\n    readFileAsync(adapterName: string | null, path: string, options?: unknown): ioBroker.ReadFilePromise;\n    writeFileAsync(adapterName: string | null, path: string, data: Buffer | string, options?: unknown): Promise<void>;\n    /** Checks if a file exists in the DB */\n    fileExistsAsync(adapterName: string | null, path: string, options?: unknown): Promise<boolean>;\n\n    // TODO correct types needed\n    getHistoryAsync(...args: any[]): Promise<any>;\n    /** Deletes a state from the states DB, but not the associated object. Consider using deleteState instead */\n    delStateAsync(id: string, options?: unknown): Promise<void>;\n    /** Deletes a state from the states DB, but not the associated object */\n    delForeignStateAsync(id: string, options?: unknown): Promise<void>;\n    /** Read all states of this adapter which match the given pattern */\n    getStatesAsync(pattern: string, options?: unknown): ioBroker.GetStatesPromise;\n    /** Read all states (which might not belong to this adapter) which match the given pattern */\n    getForeignStatesAsync(pattern: Pattern, options?: unknown): ioBroker.GetStatesPromise;\n    /** Subscribe to changes of states (which might not belong to this adapter) */\n    subscribeForeignStatesAsync(pattern: string | string[], options?: unknown): Promise<void>;\n    /** Subscribe from changes of states (which might not belong to this adapter) */\n    unsubscribeForeignStatesAsync(pattern: string | string[], options?: unknown): Promise<void>;\n    /** Subscribe to changes of states in this instance */\n    subscribeStatesAsync(pattern: Pattern, options?: unknown): Promise<void>;\n    /** Subscribe from changes of states in this instance */\n    unsubscribeStatesAsync(pattern: Pattern, options?: unknown): Promise<void>;\n    /**\n     * Helper function that looks for first free TCP port starting with the given one.\n     */\n    getPortAsync(port: number): Promise<number>;\n    /** Read a value (which might not belong to this adapter) from the states DB. */\n    getForeignStateAsync(id: string, options?: unknown): ioBroker.GetStatePromise;\n    /** Validates username and password */\n    checkPasswordAsync(user: string, password: string, options?: unknown): Promise<boolean>;\n    /** Sets a new password for the given user */\n    setPasswordAsync(user: string, password: string, options?: unknown): Promise<void>;\n    /** <INTERNAL> Checks if a user exists and is in the given group. */\n    checkGroupAsync(user: string, group: string, options?: unknown): Promise<boolean>;\n    /** <INTERNAL> Determines the users permissions */\n    calculatePermissionsAsync(\n        user: string,\n        commandsPermissions: CommandsPermissions,\n        options?: unknown,\n    ): Promise<ioBroker.PermissionSet>;\n    /** Creates or overwrites an object in the object db */\n    setObjectAsync(id: string, obj: ioBroker.SettableObject, options?: unknown): ioBroker.SetObjectPromise;\n    /** Creates or overwrites an object (which might not belong to this adapter) in the object db */\n    setForeignObjectAsync<T extends string>(\n        id: T,\n        obj: ioBroker.SettableObject<ioBroker.ObjectIdToObjectType<T, 'write'>>,\n        options?: unknown,\n    ): ioBroker.SetObjectPromise;\n    // TODO: correct types\n    getCertificatesAsync(\n        publicName?: string,\n        privateName?: string,\n        chainedName?: string,\n    ): Promise<GetCertificatesPromiseReturnType>;\n    /** Get all states, channels, devices and folders of this adapter */\n    getAdapterObjectsAsync(): Promise<Record<string, ioBroker.AdapterScopedObject>>;\n\n    /** Reads an object (which might not belong to this adapter) from the object db*/\n    getForeignObjectAsync<T extends string>(id: T, options?: unknown): ioBroker.GetObjectPromise<T>;\n\n    /**\n     * Writes a value (which might not belong to this adapter) into the states DB only if it has changed.\n     */\n    setForeignStateChangedAsync(\n        id: string,\n        state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState,\n        ack?: boolean,\n    ): ioBroker.SetStateChangedPromise;\n    setForeignStateChangedAsync(\n        id: string,\n        state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState,\n        options?: unknown,\n    ): ioBroker.SetStateChangedPromise;\n    setForeignStateChangedAsync(\n        id: string,\n        state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState,\n        ack: boolean,\n        options: unknown,\n    ): ioBroker.SetStateChangedPromise;\n\n    /**\n     * Writes a value into the states DB only if it has changed.\n     */\n    setStateChangedAsync(\n        id: string,\n        state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState,\n        ack?: boolean,\n    ): ioBroker.SetStateChangedPromise;\n    setStateChangedAsync(\n        id: string,\n        state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState,\n        options?: unknown,\n    ): ioBroker.SetStateChangedPromise;\n    setStateChangedAsync(\n        id: string,\n        state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState,\n        ack: boolean,\n        options: unknown,\n    ): ioBroker.SetStateChangedPromise;\n\n    /**\n     * Sends a message to a specific host or all hosts.\n     */\n    sendToHostAsync(hostName: string, message: ioBroker.MessagePayload): Promise<ioBroker.Message | undefined>;\n    sendToHostAsync(\n        hostName: string,\n        command: string,\n        message: ioBroker.MessagePayload,\n    ): Promise<ioBroker.Message | undefined>;\n\n    /**\n     * Sends a message to a specific instance or all instances of some specific adapter.\n     */\n    sendToAsync(instanceName: string, message: ioBroker.MessagePayload): Promise<ioBroker.Message | undefined>;\n    sendToAsync(\n        instanceName: string,\n        command: string,\n        message: ioBroker.MessagePayload,\n        options?: SendToOptions,\n    ): Promise<ioBroker.Message | undefined>;\n\n    /**\n     * Deletes a given file\n     */\n    delFile(adapterName: string | null, path: string, callback: ioBroker.ErrnoCallback): void;\n    delFile(adapterName: string | null, path: string, options: unknown, callback: ioBroker.ErrnoCallback): void;\n\n    /**\n     * Writes a value into the states DB.\n     *\n     * @deprecated use `adapter.setState` without callback instead\n     */\n    setStateAsync(\n        id: string,\n        state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState,\n        ack?: boolean,\n    ): ioBroker.SetStatePromise;\n    /** @deprecated use `adapter.setState` without callback instead */\n    setStateAsync(\n        id: string,\n        state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState,\n        options?: unknown,\n    ): ioBroker.SetStatePromise;\n    /** @deprecated use `adapter.setState` without callback instead */\n    setStateAsync(\n        id: string,\n        state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState,\n        ack: boolean,\n        options: unknown,\n    ): ioBroker.SetStatePromise;\n\n    /**\n     * Writes a value (which might not belong to this adapter) into the states DB.\n     */\n    setForeignStateAsync(\n        id: string,\n        state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState,\n        ack?: boolean,\n    ): ioBroker.SetStatePromise;\n    setForeignStateAsync(\n        id: string,\n        state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState,\n        options?: unknown,\n    ): ioBroker.SetStatePromise;\n    setForeignStateAsync(\n        id: string,\n        state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState,\n        ack: boolean,\n        options: unknown,\n    ): ioBroker.SetStatePromise;\n\n    /**\n     * Get foreign objects by pattern, by specific type and resolve their enums.\n     */\n    getForeignObjectsAsync<T extends ioBroker.ObjectType>(\n        pattern: Pattern,\n        type: T,\n        enums?: ioBroker.EnumList | null,\n        options?: unknown,\n    ): ioBroker.GetObjectsPromiseTyped<T>;\n    getForeignObjectsAsync<T extends ioBroker.ObjectType>(\n        pattern: Pattern,\n        type: T,\n        options?: unknown,\n    ): ioBroker.GetObjectsPromiseTyped<T>;\n    getForeignObjectsAsync(pattern: Pattern, options?: unknown): ioBroker.GetObjectsPromise;\n\n    /**\n     * creates an object with type device\n     *\n     * @deprecated use `extendObject` instead\n     */\n    createDeviceAsync(deviceName: string, common?: Partial<ioBroker.DeviceCommon>): ioBroker.SetObjectPromise;\n    /** @deprecated use `extendObject` instead */\n    createDeviceAsync(\n        deviceName: string,\n        common: Partial<ioBroker.DeviceCommon>,\n        native?: Record<string, any>,\n    ): ioBroker.SetObjectPromise;\n    /** @deprecated use `extendObject` instead */\n    createDeviceAsync(\n        deviceName: string,\n        common: Partial<ioBroker.DeviceCommon>,\n        native: Record<string, any>,\n        options?: unknown,\n    ): ioBroker.SetObjectPromise;\n\n    /**\n     * Finds an object by its ID or name\n     */\n    findForeignObjectAsync(idOrName: string, type: string): Promise<{ id: string; name: string }>;\n\n    /**\n     * Creates an object with type channel. It must be located under a device\n     *\n     * @deprecated use `extendObject` instead\n     */\n    createChannelAsync(\n        parentDevice: string,\n        channelName: string,\n        roleOrCommon?: string | Partial<ioBroker.ChannelCommon>,\n    ): ioBroker.SetObjectPromise;\n    /** @deprecated use `extendObject` instead */\n    createChannelAsync(\n        parentDevice: string,\n        channelName: string,\n        roleOrCommon: string | Partial<ioBroker.ChannelCommon>,\n        native?: Record<string, any>,\n    ): ioBroker.SetObjectPromise;\n    /** @deprecated use `extendObject` instead */\n    createChannelAsync(\n        parentDevice: string,\n        channelName: string,\n        roleOrCommon: string | Partial<ioBroker.ChannelCommon>,\n        native: Record<string, any>,\n        options?: unknown,\n    ): ioBroker.SetObjectPromise;\n\n    /**\n     * Creates a state and the corresponding object. It must be located in a channel under a device\n     *\n     * @deprecated use `extendObject` instead\n     */\n    createStateAsync(\n        parentDevice: string,\n        parentChannel: string,\n        stateName: string,\n        roleOrCommon?: string | Partial<ioBroker.StateCommon>,\n    ): ioBroker.SetObjectPromise;\n    /** @deprecated use `extendObject` instead */\n    createStateAsync(\n        parentDevice: string,\n        parentChannel: string,\n        stateName: string,\n        roleOrCommon: string | Partial<ioBroker.StateCommon>,\n        native?: Record<string, any>,\n    ): ioBroker.SetObjectPromise;\n    /** @deprecated use `extendObject` instead */\n    createStateAsync(\n        parentDevice: string,\n        parentChannel: string,\n        stateName: string,\n        roleOrCommon: string | Partial<ioBroker.StateCommon>,\n        native: Record<string, any>,\n        options?: unknown,\n    ): ioBroker.SetObjectPromise;\n\n    /**\n     * Deletes a channel and its states. It must have been created with createChannel\n     *\n     * @deprecated use `this.delObject` instead\n     */\n    deleteChannelAsync(channelName: string, options?: unknown): Promise<void>;\n    /** @deprecated use `this.delObject` instead */\n    deleteChannelAsync(parentDevice: string, channelName: string, options?: unknown): Promise<void>;\n\n    /**\n     * Deletes a state. It must have been created with createState\n     *\n     * @deprecated use `this.delObject` instead\n     */\n    deleteStateAsync(stateName: string, options?: unknown): Promise<void>;\n    /** @deprecated use `this.delObject` instead */\n    deleteStateAsync(parentChannel: string, stateName: string, options?: unknown): Promise<void>;\n    /** @deprecated use `this.delObject` instead */\n    deleteStateAsync(parentDevice: string, parentChannel: string, stateName: string, options?: unknown): Promise<void>;\n\n    /**\n     * Returns a list of all channels in this adapter instance @param parentDevice (optional) Name\n     * of the parent device to filter the channels by @param options (optional) Some internal options.\n     */\n    getChannelsOfAsync(): Promise<ioBroker.ChannelObject[]>;\n    getChannelsOfAsync(parentDevice: string, options?: unknown): Promise<ioBroker.ChannelObject[]>;\n\n    /**\n     * Returns a list of all channels in this adapter instance\n     */\n    getChannels(callback: ioBroker.GetObjectsCallback3<ioBroker.ChannelObject>): void;\n    getChannels(parentDevice: string, callback: ioBroker.GetObjectsCallback3<ioBroker.ChannelObject>): void;\n    getChannels(\n        parentDevice: string,\n        options: unknown,\n        callback: ioBroker.GetObjectsCallback3<ioBroker.ChannelObject>,\n    ): void;\n\n    /**\n     * Returns a list of all channels in this adapter instance @param parentDevice (optional)\n     * Name of the parent device to filter the channels by @param options (optional) Some internal options.\n     */\n    getChannelsAsync(): Promise<ioBroker.ChannelObject[]>;\n    getChannelsAsync(parentDevice: string, options?: unknown): Promise<ioBroker.ChannelObject[]>;\n\n    /**\n     * Returns a list of all states in this adapter instance @param parentDevice (optional)\n     * Name of the parent device to filter the channels by @param parentChannel (optional)\n     * Name of the parent channel to filter the channels by @param options (optional) Some internal options.\n     */\n    getStatesOfAsync(): Promise<ioBroker.StateObject[]>;\n    getStatesOfAsync(parentDevice: string, parentChannel?: string): Promise<ioBroker.StateObject[]>;\n    getStatesOfAsync(parentDevice: string, parentChannel: string, options?: unknown): Promise<ioBroker.StateObject[]>;\n}\n\n/**\n * Adapter class\n *\n * How the initialization happens:\n *  _initObjects => _initStates => _prepareInitAdapter => _initAdapter => _initLogging => _createInstancesObjects => ready\n *\n */\nexport class AdapterClass extends EventEmitter {\n    /** Cache of all deprecations which have already been transmitted */\n    private reportedDeprecations = new Set<string>();\n    /** Instance to access states DB */\n    #states?: StatesInRedisClient | null;\n    /** Instance to access objects DB */\n    #objects?: ObjectsInRedisClient | null;\n    /** States DB constructor */\n    private States?: typeof StatesInRedisClient;\n    /** Objects DB constructor */\n    private Objects?: typeof ObjectsInRedisClient;\n    /** Contents of iobroker.json */\n    private readonly _config: Record<string, any>;\n    private readonly _options: AdapterOptions;\n    private readonly startedInCompactMode: boolean;\n    /** List of instances which want our logs */\n    private readonly logList = new Set<string>();\n    private readonly aliases = new Map<string, AliasDetails>();\n    private readonly aliasPatterns = new Set<string>();\n    private enums: Record<string, any> = {};\n    private eventLoopLags: number[] = [];\n    private overwriteLogLevel: boolean = false;\n    adapterReady: boolean = false;\n    /** Callbacks from sendTo */\n    private readonly messageCallbacks = new Map<number, MessageCallbackObject>();\n    /**\n     * Contains a live cache of the adapter's states.\n     * NOTE: This is only defined if the adapter was initialized with the option states: true.\n     */\n    oStates?: Record<string, ioBroker.State | undefined>;\n    /**\n     * Contains a live cache of the adapter's objects.\n     * NOTE: This is only defined if the adapter was initialized with the option objects: true.\n     */\n    oObjects?: Record<string, ioBroker.Object | undefined>;\n    private _stopInProgress: boolean = false;\n    private _callbackId: number = 1;\n    private _firstConnection: boolean = true;\n    private readonly _timers = new Set<NodeJS.Timeout>();\n    private readonly _intervals = new Set<NodeJS.Timeout>();\n    private readonly _delays = new Set<NodeJS.Timeout>();\n    /** For ease of use the log property is always defined, however it is only available after `ready` has been called. */\n    log!: Log;\n    performStrictObjectChecks: boolean;\n    private readonly _logger: Winston.Logger;\n    private _restartScheduleJob: any;\n    private _schedule?: typeof NodeSchedule;\n    private namespaceLog: string;\n    namespace: `${string}.${number}`;\n    name: string;\n    private _systemSecret?: string;\n    /** Whether the adapter has already terminated */\n    private terminated: boolean = false;\n    /** The cache of usernames */\n    private usernames: Record<string, { id: string }> = {};\n    /** A RegExp to test for forbidden chars in object IDs */\n    readonly FORBIDDEN_CHARS: RegExp = FORBIDDEN_CHARS;\n    private inputCount: number = 0;\n    private outputCount: number = 0;\n    /** The cache of users */\n    private users: Record<ioBroker.ObjectIDs.User, { groups: any; acl: any }> = {}; // todo\n    /** The cache of user groups */\n    private groups: Record<string, Partial<ioBroker.GroupObject>> = {};\n    /** An array of instances, that support auto subscribe */\n    private autoSubscribe: string[] = [];\n    private defaultHistory: null | string = null;\n    private pluginHandler?: InstanceType<typeof PluginHandler>;\n    private _reportInterval?: null | NodeJS.Timeout;\n    private getPortRunning: null | InternalGetPortOptions = null;\n    private readonly _namespaceRegExp: RegExp;\n    instance?: number;\n    // @ts-expect-error decide how to handle it\n    private _utils: Validator;\n    /** contents of io-package.json */\n    adapterConfig?: AdapterOptions | ioBroker.InstanceObject | null;\n    connected?: boolean;\n    adapterDir: string;\n    /** contents of package.json */\n    pack?: Record<string, any>;\n    /** contents of io-package.json */\n    ioPack: ioBroker.InstanceObject;\n    private _initializeTimeout?: NodeJS.Timeout | null;\n    private inited?: boolean;\n    /** contents of iobroker.json if required via AdapterOptions */\n    systemConfig?: Record<string, any>;\n    /** the configured date format of system.config, only available if requested via AdapterOptions `useFormatDate` */\n    dateFormat?: any;\n    /** if float comma instead of dot is used, only available if requested via AdapterOptions `useFormatDate` */\n    isFloatComma?: boolean;\n    /** configured language of system.config, only available if requested via AdapterOptions `useFormatDate` */\n    language?: ioBroker.Languages;\n    /** longitude configured in system.config, only available if requested via AdapterOptions `useFormatDate`*/\n    longitude?: number;\n    /** latitude configured in system.config, only available if requested via AdapterOptions `useFormatDate`*/\n    latitude?: number;\n    private _defaultObjs?: Record<string, Partial<ioBroker.StateCommon>>;\n    private _aliasObjectsSubscribed?: boolean;\n    config: ioBroker.AdapterConfig = {};\n    host?: string;\n    common?: ioBroker.InstanceCommon;\n    private mboxSubscribed?: boolean;\n    /** Stop the adapter */\n    stop?: (params?: StopParameters) => Promise<void>;\n    version?: string;\n    /** Stop the adapter only defined in compact, not for external usage */\n    protected kill?: () => Promise<void>;\n    processLog?: (msg: any) => void;\n    /**\n     * Start or stop subscribing to log messages\n     * The method is only available if logTransporter is active via io-pack or adapter options\n     * Note, that stopping will stop after 10 seconds, not immediately\n     *\n     * @param isActive - if log subscription should be activated or deactivated\n     * @param options - options passed to setState e.g. user permissions\n     */\n    requireLog?: (isActive: boolean, options?: Partial<GetUserGroupsOptions>) => Promise<void> | void;\n    private logOffTimer?: NodeJS.Timeout | null;\n    private logRequired?: boolean;\n    private patterns?: Record<string, { regex: string }>;\n    private statesConnectedTime?: number;\n    /** Constants for frequent use in adapters */\n    readonly constants = {\n        STATE_QUALITY,\n    } as const;\n\n    /** Features supported by the running instance */\n    private readonly SUPPORTED_FEATURES = getSupportedFeatures();\n    /** Controller for messaging related functionality */\n    private readonly uiMessagingController: UserInterfaceMessagingController;\n\n    constructor(options: AdapterOptions | string) {\n        super();\n\n        // enable \"const adapter = require(__dirname + '/../../lib/adapter.js')('adapterName');\" call\n        if (typeof options === 'string') {\n            this._options = { name: options };\n        } else {\n            this._options = options;\n        }\n\n        const configFileName = tools.getConfigFileName();\n\n        if (fs.pathExistsSync(configFileName)) {\n            this._config = fs.readJsonSync(configFileName);\n            this._config.states = this._config.states || { type: 'jsonl' };\n            this._config.objects = this._config.objects || { type: 'jsonl' };\n            // Make sure the DB has enough time (5s). JsonL can take a bit longer if the process just crashed before\n            // because the lockfile might not have been freed.\n            this._config.states.connectTimeout = Math.max(this._config.states.connectTimeout || 0, 5_000);\n            this._config.objects.connectTimeout = Math.max(this._config.objects.connectTimeout || 0, 5_000);\n        } else {\n            throw new Error(`Cannot find ${configFileName}`);\n        }\n\n        if (!this._options) {\n            throw new Error('Configuration not set!');\n        }\n\n        if (this._options.config && !this._options.config.log) {\n            this._options.config.log = this._config.log;\n        }\n\n        this._config = this._options.config || this._config;\n        this.startedInCompactMode = !!this._options.compact;\n\n        const parsedArgs = yargs(process.argv.slice(2))\n            .options({\n                loglevel: {\n                    describe: 'Define adapter log level',\n                    type: 'string',\n                },\n                silent: {\n                    describe: 'If is install run',\n                    type: 'boolean',\n                },\n                install: {\n                    describe: 'If is install run',\n                    type: 'boolean',\n                },\n                logs: {\n                    describe: 'If console output desired',\n                    type: 'boolean',\n                },\n                console: {\n                    describe: 'If console output desired',\n                    type: 'boolean',\n                },\n                force: {\n                    describe: 'If force start even if disabled',\n                    type: 'boolean',\n                },\n                debug: {\n                    describe: 'Same as --force combined with --console',\n                    type: 'boolean',\n                },\n                instance: {\n                    describe: 'Instance id, e.g. 0',\n                    type: 'string',\n                },\n            })\n            .parseSync();\n\n        if (parsedArgs.loglevel && ['info', 'debug', 'error', 'warn', 'silly'].includes(parsedArgs.loglevel)) {\n            this._config.log.level = parsedArgs.loglevel;\n            this.overwriteLogLevel = true;\n        }\n\n        if (parsedArgs.silent || parsedArgs.install) {\n            this._config.isInstall = true;\n        }\n\n        if (parsedArgs.logs || parsedArgs.console) {\n            this._config.consoleOutput = true;\n        }\n\n        if (parsedArgs.force) {\n            this._config.forceIfDisabled = true;\n        }\n\n        if (parsedArgs.debug) {\n            this._config.forceIfDisabled = true;\n            this._config.consoleOutput = true;\n            if (this._config.log.level !== 'silly') {\n                this._config.log.level = 'debug';\n                this.overwriteLogLevel = true;\n            }\n        }\n\n        if (parsedArgs.instance && parseInt(parsedArgs.instance, 10).toString() === parsedArgs.instance) {\n            this._config.instance = parseInt(parsedArgs.instance, 10);\n        }\n\n        this._config.log.level = this._config.log.level || 'info';\n\n        this._config.log.noStdout = !this._config.consoleOutput;\n\n        this.performStrictObjectChecks = this._options.strictObjectChecks !== false;\n\n        this.name = this._options.name;\n\n        if (!this.name) {\n            throw new Error('No name of adapter!');\n        }\n\n        const instance = parseInt(\n            this._options.compactInstance !== undefined\n                ? this._options.compactInstance\n                : this._options.instance !== undefined\n                  ? this._options.instance\n                  : this._config.instance || 0,\n            10,\n        );\n\n        this.namespace = `${this.name}.${instance}`;\n        this.namespaceLog = this.namespace + (this.startedInCompactMode ? ' (COMPACT)' : ` (${process.pid})`);\n        this._namespaceRegExp = new RegExp(`^${`${this.namespace}.`.replace(/\\./g, '\\\\.')}`); // cache the regex object 'adapter.0.'\n\n        this._logger = logger(this._config.log);\n\n        // compatibility\n        if (!this._logger.silly) {\n            this._logger.silly = this._logger.debug;\n        }\n\n        // If installed as npm module\n        if (this._options.dirname) {\n            this.adapterDir = this._options.dirname.replace(/\\\\/g, '/');\n        } else {\n            const adapterDir = tools.getAdapterDir(this.name);\n\n            if (!adapterDir) {\n                this._logger.error(`${this.namespaceLog} Cannot find directory of adapter ${this.name}`);\n                this.terminate(EXIT_CODES.CANNOT_FIND_ADAPTER_DIR);\n            }\n\n            this.adapterDir = adapterDir;\n        }\n\n        if (fs.existsSync(`${this.adapterDir}/io-package.json`)) {\n            this.ioPack = fs.readJSONSync(`${this.adapterDir}/io-package.json`);\n        } else {\n            this._logger.error(`${this.namespaceLog} Cannot find: ${this.adapterDir}/io-package.json`);\n            this.terminate(EXIT_CODES.CANNOT_FIND_ADAPTER_DIR);\n        }\n\n        this.uiMessagingController = new UserInterfaceMessagingController({\n            adapter: this,\n            subscribeCallback: this._options.uiClientSubscribe,\n            unsubscribeCallback: this._options.uiClientUnsubscribe,\n        });\n\n        // Create dynamic methods\n        /**\n         * Promise-version of `Adapter.getPort`\n         */\n        this.getPortAsync = tools.promisifyNoError(this.getPort, this);\n\n        /**\n         * Promise-version of `Adapter.checkPassword`\n         */\n        this.checkPasswordAsync = tools.promisifyNoError(this.checkPassword, this);\n\n        /**\n         * Promise-version of `Adapter.setPassword`\n         */\n        this.setPasswordAsync = tools.promisify(this.setPassword, this);\n\n        /**\n         * Promise-version of `Adapter.checkGroup`\n         */\n        this.checkGroupAsync = tools.promisifyNoError(this.checkGroup, this);\n\n        /**\n         * Promise-version of `Adapter.calculatePermissions`\n         */\n        this.calculatePermissionsAsync = tools.promisifyNoError(this.calculatePermissions, this);\n\n        /**\n         * Promise-version of `Adapter.getCertificates`\n         */\n        this.getCertificatesAsync = tools.promisify(this.getCertificates, this);\n\n        /**\n         * Promise-version of `Adapter.setObject`\n         */\n        this.setObjectAsync = tools.promisify(this.setObject, this);\n\n        /**\n         * Promise-version of `Adapter.getAdapterObjects`\n         */\n        this.getAdapterObjectsAsync = tools.promisifyNoError(this.getAdapterObjects, this);\n\n        /**\n         * Promise-version of `Adapter.extendObject`\n         */\n        this.extendObjectAsync = tools.promisify(this.extendObject, this);\n\n        /**\n         * Promise-version of `Adapter.setForeignObject`\n         */\n        this.setForeignObjectAsync = tools.promisify(this.setForeignObject, this);\n\n        /**\n         * Promise-version of `Adapter.extendForeignObject`\n         */\n        this.extendForeignObjectAsync = tools.promisify(this.extendForeignObject, this);\n\n        /**\n         * Promise-version of `Adapter.getObject`\n         */\n        this.getObjectAsync = tools.promisify(this.getObject, this);\n\n        /**\n         * Promise-version of `Adapter.getObjectView`\n         */\n        this.getObjectViewAsync = tools.promisify(this.getObjectView, this);\n\n        /**\n         * Promise-version of `Adapter.getObjectList`\n         */\n        this.getObjectListAsync = tools.promisify(this.getObjectList, this);\n\n        /**\n         * Promise-version of `Adapter.getEnum`\n         */\n        this.getEnumAsync = tools.promisify(this.getEnum, this, ['result', 'requestEnum']);\n\n        /**\n         * Promise-version of `Adapter.getEnums`\n         */\n        this.getEnumsAsync = tools.promisify(this.getEnums, this);\n\n        /**\n         * Promise-version of `Adapter.getForeignObjects`\n         */\n        this.getForeignObjectsAsync = tools.promisify(this.getForeignObjects, this);\n\n        /**\n         * Promise-version of `Adapter.findForeignObject`\n         */\n        this.findForeignObjectAsync = tools.promisify(this.findForeignObject, this, ['id', 'name']);\n\n        /**\n         * Promise-version of `Adapter.getForeignObject`\n         */\n        this.getForeignObjectAsync = tools.promisify(this.getForeignObject, this);\n\n        /**\n         * Promise-version of `Adapter.delObject`\n         */\n        this.delObjectAsync = tools.promisify(this.delObject, this);\n\n        /**\n         * Promise-version of `Adapter.delForeignObject`\n         */\n        this.delForeignObjectAsync = tools.promisify(this.delForeignObject, this);\n\n        /**\n         * Promise-version of `Adapter.subscribeObjects`\n         */\n        this.subscribeObjectsAsync = tools.promisify(this.subscribeObjects, this);\n\n        /**\n         * Promise-version of `Adapter.unsubscribeObjects`\n         */\n        this.unsubscribeObjectsAsync = tools.promisify(this.unsubscribeObjects, this);\n\n        /**\n         * Promise-version of `Adapter.subscribeForeignObjects`\n         */\n        this.subscribeForeignObjectsAsync = tools.promisify(this.subscribeForeignObjects, this);\n\n        /**\n         * Promise-version of `Adapter.unsubscribeForeignObjects`\n         */\n        this.unsubscribeForeignObjectsAsync = tools.promisify(this.unsubscribeForeignObjects, this);\n\n        /**\n         * Promise-version of `Adapter.setObjectNotExists`\n         */\n        this.setObjectNotExistsAsync = tools.promisify(this.setObjectNotExists, this);\n\n        /**\n         * Promise-version of `Adapter.setForeignObjectNotExists`\n         */\n        this.setForeignObjectNotExistsAsync = tools.promisify(this.setForeignObjectNotExists, this);\n\n        /**\n         * Promise-version of `Adapter.createDevice`\n         *\n         * @deprecated use `extendObject` instead\n         */\n        this.createDeviceAsync = tools.promisify(this.createDevice, this);\n\n        /**\n         * Promise-version of `Adapter.createChannel`\n         *\n         * @deprecated use `extendObject` instead\n         */\n        this.createChannelAsync = tools.promisify(this.createChannel, this);\n\n        /**\n         * Promise-version of `Adapter.createState`\n         *\n         * @deprecated use `extendObject` instead\n         */\n        this.createStateAsync = tools.promisify(this.createState, this);\n\n        /**\n         * Promise-version of `Adapter.deleteDevice`\n         *\n         * @deprecated use `delObject` instead\n         */\n        this.deleteDeviceAsync = tools.promisify(this.deleteDevice, this);\n\n        /**\n         * Promise-version of `Adapter.addChannelToEnum`\n         */\n        this.addChannelToEnumAsync = tools.promisify(this.addChannelToEnum, this);\n\n        /**\n         * Promise-version of `Adapter.deleteChannelFromEnum`\n         */\n        this.deleteChannelFromEnumAsync = tools.promisify(this.deleteChannelFromEnum, this);\n\n        /**\n         * Promise-version of `Adapter.deleteChannel`\n         *\n         * @deprecated use `delObject` instead\n         */\n        this.deleteChannelAsync = tools.promisify(this.deleteChannel, this);\n\n        /**\n         * Promise-version of `Adapter.deleteState`\n         *\n         * @deprecated use `delObject` instead\n         */\n        this.deleteStateAsync = tools.promisify(this.deleteState, this);\n\n        /**\n         * Promise-version of `Adapter.getDevices`\n         */\n        this.getDevicesAsync = tools.promisify(this.getDevices, this);\n\n        /**\n         * Promise-version of `Adapter.getChannelsOf`\n         */\n        this.getChannelsOfAsync = tools.promisify(this.getChannelsOf, this);\n\n        this.getChannels = this.getChannelsOf;\n        this.getChannelsAsync = this.getChannelsOfAsync;\n\n        /**\n         * Promise-version of `Adapter.getStatesOf`\n         */\n        this.getStatesOfAsync = tools.promisify(this.getStatesOf, this);\n\n        /**\n         * Promise-version of `Adapter.addStateToEnum`\n         */\n        this.addStateToEnumAsync = tools.promisify(this.addStateToEnum, this);\n\n        /**\n         * Promise-version of `Adapter.deleteStateFromEnum`\n         */\n        this.deleteStateFromEnumAsync = tools.promisify(this.deleteStateFromEnum, this);\n\n        /**\n         * Promise-version of `Adapter.chmodFile`\n         */\n        this.chmodFileAsync = tools.promisify(this.chmodFile, this);\n\n        /**\n         * Promise-version of `Adapter.chownFile`\n         */\n        this.chownFileAsync = tools.promisify(this.chownFile, this);\n\n        /**\n         * Promise-version of `Adapter.readDir`\n         */\n        this.readDirAsync = tools.promisify(this.readDir, this);\n\n        /**\n         * Promise-version of `Adapter.unlink`\n         */\n        this.unlinkAsync = tools.promisify(this.unlink, this);\n\n        this.delFile = this.unlink;\n        this.delFileAsync = this.unlinkAsync;\n\n        /**\n         * Promise-version of `Adapter.rename`\n         */\n        this.renameAsync = tools.promisify(this.rename, this);\n\n        /**\n         * Promise-version of `Adapter.mkdir`\n         */\n        this.mkdirAsync = tools.promisify(this.mkdir, this);\n\n        /**\n         * Promise-version of `Adapter.readFile`\n         */\n        this.readFileAsync = tools.promisify(this.readFile, this, ['file', 'mimeType']);\n\n        /**\n         * Promise-version of `Adapter.writeFile`\n         */\n        this.writeFileAsync = tools.promisify(this.writeFile, this);\n\n        /**\n         * Promise-version of `Adapter.fileExists`\n         */\n        this.fileExistsAsync = tools.promisify(this.fileExists, this);\n\n        /**\n         * Promise-version of `Adapter.sendToHost`\n         */\n        this.sendToHostAsync = tools.promisifyNoError(this.sendToHost, this);\n\n        /**\n         * Promise-version of `Adapter.setState`\n         */\n        this.setStateAsync = tools.promisify(this.setState, this);\n\n        /**\n         * Promise-version of `Adapter.setStateChanged`\n         */\n        this.setStateChangedAsync = tools.promisify(this.setStateChanged, this, ['id', 'notChanged']);\n\n        /**\n         * Promise-version of `Adapter.setForeignState`\n         */\n        this.setForeignStateAsync = tools.promisify(this.setForeignState, this);\n\n        /**\n         * Promise-version of `Adapter.setForeignStateChanged`\n         */\n        this.setForeignStateChangedAsync = tools.promisify(this.setForeignStateChanged, this);\n\n        /**\n         * Promise-version of `Adapter.getState`\n         */\n        this.getStateAsync = tools.promisify(this.getState, this);\n\n        /**\n         * Promise-version of `Adapter.getForeignState`\n         */\n        this.getForeignStateAsync = tools.promisify(this.getForeignState, this);\n\n        /**\n         * Promise-version of `Adapter.getHistory`\n         */\n        this.getHistoryAsync = tools.promisify(this.getHistory, this, ['result', 'step', 'sessionId']);\n\n        /**\n         * Promise-version of `Adapter.delState`\n         */\n        this.delStateAsync = tools.promisify(this.delState, this);\n\n        /**\n         * Promise-version of `Adapter.delForeignState`\n         */\n        this.delForeignStateAsync = tools.promisify(this.delForeignState, this);\n\n        /**\n         * Promise-version of `Adapter.getStates`\n         */\n        this.getStatesAsync = tools.promisify(this.getStates, this);\n\n        /**\n         * Promise-version of `Adapter.getForeignStates`\n         */\n        this.getForeignStatesAsync = tools.promisify(this.getForeignStates, this);\n\n        /**\n         * Promise-version of `Adapter.subscribeForeignStates`\n         */\n        this.subscribeForeignStatesAsync = tools.promisify(this.subscribeForeignStates, this);\n\n        /**\n         * Promise-version of `Adapter.unsubscribeForeignStates`\n         */\n        this.unsubscribeForeignStatesAsync = tools.promisify(this.unsubscribeForeignStates, this);\n\n        /**\n         * Promise-version of `Adapter.subscribeStates`\n         */\n        this.subscribeStatesAsync = tools.promisify(this.subscribeStates, this);\n\n        /**\n         * Promise-version of `Adapter.unsubscribeStates`\n         */\n        this.unsubscribeStatesAsync = tools.promisify(this.unsubscribeStates, this);\n\n        this.setExecutableCapabilities = tools.setExecutableCapabilities;\n        this._init();\n    }\n\n    /**\n     * Get the adapter scoped package identifier of a node module\n     *\n     * @param moduleName name of the node module\n     */\n    getAdapterScopedPackageIdentifier(moduleName: string): string {\n        return getAdapterScopedPackageIdentifier({ moduleName, namespace: this.namespace });\n    }\n\n    installNodeModule(moduleName: string, options: InstallNodeModuleOptions): Promise<CommandResult>;\n\n    /**\n     * Install specified npm module\n     *\n     * @param moduleNameOrUrl name of the node module or GitHub url which can be passed to `npm install`\n     * @param options version information\n     */\n    installNodeModule(moduleNameOrUrl: unknown, options: unknown): Promise<CommandResult> {\n        Validator.assertString(moduleNameOrUrl, 'moduleNameOrUrl');\n        Validator.assertObject<InstallNodeModuleOptions>(options, 'options');\n\n        return this._installNodeModule({ ...options, moduleNameOrUrl });\n    }\n\n    private async _installNodeModule(options: InternalInstallNodeModuleOptions): Promise<CommandResult> {\n        const { moduleNameOrUrl, version } = options;\n\n        let moduleName = moduleNameOrUrl;\n        const isUrl = URL.canParse(moduleNameOrUrl);\n\n        if (isUrl) {\n            moduleName = await requestModuleNameByUrl(moduleNameOrUrl);\n        }\n\n        const internalModuleName = getAdapterScopedPackageIdentifier({ moduleName, namespace: this.namespace });\n        const packageIdentifier = isUrl ? moduleNameOrUrl : `npm:${moduleName}@${version}`;\n\n        return tools.installNodeModule(`${internalModuleName}@${packageIdentifier}`);\n    }\n\n    /**\n     * List all additional installed node modules from this adapter\n     */\n    listInstalledNodeModules(): Promise<string[]> {\n        return listInstalledNodeModules(this.namespace);\n    }\n\n    uninstallNodeModule(moduleName: string): Promise<CommandResult>;\n\n    /**\n     * Uninstall specified npm module\n     *\n     * @param moduleName name of the node module\n     */\n    uninstallNodeModule(moduleName: unknown): Promise<CommandResult> {\n        Validator.assertString(moduleName, 'moduleName');\n\n        const internalModuleName = getAdapterScopedPackageIdentifier({ moduleName, namespace: this.namespace });\n        return tools.uninstallNodeModule(internalModuleName);\n    }\n\n    importNodeModule(moduleName: string): Promise<unknown>;\n\n    /**\n     * Import a node module which has been installed via `installNodeModule`\n     *\n     * @param moduleName name of the node module\n     * @returns the required node module\n     */\n    importNodeModule(moduleName: unknown): Promise<unknown> {\n        Validator.assertString(moduleName, 'moduleName');\n\n        const internalModuleName = getAdapterScopedPackageIdentifier({ moduleName, namespace: this.namespace });\n        // TODO: if https://github.com/microsoft/TypeScript/issues/54022 ever gets resolved, we should improve the return type\n        return import(internalModuleName);\n    }\n\n    // overload with real types\n    decrypt(secretVal: string, value?: string): string;\n    decrypt(value: string): string;\n    /**\n     * Decrypt the password/value with given key\n     *\n     * @param secretVal to use for decrypt (or value if only one parameter is given)\n     * @param value value to decrypt (if secret is provided)\n     */\n    decrypt(secretVal: unknown, value?: unknown): string {\n        if (value === undefined) {\n            value = secretVal;\n            secretVal = this._systemSecret;\n        }\n\n        Validator.assertString(secretVal, 'secretVal');\n        Validator.assertString(value, 'value');\n\n        return tools.decrypt(secretVal, value);\n    }\n\n    // overload with real types\n    encrypt(secretVal: string, value?: string): string;\n    encrypt(value: string): string;\n\n    /**\n     * Encrypt the password/value with given key\n     *\n     * @param secretVal to use for encrypting (or value if only one parameter is given)\n     * @param [value] value to encrypt (if secret is provided)\n     */\n    encrypt(secretVal: unknown, value?: unknown): string {\n        if (value === undefined) {\n            value = secretVal;\n            secretVal = this._systemSecret;\n        }\n\n        Validator.assertString(secretVal, 'secretVal');\n        Validator.assertString(value, 'value');\n\n        return tools.encrypt(secretVal, value);\n    }\n\n    // real types overload\n    getSession(id: string, callback: ioBroker.GetSessionCallback): MaybePromise;\n    // unknown guard implementation\n    getSession(id: unknown, callback: unknown): MaybePromise {\n        Validator.assertString(id, 'id');\n        Validator.assertCallback(callback, 'callback');\n\n        return this._getSession({ id, callback });\n    }\n\n    // actual implementation\n    private _getSession(options: InternalGetSessionOptions): MaybePromise {\n        if (!this.#states) {\n            // if states is no longer existing, we do not need to unsubscribe\n            this._logger.info(`${this.namespaceLog} getSession not processed because States database not connected`);\n            return tools.maybeCallbackWithError(options.callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        this.#states.getSession(options.id, options.callback);\n    }\n\n    // overload for docs\n    setSession(id: string, ttl: number, data: Record<string, any>, callback?: ioBroker.ErrorCallback): MaybePromise;\n\n    // unknown implementation guards\n    setSession(id: unknown, ttl: unknown, data: unknown, callback: unknown): MaybePromise {\n        Validator.assertString(id, 'id');\n        Validator.assertOptionalCallback(callback, 'callback');\n        Validator.assertNumber(ttl, 'ttl');\n        Validator.assertObject(data, 'data');\n\n        return this._setSession({ id, ttl, data, callback });\n    }\n\n    // actual implementation\n    private _setSession(options: InternalSetSessionOptions): MaybePromise {\n        if (!this.#states) {\n            // if states is no longer existing, we do not need to unsubscribe\n            this._logger.info(`${this.namespaceLog} setSession not processed because States database not connected`);\n            return tools.maybeCallbackWithError(options.callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n        this.#states.setSession(options.id, options.ttl, options.data, options.callback);\n    }\n\n    // real types overload\n    destroySession(id: string, callback?: ioBroker.ErrorCallback): MaybePromise;\n    destroySession(id: unknown, callback: unknown): MaybePromise {\n        Validator.assertString(id, 'id');\n        Validator.assertOptionalCallback(callback, 'callback');\n\n        return this._destroySession({ id, callback });\n    }\n\n    private _destroySession(options: InternalDestroySessionOptions): void | Promise<void> {\n        if (!this.#states) {\n            // if states is no longer existing, we do not need to unsubscribe\n            this._logger.info(\n                `${this.namespaceLog} destroySession not processed because States database not connected`,\n            );\n            return tools.maybeCallbackWithError(options.callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        this.#states.destroySession(options.id, options.callback);\n    }\n\n    private async _getObjectsByArray(\n        keys: string[],\n        options?: Record<string, any> | null,\n    ): Promise<(ioBroker.AnyObject | null)[]> {\n        try {\n            const res = await this.#objects!.getObjects(keys, options);\n            return res;\n        } catch (e) {\n            this._logger.error(`Could not get objects by array: ${e.message}`);\n            return [];\n        }\n    }\n\n    // external signature\n    terminate(exitCode?: number): never;\n    terminate(reason?: string, exitCode?: number): never;\n\n    /**\n     * stops the execution of adapter, but not disables it.\n     *\n     * Sometimes, the adapter must be stopped if some libraries are missing.\n     *\n     * @param reason optional termination description\n     * @param exitCode optional exit code\n     */\n    terminate(reason: unknown, exitCode?: unknown): void {\n        // This function must be defined very first, because in the next lines will be yet used.\n        if (this.terminated) {\n            return;\n        }\n        this.terminated = true;\n\n        this.pluginHandler && this.pluginHandler.destroyAll();\n\n        if (this._reportInterval) {\n            clearInterval(this._reportInterval);\n            this._reportInterval = null;\n        }\n        if (this._restartScheduleJob) {\n            this._restartScheduleJob.cancel();\n            this._restartScheduleJob = null;\n        }\n\n        let _reason = 'Without reason';\n        let _exitCode: number;\n\n        if (typeof reason === 'number') {\n            // Only the exit code was passed\n            exitCode = reason;\n            _reason = 'Without reason';\n        } else if (reason && typeof reason === 'string') {\n            _reason = reason;\n        }\n\n        if (typeof exitCode !== 'number') {\n            _exitCode = !this._config.isInstall ? EXIT_CODES.ADAPTER_REQUESTED_TERMINATION : EXIT_CODES.NO_ERROR;\n        } else {\n            _exitCode = exitCode;\n        }\n\n        const isNotCritical =\n            _exitCode === EXIT_CODES.ADAPTER_REQUESTED_TERMINATION ||\n            _exitCode === EXIT_CODES.START_IMMEDIATELY_AFTER_STOP ||\n            _exitCode === EXIT_CODES.NO_ERROR;\n        const text = `${this.namespaceLog} Terminated (${Validator.getErrorText(_exitCode)}): ${_reason}`;\n        if (isNotCritical) {\n            this._logger.info(text);\n        } else {\n            this._logger.warn(text);\n        }\n        setTimeout(async () => {\n            // give last states some time to get handled\n            if (this.#states) {\n                try {\n                    await this.#states.destroy();\n                } catch {\n                    // ignore\n                }\n            }\n            if (this.#objects) {\n                try {\n                    await this.#objects.destroy();\n                } catch {\n                    //ignore\n                }\n            }\n            if (this.startedInCompactMode) {\n                this.emit('exit', _exitCode, reason);\n                this.#states = null;\n                this.#objects = null;\n            } else {\n                process.exit(_exitCode);\n            }\n        }, 500);\n    }\n\n    // external signature\n    getPort(port: number, host?: string, callback?: (port: number) => void): void;\n    getPort(port: number, callback?: (port: number) => void): void;\n\n    /**\n     * Helper function to find next free port\n     *\n     * Looks for first free TCP port starting with given one:\n     * ```js\n     *     adapter.getPort(8081, function (port) {\n     *         adapter.log.debug('Following port is free: ' + port);\n     *     });\n     * ```\n     *\n     * @param port port number to start the search for free port\n     * @param [host] optional hostname for the port search\n     * @param callback return result\n     *        ```js\n     *        function (port) {}\n     *        ```\n     */\n    getPort(port: unknown, host: unknown, callback?: unknown): void {\n        if (!port) {\n            throw new Error('adapterGetPort: no port');\n        }\n\n        if (typeof host === 'function') {\n            callback = host;\n            host = null;\n        }\n\n        if (typeof port === 'string') {\n            port = parseInt(port, 10);\n        }\n\n        let _host: string | undefined;\n        if (!host) {\n            _host = undefined;\n        } else {\n            Validator.assertString(host, 'host');\n            _host = host;\n        }\n\n        Validator.assertNumber(port, 'port');\n        Validator.assertOptionalCallback(callback, 'callback');\n\n        return this._getPort({ port, host: _host, callback });\n    }\n\n    private _getPort(options: InternalGetPortOptions): void {\n        this.getPortRunning = options;\n        const server = net.createServer();\n        try {\n            server.listen({ port: options.port, host: options.host }, () => {\n                server.once('close', () => {\n                    return tools.maybeCallback(options.callback, options.port);\n                });\n                server.close();\n            });\n            server.on('error', () => {\n                setTimeout(() => this.getPort(options.port + 1, options.host, options.callback), 100);\n            });\n        } catch {\n            setImmediate(() => this.getPort(options.port + 1, options.host, options.callback));\n        }\n    }\n\n    supportsFeature(featureName: SupportedFeature): boolean;\n\n    /**\n     * Method to check for available Features for adapter development\n     *\n     * Use it like ...\n     * ```js\n     *     if (adapter.supportsFeature && adapter.supportsFeature('ALIAS')) {\n     *         ...\n     *     }\n     * ```\n\n     * @param featureName the name of the feature to check\n     * @returns true/false if the feature is in the list of supported features\n     */\n    supportsFeature(featureName: unknown): boolean {\n        if (typeof featureName === 'string') {\n            return this.SUPPORTED_FEATURES.includes(featureName as SupportedFeature);\n        }\n        return false;\n    }\n\n    // external signature\n    checkPassword(\n        user: string,\n        pw: string,\n        options: Record<string, any>,\n        callback: CheckPasswordCallback,\n    ): Promise<void>;\n    checkPassword(user: string, pw: string, callback: CheckPasswordCallback): Promise<void>;\n\n    /**\n     * validates user and password\n     *\n     * @param user user name as text\n     * @param pw password as text\n     * @param [options] optional user context\n     * @param callback return result\n     *        ```js\n     *            function (result) {\n     *              if (result) adapter.log.debug('User is valid');\n     *            }\n     *        ```\n     */\n    checkPassword(user: unknown, pw: unknown, options: unknown, callback?: unknown): Promise<void> {\n        if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n\n        if (!callback) {\n            throw new Error('checkPassword: no callback');\n        }\n\n        Validator.assertCallback(callback, 'callback');\n        Validator.assertString(user, 'user');\n        Validator.assertString(pw, 'pw');\n\n        if (options !== undefined && options !== null) {\n            Validator.assertObject(options, 'options');\n        }\n\n        return this._checkPassword({ user, pw, options, callback });\n    }\n\n    private async _checkPassword(options: InternalCheckPasswordOptions): Promise<void> {\n        let { user } = options;\n        const { callback, pw } = options;\n\n        if (user && !user.startsWith('system.user.')) {\n            // it's not yet a `system.user.xy` id, thus we assume it's a username\n            if (!this.usernames[user]) {\n                // we did not find the id of the username in our cache -> update cache\n                try {\n                    await this._updateUsernameCache();\n                } catch (e) {\n                    this._logger.error(`${this.namespaceLog} ${e.message}`);\n                }\n                if (!this.usernames[user]) {\n                    // user still not there, it's no valid user -> fallback to legacy check\n                    user = `system.user.${user\n                        .toString()\n                        .replace(this.FORBIDDEN_CHARS, '_')\n                        .replace(/\\s/g, '_')\n                        .replace(/\\./g, '_')\n                        .toLowerCase()}`;\n                } else {\n                    user = this.usernames[user].id;\n                }\n            } else {\n                user = this.usernames[user].id;\n            }\n        }\n\n        this.getForeignObject(user, options, (err, obj) => {\n            if (err || !obj || !obj.common || (!obj.common.enabled && user !== SYSTEM_ADMIN_USER)) {\n                return tools.maybeCallback(callback, false, user);\n            }\n            password(pw).check(obj.common.password, (err, res) => {\n                return tools.maybeCallback(callback, !!res, user);\n            });\n        });\n    }\n\n    /**\n     * This method update the cached values in `this.usernames`\n     */\n    private async _updateUsernameCache(): Promise<void> {\n        try {\n            // get all users\n            const obj = await this.getObjectListAsync({ startkey: 'system.user.', endkey: 'system.user.\\u9999' });\n            // make sure cache is cleared\n            this.usernames = {};\n            for (const row of obj.rows) {\n                if (row.value.common && typeof row.value.common.name === 'string') {\n                    this.usernames[row.value.common.name] = { id: row.id.replace(FORBIDDEN_CHARS, '_') };\n                } else {\n                    this._logger.warn(`${this.namespaceLog} Invalid username for id \"${row.id}\"`);\n                }\n            }\n        } catch (e) {\n            throw new Error(`Could not update user cache: ${e.message}`);\n        }\n    }\n\n    // external signature\n    getUserID(username: string): Promise<string | undefined>;\n    /**\n     * Return ID of given username\n     *\n     * @param username - name of the user\n     */\n    getUserID(username: unknown): Promise<string | undefined> {\n        Validator.assertString(username, 'username');\n\n        return this._getUserID({ username });\n    }\n\n    private async _getUserID(options: InternalGetUserIDOptions): Promise<string | undefined> {\n        if (!this.usernames[options.username]) {\n            try {\n                // did not find username, we should have a look in the cache\n                await this._updateUsernameCache();\n\n                if (!this.usernames[options.username]) {\n                    return;\n                }\n            } catch (e) {\n                this._logger.error(`${this.namespaceLog} ${e.message}`);\n                return;\n            }\n        }\n\n        return this.usernames[options.username].id;\n    }\n\n    // external signature\n    setPassword(\n        user: string,\n        pw: string,\n        options: Record<string, any>,\n        callback?: ioBroker.ErrorCallback,\n    ): Promise<void>;\n\n    setPassword(user: string, pw: string, callback?: ioBroker.ErrorCallback): Promise<void>;\n\n    /**\n     * sets the user's password\n     *\n     * @param user user name as text\n     * @param pw password as text\n     * @param [options] optional user context\n     * @param [callback] return result\n     *        ```js\n     *            function (err) {\n     *              if (err) adapter.log.error('Cannot set password: ' + err);\n     *            }\n     *        ```\n     */\n    setPassword(user: unknown, pw: unknown, options: unknown, callback?: unknown): Promise<void> {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        Validator.assertString(user, 'user');\n        Validator.assertString(pw, 'pw');\n        Validator.assertOptionalCallback(callback, 'callback');\n        if (options !== undefined && options !== null) {\n            Validator.assertObject(options, 'options');\n        }\n\n        return this._setPassword({ user, pw, options, callback });\n    }\n\n    private async _setPassword(options: InternalSetPasswordOptions): Promise<void> {\n        if (options.user && !options.user.startsWith('system.user.')) {\n            // it's not yet a `system.user.xy` id, thus we assume it's a username\n            if (!this.usernames[options.user]) {\n                // we did not find the id of the username in our cache -> update cache\n                try {\n                    await this._updateUsernameCache();\n                } catch (e) {\n                    this._logger.error(`${this.namespaceLog} ${e}`);\n                }\n                if (!this.usernames[options.user]) {\n                    // user still not there, fallback to legacy check\n                    options.user = `system.user.${options.user\n                        .toString()\n                        .replace(this.FORBIDDEN_CHARS, '_')\n                        .replace(/\\s/g, '_')\n                        .replace(/\\./g, '_')\n                        .toLowerCase()}`;\n                } else {\n                    options.user = this.usernames[options.user].id;\n                }\n            } else {\n                options.user = this.usernames[options.user].id;\n            }\n        }\n\n        this.getForeignObject(options.user, options, (err, obj) => {\n            if (err || !obj) {\n                return tools.maybeCallbackWithError(options.callback, 'User does not exist');\n            }\n\n            // BF: (2020.05.22) are the empty passwords allowed??\n            if (!options.pw) {\n                this.extendForeignObject(\n                    options.user,\n                    {\n                        common: {\n                            password: '',\n                        },\n                    },\n                    options.options || {},\n                    () => {\n                        return tools.maybeCallback(options.callback);\n                    },\n                );\n            } else {\n                password(options.pw).hash(null, null, (err, res) => {\n                    if (err) {\n                        return tools.maybeCallbackWithError(options.callback, err);\n                    }\n                    this.extendForeignObject(\n                        options.user,\n                        {\n                            common: {\n                                password: res,\n                            },\n                        },\n                        options.options || {},\n                        () => {\n                            return tools.maybeCallbackWithError(options.callback, null);\n                        },\n                    );\n                });\n            }\n        });\n    }\n\n    // external signature\n    checkGroup(user: string, group: string, options: Record<string, any>, callback?: CheckGroupCallback): Promise<void>;\n    checkGroup(user: string, group: string, callback?: CheckGroupCallback): Promise<void>;\n\n    /**\n     * returns if user exists and is in the group\n     *\n     * This function used mostly internally and the adapter developer do not require it.\n     *\n     * @param user user name as text\n     * @param group group name\n     * @param [options] optional user context\n     * @param callback return result\n     *        ```js\n     *            function (result) {\n     *              if (result) adapter.log.debug('User exists and in the group');\n     *            }\n     *        ```\n     */\n    checkGroup(user: unknown, group: unknown, options: unknown, callback?: unknown): Promise<void> {\n        user = user || '';\n\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        Validator.assertString(user, 'user');\n        Validator.assertString(group, 'group');\n        if (options !== undefined && options !== null) {\n            Validator.assertObject(options, 'options');\n        }\n        Validator.assertOptionalCallback(callback, 'callback');\n\n        return this._checkGroup({ user, group, options, callback });\n    }\n\n    private async _checkGroup(options: InternalCheckGroupOptions): Promise<void> {\n        if (options.user && !options.user.startsWith('system.user.')) {\n            // it's not yet a `system.user.xy` id, thus we assume it's a username\n            if (!this.usernames[options.user]) {\n                // we did not find the id of the username in our cache -> update cache\n                try {\n                    await this._updateUsernameCache();\n                } catch (e) {\n                    this._logger.error(`${this.namespaceLog} ${e}`);\n                }\n\n                if (!this.usernames[options.user]) {\n                    // user still not there, it's no valid user -> fallback\n                    options.user = `system.user.${options.user\n                        .toString()\n                        .replace(this.FORBIDDEN_CHARS, '_')\n                        .replace(/\\s/g, '_')\n                        .replace(/\\./g, '_')\n                        .toLowerCase()}`;\n                } else {\n                    options.user = this.usernames[options.user].id;\n                }\n            } else {\n                options.user = this.usernames[options.user].id;\n            }\n        }\n\n        if (options.group && !options.group.startsWith('system.group.')) {\n            options.group = `system.group.${options.group}`;\n        }\n        this.getForeignObject(options.user, options, (err, obj) => {\n            if (err || !obj) {\n                return tools.maybeCallback(options.callback, false);\n            }\n            this.getForeignObject(options.group, options, (err, obj) => {\n                if (err || !obj) {\n                    return tools.maybeCallback(options.callback, false);\n                }\n                if (obj.common.members.includes(options.user)) {\n                    return tools.maybeCallback(options.callback, true);\n                }\n                return tools.maybeCallback(options.callback, false);\n            });\n        });\n    }\n\n    // external signature\n    calculatePermissions(\n        user: string,\n        commandsPermissions: CommandsPermissions,\n        options?: Record<string, any>,\n        callback?: CalculatePermissionsCallback,\n    ): Promise<void | ioBroker.PermissionSet>;\n    calculatePermissions(\n        user: string,\n        commandsPermissions: CommandsPermissions,\n        callback?: CalculatePermissionsCallback,\n    ): Promise<void | ioBroker.PermissionSet>;\n\n    /**\n     * get the user permissions\n     *\n     * This function used mostly internally and the adapter developer do not require it.\n     * The function reads permissions of user's groups (it can be more than one) and merge permissions together\n     *\n     * @param  user user name as text\n     * @param  commandsPermissions object that describes the access rights like\n     *     ```js\n     *         // static information\n     *         var commandsPermissions = {\n     *            getObject:          {type: 'object',    operation: 'read'},\n     *            getObjects:         {type: 'object',    operation: 'list'},\n     *            getObjectView:      {type: 'object',    operation: 'list'},\n     *            setObject:          {type: 'object',    operation: 'write'},\n     *            subscribeObjects:   {type: 'object',    operation: 'read'},\n     *            unsubscribeObjects: {type: 'object',    operation: 'read'},\n     *            subscribeFiles:     {type: 'object',    operation: 'read'},\n     *            unsubscribeFiles:   {type: 'object',    operation: 'read'},\n     *\n     *            getStates:          {type: 'state',     operation: 'list'},\n     *            getState:           {type: 'state',     operation: 'read'},\n     *            setState:           {type: 'state',     operation: 'write'},\n     *            getStateHistory:    {type: 'state',     operation: 'read'},\n     *            subscribe:          {type: 'state',     operation: 'read'},\n     *            unsubscribe:        {type: 'state',     operation: 'read'},\n     *            getVersion:         {type: '',          operation: ''},\n     *\n     *            httpGet:            {type: 'other',     operation: 'http'},\n     *            sendTo:             {type: 'other',     operation: 'sendto'},\n     *            sendToHost:         {type: 'other',     operation: 'sendto'},\n     *\n     *            readFile:           {type: 'file',      operation: 'read'},\n     *            readFile64:         {type: 'file',      operation: 'read'},\n     *            writeFile:          {type: 'file',      operation: 'write'},\n     *            writeFile64:        {type: 'file',      operation: 'write'},\n     *            unlink:             {type: 'file',      operation: 'delete'},\n     *            rename:             {type: 'file',      operation: 'write'},\n     *            mkdir:              {type: 'file',      operation: 'write'},\n     *            readDir:            {type: 'file',      operation: 'list'},\n     *            chmodFile:          {type: 'file',      operation: 'write'},\n     *            chownFile:          {type: 'file',      operation: 'write'},\n     *\n     *            authEnabled:        {type: '',          operation: ''},\n     *            disconnect:         {type: '',          operation: ''},\n     *            listPermissions:    {type: '',          operation: ''},\n     *            getUserPermissions: {type: 'object',    operation: 'read'}\n     *         };\n     *        ```\n     * @param [options] optional user context\n     * @param [callback] return result\n     *        ```js\n     *            function (acl) {\n     *              // Access control object for admin looks like:\n     *              // {\n     *              //    file: {\n     *              //         read:       true,\n     *              //         write:      true,\n     *              //         'delete':   true,\n     *              //         create:     true,\n     *              //         list:       true\n     *              //     },\n     *              //     object: {\n     *              //         read:       true,\n     *              //         write:      true,\n     *              //         'delete':   true,\n     *              //         list:       true\n     *              //     },\n     *              //     state: {\n     *              //         read:       true,\n     *              //         write:      true,\n     *              //         'delete':   true,\n     *              //         create:     true,\n     *              //         list:       true\n     *              //     },\n     *              //     user: 'admin',\n     *              //     users:  {\n     *              //         read:       true,\n     *              //         write:      true,\n     *              //         create:     true,\n     *              //         'delete':   true,\n     *              //         list:       true\n     *              //     },\n     *              //     other: {\n     *              //         execute:    true,\n     *              //         http:       true,\n     *              //         sendto:     true\n     *              //     },\n     *              //     groups: ['administrator'] // can be more than one\n     *              // }\n     *            }\n     *        ```\n     */\n    calculatePermissions(\n        user: unknown,\n        commandsPermissions: unknown,\n        options: unknown,\n        callback?: unknown,\n    ): Promise<void | ioBroker.PermissionSet> {\n        user = user || '';\n\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        Validator.assertString(user, 'user');\n        if (!Array.isArray(commandsPermissions)) {\n            Validator.assertObject(commandsPermissions, 'commandsPermissions');\n        }\n        if (options !== undefined && options !== null) {\n            Validator.assertObject(options, 'options');\n        }\n        Validator.assertOptionalCallback(callback, 'callback');\n\n        return this._calculatePermissions({ user, commandsPermissions, options, callback });\n    }\n\n    private async _calculatePermissions(\n        options: InternalCalculatePermissionsOptions,\n    ): Promise<void | ioBroker.PermissionSet> {\n        const { user } = options;\n        let userId: ioBroker.ObjectIDs.User;\n\n        if (user && !user.startsWith('system.user.')) {\n            // it's not yet a `system.user.xy` id, thus we assume it's a username\n            if (!this.usernames[options.user]) {\n                // we did not find the id of the username in our cache -> update cache\n                try {\n                    await this._updateUsernameCache();\n                } catch (e) {\n                    this._logger.error(`${this.namespaceLog} ${e.message}`);\n                }\n                // user still not there, fallback\n                if (!this.usernames[user]) {\n                    userId = `system.user.${user\n                        .toString()\n                        .replace(this.FORBIDDEN_CHARS, '_')\n                        .replace(/\\s/g, '_')\n                        .replace(/\\./g, '_')\n                        .toLowerCase()}`;\n                } else {\n                    userId = this.usernames[user].id as ioBroker.ObjectIDs.User;\n                }\n            } else {\n                userId = this.usernames[user].id as ioBroker.ObjectIDs.User;\n            }\n        } else {\n            userId = user as ioBroker.ObjectIDs.User;\n        }\n\n        // read all groups\n        let acl: Partial<ioBroker.PermissionSet> = { user: userId };\n        if (userId === SYSTEM_ADMIN_USER) {\n            acl.groups = [SYSTEM_ADMIN_GROUP];\n            for (const commandPermission of Object.values(options.commandsPermissions)) {\n                if (!commandPermission.type) {\n                    continue;\n                }\n                // @ts-expect-error we fix this later\n                acl[commandPermission.type] = acl[commandPermission.type] || {};\n                // @ts-expect-error we fix this later\n                acl[commandPermission.type][commandPermission.operation] = true;\n            }\n\n            return tools.maybeCallback(options.callback, acl as ioBroker.PermissionSet);\n        }\n        this.getForeignObjects('*', 'group', null, options, (err, groups) => {\n            acl.groups = [];\n            // aggregate all groups permissions, where this user is\n            if (groups) {\n                for (const g of Object.keys(groups)) {\n                    if (groups[g]?.common?.members && groups[g].common.members.includes(userId)) {\n                        acl.groups.push(groups[g]._id);\n                        if (groups[g]._id === SYSTEM_ADMIN_GROUP) {\n                            acl = {\n                                file: {\n                                    read: true,\n                                    write: true,\n                                    delete: true,\n                                    create: true,\n                                    list: true,\n                                },\n                                // @ts-expect-error create is missing\n                                object: {\n                                    read: true,\n                                    write: true,\n                                    delete: true,\n                                    list: true,\n                                },\n                                state: {\n                                    read: true,\n                                    write: true,\n                                    delete: true,\n                                    create: true,\n                                    list: true,\n                                },\n                                user: userId,\n                                users: {\n                                    read: true,\n                                    write: true,\n                                    create: true,\n                                    delete: true,\n                                    list: true,\n                                },\n                                other: {\n                                    execute: true,\n                                    http: true,\n                                    sendto: true,\n                                },\n                                groups: acl.groups,\n                            };\n                            break;\n                        }\n\n                        const gAcl = groups[g].common.acl;\n                        try {\n                            for (const type of Object.keys(gAcl)) {\n                                // fix bug. Some version have user instead of users.\n                                if (type === 'user') {\n                                    // @ts-expect-error fix it\n                                    acl.users = acl.users || {};\n                                } else {\n                                    // @ts-expect-error fix it\n                                    acl[type] = acl[type] || {};\n                                }\n                                // @ts-expect-error fix it\n                                for (const op of Object.keys(gAcl[type])) {\n                                    // fix error\n                                    if (type === 'user') {\n                                        // @ts-expect-error fix it\n                                        acl.users[op] = acl.users[op] || gAcl.user[op];\n                                    } else {\n                                        // @ts-expect-error fix it\n                                        acl[type][op] = acl[type][op] || gAcl[type][op];\n                                    }\n                                }\n                            }\n                        } catch (e) {\n                            this._logger.error(`${this.namespaceLog} Cannot set acl: ${e.message}`);\n                            this._logger.error(`${this.namespaceLog} Cannot set acl: ${JSON.stringify(gAcl)}`);\n                            this._logger.error(`${this.namespaceLog} Cannot set acl: ${JSON.stringify(acl)}`);\n                        }\n                    }\n                }\n            }\n\n            return tools.maybeCallback(options.callback, acl as ioBroker.PermissionSet);\n        });\n    }\n\n    /**\n     * Stop an instance gracefully\n     *\n     * @param options information about the stoppage\n     */\n    private async _stop(options: InternalStopParameters = {}): Promise<void> {\n        const { isPause, isScheduled, reason } = options;\n        let { exitCode, updateAliveState } = options;\n\n        exitCode = exitCode || (isScheduled ? EXIT_CODES.START_IMMEDIATELY_AFTER_STOP : 0);\n        if (updateAliveState === undefined) {\n            updateAliveState = true;\n        }\n\n        if (!this._stopInProgress || this._config.isInstall) {\n            // when interval is deleted we already had a stop call before\n            this._stopInProgress = true;\n            this._reportInterval && clearInterval(this._reportInterval);\n            this._reportInterval = null;\n            const id = `system.adapter.${this.namespace}`;\n\n            const finishUnload = async (): Promise<void> => {\n                if (this._timers.size) {\n                    this._timers.forEach(timer => clearTimeout(timer));\n                    this._timers.clear();\n                }\n\n                if (this._intervals.size) {\n                    this._intervals.forEach(interval => clearInterval(interval));\n                    this._intervals.clear();\n                }\n\n                if (this._delays.size) {\n                    this._delays.forEach(timer => clearTimeout(timer));\n                    this._delays.clear();\n                }\n\n                if (this.messageCallbacks.size) {\n                    this.messageCallbacks.forEach(callbackObj => clearTimeout(callbackObj.timer));\n                    this.messageCallbacks.clear();\n                }\n\n                if (this.#states && updateAliveState) {\n                    this.outputCount++;\n                    await this.#states.setState(`${id}.alive`, { val: false, ack: true, from: id });\n                    if (!isPause) {\n                        this._logger.info(`${this.namespaceLog} terminating`);\n                    }\n\n                    // To this moment, the class could be destroyed\n                    this.terminate(reason, exitCode);\n                } else {\n                    if (!isPause) {\n                        this._logger.info(`${this.namespaceLog} terminating`);\n                    }\n                    this.terminate(reason, exitCode);\n                }\n            };\n\n            // if we were never ready, we don't trigger the unload procedure\n            if (this.adapterReady) {\n                if (typeof this._options.unload === 'function') {\n                    if (this._options.unload.length >= 1) {\n                        // The method takes (at least) a callback\n                        this._options.unload(finishUnload);\n                    } else {\n                        // The method takes no arguments, so it must return a Promise\n                        // @ts-expect-error already fixed in the latest types\n                        const unloadPromise = this._options.unload();\n                        if (unloadPromise instanceof Promise) {\n                            // Call finishUnload in the case of success and failure\n                            try {\n                                await unloadPromise;\n                            } finally {\n                                finishUnload();\n                            }\n                        } else {\n                            // No callback accepted and no Promise returned - force unload\n                            this._logger.error(\n                                `${this.namespaceLog} Error in ${id}: The unload method must return a Promise if it does not accept a callback!`,\n                            );\n                        }\n                    }\n                } else {\n                    this.emit('unload', finishUnload);\n                }\n            }\n\n            // Even if the developer forgets to call the unload callback, we need to stop the process.\n            // Therefore, wait a short while and then force the unload procedure\n            setTimeout(() => {\n                if (this.#states) {\n                    finishUnload();\n\n                    // Give 1 second to write the value\n                    setTimeout(() => {\n                        if (!isPause) {\n                            this._logger.info(`${this.namespaceLog} terminating with timeout`);\n                        }\n                        this.terminate(exitCode);\n                    }, 1_000);\n                } else {\n                    if (!isPause) {\n                        this._logger.info(`${this.namespaceLog} terminating`);\n                    }\n                    this.terminate(exitCode);\n                }\n            }, this.common?.stopTimeout || 500);\n        }\n    }\n\n    /**\n     * Reads the file certificate from a given path and adds a file watcher to restart adapter on cert changes\n     * if a cert is passed it is returned as it is\n     *\n     * @param cert cert or path to cert\n     */\n    private _readFileCertificate(cert: string): string {\n        if (typeof cert === 'string') {\n            try {\n                // if length < 1024 it's no valid cert, so we assume a path to a valid certificate\n                if (cert.length < 1024 && fs.existsSync(cert)) {\n                    const certFile = cert;\n                    cert = fs.readFileSync(certFile, 'utf8');\n                    // start watcher of this file\n                    fs.watch(certFile, (eventType, filename) => {\n                        this._logger.warn(\n                            `${this.namespaceLog} New certificate \"${filename}\" detected. Restart adapter`,\n                        );\n                        setTimeout(() => this._stop({ isPause: false, isScheduled: true }), 2_000);\n                    });\n                }\n            } catch (e) {\n                this._logger.error(`${this.namespaceLog} Could not read certificate from file ${cert}: ${e.message}`);\n            }\n        }\n        return cert;\n    }\n\n    // public signature\n    getCertificates(\n        publicName?: string,\n        privateName?: string,\n        chainedName?: string,\n        callback?: GetCertificatesCallback,\n    ): void;\n\n    /**\n     * returns SSL certificates by name\n     *\n     * This function returns SSL certificates (private key, public cert and chained certificate).\n     * Names are defined in the system's configuration in admin, e.g. \"defaultPrivate\", \"defaultPublic\".\n     * The result can be directly used for creation of https server.\n     *\n     * @param [publicName] public certificate name\n     * @param [privateName] private certificate name\n     * @param [chainedName] optional chained certificate name\n     * @param callback return result\n     *        ```js\n     *            function (err, certs, letsEncrypt) {\n     *              adapter.log.debug('private key: ' + certs.key);\n     *              adapter.log.debug('public cert: ' + certs.cert);\n     *              adapter.log.debug('chained cert: ' + certs.ca);\n     *            }\n     *        ```\n     */\n    getCertificates(\n        publicName: unknown,\n        privateName: unknown,\n        chainedName: unknown,\n        callback: unknown,\n    ): Promise<GetCertificatesPromiseReturnType | void> {\n        if (typeof publicName === 'function') {\n            callback = publicName;\n            publicName = undefined;\n        }\n        if (typeof privateName === 'function') {\n            callback = privateName;\n            privateName = undefined;\n        }\n        if (typeof chainedName === 'function') {\n            callback = chainedName;\n            chainedName = undefined;\n        }\n\n        const config = this.config as InternalAdapterConfig;\n\n        publicName = publicName || config.certPublic;\n        privateName = privateName || config.certPrivate;\n        chainedName = chainedName || config.certChained;\n\n        if (publicName !== undefined) {\n            Validator.assertString(publicName, 'publicName');\n        }\n\n        if (privateName !== undefined) {\n            Validator.assertString(privateName, 'privateName');\n        }\n\n        if (chainedName !== undefined) {\n            Validator.assertString(chainedName, 'chainedName');\n        }\n\n        Validator.assertOptionalCallback(callback, 'callback');\n\n        return this._getCertificates({ publicName, privateName, chainedName, callback });\n    }\n\n    private async _getCertificates(\n        options: InternalGetCertificatesOptions,\n    ): Promise<[cert: ioBroker.Certificates, useLetsEncryptCert?: boolean] | void> {\n        const { publicName, chainedName, privateName, callback } = options;\n        let obj: ioBroker.OtherObject | undefined | null;\n\n        if (!this.#objects) {\n            this._logger.info(\n                `${this.namespaceLog} getCertificates not processed because Objects database not connected`,\n            );\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        try {\n            // Load certificates\n            obj = await this.#objects.getObject('system.certificates');\n        } catch {\n            // ignore\n        }\n\n        if (\n            !obj ||\n            !obj.native.certificates ||\n            !publicName ||\n            !privateName ||\n            !obj.native.certificates[publicName] ||\n            !obj.native.certificates[privateName] ||\n            (chainedName && !obj.native.certificates[chainedName])\n        ) {\n            this._logger.error(\n                `${this.namespaceLog} Cannot configure secure web server, because no certificates found: ${publicName}, ${privateName}, ${chainedName}`,\n            );\n            if (publicName === 'defaultPublic' || privateName === 'defaultPrivate') {\n                this._logger.info(\n                    `${this.namespaceLog} Default certificates seem to be configured but missing. You can execute \"iobroker cert create\" in your shell to create these.`,\n                );\n            }\n\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_NOT_FOUND);\n        }\n        let ca: string | undefined;\n        if (chainedName) {\n            const chained = this._readFileCertificate(obj.native.certificates[chainedName]).split(\n                '-----END CERTIFICATE-----\\r\\n',\n            );\n            // it is still a file name, and the file maybe does not exist, but we can omit this error\n            if (chained.join('').length >= 512) {\n                const caArr = [];\n                for (const cert of chained) {\n                    if (cert.replace(/(\\r\\n|\\r|\\n)/g, '').trim()) {\n                        caArr.push(`${cert}-----END CERTIFICATE-----\\r\\n`);\n                    }\n                }\n                ca = caArr.join('');\n            }\n        }\n\n        return tools.maybeCallbackWithError(\n            callback,\n            null,\n            {\n                key: this._readFileCertificate(obj.native.certificates[privateName]),\n                cert: this._readFileCertificate(obj.native.certificates[publicName]),\n                ca,\n            },\n            obj.native.letsEncrypt,\n        );\n    }\n\n    /**\n     * Restarts an instance of the adapter.\n     *\n     */\n    restart(): void {\n        if (this.stop) {\n            this._logger.warn(`${this.namespaceLog} Restart initiated`);\n            this.stop();\n        } else {\n            this._logger.warn(`${this.namespaceLog} Cannot initiate restart, because this.stop is not defined`);\n        }\n    }\n\n    updateConfig(newConfig: Record<string, any>): ioBroker.SetObjectPromise;\n    /**\n     * Updates the adapter config with new values. Only a subset of the configuration has to be provided,\n     * since merging with the existing config is done automatically, e.g., like this:\n     *\n     * `adapter.updateConfig({prop1: \"newValue1\"})`\n     *\n     * After updating the configuration, the adapter is automatically restarted.\n     *\n     * @param newConfig The new config values to be stored\n     */\n    updateConfig(newConfig: unknown): ioBroker.SetObjectPromise {\n        Validator.assertObject(newConfig, 'newConfig');\n\n        return this._updateConfig({ newConfig });\n    }\n\n    private async _updateConfig(options: InternalUpdateConfigOptions): ioBroker.SetObjectPromise {\n        const { newConfig } = options;\n\n        // update the adapter config object\n        const configObjId = `system.adapter.${this.namespace}`;\n        let obj;\n        try {\n            obj = await this.getForeignObjectAsync(configObjId);\n        } catch (e) {\n            this._logger.error(`${this.namespaceLog} Updating the adapter config failed: ${e.message}`);\n        }\n\n        if (!obj) {\n            throw new Error(tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        const oldConfig = obj.native;\n        let mergedConfig: Record<string, unknown>;\n\n        // merge the old and new configuration\n        if ('encryptedNative' in obj && Array.isArray(obj.encryptedNative)) {\n            const secret = await this.getSystemSecret();\n            decryptArray({ obj: oldConfig, secret, keys: obj.encryptedNative });\n            mergedConfig = { ...oldConfig, ...newConfig };\n            encryptArray({ obj: mergedConfig, secret, keys: obj.encryptedNative });\n        } else {\n            mergedConfig = { ...oldConfig, ...newConfig };\n        }\n\n        obj.native = mergedConfig;\n\n        return this.setForeignObjectAsync(configObjId, obj);\n    }\n\n    /**\n     * Disables and stops the adapter instance.\n     *\n     */\n    async disable(): ioBroker.SetObjectPromise {\n        // update the adapter config object\n        const configObjId = `system.adapter.${this.namespace}`;\n        let obj;\n        try {\n            obj = await this.getForeignObjectAsync(configObjId);\n        } catch (e) {\n            this._logger.error(`${this.namespaceLog} Disabling the adapter instance failed: ${e.message}`);\n        }\n\n        if (!obj) {\n            throw new Error(tools.ERRORS.ERROR_DB_CLOSED);\n        }\n        obj.common.enabled = false;\n        return this.setForeignObjectAsync(configObjId, obj);\n    }\n\n    async getEncryptedConfig(attribute: string, callback?: GetEncryptedConfigCallback): Promise<string | void>;\n\n    /**\n     * Reads the encrypted parameter from config.\n     *\n     * It returns promise if no callback is provided.\n     *\n     * @param attribute - attribute name in native configuration part\n     * @param [callback] - optional callback\n     */\n    getEncryptedConfig(attribute: unknown, callback: unknown): Promise<string | void> {\n        Validator.assertString(attribute, 'attribute');\n        Validator.assertOptionalCallback(callback, 'callback');\n\n        return this._getEncryptedConfig({ attribute, callback });\n    }\n\n    private async _getEncryptedConfig(options: InternalGetEncryptedConfigOptions): Promise<string | void> {\n        const { attribute, callback } = options;\n\n        const value = (this.config as InternalAdapterConfig)[attribute];\n\n        if (typeof value === 'string') {\n            const secret = await this.getSystemSecret();\n            return tools.maybeCallbackWithError(callback, null, tools.decrypt(secret, value));\n        }\n        return tools.maybeCallbackWithError(callback, `Attribute \"${attribute}\" not found`);\n    }\n\n    /**\n     * Get the system secret, after retrieved once it will be read from the cache\n     */\n    private async getSystemSecret(): Promise<string> {\n        if (this._systemSecret !== undefined) {\n            return this._systemSecret;\n        }\n\n        try {\n            const data = await this.getForeignObjectAsync('system.config');\n            if (data?.native) {\n                this._systemSecret = data.native.secret;\n            }\n        } catch {\n            // do nothing - we initialize default secret below\n        }\n\n        this._systemSecret = this._systemSecret || DEFAULT_SECRET;\n        return this._systemSecret;\n    }\n\n    // external signature\n    setTimeout<TCallback extends TimeoutCallback>(\n        cb: TCallback,\n        timeout: number,\n        ...args: Parameters<TCallback>\n    ): ioBroker.Timeout | undefined;\n    /**\n     * Same as setTimeout,\n     * but it clears the running timers during the unloading process\n     * does not work after unload has been called\n     *\n     * @param cb - timer callback\n     * @param timeout - timeout in milliseconds\n     * @param args - as many arguments as needed, which will be passed to setTimeout\n     * @returns timer id\n     */\n    setTimeout(cb: unknown, timeout: unknown, ...args: unknown[]): ioBroker.Timeout | undefined {\n        if (typeof cb !== 'function') {\n            this._logger.warn(\n                `${this.namespaceLog} setTimeout expected callback to be of type \"function\", but got \"${typeof cb}\"`,\n            );\n            return;\n        }\n\n        if (this._stopInProgress) {\n            this._logger.warn(`${this.namespaceLog} setTimeout called, but adapter is shutting down`);\n            return;\n        }\n\n        Validator.assertNumber(timeout, 'timeout');\n        Validator.assertTimeout(timeout);\n\n        const timer = setTimeout.call(\n            null,\n            () => {\n                this._timers.delete(timer);\n                cb(...args);\n            },\n            timeout,\n        );\n        this._timers.add(timer);\n\n        return timer as unknown as ioBroker.Timeout;\n    }\n\n    clearTimeout(timer: ioBroker.Timeout | undefined): void;\n\n    /**\n     * Same as clearTimeout\n     * but it checks the running timers on unload\n     *\n     * @param timer - the timer object\n     */\n    clearTimeout(timer: unknown): void {\n        if (timer === undefined) {\n            return;\n        }\n\n        // should we further validate this?\n        clearTimeout(timer as NodeJS.Timeout);\n        this._timers.delete(timer as NodeJS.Timeout);\n    }\n\n    // external signature\n    delay(timeout: number): Promise<void>;\n\n    /**\n     * delays the fulfillment of the promise the amount of time.\n     * it will not fulfill during and after adapter shutdown\n     *\n     * @param timeout - timeout in milliseconds\n     * @returns promise when timeout is over\n     */\n    delay(timeout: unknown): Promise<void> {\n        if (this._stopInProgress) {\n            this._logger.warn(`${this.namespaceLog} delay called, but adapter is shutting down`);\n        }\n\n        Validator.assertNumber(timeout, 'timeout');\n\n        return new Promise(resolve => {\n            const timer = setTimeout(() => {\n                this._delays.delete(timer);\n                if (!this._stopInProgress) {\n                    resolve();\n                }\n            }, timeout);\n            this._delays.add(timer);\n        });\n    }\n\n    // external signature\n    setInterval<TCallback extends TimeoutCallback>(\n        cb: TCallback,\n        timeout: number,\n        ...args: Parameters<TCallback>\n    ): ioBroker.Interval | undefined;\n\n    /**\n     * Same as setInterval\n     * but it clears the running intervals during the unload process\n     * does not work after unload has been called\n     *\n     * @param cb - interval callback\n     * @param timeout - interval in milliseconds\n     * @param args - as many arguments as needed, which will be passed to setTimeout\n     * @returns interval interval object\n     */\n    setInterval(cb: unknown, timeout: unknown, ...args: unknown[]): ioBroker.Interval | undefined {\n        if (typeof cb !== 'function') {\n            this._logger.error(\n                `${this.namespaceLog} setInterval expected callback to be of type \"function\", but got \"${typeof cb}\"`,\n            );\n            return;\n        }\n\n        if (this._stopInProgress) {\n            this._logger.warn(`${this.namespaceLog} setInterval called, but adapter is shutting down`);\n            return;\n        }\n\n        Validator.assertNumber(timeout, 'timeout');\n        Validator.assertTimeout(timeout);\n\n        const id = setInterval(() => cb(...args), timeout);\n        this._intervals.add(id);\n\n        return id as unknown as ioBroker.Interval;\n    }\n\n    // external signature\n    clearInterval(interval: ioBroker.Interval | undefined): void;\n\n    /**\n     * Same as clearInterval\n     * but it checks the running intervals on unload\n     *\n     * @param interval - interval object\n     */\n    clearInterval(interval: unknown): void {\n        if (interval === undefined) {\n            return;\n        }\n\n        // should we further validate it is a valid interval?\n        clearInterval(interval as NodeJS.Timeout);\n        this._intervals.delete(interval as NodeJS.Timeout);\n    }\n\n    setObject(id: string, obj: ioBroker.SettableObject, callback?: ioBroker.SetObjectCallback): Promise<void>;\n    setObject(\n        id: string,\n        obj: ioBroker.SettableObject,\n        options: unknown,\n        callback?: ioBroker.SetObjectCallback,\n    ): Promise<void>;\n    setObject(id: string, obj: ioBroker.SettableObject, callback?: ioBroker.SetObjectCallback): Promise<void>;\n    /**\n     * Creates or overwrites an object in objectDB.\n     *\n     * This function can create or overwrite objects in objectDB for this adapter.\n     * Only Ids that belong to this adapter can be modified. So the function automatically adds \"adapter.X.\" to ID.\n     * <b>common</b>, <b>native</b> and <b>type</b> attributes are mandatory, and it will be checked.\n     * Additionally, type \"state\" requires <b>role</b>, <b>type</b> and <b>name</b>, e.g.:\n     * ```js\n     * {\n     *     common: {\n     *          name: 'object name',\n     *          type: 'number', // string, boolean, object, mixed, array\n     *          role: 'value'   // see https://github.com/ioBroker/ioBroker/blob/master/doc/SCHEMA.md#state-commonrole\n     *     },\n     *     native: {},\n     *     type: 'state' // channel, device\n     * }\n     * ```\n     *\n     * @param id object ID, that must be overwritten or created.\n     * @param obj new object\n     * @param [options] optional user context\n     * @param [callback] return result\n     *        ```js\n     *            function (err, obj) {\n     *              // obj is {id: id}\n     *              if (err) adapter.log.error('Cannot write object: ' + err);\n     *            }\n     *        ```\n     */\n    setObject(id: unknown, obj: unknown, options: unknown, callback?: unknown): Promise<void> | void {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        Validator.assertString(id, 'id');\n        Validator.assertObject(obj, 'obj');\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n        Validator.assertOptionalCallback(callback, 'callback');\n\n        return this._setObject({ id, obj: obj as ioBroker.SettableObject, options, callback });\n    }\n\n    private async _setObject(options: InternalSetObjectOptions): Promise<void> {\n        if (!this._defaultObjs) {\n            this._defaultObjs = (await import('./defaultObjs.js')).createDefaults();\n        }\n\n        if (!options.obj) {\n            this._logger.error(`${this.namespaceLog} setObject: try to set null object for ${options.id}`);\n            return tools.maybeCallbackWithError(options.callback, tools.ERRORS.ERROR_EMPTY_OBJECT);\n        }\n\n        // TODO: refactor the following checks in a separate validation method\n        if (!tools.isObject(options.obj)) {\n            this._logger.error(\n                `${\n                    this.namespaceLog\n                } setForeignObject: type of object parameter expected to be an object, but \"${typeof options.obj}\" provided`,\n            );\n            return tools.maybeCallbackWithError(options.callback, tools.ERRORS.ERROR_NO_OBJECT);\n        }\n\n        if (options.obj.type !== 'meta') {\n            try {\n                this._utils.validateId(options.id, false, null);\n            } catch (e) {\n                this._logger.error(tools.appendStackTrace(`${this.namespaceLog} ${e.message}`));\n                return;\n            }\n        }\n\n        if (options.obj.type) {\n            if (!options.obj.native) {\n                this._logger.warn(\n                    `${this.namespaceLog} setObject ${options.id} (type=${options.obj.type}) property native missing!`,\n                );\n                options.obj.native = {};\n            }\n            // Check property 'common'\n            if (!options.obj.common) {\n                this._logger.warn(\n                    `${this.namespaceLog} setObject ${options.id} (type=${options.obj.type}) property common missing!`,\n                );\n                // @ts-expect-error fix later on\n                options.obj.common = {};\n            } else if (options.obj.type === 'state') {\n                // Try to extend the model for type='state'\n                // Check property 'role' by 'state'\n                if (options.obj.common.role && this._defaultObjs[options.obj.common.role]) {\n                    options.obj.common = extend(\n                        true,\n                        {},\n                        this._defaultObjs[options.obj.common.role],\n                        options.obj.common,\n                    );\n                } else if (!options.obj.common.role) {\n                    this._logger.warn(\n                        `${this.namespaceLog} setObject ${options.id} (type=${options.obj.type}) property common.role missing!`,\n                    );\n                }\n                if (!options.obj.common.type) {\n                    this._logger.warn(\n                        `${this.namespaceLog} setObject ${options.id} (type=${options.obj.type}) property common.type missing!`,\n                    );\n                }\n                if (\n                    'custom' in options.obj.common &&\n                    options.obj.common.custom !== null &&\n                    !tools.isObject(options.obj.common.custom)\n                ) {\n                    this._logger.error(\n                        `${this.namespaceLog} setObject ${options.id} (type=${\n                            options.obj.type\n                        }) property common.custom is of type ${typeof options.obj.common.custom}, expected object.`,\n                    );\n                    return tools.maybeCallbackWithError(options.callback, 'common.custom needs to be an object');\n                }\n            } else if (options.obj.common) {\n                if ('custom' in options.obj.common && options.obj.common.custom !== null) {\n                    this._logger.warn(\n                        `${this.namespaceLog} setObject ${options.id} (type=${options.obj.type}) property common.custom must not exist.`,\n                    );\n                    delete options.obj.common.custom;\n                }\n            }\n\n            if (options.obj.common && !Object.prototype.hasOwnProperty.call(options.obj.common, 'name')) {\n                options.obj.common.name = options.id;\n                // it is a more unimportant warning as debug\n                this._logger.debug(\n                    `${this.namespaceLog} setObject ${options.id} (type=${options.obj.type}) property common.name missing, using id as name`,\n                );\n            }\n\n            options.id = this._utils.fixId(options.id, false);\n\n            if ('children' in options.obj || 'parent' in options.obj) {\n                this._logger.warn(`${this.namespaceLog} Do not use parent or children for ${options.id}`);\n            }\n\n            options.obj.from = options.obj.from || `system.adapter.${this.namespace}`;\n            options.obj.user = options.obj.user || (options.options ? options.options.user : '') || SYSTEM_ADMIN_USER;\n            options.obj.ts = options.obj.ts || Date.now();\n\n            this._setObjectWithDefaultValue(options.id, options.obj, options.options, options.callback);\n        } else {\n            this._logger.error(`${this.namespaceLog} setObject ${options.id} mandatory property type missing!`);\n            return tools.maybeCallbackWithError(options.callback, 'mandatory property type missing!');\n        }\n    }\n\n    /**\n     * Helper method for `set[Foreign]Object[NotExists]` that also sets the default value if one is configured\n     *\n     * @param id of the object\n     * @param obj The object to set\n     * @param options optional user context\n     * @param callback optional callback\n     */\n    private async _setObjectWithDefaultValue(\n        id: string,\n        obj: ioBroker.SettableObject,\n        options?: Record<string, any> | null,\n        callback?: ioBroker.SetObjectCallback,\n    ): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.SetObjectCallback> | void> {\n        if (!this.#objects) {\n            this._logger.info(`${this.namespaceLog} setObject not processed because Objects database not connected`);\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        try {\n            tools.validateGeneralObjectProperties(obj, false);\n        } catch (e) {\n            await this.reportDeprecation({\n                deprecationMessage: `Object ${id} is invalid: ${e.message}`,\n                version: '7.0.0',\n            });\n        }\n\n        try {\n            this._utils.validateId(id, true, options);\n        } catch (e) {\n            return tools.maybeCallbackWithError(callback, e);\n        }\n\n        try {\n            const result = await this.#objects.setObjectAsync(id, obj, options);\n            if (obj.type === 'state' && obj.common && obj.common.def !== undefined && obj.common.def !== null) {\n                const state = await this.getForeignStateAsync(id);\n                // only set the def state, if state is non-existent\n                if (!state || state.val === undefined) {\n                    await this.setForeignStateAsync(id, {\n                        val: obj.common.def,\n                        q: this.constants.STATE_QUALITY.SUBSTITUTE_INITIAL_VALUE,\n                        ack: true,\n                    });\n                }\n            }\n            return tools.maybeCallbackWithError(callback, null, result);\n        } catch (e) {\n            return tools.maybeCallbackWithError(callback, e);\n        }\n    }\n\n    // external signature\n    getAdapterObjects(\n        callback: (objects: Record<string, ioBroker.AdapterScopedObject>) => void,\n    ): Promise<Record<string, ioBroker.AdapterScopedObject> | void>;\n\n    /**\n     * Get all states, channels and devices of this adapter.\n     *\n     * @param callback return result\n     *        ```js\n     *            function (objects) {\n     *                for (var id in objects) {\n     *                    adapter.log.debug(id);\n     *                }\n     *            }\n     *        ```\n     */\n    getAdapterObjects(callback: unknown): Promise<Record<string, ioBroker.AdapterScopedObject> | void> {\n        Validator.assertOptionalCallback(callback, 'callback');\n\n        return this._getAdapterObjects({ callback });\n    }\n\n    private async _getAdapterObjects(\n        options: InternalGetAdapterObjectsOptions,\n    ): Promise<Record<string, ioBroker.AdapterScopedObject> | void> {\n        const ret: Record<string, ioBroker.AdapterScopedObject> = {};\n        // Adds result rows to the return object\n        const addRows = (rows: any[] | undefined): void => {\n            if (rows) {\n                for (const { id, value } of rows) {\n                    ret[id] = value;\n                }\n            }\n        };\n\n        if (!this.#objects) {\n            return tools.maybeCallback(options.callback, ret);\n        }\n\n        const params = {\n            startkey: `${this.namespace}.`,\n            endkey: `${this.namespace}.\\u9999`,\n            include_docs: true,\n        };\n\n        try {\n            const folders = await this.#objects.getObjectViewAsync('system', 'folder', params);\n            if (folders) {\n                addRows(folders.rows);\n            }\n        } catch {\n            /* ignore, we'll return what we get till now */\n        }\n        try {\n            const devices = await this.#objects.getObjectViewAsync('system', 'device', params);\n            if (devices) {\n                addRows(devices.rows);\n            }\n        } catch {\n            /* ignore, we'll return what we get till now */\n        }\n        try {\n            const channels = await this.#objects.getObjectViewAsync('system', 'channel', params);\n            if (channels) {\n                addRows(channels.rows);\n            }\n        } catch {\n            /* ignore, we'll return what we get till now */\n        }\n        try {\n            const states = await this.#objects.getObjectViewAsync('system', 'state', params);\n            if (states) {\n                addRows(states.rows);\n            }\n        } catch {\n            /* ignore, we'll return what we get till now */\n        }\n\n        return tools.maybeCallback(options.callback, ret);\n    }\n\n    // public signatures\n    extendObject(id: string, objPart: ioBroker.PartialObject): ioBroker.SetObjectPromise;\n    extendObject(id: string, objPart: ioBroker.PartialObject, callback?: ioBroker.SetObjectCallback): void;\n    extendObject(\n        id: string,\n        objPart: ioBroker.PartialObject,\n        options: ioBroker.ExtendObjectOptions,\n    ): ioBroker.SetObjectPromise;\n    extendObject(\n        id: string,\n        objPart: ioBroker.PartialObject,\n        options: ioBroker.ExtendObjectOptions,\n        callback?: ioBroker.SetObjectCallback,\n    ): void;\n\n    /**\n     * Extend some object and create it if it does not exist\n     *\n     * You can change or extend some object. E.g. existing object is:\n     * ```js\n     * {\n     *   common: {\n     *     name: 'Adapter name',\n     *     desc: 'Description'\n     *   },\n     *   type: 'state',\n     *   native: {\n     *     unused: 'text'\n     *  }\n     * }\n     * ```\n     *\n     * If following object will be passed as argument\n     *\n     * ```js\n     * {\n     *   common: {\n     *     desc: 'New description',\n     *     min: 0,\n     *     max: 100\n     *   },\n     *   native: {\n     *     unused: null\n     *   }\n     * }\n     * ```\n     *\n     * We will get as output:\n     * ```js\n     * {\n     *   common: {\n     *     desc: 'New description',\n     *     min: 0,\n     *     max: 100\n     *   },\n     *   type: 'state',\n     *   native: {}\n     * }\n     * ```\n     *\n     * @param id object ID, that must be extended\n     * @param obj part that must be extended\n     * @param options optional user context\n     * @param callback return result\n     *        ```js\n     *            function (err, obj) {\n     *                if (err) adapter.log.error(err);\n     *                // obj is {\"id\": id}\n     *            }\n     *        ```\n     */\n    extendObject(id: unknown, obj: unknown, options?: unknown, callback?: unknown): Promise<any> | void {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        Validator.assertOptionalCallback(callback, 'callback');\n        Validator.assertString(id, 'id');\n\n        if (!obj) {\n            this._logger.error(`${this.namespaceLog} extendObject: try to extend null object for ${id}`);\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_EMPTY_OBJECT);\n        }\n\n        if (!tools.isObject(obj)) {\n            this._logger.error(\n                `${\n                    this.namespaceLog\n                } extendObject: type of object parameter expected to be an object, but ${typeof obj} provided`,\n            );\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_NO_OBJECT);\n        }\n\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n\n        return this._extendObject({ id, obj: obj as ioBroker.SettableObject, options, callback });\n    }\n\n    // TODO: the public return type needs to be defined correctly, probably needs to be discussed\n    private async _extendObject(options: InternalSetObjectOptions): Promise<any> {\n        if (!this.#objects) {\n            this._logger.info(`${this.namespaceLog} extendObject not processed because Objects database not connected`);\n            return tools.maybeCallbackWithError(options.callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        try {\n            tools.validateGeneralObjectProperties(options.obj, true);\n        } catch (e) {\n            await this.reportDeprecation({\n                deprecationMessage: `Object ${options.id} is invalid: ${e.message}`,\n                version: '7.0.0',\n            });\n        }\n\n        try {\n            this._utils.validateId(options.id, false, null);\n        } catch (e) {\n            return tools.maybeCallbackWithError(options.callback, e);\n        }\n\n        options.id = this._utils.fixId(options.id, false);\n        options.id = this.fixForbiddenCharsInId(options.id);\n\n        if ('children' in options.obj || 'parent' in options.obj) {\n            this._logger.warn(`${this.namespaceLog} Do not use parent or children for ${options.id}`);\n        }\n\n        // Read whole object\n        let oldObj;\n        try {\n            oldObj = await this.#objects.getObjectAsync(options.id, options.options);\n        } catch (e) {\n            return tools.maybeCallbackWithError(options.callback, e);\n        }\n\n        if (!this.#objects) {\n            this._logger.info(`${this.namespaceLog} extendObject not processed because Objects database not connected`);\n            return tools.maybeCallbackWithError(options.callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        // remove the preserve attributes\n        if (oldObj && options.options && tools.isObject(options.options.preserve)) {\n            tools.removePreservedProperties(options.options.preserve, oldObj, options.obj);\n        }\n\n        // delete arrays if they should be changed\n        if (\n            options.obj &&\n            ((options.obj.common && 'members' in options.obj.common) ||\n                (options.obj.native && 'repositories' in options.obj.native) ||\n                (options.obj.native && 'certificates' in options.obj.native) ||\n                (options.obj.native && 'devices' in options.obj.native))\n        ) {\n            if (!oldObj) {\n                this._logger.error(`${this.namespaceLog} Object ${options.id} not exist!`);\n                oldObj = {};\n            }\n            if (\n                options.obj.native &&\n                'repositories' in options.obj.native &&\n                oldObj.native &&\n                oldObj.native.repositories\n            ) {\n                oldObj.native.repositories = [];\n            }\n            if (options.obj.common && 'members' in options.obj.common && oldObj.common && oldObj.common.members) {\n                oldObj.common.members = [];\n            }\n            if (\n                options.obj.native &&\n                'certificates' in options.obj.native &&\n                oldObj.native &&\n                oldObj.native.certificates\n            ) {\n                oldObj.native.certificates = [];\n            }\n            if (options.obj.native && 'devices' in options.obj.native && oldObj.native && oldObj.native.devices) {\n                oldObj.native.devices = [];\n            }\n\n            options.obj.from = options.obj.from || `system.adapter.${this.namespace}`;\n            options.obj.user = options.obj.user || (options.options ? options.options.user : '') || SYSTEM_ADMIN_USER;\n            options.obj.ts = options.obj.ts || Date.now();\n\n            options.obj = extend(true, oldObj, options.obj);\n\n            // @ts-expect-error TODO we are returning type Object for ease of use to devs, but formally these are AnyObjects, e.g. not guaranteed to have common\n            return this.#objects.setObject(options.id, options.obj, options.options, options.callback);\n        }\n        options.obj.from = options.obj.from || `system.adapter.${this.namespace}`;\n        options.obj.user = options.obj.user || (options.options ? options.options.user : '') || SYSTEM_ADMIN_USER;\n        options.obj.ts = options.obj.ts || Date.now();\n\n        if (\n            (options.obj.type && options.obj.type === 'state') ||\n            (!options.obj.type && oldObj && oldObj.type === 'state')\n        ) {\n            if (\n                options.obj.common &&\n                'custom' in options.obj.common &&\n                options.obj.common.custom !== null &&\n                !tools.isObject(options.obj.common.custom)\n            ) {\n                this._logger.error(\n                    `${this.namespaceLog} extendObject ${options.id} (type=${\n                        options.obj.type\n                    }) property common.custom is of type ${typeof options.obj.common.custom}, expected object.`,\n                );\n                return tools.maybeCallbackWithError(options.callback, 'common.custom needs to be an object');\n            }\n        } else {\n            if (options.obj.common && 'custom' in options.obj.common && options.obj.common.custom !== null) {\n                this._logger.warn(\n                    `${this.namespaceLog} setObject ${options.id} (type=${options.obj.type}) property common.custom must not exist.`,\n                );\n                delete options.obj.common.custom;\n            }\n        }\n\n        if (!oldObj) {\n            // if old object is not existing we behave like setObject\n            return this.setForeignObject(options.id, options.obj, options.options, options.callback);\n        }\n\n        try {\n            const cbObj = await this.#objects.extendObjectAsync(options.id, options.obj, options.options || {});\n            let defState;\n            if (options.obj.type === 'state' || oldObj.type === 'state') {\n                if (options.obj.common && 'def' in options.obj.common && options.obj.common.def !== undefined) {\n                    defState = options.obj.common.def;\n                } else if (oldObj.common && oldObj.common.def !== undefined) {\n                    defState = oldObj.common.def;\n                }\n            }\n\n            if (defState !== undefined) {\n                let currentStateObj;\n                try {\n                    currentStateObj = await this.getForeignStateAsync(options.id);\n                } catch {\n                    // do nothing\n                }\n                if (!currentStateObj) {\n                    try {\n                        await this.setForeignStateAsync(options.id, {\n                            val: defState,\n                            q: this.constants.STATE_QUALITY.SUBSTITUTE_INITIAL_VALUE,\n                            ack: true,\n                        });\n                    } catch (e) {\n                        this._logger.info(\n                            `${this.namespaceLog} Default value for state \"${options.id}\" could not be set: ${e.message}`,\n                        );\n                    }\n                }\n            }\n            return tools.maybeCallbackWithError(options.callback, null, cbObj);\n        } catch (e) {\n            return tools.maybeCallbackWithError(options.callback, e);\n        }\n    }\n\n    // external signatures\n    setForeignObject<T extends string>(\n        id: T,\n        obj: ioBroker.SettableObject<ioBroker.ObjectIdToObjectType<T, 'write'>>,\n        callback?: ioBroker.SetObjectCallback,\n    ): void;\n    setForeignObject<T extends string>(\n        id: T,\n        obj: ioBroker.SettableObject<ioBroker.ObjectIdToObjectType<T, 'write'>>,\n        options: unknown,\n        callback?: ioBroker.SetObjectCallback,\n    ): void;\n\n    /**\n     * Same as {@link AdapterClass.setObject}, but for any object.\n     *\n     * ID must be specified as a full name with adapter namespace. E.g \"hm-rpc.0.ABC98989.1.STATE\"\n     *\n     * @param id object ID, that must be overwritten or created.\n     * @param obj new object\n     * @param options optional user context\n     * @param callback return result\n     *        ```js\n     *            function (err, obj) {\n     *              // obj is {id: id}\n     *              if (err) adapter.log.error('Cannot write object: ' + err);\n     *            }\n     *        ```\n     */\n    setForeignObject(id: unknown, obj: unknown, options: unknown, callback?: unknown): MaybePromise {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        Validator.assertOptionalCallback(callback, 'callback');\n        Validator.assertString(id, 'id');\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n\n        if (!obj) {\n            this._logger.error(`${this.namespaceLog} setForeignObject: try to set null object for ${id}`);\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_EMPTY_OBJECT);\n        }\n\n        if (!tools.isObject(obj)) {\n            this._logger.error(\n                `${\n                    this.namespaceLog\n                } setForeignObject: type of object parameter expected to be an object, but ${typeof obj} provided`,\n            );\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_NO_OBJECT);\n        }\n\n        return this._setForeignObject({ id, obj: obj as ioBroker.SettableObject, options, callback });\n    }\n\n    private _setForeignObject(_options: InternalSetObjectOptions): MaybePromise {\n        const { options, callback, obj } = _options;\n        let { id } = _options;\n\n        obj.from = obj.from || `system.adapter.${this.namespace}`;\n        obj.user = obj.user || options?.user || SYSTEM_ADMIN_USER;\n        obj.ts = obj.ts || Date.now();\n\n        id = this.fixForbiddenCharsInId(id);\n\n        // check that alias is valid if given\n        if (obj.common && 'alias' in obj.common && obj.common.alias.id) {\n            // if alias is object validate read and write\n            if (typeof obj.common.alias.id === 'object') {\n                try {\n                    this._utils.validateId(obj.common.alias.id.write, true, null);\n                    this._utils.validateId(obj.common.alias.id.read, true, null);\n                } catch (e) {\n                    return tools.maybeCallbackWithError(callback, `Alias id is invalid: ${e.message}`);\n                }\n\n                if (\n                    obj.common.alias.id.write.startsWith(ALIAS_STARTS_WITH) ||\n                    obj.common.alias.id.read.startsWith(ALIAS_STARTS_WITH)\n                ) {\n                    return tools.maybeCallbackWithError(callback, 'Aliases cannot be used as target for aliases');\n                }\n            } else {\n                try {\n                    this._utils.validateId(obj.common.alias.id, true, null);\n                } catch (e) {\n                    return tools.maybeCallbackWithError(callback, `Alias id is invalid: ${e.message}`);\n                }\n\n                if (obj.common.alias.id.startsWith(ALIAS_STARTS_WITH)) {\n                    return tools.maybeCallbackWithError(callback, 'Aliases cannot be used as target for aliases');\n                }\n            }\n        }\n\n        this._setObjectWithDefaultValue(id, obj, options, callback);\n    }\n\n    // external signatures\n    extendForeignObject<T extends string>(\n        id: T,\n        objPart: ioBroker.PartialObject<ioBroker.ObjectIdToObjectType<T, 'write'>>,\n        callback?: ioBroker.SetObjectCallback,\n    ): void;\n    extendForeignObject<T extends string>(\n        id: T,\n        objPart: ioBroker.PartialObject<ioBroker.ObjectIdToObjectType<T, 'write'>>,\n        options: ioBroker.ExtendObjectOptions,\n        callback?: ioBroker.SetObjectCallback,\n    ): void;\n\n    /**\n     * Same as {@link AdapterClass.extendObject}, but for any object.\n     *\n     * ID must be specified as a full name with adapter namespace. E.g \"hm-rpc.0.ABC98989.1.STATE\"\n     *\n     * @param id object ID, that must be extended\n     * @param obj part that must be extended\n     * @param options optional user context, or use attribute preserve e.g. `{preserve: {common: ['name']}}` to preserve common.name\n     * @param callback return result\n     *        ```js\n     *            function (err, obj) {\n     *                // obj is {\"id\": id}\n     *                if (err) adapter.log.error(err);\n     *            }\n     *        ```\n     */\n    extendForeignObject(\n        id: unknown,\n        obj: unknown,\n        options: unknown,\n        callback?: unknown,\n    ): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.SetObjectCallback> | void> | void {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        Validator.assertOptionalCallback(callback, 'callback');\n\n        try {\n            this._utils.validateId(id, true, null);\n        } catch (e) {\n            return tools.maybeCallbackWithError(callback, e);\n        }\n\n        Validator.assertString(id, 'id');\n\n        if (!obj) {\n            this._logger.error(`${this.namespaceLog} extendForeignObject: try to set null object for ${id}`);\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_EMPTY_OBJECT);\n        }\n\n        Validator.assertObject(obj, 'obj');\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n        Validator.assertOptionalCallback(callback, 'callback');\n\n        return this._extendForeignObjectAsync({\n            id: this.fixForbiddenCharsInId(id),\n            obj: obj as ioBroker.SettableObject,\n            callback,\n            options,\n        });\n    }\n\n    private async _extendForeignObjectAsync(\n        _options: InternalSetObjectOptions,\n    ): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.SetObjectCallback> | void> {\n        const { id, callback, options } = _options;\n        let { obj } = _options;\n\n        if (!this.#objects) {\n            this._logger.info(\n                `${this.namespaceLog} extendForeignObject not processed because Objects database not connected`,\n            );\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        // Read whole object\n        let oldObj;\n        try {\n            oldObj = await this.#objects.getObjectAsync(id, options);\n        } catch (e) {\n            return tools.maybeCallbackWithError(callback, e);\n        }\n\n        // remove the preserve attributes\n        if (oldObj && options && tools.isObject(options.preserve)) {\n            tools.removePreservedProperties(options.preserve, oldObj, obj);\n        }\n\n        // delete arrays if they should be changed\n        if (\n            obj &&\n            ((obj.common && 'members' in obj.common) ||\n                (obj.native && 'repositories' in obj.native) ||\n                (obj.native && 'certificates' in obj.native) ||\n                (obj.native && 'devices' in obj.native))\n        ) {\n            if (!oldObj) {\n                this._logger.error(`${this.namespaceLog} Object ${id} not exist!`);\n                oldObj = {};\n            }\n            if (obj.native && 'repositories' in obj.native && oldObj.native && oldObj.native.repositories) {\n                oldObj.native.repositories = [];\n            }\n            if (obj.common && 'members' in obj.common && oldObj.common && oldObj.common.members) {\n                oldObj.common.members = [];\n            }\n            if (obj.native && 'certificates' in obj.native && oldObj.native && oldObj.native.certificates) {\n                oldObj.native.certificates = [];\n            }\n            if (obj.native && 'devices' in obj.native && oldObj.native && oldObj.native.devices) {\n                oldObj.native.devices = [];\n            }\n\n            obj.from = obj.from || `system.adapter.${this.namespace}`;\n            obj.user = obj.user || options?.user || SYSTEM_ADMIN_USER;\n            obj.ts = obj.ts || Date.now();\n\n            obj = extend(true, oldObj, obj);\n\n            // @ts-expect-error TODO we are returning type Object for ease of use to devs, but formally these are AnyObjects, e.g. not guaranteed to have common\n            return this.#objects.setObject(id, obj, options, callback);\n        }\n        obj.from = obj.from || `system.adapter.${this.namespace}`;\n        obj.user = obj.user || options?.user || SYSTEM_ADMIN_USER;\n        obj.ts = obj.ts || Date.now();\n\n        if ((obj.type && obj.type === 'state') || (!obj.type && oldObj && oldObj.type === 'state')) {\n            if (\n                obj.common &&\n                'custom' in obj.common &&\n                obj.common.custom !== null &&\n                !tools.isObject(obj.common.custom)\n            ) {\n                this._logger.error(\n                    `${this.namespaceLog} extendObject ${id} (type=${\n                        obj.type\n                    }) property common.custom is of type ${typeof obj.common.custom}, expected object.`,\n                );\n                return tools.maybeCallbackWithError(callback, 'common.custom needs to be an object');\n            }\n        } else {\n            if (obj.common && 'custom' in obj.common && obj.common.custom !== null) {\n                this._logger.warn(\n                    `${this.namespaceLog} setObject ${id} (type=${obj.type}) property common.custom must not exist.`,\n                );\n                delete obj.common.custom;\n            }\n        }\n\n        if (!oldObj) {\n            // if old object is not existing we behave like setObject\n            return this.setForeignObject(id, obj, options, callback);\n        }\n\n        try {\n            const cbObj = await this.#objects.extendObjectAsync(id, obj, options || {});\n            if (cbObj?.value.type === 'state') {\n                let defState;\n                if (obj.common && 'def' in obj.common && obj.common.def !== undefined) {\n                    defState = obj.common.def;\n                } else if (oldObj.common && oldObj.common.def !== undefined) {\n                    defState = oldObj.common.def;\n                }\n                if (defState !== undefined) {\n                    let currentStateObj;\n                    try {\n                        currentStateObj = await this.getForeignStateAsync(id);\n                    } catch {\n                        // do nothing\n                    }\n                    if (!currentStateObj) {\n                        try {\n                            await this.setForeignStateAsync(id, {\n                                val: defState,\n                                q: this.constants.STATE_QUALITY.SUBSTITUTE_INITIAL_VALUE,\n                                ack: true,\n                            });\n                        } catch (e) {\n                            this._logger.info(\n                                `${this.namespaceLog} Default value for state \"${id}\" could not be set: ${e.message}`,\n                            );\n                        }\n                    }\n                }\n            }\n\n            return tools.maybeCallbackWithError(callback, null, cbObj);\n        } catch (e) {\n            return tools.maybeCallbackWithError(callback, e);\n        }\n    }\n\n    // external signature\n    objectExists(id: string, options?: Record<string, any> | null): Promise<boolean | void>;\n\n    /**\n     * Checks if an object exists to the given id, id will be fixed first\n     *\n     * @param id id of the object\n     * @param options optional user context\n     */\n    objectExists(id: unknown, options: unknown): Promise<boolean | void> {\n        if (!this.#objects) {\n            this._logger.info(`${this.namespaceLog} objectExists not processed because Objects database not connected`);\n            return Promise.resolve();\n        }\n\n        Validator.assertString(id, 'id');\n        if (options !== undefined && options !== null) {\n            Validator.assertObject(options, 'options');\n        }\n\n        id = this._utils.fixId(id);\n\n        this._utils.validateId(id, false, null);\n\n        return this.#objects.objectExists(id, options);\n    }\n\n    // external signature\n    foreignObjectExists(id: string, options?: Record<string, any> | null): Promise<boolean | void>;\n\n    /**\n     * Checks if an object exists to the given id\n     *\n     * @param id id of the object\n     * @param options optional user context\n     */\n    foreignObjectExists(id: unknown, options: unknown): Promise<boolean | void> {\n        if (!this.#objects) {\n            this._logger.info(\n                `${this.namespaceLog} foreignObjectExists not processed because Objects database not connected`,\n            );\n            return Promise.resolve();\n        }\n\n        Validator.assertString(id, 'id');\n        if (options !== undefined && options !== null) {\n            Validator.assertObject(options, 'options');\n        }\n\n        this._utils.validateId(id, true, null);\n\n        return this.#objects.objectExists(id, options);\n    }\n\n    // external signature\n    getObject(id: string, callback: ioBroker.GetObjectCallback): void;\n    getObject(id: string, options: unknown, callback: ioBroker.GetObjectCallback): void;\n\n    /**\n     * Get object of this instance.\n     *\n     * It is not required, that ID consists namespace. E.g. to get object of \"adapterName.X.myObject\", only \"myObject\" is required as ID.\n     *\n     * @param id exactly object ID (without namespace)\n     * @param options optional user context\n     * @param callback return result\n     *        ```js\n     *            function (err, obj) {\n     *              if (err) adapter.log.error('Cannot get object: ' + err);\n     *            }\n     *        ```\n     */\n    getObject(id: unknown, options: unknown, callback?: unknown): any {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        Validator.assertCallback(callback, 'callback');\n        Validator.assertString(id, 'id');\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n\n        if (!this.#objects) {\n            this._logger.info(`${this.namespaceLog} getObject not processed because Objects database not connected`);\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        try {\n            this._utils.validateId(id, false, null);\n        } catch (e) {\n            return tools.maybeCallbackWithError(callback, e);\n        }\n\n        this.#objects.getObject(this._utils.fixId(id), options, callback);\n    }\n\n    getObjectView<Design extends string = string, Search extends string = string>(\n        design: Design,\n        search: Search,\n        params: ioBroker.GetObjectViewParams | null | undefined,\n        callback: ioBroker.GetObjectViewCallback<ioBroker.InferGetObjectViewItemType<Design, Search>>,\n    ): void;\n    getObjectView<Design extends string = string, Search extends string = string>(\n        design: Design,\n        search: Search,\n        params: ioBroker.GetObjectViewParams | null | undefined,\n        options: unknown,\n        callback: ioBroker.GetObjectViewCallback<ioBroker.InferGetObjectViewItemType<Design, Search>>,\n    ): void;\n\n    /**\n     * Read object view from DB.\n     *\n     * It is required, that ID consists namespace in startkey and endkey. E.g. `{startkey: 'hm-rpc.' + adapter.instance + '.', endkey: 'hm-rpc.' + adapter.instance + '.\\u9999'}`\n     * to get all objects of the instance.\n     *\n     * @param design name of the design\n     * @param search name of the view\n     * @param params object containing startkey: first id to include in result; endkey: last id to include in result\n     * @param options additional objects, e.g. for permissions\n     * @param callback return result\n     *      ```js\n     *          function (err, doc) {\n     *              if (doc && doc.rows) {\n     *                   for (var i = 0; i < doc.rows.length; i++) {\n     *                       var id  = doc.rows[i].id;\n     *                        var obj = doc.rows[i].value;\n     *                        adapter.log.info('Found ' + id + ': ' + JSON.stringify(obj));\n     *                   }\n     *                           if (!doc.rows.length) adapter.log.info('No objects found.');\n     *               } else {\n     *                   adapter.log.info('No objects found: ' + err);\n     *               }\n     *           }\n     *           ```\n     */\n    getObjectView(\n        design: unknown,\n        search: unknown,\n        params: unknown,\n        options: unknown,\n        callback?: unknown,\n    ): void | ioBroker.GetObjectViewPromise<any> {\n        if (typeof options === 'function') {\n            callback = options;\n            options = undefined;\n        }\n\n        Validator.assertString(design, 'design');\n        Validator.assertString(search, 'search');\n        Validator.assertOptionalCallback(callback, 'callback');\n        params = params || {};\n        Validator.assertObject(params, 'params');\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n\n        return this._getObjectView({ design, search, params, options, callback });\n    }\n\n    private _getObjectView(_options: InternalGetObjectViewOptions): void | ioBroker.GetObjectViewPromise<any> {\n        const { design, search, params, options, callback } = _options;\n\n        if (!this.#objects) {\n            this._logger.info(\n                `${this.namespaceLog} getObjectView not processed because Objects database not connected`,\n            );\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        // Limit search ranges for system views to the relevant namespaces\n        // to prevent too wide searches where the objects never will be\n        if (design === 'system' && !params.startkey && (!params.endkey || params.endkey === '\\u9999')) {\n            switch (search) {\n                case 'host':\n                    params.startkey = 'system.host.';\n                    params.endkey = 'system.host.\\u9999';\n                    break;\n                case 'adapter':\n                case 'instance':\n                case 'instanceStats':\n                    params.startkey = 'system.adapter.';\n                    params.endkey = 'system.adapter.\\u9999';\n                    break;\n                case 'enum':\n                    params.startkey = 'enum.';\n                    params.endkey = 'enum.\\u9999';\n                    break;\n                case 'script':\n                    params.startkey = 'script.';\n                    params.endkey = 'script.\\u9999';\n                    break;\n                case 'group':\n                    params.startkey = 'system.group.';\n                    params.endkey = 'system.group.\\u9999';\n                    break;\n                case 'user':\n                    params.startkey = 'system.user.';\n                    params.endkey = 'system.user.\\u9999';\n                    break;\n                case 'config':\n                    params.startkey = 'system.';\n                    params.endkey = 'system.\\u9999';\n                    break;\n            }\n        }\n\n        // @ts-expect-error fix it\n        return this.#objects.getObjectView(design, search, params, options, callback);\n    }\n\n    // external signatures\n    getObjectList(\n        params: ioBroker.GetObjectListParams | null,\n        callback: ioBroker.GetObjectListCallback<ioBroker.Object>,\n    ): void;\n    getObjectList(\n        params: ioBroker.GetObjectListParams | null,\n        options: { sorted?: boolean } | Record<string, any>,\n        callback: ioBroker.GetObjectListCallback<ioBroker.Object>,\n    ): void;\n\n    /**\n     * Read object list from DB.\n     *\n     * It is required, that ID consists namespace in startkey and endkey. E.g. `{startkey: 'hm-rpc.' + adapter.instance + '.', endkey: 'hm-rpc.' + adapter.instance + '.\\u9999'}`\n     * to get all objects of the instance.\n     *\n     * @param params startkey and endkey information\n     * @param options additional options, e.g. for permissions\n     * @param callback optional callback\n     *      ```js\n     *          function (err, res) {\n     *              if (res && res.rows) {\n     *                   for (var i = 0; i < res.rows.length; i++) {\n     *                       var id  = res.rows[i].id;\n     *                       var obj = res.rows[i].value;\n     *                       adapter.log.info('Found ' + id + ': ' + JSON.stringify(obj));\n     *                   }\n     *                   if (!res.rows.length) adapter.log.info('No objects found.');\n     *              } else {\n     *                  adapter.log.info('No objects found: ' + err);\n     *              }\n     *          }\n     *       ```\n     */\n    getObjectList(params: unknown, options: unknown, callback?: unknown): any {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n\n        Validator.assertObject(params, 'params');\n        Validator.assertOptionalCallback(callback, 'callback');\n\n        if (!this.#objects) {\n            this._logger.info(\n                `${this.namespaceLog} getObjectList not processed because Objects database not connected`,\n            );\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        this.#objects.getObjectList(params, options, callback);\n    }\n\n    // external signatures\n    getEnum(callback: ioBroker.GetEnumCallback): void;\n    getEnum(name: string, callback: ioBroker.GetEnumCallback): void;\n    getEnum(name: string, options: unknown, callback: ioBroker.GetEnumCallback): void;\n\n    /**\n     * Get the enum tree.\n     *\n     * Get enums of specified tree or all enums if nothing specified as object with values.\n     * If getEnum called with no enum specified, all enums will be returned:\n     * ```js\n     *      adapter.getEnums(function (err, enums, requestEnum) {\n     *        // All enums\n     *        if (err) adapter.log.error('Cannot get object: ' + err);\n     *        for (var e in enums) {\n     *           adapter.log.debug('Enum \"' + e + '\" has following members: ' + enums[e].common.members.join(', '));\n     *        }\n     *      });\n     * ```\n     *\n     * @param _enum enum name, e.g. 'rooms', 'function' or '' (all enums)\n     * @param options optional user context\n     * @param callback return result\n     *        ```js\n     *            function (err, enums, requestEnum) {\n     *              // requestEnum is _enum\n     *              if (err) adapter.log.error('Cannot get object: ' + err);\n     *              for (var e in enums) {\n     *                 adapter.log.debug('Enum \"' + e + '\" has following members: ' + enums[e].common.members.join(', '));\n     *              }\n     *            }\n     *        ```\n     */\n    getEnum(_enum: unknown, options?: unknown, callback?: unknown): any {\n        if (typeof _enum === 'function') {\n            callback = _enum;\n            options = null;\n            _enum = '';\n        }\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        Validator.assertString(_enum, '_enum');\n        Validator.assertOptionalCallback(callback, 'callback');\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n\n        return this._getEnum({ _enum, options, callback });\n    }\n\n    private _getEnum(_options: InternalGetEnumOptions): Promise<void> | void {\n        const { options, callback } = _options;\n        let { _enum } = _options;\n\n        if (!this.#objects) {\n            this._logger.info(`${this.namespaceLog} getEnum not processed because Objects database not connected`);\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        if (!_enum.startsWith('enum.')) {\n            _enum = `enum.${_enum}`;\n        }\n        const result: Record<string, ioBroker.EnumObject> = {};\n\n        this.#objects.getObjectView(\n            'system',\n            'enum',\n            {\n                startkey: `${_enum}.`,\n                endkey: `${_enum}.\\u9999`,\n            },\n            options,\n            (err, res) => {\n                if (err) {\n                    return tools.maybeCallbackWithError(callback, err);\n                }\n                if (res?.rows) {\n                    for (const row of res.rows) {\n                        result[row.id] = row.value;\n                    }\n                }\n                return tools.maybeCallbackWithError(callback, err, result, _enum);\n            },\n        );\n    }\n\n    // public signatures\n    getEnums(callback: ioBroker.GetEnumsCallback): void;\n    getEnums(enumList: ioBroker.EnumList, callback: ioBroker.GetEnumsCallback): void;\n    getEnums(enumList: ioBroker.EnumList, options: unknown, callback: ioBroker.GetEnumsCallback): void;\n\n    /**\n     * Read the members of given enums.\n     *\n     * Get enums of specified tree or all enums if nothing specified as object with values.\n     *\n     * @param _enumList enum name or names, e.g. ['rooms', 'function']\n     * @param options optional user context\n     * @param callback return result\n     *        ```js\n     *            function (err, enums) {\n     *              // requestEnum is _enum\n     *              if (err) adapter.log.error('Cannot get object: ' + err);\n     *              // Result is like\n     *              // {\n     *              //    \"enum.rooms\": {\n     *              //       \"enum.rooms.livingroom\": {\n     *              //           common: {\n     *              //              members: ['ID1', 'ID2']\n     *              //           }\n     *              //       },\n     *              //       \"enum.rooms.sleepingroom\": {\n     *              //           common: {\n     *              //              members: ['ID3', 'ID4']\n     *              //           }\n     *              //       }\n     *              //    },\n     *              //    \"enum.functions\": {\n     *              //       \"enum.rooms.light\": {\n     *              //           common: {\n     *              //              members: ['ID1', 'ID6']\n     *              //           }\n     *              //       },\n     *              //       \"enum.rooms.weather\": {\n     *              //           common: {\n     *              //              members: ['ID4', 'ID7']\n     *              //           }\n     *              //       }\n     *              //    }\n     *              // }\n     *            }\n     *        ```\n     */\n    getEnums(\n        _enumList: unknown,\n        options?: unknown,\n        callback?: unknown,\n    ): Promise<{ [groupName: string]: Record<string, ioBroker.EnumObject> } | void> {\n        if (typeof _enumList === 'function') {\n            callback = _enumList;\n            _enumList = undefined;\n        }\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        Validator.assertOptionalCallback(callback, 'callback');\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n\n        return this._getEnums({ _enumList: _enumList as ioBroker.EnumList | undefined, options, callback });\n    }\n\n    private async _getEnums(\n        _options: InternalGetEnumsOptions,\n    ): Promise<{ [groupName: string]: Record<string, ioBroker.EnumObject> } | void> {\n        const { options, callback } = _options;\n        let { _enumList } = _options;\n\n        if (!this.#objects) {\n            this._logger.info(`${this.namespaceLog} getEnums not processed because Objects database not connected`);\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        const _enums: {\n            [groupName: string]: Record<string, ioBroker.EnumObject>;\n        } = {};\n        if (_enumList) {\n            if (typeof _enumList === 'string') {\n                _enumList = [_enumList];\n            }\n            const promises = [];\n\n            for (const currEnum of _enumList) {\n                promises.push(\n                    new Promise<void>((resolve, reject) =>\n                        this.getEnum(currEnum, options, (err, list, _enum) => {\n                            if (err) {\n                                return reject(err);\n                            } else if (list && _enum) {\n                                _enums[_enum] = list;\n                            }\n                            resolve();\n                        }),\n                    ),\n                );\n            }\n\n            try {\n                await Promise.all(promises);\n                return tools.maybeCallbackWithError(callback, null, _enums);\n            } catch (e) {\n                return tools.maybeCallbackWithError(callback, e);\n            }\n        } else {\n            // Read all enums\n            this.#objects.getObjectView(\n                'system',\n                'enum',\n                {\n                    startkey: 'enum.',\n                    endkey: 'enum.\\u9999',\n                },\n                options,\n                (err, res) => {\n                    // be aware, that res.rows[x].id is the name of enum!\n                    if (err) {\n                        return tools.maybeCallbackWithError(callback, err);\n                    }\n                    const result: {\n                        [groupName: string]: Record<string, ioBroker.EnumObject>;\n                    } = {};\n                    if (res?.rows) {\n                        for (const row of res.rows) {\n                            const parts: string[] = row.id.split('.', 3);\n                            if (!parts[2]) {\n                                continue;\n                            }\n                            if (!result[`${parts[0]}.${parts[1]}`]) {\n                                result[`${parts[0]}.${parts[1]}`] = {};\n                            }\n                            result[`${parts[0]}.${parts[1]}`][row.id] = row.value;\n                        }\n                    }\n\n                    return tools.maybeCallbackWithError(callback, err, result);\n                },\n            );\n        }\n    }\n\n    // external signatures\n    getForeignObjects(patter: Pattern): Promise<ioBroker.NonNullCallbackReturnTypeOf<ioBroker.GetObjectsCallback>>;\n    getForeignObjects(pattern: Pattern, callback: ioBroker.GetObjectsCallback): void;\n    getForeignObjects(pattern: Pattern, options: unknown, callback: ioBroker.GetObjectsCallback): void;\n    getForeignObjects<T extends ioBroker.ObjectType>(\n        pattern: Pattern,\n        type: T,\n        callback: ioBroker.GetObjectsCallbackTyped<T>,\n    ): void;\n    getForeignObjects<T extends ioBroker.ObjectType>(\n        pattern: Pattern,\n        type: T,\n        enums: ioBroker.EnumList,\n        callback: ioBroker.GetObjectsCallbackTyped<T>,\n    ): void;\n    getForeignObjects<T extends ioBroker.ObjectType>(\n        pattern: Pattern,\n        type: T,\n        options: unknown,\n        callback: ioBroker.GetObjectsCallbackTyped<T>,\n    ): void;\n    getForeignObjects<T extends ioBroker.ObjectType>(\n        pattern: Pattern,\n        type: T,\n        enums: ioBroker.EnumList | null,\n        options: unknown,\n        callback: ioBroker.GetObjectsCallbackTyped<T>,\n    ): void;\n    /**\n     * Get objects by pattern, by specific type and resolve their enums.\n     *\n     * Get all objects in the system of specified type. E.g.:\n     *\n     * ```js\n     * adapter.getForeignObjects('hm-rega.0.*', 'state', ['rooms', 'functions'], function (err, objs) {\n     *   if (err) adapter.log.error('Cannot get object: ' + err);\n     *   // objs look like:\n     *   // {\n     *   //    \"hm-rega.0.ABC0000.1.STATE\": {\n     *   //        common: {...},\n     *   //        native: {},\n     *   //        type: 'state',\n     *   //        enums: {\n     *   //           'enums.rooms.livingroom': 'Living room',\n     *   //           'enums.functions.light': 'Light'\n     *   //       }\n     *   //    },\n     *   //    \"hm-rega.0.ABC0000.2.STATE\": {\n     *   //        common: {...},\n     *   //        native: {},\n     *   //        type: 'state',\n     *   //        enums: {\n     *   //           'enums.rooms.sleepingroom': 'Sleeping room',\n     *   //           'enums.functions.window': 'Windows'\n     *   //       }\n     *   //    }\n     * }\n     * ```\n     *\n     * @param pattern object ID/wildcards\n     * @param type type of object: 'state', 'channel' or 'device'. Default - 'state'\n     * @param enums object ID, that must be overwritten or created.\n     * @param options optional user context\n     * @param callback return result\n     *        ```js\n     *            function (err, obj) {\n     *              if (err) adapter.log.error('Cannot get object: ' + err);\n     *            }\n     *        ```\n     */\n    getForeignObjects(\n        pattern: unknown,\n        type?: unknown,\n        enums?: unknown,\n        options?: unknown,\n        callback?: unknown,\n    ): Promise<ioBroker.NonNullCallbackReturnTypeOf<ioBroker.GetObjectsCallback> | void> {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        if (typeof enums === 'function') {\n            callback = enums;\n            enums = undefined;\n        }\n        if (typeof type === 'function') {\n            callback = type;\n            type = undefined;\n        }\n        if (typeof type === 'object') {\n            options = type;\n            type = undefined;\n        }\n        if (typeof enums === 'object' && !Array.isArray(enums)) {\n            options = enums;\n            enums = undefined;\n        }\n\n        Validator.assertOptionalCallback(callback, 'callback');\n\n        Validator.assertPattern(pattern, 'pattern');\n\n        if (type !== undefined) {\n            Validator.assertString(type, 'type');\n        }\n\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n\n        return this._getForeignObjects({\n            pattern,\n            type,\n            enums: enums as ioBroker.EnumList | undefined,\n            options,\n            callback,\n        });\n    }\n\n    private async _getForeignObjects(\n        _options: InternalGetObjectsOptions,\n    ): Promise<ioBroker.NonNullCallbackReturnTypeOf<ioBroker.GetObjectsCallback> | void> {\n        const { options, callback, type, pattern, enums } = _options;\n\n        if (!this.#objects) {\n            this._logger.info(\n                `${this.namespaceLog} getForeignObjects not processed because Objects database not connected`,\n            );\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        let objs: (ioBroker.AnyObject | null)[];\n\n        if (Array.isArray(pattern)) {\n            try {\n                objs = await this.#objects.getObjects(pattern, options);\n            } catch (e) {\n                return tools.maybeCallbackWithError(callback, e);\n            }\n        } else {\n            let params: ioBroker.GetObjectViewParams = {};\n\n            if (pattern && pattern !== '*') {\n                params = {\n                    startkey: pattern.replace(/\\*/g, ''),\n                    endkey: pattern.replace(/\\*/g, '\\u9999'),\n                };\n            }\n\n            try {\n                const res = await this.#objects.getObjectView('system', type || 'state', params, options);\n                objs = res.rows.map(row => row.value);\n            } catch (e) {\n                return tools.maybeCallbackWithError(callback, e);\n            }\n        }\n\n        // don't forget, that enums returns names in row[x].id and not IDs, you can find id in rows[x].value._id\n        let _enums;\n        try {\n            _enums = await this.getEnumsAsync(enums);\n        } catch (e) {\n            this._logger.warn(`Cannot get enums on getForeignObjects: ${e.message}`);\n        }\n\n        const list: Record<string, any> = {};\n\n        for (let i = 0; i < objs.length; i++) {\n            const obj = objs[i];\n            if (!obj) {\n                // It is not so important warning, so print it as debug\n                this._logger.debug(\n                    `${this.namespaceLog} getEnums(${JSON.stringify(\n                        enums,\n                    )}) returned an enum without a value at index ${i}, obj - ${JSON.stringify(obj)}`,\n                );\n                continue;\n            }\n\n            const id: string = obj._id;\n            list[id] = obj;\n            if (_enums && id) {\n                // get device or channel of this state and check it too\n                const parts = id.split('.');\n                parts.splice(parts.length - 1, 1);\n                const channel = parts.join('.');\n                parts.splice(parts.length - 1, 1);\n                const device = parts.join('.');\n\n                list[id].enums = {};\n                for (const _enum of Object.values(_enums)) {\n                    for (const [enumID, enumObj] of Object.entries(_enum)) {\n                        if (!enumObj?.common?.members) {\n                            continue;\n                        }\n\n                        if (\n                            enumObj.common.members.includes(id) ||\n                            enumObj.common.members.includes(channel) ||\n                            enumObj.common.members.includes(device)\n                        ) {\n                            list[id].enums[enumID] = enumObj.common.name;\n                        }\n                    }\n                }\n            }\n            // remove protectedNative if not admin, not cloud or not own adapter\n            if (\n                obj &&\n                'protectedNative' in obj &&\n                Array.isArray(obj.protectedNative) &&\n                obj.native &&\n                id &&\n                id.startsWith('system.adapter.') &&\n                !NO_PROTECT_ADAPTERS.includes(this.name) &&\n                this.name !== id.split('.')[2]\n            ) {\n                for (const attr of obj.protectedNative) {\n                    delete obj.native[attr];\n                }\n            }\n        }\n        return tools.maybeCallbackWithError(callback, null, list);\n    }\n\n    // external signature\n    findForeignObject(idOrName: string, type: string | null, callback: ioBroker.FindObjectCallback): void;\n    findForeignObject(\n        idOrName: string,\n        type: string | null,\n        options: unknown,\n        callback: ioBroker.FindObjectCallback,\n    ): void;\n\n    /**\n     * Find any object by name or ID.\n     *\n     * Find object by the exact name or ID.\n     *\n     * @param id exactly object ID (without namespace)\n     * @param type optional common.type of state: 'number', 'string', 'boolean', 'file', ...\n     * @param options optional user context\n     * @param callback return result\n     *        ```js\n     *            adapter.findForeignObject('Some name', function (err, id, name) {\n     *              if (err) adapter.log.error('Cannot get object: ' + err);\n     *              adapter.log.debug('ID of object with name \"' + name + '\" is \"' + id + '\"');\n     *            }\n     *        ```\n     */\n    findForeignObject(id: unknown, type: unknown, options: unknown, callback?: unknown): any {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n        if (typeof type === 'function') {\n            callback = type;\n            type = null;\n        }\n\n        Validator.assertCallback(callback, 'callback');\n        if (type !== null) {\n            Validator.assertString(type, 'type');\n        }\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n\n        if (!this.#objects) {\n            this._logger.info(\n                `${this.namespaceLog} findForeignObject not processed because Objects database not connected`,\n            );\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        try {\n            this._utils.validateId(id, true, null);\n        } catch (e) {\n            return tools.maybeCallbackWithError(callback, e);\n        }\n\n        this.#objects.findObject(id, type, options || {}, callback);\n    }\n\n    // external signatures\n    getForeignObject<T extends string>(\n        id: T,\n        callback: ioBroker.GetObjectCallback<T>,\n    ): void | Promise<void | ioBroker.ObjectIdToObjectType<T> | null>;\n    getForeignObject<T extends string>(\n        id: T,\n        options: unknown,\n        callback: ioBroker.GetObjectCallback<T>,\n    ): void | Promise<void | ioBroker.ObjectIdToObjectType<T> | null>;\n\n    /**\n     * Get any object.\n     *\n     * ID must be specified with namespace.\n     *\n     * @param id exactly object ID (with namespace)\n     * @param options optional user context\n     * @param callback return result\n     *        ```js\n     *            function (err, obj) {\n     *              if (err) adapter.log.error('Cannot get object: ' + err);\n     *            }\n     *        ```\n     */\n    getForeignObject(\n        id: unknown,\n        options: unknown,\n        callback?: unknown,\n    ): void | Promise<void | ioBroker.AnyObject | null> {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        Validator.assertOptionalCallback(callback, 'callback');\n        if (options !== undefined && options !== null) {\n            Validator.assertObject(options, 'options');\n        }\n\n        try {\n            this._utils.validateId(id, true, options);\n        } catch (e) {\n            return tools.maybeCallbackWithError(callback, e);\n        }\n\n        return this._getForeignObject({ id, options, callback });\n    }\n\n    private async _getForeignObject(options: InternalGetObjectOptions): Promise<void | ioBroker.AnyObject | null> {\n        if (!this.#objects) {\n            this._logger.info(\n                `${this.namespaceLog} getForeignObject not processed because Objects database not connected`,\n            );\n            return tools.maybeCallbackWithError(options.callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        try {\n            const obj = await this.#objects.getObjectAsync(options.id, options);\n            // remove protectedNative if not admin, not cloud or not own adapter\n            if (\n                obj &&\n                'protectedNative' in obj &&\n                Array.isArray(obj.protectedNative) &&\n                obj._id &&\n                obj._id.startsWith('system.adapter.') &&\n                obj.native &&\n                !NO_PROTECT_ADAPTERS.includes(this.name) &&\n                this.name !== obj._id.split('.')[2]\n            ) {\n                for (const attr of obj.protectedNative) {\n                    delete obj.native[attr];\n                }\n            }\n\n            return tools.maybeCallbackWithError(options.callback, null, obj);\n        } catch (e) {\n            return tools.maybeCallbackWithError(options.callback, e);\n        }\n    }\n\n    delObject(id: string, callback?: ioBroker.ErrorCallback): void;\n    delObject(id: string, options?: ioBroker.DelObjectOptions | null, callback?: ioBroker.ErrorCallback): void;\n\n    /**\n     * Delete an object of this instance.\n     *\n     * It is not required to provide the adapter namespace, because it will automatically be added.\n     * E.g. to delete \"adapterName.X.myObject\", only \"myObject\" is required as ID.\n     *\n     * The corresponding state will be deleted too if the object has type \"state\".\n     *\n     * @param id exactly object ID (without namespace)\n     * @param options optional user context. E.g. recursive option could be true\n     * @param callback return result\n     *        ```js\n     *            function (err) {\n     *              if (err) adapter.log.error('Cannot delete object: ' + err);\n     *            }\n     *        ```\n     */\n    delObject(id: unknown, options: unknown, callback?: unknown): any {\n        Validator.assertString(id, 'id');\n\n        // delObject does the same as delForeignObject, but fixes the ID first\n        id = this._utils.fixId(id);\n\n        // @ts-expect-error we have ensured that it is string for the rest the method will validate again\n        this.delForeignObject(id, options, callback);\n    }\n\n    private _deleteObjects(\n        tasks: { id: string; [other: string]: any }[],\n        options: Record<string, any>,\n        cb?: () => void,\n    ): void | Promise<void> {\n        if (!tasks || !tasks.length) {\n            return tools.maybeCallback(cb);\n        }\n        const task = tasks.shift();\n        this.#objects!.delObject(task!.id, options, async err => {\n            if (err) {\n                return tools.maybeCallbackWithError(cb, err);\n            }\n            if (task!.state) {\n                try {\n                    await this.delForeignStateAsync(task!.id, options);\n                } catch (e) {\n                    this._logger.warn(`${this.namespaceLog} Could not remove state of ${task!.id}: ${e.message}`);\n                }\n            }\n            try {\n                await tools.removeIdFromAllEnums(this.#objects, task!.id, this.enums);\n            } catch (e) {\n                this._logger.warn(`${this.namespaceLog} Could not remove ${task!.id} from enums: ${e.message}`);\n            }\n            setImmediate(() => this._deleteObjects(tasks, options, cb));\n        });\n    }\n\n    delForeignObject(id: string, callback?: ioBroker.ErrorCallback): void;\n    delForeignObject(id: string, options: ioBroker.DelObjectOptions, callback?: ioBroker.ErrorCallback): void;\n\n    /**\n     * Delete any object.\n     *\n     * The full ID with namespace must be specified. The corresponding state will be deleted too if the object has type \"state\".\n     *\n     * @param id exactly object ID (with namespace)\n     * @param options optional user context or `{ recursive: true }` to delete all underlying objects\n     * @param callback return result\n     *        ```js\n     *            function (err) {\n     *              if (err) adapter.log.error('Cannot delete object: ' + err);\n     *            }\n     *        ```\n     */\n    delForeignObject(id: unknown, options: unknown, callback?: unknown): any {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        Validator.assertString(id, 'id');\n        Validator.assertOptionalCallback(callback, 'callback');\n        if (options !== undefined && options !== null) {\n            Validator.assertObject(options, 'options');\n        }\n\n        if (!this.#objects) {\n            this._logger.info(\n                `${this.namespaceLog} delForeignObject not processed because Objects database not connected`,\n            );\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        try {\n            this._utils.validateId(id, true, options);\n        } catch (e) {\n            return tools.maybeCallbackWithError(callback, e);\n        }\n\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n\n        Validator.assertOptionalCallback(callback, 'callback');\n\n        return this._delForeignObject({ id, options, callback });\n    }\n\n    private _delForeignObject(_options: InternalDelObjectOptions): void {\n        const { id, options, callback } = _options;\n\n        // If recursive deletion of all underlying objects, including id\n        if (options?.recursive) {\n            // read object itself\n            this.#objects!.getObject(id, options, (err, obj) => {\n                const tasks =\n                    obj && (!obj.common || !obj.common.dontDelete) ? [{ id, state: obj.type === 'state' }] : [];\n\n                const selector = { startkey: `${id}.`, endkey: `${id}.\\u9999` };\n                // read all underlying states\n                this.#objects!.getObjectList(selector, options, (err, res) => {\n                    res &&\n                        res.rows.forEach(\n                            (item: ioBroker.GetObjectListItem<ioBroker.Object>) =>\n                                !tasks.find(task => task.id === item.id) &&\n                                (!item.value || !item.value.common || !item.value.common.dontDelete) && // exclude objects with dontDelete flag\n                                tasks.push({ id: item.id, state: item.value && item.value.type === 'state' }),\n                        );\n                    this._deleteObjects(tasks, options, callback);\n                });\n            });\n        } else {\n            this.#objects!.getObject(id, options, async (err, obj) => {\n                if (err) {\n                    return tools.maybeCallbackWithError(callback, err);\n                } else if (obj) {\n                    // do not allow deletion of objects with dontDelete flag\n                    if (obj.common?.dontDelete) {\n                        return tools.maybeCallbackWithError(callback, new Error('not deletable'));\n                    }\n\n                    try {\n                        await this.#objects!.delObject(obj._id, options);\n                    } catch (e) {\n                        return tools.maybeCallbackWithError(callback, e);\n                    }\n                    if (obj.type === 'state') {\n                        try {\n                            await this.delForeignStateAsync(id, options);\n                        } catch {\n                            // Ignore\n                        }\n                    }\n                    try {\n                        await tools.removeIdFromAllEnums(this.#objects, id, this.enums);\n                    } catch (e) {\n                        return tools.maybeCallbackWithError(callback, e);\n                    }\n                }\n                return tools.maybeCallback(callback);\n            });\n        }\n    }\n\n    // external signatures\n    subscribeObjects(pattern: Pattern, callback?: ioBroker.ErrorCallback): void;\n    subscribeObjects(pattern: Pattern, options: unknown, callback?: ioBroker.ErrorCallback): void;\n\n    /**\n     * Subscribe for the changes of objects in this instance.\n     *\n     * @param pattern pattern like 'channel.*' or '*' (all objects of this adapter) - without namespaces\n     * @param options optional user context\n     * @param callback optional returns result\n     *        ```js\n     *            function (err) {\n     *              if (err) adapter.log.error('Cannot subscribe object: ' + err);\n     *            }\n     *        ```\n     */\n    subscribeObjects(pattern: unknown, options: unknown, callback?: unknown): any {\n        if (typeof options === 'function') {\n            callback = options;\n            options = undefined;\n        }\n\n        Validator.assertOptionalCallback(callback, 'callback');\n        Validator.assertPattern(pattern, 'pattern');\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n\n        if (!this.#objects) {\n            this._logger.info(\n                `${this.namespaceLog} subscribeObjects not processed because Objects database not connected`,\n            );\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        if (pattern === '*') {\n            this.#objects.subscribeUser(`${this.namespace}.*`, options, callback);\n        } else {\n            const fixedPattern = Array.isArray(pattern) ? pattern : this._utils.fixId(pattern, true);\n            this.#objects.subscribeUser(fixedPattern, options, callback);\n        }\n    }\n\n    unsubscribeObjects(pattern: Pattern, callback?: ioBroker.ErrorCallback): void;\n    unsubscribeObjects(pattern: Pattern, options: unknown, callback?: ioBroker.ErrorCallback): void;\n\n    /**\n     * Unsubscribe on the changes of objects in this instance.\n     *\n     * @param pattern pattern like 'channel.*' or '*' (all objects) - without namespaces\n     * @param options optional user context\n     * @param callback optional returns result\n     *        ```js\n     *            function (err) {\n     *              if (err) adapter.log.error('Cannot unsubscribe object: ' + err);\n     *            }\n     *        ```\n     */\n    unsubscribeObjects(pattern: unknown, options: unknown, callback?: unknown): any {\n        if (typeof options === 'function') {\n            callback = options;\n            options = undefined;\n        }\n\n        Validator.assertOptionalCallback(callback, 'callback');\n        Validator.assertPattern(pattern, 'pattern');\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n\n        if (!this.#objects) {\n            this._logger.info(\n                `${this.namespaceLog} unsubscribeObjects not processed because Objects database not connected`,\n            );\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        if (pattern === '*') {\n            this.#objects.unsubscribeUser(`${this.namespace}.*`, options, callback);\n        } else {\n            const fixedPattern = Array.isArray(pattern) ? pattern : this._utils.fixId(pattern, true);\n            this.#objects.unsubscribeUser(fixedPattern, options, callback);\n        }\n    }\n\n    // external signatures\n    subscribeForeignObjects(pattern: string | string[], callback?: ioBroker.ErrorCallback): void;\n    subscribeForeignObjects(pattern: string | string[], options: unknown, callback?: ioBroker.ErrorCallback): void;\n\n    /**\n     * Subscribe for the changes of objects in any instance.\n     *\n     * @param pattern pattern like 'channel.*' or '*' (all objects) - without namespaces. You can use array of patterns\n     * @param options optional user context\n     * @param callback optional returns result\n     *        ```js\n     *            function (err) {\n     *              if (err) adapter.log.error('Cannot subscribe object: ' + err);\n     *            }\n     *        ```\n     */\n    subscribeForeignObjects(pattern: unknown, options: unknown, callback?: unknown): any {\n        if (typeof options === 'function') {\n            callback = options;\n            options = undefined;\n        }\n\n        Validator.assertOptionalCallback(callback, 'callback');\n        Validator.assertPattern(pattern, 'pattern');\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n\n        if (!this.#objects) {\n            this._logger.info(\n                `${this.namespaceLog} subscribeForeignObjects not processed because Objects database not connected`,\n            );\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        this.#objects.subscribeUser(pattern, options, callback);\n    }\n\n    // external signatures\n    unsubscribeForeignObjects(pattern: string | string[], callback?: ioBroker.ErrorCallback): void;\n    unsubscribeForeignObjects(pattern: string | string[], options: unknown, callback?: ioBroker.ErrorCallback): void;\n\n    /**\n     * Unsubscribe for the patterns on all objects.\n     *\n     * @param pattern pattern like 'channel.*' or '*' (all objects) - without namespaces\n     * @param options optional user context\n     * @param callback optional returns result\n     *        ```js\n     *            function (err) {\n     *              if (err) adapter.log.error('Cannot unsubscribe object: ' + err);\n     *            }\n     *        ```\n     */\n    unsubscribeForeignObjects(pattern: unknown, options: unknown, callback?: unknown): any {\n        if (typeof options === 'function') {\n            callback = options;\n            options = undefined;\n        }\n        if (!pattern) {\n            pattern = '*';\n        }\n\n        Validator.assertOptionalCallback(callback, 'callback');\n        Validator.assertPattern(pattern, 'pattern');\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n\n        if (!this.#objects) {\n            this._logger.info(\n                `${this.namespaceLog} unsubscribeForeignObjects not processed because Objects database not connected`,\n            );\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        this.#objects.unsubscribeUser(pattern, options, callback);\n    }\n\n    // external signatures\n    subscribeForeignFiles(id: string, pattern: string | string[], options?: unknown): Promise<void>;\n\n    /**\n     * Subscribe for the changes of files in specific instance.\n     *\n     * @param id adapter ID like 'vis-2.0' or 'vis-2.admin'\n     * @param pattern pattern like 'channel.*' or '*' (all files) - without namespaces. You can use array of patterns\n     * @param options optional user context\n     */\n    subscribeForeignFiles(id: unknown, pattern: unknown, options?: unknown): Promise<void> {\n        if (!this.#objects) {\n            this._logger.info(\n                `${this.namespaceLog} subscribeForeignFiles not processed because Objects database not connected`,\n            );\n\n            throw new Error(tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        Validator.assertString(id, 'id');\n        Validator.assertPattern(pattern, 'pattern');\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n\n        return this.#objects.subscribeUserFile(id, pattern, options);\n    }\n\n    // external signatures\n    unsubscribeForeignFiles(id: string, pattern: string | string[], options?: unknown): Promise<void>;\n\n    /**\n     * Unsubscribe for the changes of files on specific instance.\n     *\n     * @param id adapter ID like 'vis-2.0' or 'vis-2.admin'\n     * @param pattern pattern like 'channel.*' or '*' (all objects) - without namespaces\n     * @param options optional user context\n     */\n    unsubscribeForeignFiles(id: unknown, pattern: unknown, options?: unknown): Promise<void> {\n        if (!pattern) {\n            pattern = '*';\n        }\n        if (!this.#objects) {\n            this._logger.info(\n                `${this.namespaceLog} unsubscribeForeignFiles not processed because Objects database not connected`,\n            );\n\n            throw new Error(tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        Validator.assertString(id, 'id');\n        Validator.assertPattern(pattern, 'pattern');\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n\n        return this.#objects.unsubscribeUserFile(id, pattern, options);\n    }\n\n    // external signatures\n    setObjectNotExists(\n        id: string,\n        obj: ioBroker.SettableObject,\n        callback?: ioBroker.SetObjectCallback,\n    ): Promise<void | ioBroker.CallbackReturnTypeOf<ioBroker.SetObjectCallback>> | void;\n    setObjectNotExists(\n        id: string,\n        obj: ioBroker.SettableObject,\n        options: unknown,\n        callback?: ioBroker.SetObjectCallback,\n    ): Promise<void | ioBroker.CallbackReturnTypeOf<ioBroker.SetObjectCallback>> | void;\n    /**\n     * Same as {@link AdapterClass.setObject}, but with check if the object exists.\n     *\n     * Only Ids that belong to this adapter can be modified. So the function automatically adds \"adapter.X.\" to ID.\n     * New object will be created only if no object exists with such ID.\n     *\n     * @param id object ID, that must be overwritten or created.\n     * @param obj new object\n     * @param options optional user context\n     * @param callback return result\n     *        ```js\n     *            function (err, obj) {\n     *              // obj is {id: id}\n     *              if (err) adapter.log.error('Cannot write object: ' + err);\n     *            }\n     *        ```\n     */\n    setObjectNotExists(\n        id: unknown,\n        obj: unknown,\n        options?: unknown,\n        callback?: unknown,\n    ): Promise<void | ioBroker.CallbackReturnTypeOf<ioBroker.SetObjectCallback>> | void {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        Validator.assertOptionalCallback(callback, 'callback');\n        if (options !== undefined && options !== null) {\n            Validator.assertObject(options, 'options');\n        }\n\n        Validator.assertObject(obj, 'obj');\n\n        try {\n            this._utils.validateId(id, false, null);\n        } catch (e) {\n            return tools.maybeCallbackWithError(callback, e);\n        }\n\n        return this._setObjectNotExists({\n            id: this.fixForbiddenCharsInId(this._utils.fixId(id)),\n            obj: obj as any,\n            options,\n            callback,\n        });\n    }\n\n    private async _setObjectNotExists(\n        options: InternalSetObjectOptions,\n    ): Promise<void | ioBroker.CallbackReturnTypeOf<ioBroker.SetObjectCallback>> {\n        if (!this.#objects) {\n            this._logger.info(\n                `${this.namespaceLog} setObjectNotExists not processed because Objects database not connected`,\n            );\n            return tools.maybeCallbackWithError(options.callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        if ('children' in options.obj || 'parent' in options.obj) {\n            this._logger.warn(`${this.namespaceLog} Do not use parent or children for ${options.id}`);\n        }\n\n        // check if object already exists\n        let objExists;\n        try {\n            objExists = await this.#objects.objectExists(options.id, options.options);\n        } catch (e) {\n            return tools.maybeCallbackWithError(\n                options.callback,\n                `Could not check object existence of ${options.id}: ${e.message}`,\n            );\n        }\n\n        if (objExists === false) {\n            if (!options.obj.from) {\n                options.obj.from = `system.adapter.${this.namespace}`;\n            }\n            if (!options.obj.user) {\n                options.obj.user = (options.options ? options.options.user : '') || SYSTEM_ADMIN_USER;\n            }\n            if (!options.obj.ts) {\n                options.obj.ts = Date.now();\n            }\n\n            return this._setObjectWithDefaultValue(options.id, options.obj, null, options.callback);\n        }\n        return tools.maybeCallbackWithError(options.callback, null);\n    }\n\n    // external signatures\n    setForeignObjectNotExists<T extends string>(\n        id: T,\n        obj: ioBroker.SettableObject<ioBroker.ObjectIdToObjectType<T, 'write'>>,\n        callback?: ioBroker.SetObjectCallback,\n    ): void;\n    setForeignObjectNotExists<T extends string>(\n        id: T,\n        obj: ioBroker.SettableObject<ioBroker.ObjectIdToObjectType<T, 'write'>>,\n        options: unknown,\n        callback?: ioBroker.SetObjectCallback,\n    ): void;\n\n    /**\n     * Same as {@link AdapterClass.setForeignObject}, but with check if the object exists.\n     *\n     * ID must be specified as a full name with adapter namespace. E.g \"hm-rpc.0.ABC98989.1.STATE\".\n     * New object will be created only if no object exists with such ID.\n     *\n     * @param id object ID, that must be overwritten or created.\n     * @param obj new object\n     * @param options user context\n     * @param callback return result\n     *        ```js\n     *            function (err, obj) {\n     *              // obj is {id: id}\n     *              if (err) adapter.log.error('Cannot write object: ' + err);\n     *            }\n     *        ```\n     */\n    setForeignObjectNotExists(\n        id: unknown,\n        obj: unknown,\n        options: unknown,\n        callback?: unknown,\n    ): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.SetObjectCallback> | void> {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        Validator.assertString(id, 'id');\n        Validator.assertObject(obj, 'obj');\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n\n        Validator.assertOptionalCallback(callback, 'callback');\n\n        return this._setForeignObjectNotExists({ id, obj: obj as ioBroker.SettableObject, options, callback });\n    }\n\n    private async _setForeignObjectNotExists(\n        _options: InternalSetObjectOptions,\n    ): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.SetObjectCallback> | void> {\n        const { id, obj, options, callback } = _options;\n\n        if (!this.#objects) {\n            this._logger.info(\n                `${this.namespaceLog} setForeignObjectNotExists not processed because Objects database not connected`,\n            );\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        try {\n            this._utils.validateId(id, true, null);\n        } catch (e) {\n            return tools.maybeCallbackWithError(callback, e);\n        }\n\n        // check if the object exists\n        let objExists;\n        try {\n            objExists = await this.#objects.objectExists(id, options || {});\n        } catch (e) {\n            return tools.maybeCallbackWithError(callback, `Could not check object existence of ${id}: ${e.message}`);\n        }\n\n        if (objExists === false) {\n            if (!obj.from) {\n                obj.from = `system.adapter.${this.namespace}`;\n            }\n            if (!obj.user) {\n                obj.user = options?.user || SYSTEM_ADMIN_USER;\n            }\n            if (!obj.ts) {\n                obj.ts = Date.now();\n            }\n\n            return this._setObjectWithDefaultValue(id, obj, null, callback);\n        }\n        return tools.maybeCallbackWithError(callback, null);\n    }\n\n    private _DCS2ID(device: string, channel: string, stateOrPoint?: boolean | string): string {\n        let id = '';\n        if (device) {\n            id += device;\n        }\n        if (channel) {\n            id += (id ? '.' : '') + channel;\n        }\n\n        if (typeof stateOrPoint === 'string') {\n            if (stateOrPoint) {\n                id += (id ? '.' : '') + stateOrPoint;\n            }\n        } else if (stateOrPoint === true && id) {\n            id += '.';\n        }\n        return id;\n    }\n\n    // external signatures\n    /** @deprecated use `this.extendObject` instead */\n    createDevice(deviceName: string, callback?: ioBroker.SetObjectCallback): void;\n    /** @deprecated use `this.extendObject` instead */\n    createDevice(\n        deviceName: string,\n        common: Partial<ioBroker.DeviceCommon>,\n        callback?: ioBroker.SetObjectCallback,\n    ): void;\n    /** @deprecated use `this.extendObject` instead */\n    createDevice(\n        deviceName: string,\n        common: Partial<ioBroker.DeviceCommon>,\n        native: Record<string, any>,\n        callback?: ioBroker.SetObjectCallback,\n    ): void;\n    /** @deprecated use `this.extendObject` instead */\n    createDevice(\n        deviceName: string,\n        common: Partial<ioBroker.DeviceCommon>,\n        native: Record<string, any>,\n        options: unknown,\n        callback?: ioBroker.SetObjectCallback,\n    ): void;\n\n    /**\n     * @param deviceName\n     * @param common\n     * @param _native\n     * @param options\n     * @param callback\n     * @deprecated use `this.extendObject` instead\n     */\n    createDevice(deviceName: unknown, common: unknown, _native?: unknown, options?: unknown, callback?: unknown): any {\n        this._logger.info(\n            `${this.namespaceLog} Method \"createDevice\" is deprecated and will be removed in js-controller 7.1, use \"extendObject/setObjectNotExists\" instead`,\n        );\n\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n        if (!deviceName) {\n            this._logger.error(`${this.namespaceLog} Try to create device with empty name!`);\n            return;\n        }\n        if (typeof _native === 'function') {\n            callback = _native;\n            _native = {};\n        }\n        if (typeof common === 'function') {\n            callback = common;\n            common = {};\n        }\n\n        Validator.assertOptionalCallback(callback, 'callback');\n        Validator.assertString(deviceName, 'deviceName');\n        if (_native !== undefined && _native !== null) {\n            Validator.assertObject(_native, '_native');\n        }\n\n        return this._createDevice({\n            common: common as Partial<ioBroker.DeviceCommon>,\n            deviceName,\n            _native,\n            callback,\n            options,\n        });\n    }\n\n    private _createDevice(_options: InternalCreateDeviceOptions): void {\n        let { common, deviceName, _native } = _options;\n        const { callback, options } = _options;\n        common = common || {};\n        common.name = common.name || deviceName;\n\n        deviceName = deviceName.replace(FORBIDDEN_CHARS, '_').replace(/\\./g, '_');\n        _native = _native || {};\n\n        this.setObjectNotExists(\n            deviceName,\n            {\n                type: 'device',\n                common: common,\n                native: _native,\n            } as ioBroker.SettableDeviceObject,\n            options,\n            callback,\n        );\n    }\n\n    /** @deprecated use `this.extendObject` instead */\n    createChannel(parentDevice: string, channelName: string, callback?: ioBroker.SetObjectCallback): void;\n    /** @deprecated use `this.extendObject` instead */\n    createChannel(\n        parentDevice: string,\n        channelName: string,\n        roleOrCommon: string | Partial<ioBroker.ChannelCommon>,\n        callback?: ioBroker.SetObjectCallback,\n    ): void;\n    /** @deprecated use `this.extendObject` instead */\n    createChannel(\n        parentDevice: string,\n        channelName: string,\n        roleOrCommon: string | Partial<ioBroker.ChannelCommon>,\n        native: Record<string, any>,\n        callback?: ioBroker.SetObjectCallback,\n    ): void;\n    /** @deprecated use `this.extendObject` instead */\n    createChannel(\n        parentDevice: string,\n        channelName: string,\n        roleOrCommon: string | Partial<ioBroker.ChannelCommon>,\n        native: Record<string, any>,\n        options: unknown,\n        callback?: ioBroker.SetObjectCallback,\n    ): void;\n\n    /**\n     * Name of channel must be in format \"channel\"\n     *\n     * @param parentDevice\n     * @param channelName\n     * @param roleOrCommon\n     * @param _native\n     * @param options\n     * @param callback\n     * @deprecated use `this.extendObject` instead\n     */\n    createChannel(\n        parentDevice: unknown,\n        channelName: unknown,\n        roleOrCommon?: unknown,\n        _native?: unknown,\n        options?: unknown,\n        callback?: unknown,\n    ): any {\n        this._logger.info(\n            `${this.namespaceLog} Method \"createChannel\" is deprecated and will be removed in js-controller 7.1, use \"extendObject/setObjectNotExists\" instead`,\n        );\n\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n        if (!channelName) {\n            throw new Error('Cannot create a channel without a name!');\n        }\n\n        if (typeof _native === 'function') {\n            callback = _native;\n            _native = {};\n        }\n\n        if (typeof roleOrCommon === 'function') {\n            callback = roleOrCommon;\n            roleOrCommon = undefined;\n        }\n\n        let common = {};\n        if (typeof roleOrCommon === 'string') {\n            common = {\n                name: '',\n                role: roleOrCommon,\n            };\n        } else if (tools.isObject(roleOrCommon)) {\n            common = roleOrCommon;\n        }\n\n        Validator.assertObject(common, 'common');\n        Validator.assertString(channelName, 'channelName');\n        Validator.assertString(parentDevice, 'parentDevice');\n        Validator.assertOptionalCallback(callback, 'callback');\n\n        common.name = common.name || channelName;\n\n        if (parentDevice) {\n            parentDevice = parentDevice.replace(FORBIDDEN_CHARS, '_').replace(/\\./g, '_');\n        }\n        channelName = channelName.replace(FORBIDDEN_CHARS, '_').replace(/\\./g, '_');\n        // @ts-expect-error ts somehow loses types here\n        channelName = this._DCS2ID(parentDevice, channelName);\n\n        _native = _native || {};\n\n        const obj = {\n            type: 'channel',\n            common: common,\n            native: _native,\n        } as const;\n\n        this.setObjectNotExists(channelName as string, obj as any, options, callback);\n    }\n\n    /** @deprecated use `this.extendObject` instead */\n    createState(\n        parentDevice: string,\n        parentChannel: string,\n        stateName: string,\n        callback?: ioBroker.SetObjectCallback,\n    ): void;\n    /** @deprecated use `this.extendObject` instead */\n    createState(\n        parentDevice: string,\n        parentChannel: string,\n        stateName: string,\n        roleOrCommon: string | Partial<ioBroker.StateCommon>,\n        callback?: ioBroker.SetObjectCallback,\n    ): void;\n    /** @deprecated use `this.extendObject` instead */\n    createState(\n        parentDevice: string,\n        parentChannel: string,\n        stateName: string,\n        roleOrCommon: string | Partial<ioBroker.StateCommon>,\n        native: Record<string, any>,\n        callback?: ioBroker.SetObjectCallback,\n    ): void;\n    /** @deprecated use `this.extendObject` instead */\n    createState(\n        parentDevice: string,\n        parentChannel: string,\n        stateName: string,\n        roleOrCommon: string | Partial<ioBroker.StateCommon>,\n        native: Record<string, any>,\n        options: unknown,\n        callback?: ioBroker.SetObjectCallback,\n    ): void;\n\n    /**\n     * @param parentDevice\n     * @param parentChannel\n     * @param stateName\n     * @param roleOrCommon\n     * @param _native\n     * @param options\n     * @param callback\n     * @deprecated use `this.extendObject` instead\n     */\n    createState(\n        parentDevice: unknown,\n        parentChannel: unknown,\n        stateName: unknown,\n        roleOrCommon: unknown,\n        _native?: unknown,\n        options?: unknown,\n        callback?: unknown,\n    ): any {\n        this._logger.info(\n            `${this.namespaceLog} Method \"createState\" is deprecated and will be removed in js-controller 7.1, use \"extendObject/setObjectNotExists\" instead`,\n        );\n\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n        if (!stateName) {\n            throw new Error('Cannot create a state without a name!');\n        }\n\n        if (typeof _native === 'function') {\n            callback = _native;\n            _native = {};\n        }\n\n        if (typeof roleOrCommon === 'function') {\n            callback = roleOrCommon;\n            roleOrCommon = undefined;\n        }\n\n        let common: any = {};\n        if (typeof roleOrCommon === 'string') {\n            common = {\n                read: true,\n                write: false,\n                name: '',\n                role: roleOrCommon,\n            };\n        } else if (tools.isObject(roleOrCommon)) {\n            common = roleOrCommon;\n        }\n\n        _native = _native || {};\n\n        Validator.assertObject(common, 'common');\n        Validator.assertString(stateName, 'stateName');\n        Validator.assertString(parentDevice, 'parentDevice');\n        Validator.assertString(parentChannel, 'parentChannel');\n        Validator.assertOptionalCallback(callback, 'callback');\n        Validator.assertObject(_native, '_native');\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n\n        return this._createState({ parentDevice, parentChannel, callback, stateName, common, _native, options });\n    }\n\n    private _createState(_options: InternalCreateStateOptions): Promise<void> | void {\n        const { _native, common, callback, options } = _options;\n        let { parentChannel, parentDevice, stateName } = _options;\n\n        common.name = common.name || stateName;\n\n        common.read = common.read === undefined ? true : common.read;\n        common.write = common.write === undefined ? false : common.write;\n\n        if (!common.role) {\n            this._logger.error(\n                `${this.namespaceLog} Try to create state ${\n                    parentDevice ? `${parentDevice}.` : ''\n                }${parentChannel}.${stateName} without role`,\n            );\n            return;\n        }\n\n        if (parentDevice) {\n            parentDevice = parentDevice.replace(FORBIDDEN_CHARS, '_').replace(/\\./g, '_');\n        }\n        if (parentChannel) {\n            parentChannel = parentChannel.replace(FORBIDDEN_CHARS, '_').replace(/\\./g, '_');\n        }\n        stateName = stateName.replace(FORBIDDEN_CHARS, '_').replace(/\\./g, '_');\n        const id = this._utils.fixId({\n            device: parentDevice,\n            channel: parentChannel,\n            state: stateName,\n        });\n\n        // Check min, max and def values for number\n        if (common.type !== undefined && common.type === 'number') {\n            let min = 0;\n            let max = 0;\n            let def = 0;\n            let err;\n            if (common.min !== undefined) {\n                min = common.min;\n                if (typeof min !== 'number') {\n                    min = parseFloat(min);\n                    if (isNaN(min)) {\n                        err = `Wrong type of ${id}.common.min`;\n                        this._logger.error(`${this.namespaceLog} ${err}`);\n                        return tools.maybeCallbackWithError(callback, err);\n                    }\n                    common.min = min;\n                }\n            }\n            if (common.max !== undefined) {\n                max = common.max;\n                if (typeof max !== 'number') {\n                    max = parseFloat(max);\n                    if (isNaN(max)) {\n                        err = `Wrong type of ${id}.common.max`;\n                        this._logger.error(`${this.namespaceLog} ${err}`);\n                        return tools.maybeCallbackWithError(callback, err);\n                    }\n                    common.max = max;\n                }\n            }\n            if (common.def !== undefined) {\n                def = common.def;\n                if (typeof def !== 'number') {\n                    def = parseFloat(def);\n                    if (isNaN(def)) {\n                        err = new Error(`Wrong type of ${id}.common.def`);\n                        this._logger.error(`${this.namespaceLog} ${err.message}`);\n                        return tools.maybeCallbackWithError(callback, err);\n                    }\n                    common.def = def;\n                }\n            }\n            if (common.min !== undefined && common.max !== undefined && min > max) {\n                common.max = min;\n                common.min = max;\n            }\n            if (common.def !== undefined && common.min !== undefined && def < min) {\n                common.def = min;\n            }\n            if (common.def !== undefined && common.max !== undefined && def > max) {\n                common.def = max;\n            }\n        }\n\n        this.setObjectNotExists(\n            id,\n            {\n                type: 'state',\n                common: common as any,\n                native: _native as any,\n            },\n            options,\n            err => {\n                if (err) {\n                    return tools.maybeCallbackWithError(callback, err);\n                } else if (common.def !== undefined) {\n                    this.getState(id, null, (err, state) => {\n                        if (!state) {\n                            if (common.defAck !== undefined) {\n                                this.setState(id, common.def, common.defAck, options, callback as any);\n                            } else {\n                                this.setState(id, common.def, options, callback as any);\n                            }\n                        } else {\n                            return tools.maybeCallback(callback);\n                        }\n                    });\n                } else {\n                    this.getState(id, null, (err, state) => {\n                        if (!state) {\n                            this.setState(id, null, true, options, callback as any);\n                        } else {\n                            return tools.maybeCallback(callback);\n                        }\n                    });\n                }\n            },\n        );\n    }\n\n    /** @deprecated use `this.delObject` instead */\n    deleteDevice(deviceName: string, callback?: ioBroker.ErrorCallback): void;\n    /** @deprecated use `this.delObject` instead */\n    deleteDevice(deviceName: string, options: unknown, callback?: ioBroker.ErrorCallback): void;\n\n    /**\n     * Delete device with all its channels and states.\n     *\n     * @deprecated use `this.delObject` instead\n     * @param deviceName is the part of ID like: adapter.instance.<deviceName>\n     * @param options optional user context\n     * @param callback return result\n     *        ```js\n     *            function (err) {\n     *              if (err) adapter.log.error('Cannot delete device: ' + err);\n     *            }\n     *        ```\n     */\n    deleteDevice(deviceName: unknown, options: unknown, callback?: unknown): any {\n        this._logger.info(\n            `${this.namespaceLog} Method \"deleteDevice\" is deprecated and will be removed in js-controller 7.1, use \"delObject\" instead`,\n        );\n\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        Validator.assertString(deviceName, 'deviceName');\n        Validator.assertOptionalCallback(callback, 'callback');\n\n        return this._deleteDevice({ deviceName, callback });\n    }\n\n    private async _deleteDevice(_options: InternalDeleteDeviceOptions): Promise<void> {\n        const { callback } = _options;\n        let { deviceName } = _options;\n\n        if (!this.#objects) {\n            this._logger.info(`${this.namespaceLog} deleteDevice not processed because Objects database not connected`);\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        deviceName = deviceName.replace(FORBIDDEN_CHARS, '_').replace(/\\./g, '_');\n        if (!this._namespaceRegExp.test(deviceName)) {\n            // make it an id\n            deviceName = `${this.namespace}.${deviceName}`;\n        }\n\n        // get object to check if it is a device\n        let obj;\n        try {\n            obj = await this.getForeignObjectAsync(deviceName);\n        } catch (e) {\n            return tools.maybeCallbackWithError(callback, e);\n        }\n\n        if (!obj || obj.type !== 'device') {\n            // it's not a device, so return but no error\n            return tools.maybeCallback(callback);\n        }\n\n        // it's a device now delete it + underlying structure\n        try {\n            await this.delForeignObjectAsync(deviceName, { recursive: true });\n        } catch (e) {\n            return tools.maybeCallbackWithError(callback, e);\n        }\n\n        return tools.maybeCallback(callback);\n    }\n\n    // external signature\n    addChannelToEnum(\n        enumName: string,\n        addTo: string,\n        parentDevice: string,\n        channelName: string,\n        callback?: ioBroker.ErrorCallback,\n    ): void;\n    addChannelToEnum(\n        enumName: string,\n        addTo: string,\n        parentDevice: string,\n        channelName: string,\n        options: unknown,\n        callback?: ioBroker.ErrorCallback,\n    ): void;\n\n    addChannelToEnum(\n        enumName: unknown,\n        addTo: unknown,\n        parentDevice: unknown,\n        channelName: unknown,\n        options: unknown,\n        callback?: unknown,\n    ): MaybePromise {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        Validator.assertString(enumName, 'enumName');\n        Validator.assertString(addTo, 'addTo');\n        Validator.assertString(parentDevice, 'parentDevice');\n        Validator.assertString(channelName, 'channelName');\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n        Validator.assertOptionalCallback(callback, 'callback');\n\n        return this._addChannelToEnum({ enumName, addTo, parentDevice, channelName, options, callback });\n    }\n\n    private _addChannelToEnum(_options: InternalAddChannelToEnumOptions): Promise<void> | void {\n        const { addTo, options, callback } = _options;\n        let { enumName, parentDevice, channelName } = _options;\n\n        if (!this.#objects) {\n            this._logger.info(\n                `${this.namespaceLog} addChannelToEnum not processed because Objects database not connected`,\n            );\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        if (parentDevice) {\n            if (this._namespaceRegExp.test(parentDevice)) {\n                parentDevice = parentDevice.substring(this.namespace.length + 1);\n            }\n            parentDevice = parentDevice.replace(FORBIDDEN_CHARS, '_').replace(/\\./g, '_');\n        }\n\n        if (this._namespaceRegExp.test(channelName)) {\n            channelName = channelName.substring(this.namespace.length + 1);\n        }\n        if (parentDevice && channelName.substring(0, parentDevice.length) === parentDevice) {\n            channelName = channelName.substring(parentDevice.length + 1);\n        }\n        channelName = channelName.replace(FORBIDDEN_CHARS, '_').replace(/\\./g, '_');\n\n        const objId = `${this.namespace}.${this._DCS2ID(parentDevice, channelName)}`;\n\n        if (addTo.startsWith('enum.')) {\n            this.#objects.getObject(addTo, options, (err, obj) => {\n                if (err) {\n                    return tools.maybeCallbackWithError(callback, err);\n                } else if (obj) {\n                    if (!obj.common.members.includes(objId)) {\n                        obj.common.members.push(objId);\n                        obj.from = `system.adapter.${this.namespace}`;\n                        obj.user = options?.user || SYSTEM_ADMIN_USER;\n                        obj.ts = Date.now();\n\n                        this.#objects!.setObject(obj._id, obj, options, callback);\n                    } else {\n                        return tools.maybeCallback(callback);\n                    }\n                }\n            });\n        } else {\n            if (enumName.startsWith('enum.')) {\n                enumName = enumName.substring(5);\n            }\n\n            this.#objects.getObject(`enum.${enumName}.${addTo}`, options, (err, obj) => {\n                if (err) {\n                    return tools.maybeCallbackWithError(callback, err);\n                }\n\n                if (obj) {\n                    // @ts-expect-error\n                    if (!obj.common.members.includes(objId)) {\n                        // @ts-expect-error\n                        obj.common.members.push(objId);\n\n                        obj.from = `system.adapter.${this.namespace}`;\n                        obj.user = options?.user || SYSTEM_ADMIN_USER;\n                        obj.ts = Date.now();\n\n                        this.#objects!.setObject(obj._id, obj, options, callback);\n                    } else {\n                        return tools.maybeCallback(callback);\n                    }\n                } else {\n                    // Create enum\n                    this.#objects!.setObject(\n                        `enum.${enumName}.${addTo}`,\n                        {\n                            common: {\n                                name: addTo,\n                                members: [objId],\n                            },\n                            from: `system.adapter.${this.namespace}`,\n                            ts: Date.now(),\n                            type: 'enum',\n                            native: {},\n                        },\n                        options,\n                        callback,\n                    );\n                }\n            });\n        }\n    }\n\n    // external signature\n    deleteChannelFromEnum(\n        enumName: string,\n        parentDevice: string,\n        channelName: string,\n        callback?: ioBroker.ErrorCallback,\n    ): void;\n    deleteChannelFromEnum(\n        enumName: string,\n        parentDevice: string,\n        channelName: string,\n        options: unknown,\n        callback?: ioBroker.ErrorCallback,\n    ): void;\n\n    deleteChannelFromEnum(\n        enumName: unknown,\n        parentDevice: unknown,\n        channelName: unknown,\n        options: unknown,\n        callback?: unknown,\n    ): any {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        Validator.assertString(enumName, 'enumName');\n        Validator.assertString(parentDevice, 'parentDevice');\n        Validator.assertString(channelName, 'channelName');\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n        Validator.assertOptionalCallback(callback, 'callback');\n\n        return this._deleteChannelFromEnum({ enumName, parentDevice, channelName, options, callback });\n    }\n\n    private _deleteChannelFromEnum(_options: InternalDeleteChannelFromEnumOptions): Promise<void> | void {\n        const { options, callback } = _options;\n        let { enumName, channelName, parentDevice } = _options;\n\n        if (!this.#objects) {\n            this._logger.info(\n                `${this.namespaceLog} deleteChannelFromEnum not processed because Objects database not connected`,\n            );\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        if (parentDevice) {\n            if (parentDevice.substring(0, this.namespace.length) === this.namespace) {\n                parentDevice = parentDevice.substring(this.namespace.length + 1);\n            }\n            parentDevice = parentDevice.replace(FORBIDDEN_CHARS, '_').replace(/\\./g, '_');\n        }\n\n        if (channelName && channelName.substring(0, this.namespace.length) === this.namespace) {\n            channelName = channelName.substring(this.namespace.length + 1);\n        }\n        if (parentDevice && channelName && channelName.substring(0, parentDevice.length) === parentDevice) {\n            channelName = channelName.substring(parentDevice.length + 1);\n        }\n        channelName = channelName || '';\n        channelName = channelName.replace(FORBIDDEN_CHARS, '_').replace(/\\./g, '_');\n\n        const objId = `${this.namespace}.${this._DCS2ID(parentDevice, channelName)}`;\n\n        if (enumName) {\n            enumName = `enum.${enumName}.`;\n        } else {\n            enumName = 'enum.';\n        }\n\n        this.#objects.getObjectView(\n            'system',\n            'enum',\n            {\n                startkey: enumName,\n                endkey: `${enumName}\\u9999`,\n            },\n            options,\n            async (err, res) => {\n                if (err) {\n                    return tools.maybeCallbackWithError(callback, err);\n                }\n\n                if (res) {\n                    for (const row of res.rows) {\n                        try {\n                            const obj = (await this.#objects!.getObject(row.id, options)) as\n                                | ioBroker.EnumObject\n                                | null\n                                | undefined;\n\n                            if (obj?.common?.members) {\n                                const pos = obj.common.members.indexOf(objId);\n                                if (pos !== -1) {\n                                    obj.common.members.splice(pos, 1);\n                                    obj.from = `system.adapter.${this.namespace}`;\n                                    obj.user = options?.user || SYSTEM_ADMIN_USER;\n                                    obj.ts = Date.now();\n\n                                    await this.#objects!.setObjectAsync(obj._id, obj, options);\n                                }\n                            }\n                        } catch (e) {\n                            return tools.maybeCallbackWithError(callback, e);\n                        }\n                    }\n                }\n                return tools.maybeCallback(callback);\n            },\n        );\n    }\n\n    // external signature\n    /** @deprecated use `this.delObject` instead */\n    deleteChannel(channelName: string, callback?: ioBroker.ErrorCallback): void;\n    /** @deprecated use `this.delObject` instead */\n    deleteChannel(channelName: string, options?: unknown, callback?: ioBroker.ErrorCallback): void;\n    /** @deprecated use `this.delObject` instead */\n    deleteChannel(\n        parentDevice: string,\n        channelName: string,\n        options?: unknown,\n        callback?: ioBroker.ErrorCallback,\n    ): void;\n\n    /**\n     * Deletes channel and underlying structure\n     *\n     * @deprecated use `this.delObject` instead\n     * @alias deleteChannel\n     * @param parentDevice is the part of ID like: adapter.instance.<deviceName>\n     * @param channelName is the part of ID like: adapter.instance.<deviceName>.<channelName>\n     * @param options optional user context\n     * @param callback return result\n     *        ```js\n     *            function (err) {\n     *              if (err) adapter.log.error('Cannot delete device: ' + err);\n     *            }\n     *        ```\n     */\n    deleteChannel(parentDevice: unknown, channelName: unknown, options?: unknown, callback?: unknown): any {\n        this._logger.info(\n            `${this.namespaceLog} Method \"deleteChannel\" is deprecated and will be removed in js-controller 7.1, use \"delObject\" instead`,\n        );\n\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n        if (typeof channelName === 'function') {\n            callback = channelName;\n            channelName = parentDevice;\n            parentDevice = '';\n        }\n        if (parentDevice && !channelName) {\n            channelName = parentDevice;\n            parentDevice = '';\n        } else if (parentDevice && typeof channelName === 'function') {\n            callback = channelName;\n            channelName = parentDevice;\n            parentDevice = '';\n        }\n\n        Validator.assertString(parentDevice, 'parentDevice');\n        Validator.assertString(channelName, 'channelName');\n        Validator.assertOptionalCallback(callback, 'callback');\n\n        return this._deleteChannel({ parentDevice, channelName, callback });\n    }\n\n    private async _deleteChannel(_options: InternalDeleteChannelOptions): Promise<void> {\n        const { callback } = _options;\n        let { channelName, parentDevice } = _options;\n\n        if (!this.#objects) {\n            this._logger.info(\n                `${this.namespaceLog} deleteChannel not processed because Objects database not connected`,\n            );\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        if (!parentDevice) {\n            parentDevice = '';\n        }\n\n        if (parentDevice) {\n            if (this._namespaceRegExp.test(parentDevice)) {\n                parentDevice = parentDevice.substring(this.namespace.length + 1);\n            }\n            parentDevice = parentDevice.replace(FORBIDDEN_CHARS, '_').replace(/\\./g, '_');\n        }\n\n        if (channelName && this._namespaceRegExp.test(channelName)) {\n            channelName = channelName.substring(this.namespace.length + 1);\n        }\n        if (parentDevice && channelName && channelName.substring(0, parentDevice.length) === parentDevice) {\n            channelName = channelName.substring(parentDevice.length + 1);\n        }\n        channelName = channelName || '';\n        channelName = channelName.replace(FORBIDDEN_CHARS, '_').replace(/\\./g, '_');\n\n        channelName = `${this.namespace}.${this._DCS2ID(parentDevice, channelName)}`;\n\n        // get object to check if it is a channel\n        let obj;\n        try {\n            obj = await this.getForeignObjectAsync(channelName);\n        } catch (e) {\n            return tools.maybeCallbackWithError(callback, e);\n        }\n\n        if (!obj || obj.type !== 'channel') {\n            // it's not a channel, so return but no error\n            return tools.maybeCallback(callback);\n        }\n\n        this._logger.info(`${this.namespaceLog} Delete channel ${channelName}`);\n\n        // it's a channel now delete it + underlying structure\n        try {\n            await this.delForeignObjectAsync(channelName, { recursive: true });\n        } catch (e) {\n            return tools.maybeCallbackWithError(callback, e);\n        }\n\n        return tools.maybeCallback(callback);\n    }\n\n    // external signature\n    /** @deprecated use `this.delObject` instead */\n    deleteState(parentChannel: string, stateName: string, options?: unknown, callback?: ioBroker.ErrorCallback): void;\n    /** @deprecated use `this.delObject` instead */\n    deleteState(stateName: string, options?: unknown, callback?: ioBroker.ErrorCallback): void;\n    /** @deprecated use `this.delObject` instead */\n    deleteState(\n        parentDevice: string | null,\n        parentChannel: string | null,\n        stateName: string,\n        options?: unknown,\n        callback?: ioBroker.ErrorCallback,\n    ): void;\n\n    /**\n     * @param parentDevice\n     * @param parentChannel\n     * @param stateName\n     * @param options\n     * @param callback\n     * @deprecated use `this.delObject` instead\n     */\n    deleteState(\n        parentDevice: unknown,\n        parentChannel: unknown,\n        stateName?: unknown,\n        options?: unknown,\n        callback?: unknown,\n    ): any {\n        this._logger.info(\n            `${this.namespaceLog} Method \"deleteState\" is deprecated and will be removed in js-controller 7.1, use \"delObject\" instead`,\n        );\n\n        if (typeof parentChannel === 'function' && stateName === undefined) {\n            stateName = parentDevice;\n            callback = parentChannel;\n            parentChannel = '';\n            parentDevice = '';\n        } else if (parentChannel === undefined && stateName === undefined) {\n            stateName = parentDevice;\n            parentDevice = '';\n            parentChannel = '';\n        } else {\n            if (typeof options === 'function') {\n                callback = options;\n                options = null;\n            }\n            if (typeof stateName === 'function') {\n                callback = stateName;\n                stateName = parentChannel;\n                parentChannel = parentDevice;\n                parentDevice = '';\n            }\n            if (typeof parentChannel === 'function') {\n                callback = parentChannel;\n                stateName = parentDevice;\n                parentChannel = '';\n                parentDevice = '';\n            }\n            if (typeof parentChannel === 'function') {\n                callback = parentChannel;\n                stateName = parentDevice;\n                parentChannel = '';\n                parentDevice = '';\n            }\n        }\n\n        parentDevice = parentDevice ?? '';\n        parentChannel = parentChannel ?? '';\n        stateName = stateName ?? '';\n\n        Validator.assertString(parentDevice, 'parentDevice');\n        Validator.assertString(parentChannel, 'parentChannel');\n        Validator.assertString(stateName, 'stateName');\n        Validator.assertOptionalCallback(callback, 'callback');\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n\n        return this._deleteState({ parentDevice, parentChannel, stateName, options, callback });\n    }\n\n    private _deleteState(_options: InternalDeleteStateOptions): void {\n        const { callback, options } = _options;\n        let { stateName, parentDevice, parentChannel } = _options;\n\n        if (parentDevice) {\n            if (this._namespaceRegExp.test(parentDevice)) {\n                parentDevice = parentDevice.substring(this.namespace.length + 1);\n            }\n\n            parentDevice = parentDevice.replace(FORBIDDEN_CHARS, '_').replace(/\\./g, '_');\n        }\n\n        if (parentChannel) {\n            if (this._namespaceRegExp.test(parentChannel)) {\n                parentChannel = parentChannel.substring(this.namespace.length + 1);\n            }\n            if (parentDevice && parentChannel.substring(0, parentDevice.length) === parentDevice) {\n                parentChannel = parentChannel.substring(parentDevice.length + 1);\n            }\n\n            parentChannel = parentChannel.replace(FORBIDDEN_CHARS, '_').replace(/\\./g, '_');\n        }\n\n        if (this._namespaceRegExp.test(stateName)) {\n            stateName = stateName.substring(this.namespace.length + 1);\n        }\n        if (parentDevice && stateName.substring(0, parentDevice.length) === parentDevice) {\n            stateName = stateName.substring(parentDevice.length + 1);\n        }\n        if (parentChannel && stateName.substring(0, parentChannel.length) === parentChannel) {\n            stateName = stateName.substring(parentChannel.length + 1);\n        }\n        stateName = stateName || '';\n        stateName = stateName.replace(FORBIDDEN_CHARS, '_').replace(/\\./g, '_');\n\n        const _name = this._DCS2ID(parentDevice, parentChannel, stateName);\n        this.delObject(_name, options, callback);\n    }\n\n    // external signature\n    getDevices(callback: ioBroker.GetObjectsCallback3<ioBroker.DeviceObject>): void;\n    getDevices(options: unknown, callback: ioBroker.GetObjectsCallback3<ioBroker.DeviceObject>): void;\n\n    getDevices(options: unknown, callback?: unknown): any {\n        if (typeof options === 'function' && typeof callback === 'object') {\n            const tmp = callback;\n            callback = options;\n            options = tmp;\n        }\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        Validator.assertCallback(callback, 'callback');\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n\n        return this._getDevices({ options, callback });\n    }\n\n    private _getDevices(_options: InternalGetDevicesOptions): Promise<void> | void {\n        const { options, callback } = _options;\n\n        if (!this.#objects) {\n            this._logger.info(`${this.namespaceLog} getDevices not processed because Objects database not connected`);\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        this.#objects.getObjectView(\n            'system',\n            'device',\n            {\n                startkey: `${this.namespace}.`,\n                endkey: `${this.namespace}.\\u9999`,\n            },\n            options,\n            (err, obj) => {\n                if (err || !obj || !obj.rows || !obj.rows.length) {\n                    return tools.maybeCallbackWithError(callback, err, err ? undefined : []);\n                }\n                const res = [];\n                for (const row of obj.rows) {\n                    if (row.value) {\n                        res.push(row.value);\n                    }\n                }\n                return tools.maybeCallbackWithError(callback, null, res);\n            },\n        );\n    }\n\n    // public signature\n    getChannelsOf(callback: ioBroker.GetObjectsCallback3<ioBroker.ChannelObject>): void;\n    getChannelsOf(parentDevice: string, callback: ioBroker.GetObjectsCallback3<ioBroker.ChannelObject>): void;\n    getChannelsOf(\n        parentDevice: string,\n        options: unknown,\n        callback: ioBroker.GetObjectsCallback3<ioBroker.ChannelObject>,\n    ): void;\n    getChannelsOf(parentDevice: unknown, options?: unknown, callback?: unknown): any {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n        if (typeof parentDevice === 'function') {\n            callback = parentDevice;\n            parentDevice = undefined;\n        }\n\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n\n        Validator.assertOptionalCallback(callback, 'callback');\n        if (parentDevice !== undefined) {\n            Validator.assertString(parentDevice, 'parentDevice');\n        }\n\n        return this._getChannelsOf({ parentDevice, options, callback });\n    }\n\n    private _getChannelsOf(options: InternalGetChannelsOfOptions): Promise<void> | void {\n        if (!this.#objects) {\n            this._logger.info(\n                `${this.namespaceLog} getChannelsOf not processed because Objects database not connected`,\n            );\n            return tools.maybeCallbackWithError(options.callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        if (!options.parentDevice) {\n            options.parentDevice = '';\n        }\n\n        if (options.parentDevice && this._namespaceRegExp.test(options.parentDevice)) {\n            options.parentDevice = options.parentDevice.substring(this.namespace.length + 1);\n        }\n\n        options.parentDevice = options.parentDevice.replace(FORBIDDEN_CHARS, '_').replace(/\\./g, '_');\n        options.parentDevice = this.namespace + (options.parentDevice ? `.${options.parentDevice}` : '');\n        this.#objects.getObjectView(\n            'system',\n            'channel',\n            {\n                startkey: `${options.parentDevice}.`,\n                endkey: `${options.parentDevice}.\\u9999`,\n            },\n            options.options || {},\n            (err, obj) => {\n                if (err || !obj || !obj.rows || !obj.rows.length) {\n                    return tools.maybeCallbackWithError(options.callback, err, err ? undefined : []);\n                }\n                const res = [];\n                for (const row of obj.rows) {\n                    if (row.value) {\n                        res.push(row.value);\n                    }\n                }\n                return tools.maybeCallbackWithError(options.callback, null, res);\n            },\n        );\n    }\n\n    // external signature\n    getStatesOf(callback: ioBroker.GetObjectsCallback3<ioBroker.StateObject>): void;\n    getStatesOf(parentDevice: string, callback: ioBroker.GetObjectsCallback3<ioBroker.StateObject>): void;\n    getStatesOf(\n        parentDevice: string | null | undefined,\n        parentChannel: string | null | undefined,\n        callback: ioBroker.GetObjectsCallback3<ioBroker.StateObject>,\n    ): void;\n    getStatesOf(\n        parentDevice: string | null | undefined,\n        parentChannel: string | null | undefined,\n        options: unknown,\n        callback: ioBroker.GetObjectsCallback3<ioBroker.StateObject>,\n    ): void;\n    getStatesOf(parentDevice: unknown, parentChannel?: unknown, options?: unknown, callback?: unknown): any {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n        if (typeof parentDevice === 'function') {\n            callback = parentDevice;\n            parentDevice = null;\n            parentChannel = null;\n        }\n        if (typeof parentChannel === 'function') {\n            callback = parentChannel;\n            parentChannel = null;\n        }\n        if (!callback) {\n            return;\n        }\n\n        Validator.assertCallback(callback, 'callback');\n\n        if (parentDevice !== null && parentDevice !== undefined) {\n            Validator.assertString(parentDevice, 'parentDevice');\n        }\n\n        if (parentChannel !== null && parentChannel !== undefined) {\n            Validator.assertString(parentChannel, 'parentChannel');\n        }\n\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n\n        return this._getStatesOf({ parentDevice, parentChannel, options, callback });\n    }\n\n    private _getStatesOf(_options: InternalGetStatesOfOptions): Promise<void> | void {\n        const { options, callback } = _options;\n        let { parentDevice, parentChannel } = _options;\n\n        if (!this.#objects) {\n            this._logger.info(`${this.namespaceLog} getStatesOf not processed because Objects database not connected`);\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        if (!parentDevice) {\n            parentDevice = '';\n        } else {\n            if (this._namespaceRegExp.test(parentDevice)) {\n                parentDevice = parentDevice.substring(this.namespace.length + 1);\n            }\n\n            parentDevice = parentDevice.replace(FORBIDDEN_CHARS, '_').replace(/\\./g, '_');\n        }\n\n        if (!parentChannel) {\n            parentChannel = '';\n        } else if (this._namespaceRegExp.test(parentChannel)) {\n            parentChannel = parentChannel.substring(this.namespace.length + 1);\n        }\n\n        if (parentDevice && parentChannel && parentChannel.substring(0, parentDevice.length) === parentDevice) {\n            parentChannel = parentChannel.substring(parentDevice.length + 1);\n        }\n\n        parentChannel = parentChannel.replace(FORBIDDEN_CHARS, '_').replace(/\\./g, '_');\n\n        const id = `${this.namespace}.${this._DCS2ID(parentDevice, parentChannel, true)}`;\n\n        this.#objects.getObjectView(\n            'system',\n            'state',\n            {\n                startkey: id,\n                endkey: `${id}\\u9999`,\n            },\n            options,\n            (err, obj) => {\n                if (err || !obj || !obj.rows || !obj.rows.length) {\n                    return tools.maybeCallbackWithError(callback, err, err ? undefined : []);\n                }\n                const res: ioBroker.StateObject[] = [];\n                let read = 0;\n                for (const row of obj.rows) {\n                    read++;\n                    this.#objects!.getObject(row.id, (err, subObj) => {\n                        if (subObj) {\n                            res.push(subObj as ioBroker.StateObject);\n                        }\n\n                        if (!--read) {\n                            return tools.maybeCallbackWithError(callback, null, res);\n                        }\n                    });\n                }\n            },\n        );\n    }\n\n    // external signature\n    addStateToEnum(\n        enumName: string,\n        addTo: string,\n        parentDevice: string,\n        parentChannel: string,\n        stateName: string,\n        callback?: ioBroker.ErrorCallback,\n    ): void;\n    addStateToEnum(\n        enumName: string,\n        addTo: string,\n        parentDevice: string,\n        parentChannel: string,\n        stateName: string,\n        options: unknown,\n        callback?: ioBroker.ErrorCallback,\n    ): void;\n    addStateToEnum(\n        enumName: unknown,\n        addTo: unknown,\n        parentDevice: unknown,\n        parentChannel: unknown,\n        stateName: unknown,\n        options: unknown,\n        callback?: unknown,\n    ): any {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        Validator.assertString(enumName, 'enumName');\n        Validator.assertString(addTo, 'addTo');\n        Validator.assertString(parentDevice, 'parentDevice');\n        Validator.assertString(parentChannel, 'parentChannel');\n        Validator.assertString(stateName, 'stateName');\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n        Validator.assertOptionalCallback(callback, 'callback');\n\n        return this._addStateToEnum({ enumName, addTo, parentDevice, parentChannel, stateName, options, callback });\n    }\n\n    private _addStateToEnum(_options: InternalAddStateToEnumOptions): Promise<void> | void {\n        const { addTo, options, callback } = _options;\n        let { enumName, parentDevice, parentChannel, stateName } = _options;\n\n        if (!this.#objects) {\n            this._logger.info(\n                `${this.namespaceLog} addStateToEnum not processed because Objects database not connected`,\n            );\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        if (parentDevice) {\n            if (this._namespaceRegExp.test(parentDevice)) {\n                parentDevice = parentDevice.substring(this.namespace.length + 1);\n            }\n\n            parentDevice = parentDevice.replace(FORBIDDEN_CHARS, '_').replace(/\\./g, '_');\n        }\n\n        if (parentChannel) {\n            if (this._namespaceRegExp.test(parentChannel)) {\n                parentChannel = parentChannel.substring(this.namespace.length + 1);\n            }\n            if (parentDevice && parentChannel.substring(0, parentDevice.length) === parentDevice) {\n                parentChannel = parentChannel.substring(parentDevice.length + 1);\n            }\n\n            parentChannel = parentChannel.replace(FORBIDDEN_CHARS, '_').replace(/\\./g, '_');\n        }\n\n        if (this._namespaceRegExp.test(stateName)) {\n            stateName = stateName.substring(this.namespace.length + 1);\n        }\n        if (parentDevice && stateName.substring(0, parentDevice.length) === parentDevice) {\n            stateName = stateName.substring(parentDevice.length + 1);\n        }\n        if (parentChannel && stateName.substring(0, parentChannel.length) === parentChannel) {\n            stateName = stateName.substring(parentChannel.length + 1);\n        }\n        stateName = stateName.replace(FORBIDDEN_CHARS, '_').replace(/\\./g, '_');\n\n        const objId = this._utils.fixId({ device: parentDevice, channel: parentChannel, state: stateName });\n\n        if (addTo.startsWith('enum.')) {\n            this.#objects.getObject(addTo, options, (err, obj) => {\n                if (err || !obj) {\n                    return tools.maybeCallbackWithError(callback, err || tools.ERRORS.ERROR_NOT_FOUND);\n                }\n\n                if (!obj.common.members.includes(objId)) {\n                    obj.common.members.push(objId);\n                    obj.from = `system.adapter.${this.namespace}`;\n                    obj.user = options?.user || SYSTEM_ADMIN_USER;\n                    obj.ts = Date.now();\n                    this.#objects!.setObject(obj._id, obj, options, callback);\n                } else {\n                    return tools.maybeCallback(callback);\n                }\n            });\n        } else {\n            if (enumName.startsWith('enum.')) {\n                enumName = enumName.substring(5);\n            }\n\n            this.#objects.getObject(`enum.${enumName}.${addTo}`, options, (err, obj) => {\n                if (!err && obj) {\n                    // @ts-expect-error cast to enum object\n                    if (!obj.common.members.includes(objId)) {\n                        obj.common.members!.push(objId);\n                        obj.from = `system.adapter.${this.namespace}`;\n                        obj.user = options?.user || SYSTEM_ADMIN_USER;\n                        obj.ts = Date.now();\n                        this.#objects!.setObject(obj._id, obj, callback);\n                    } else {\n                        return tools.maybeCallback(callback);\n                    }\n                } else {\n                    if (err) {\n                        return tools.maybeCallbackWithError(callback, err);\n                    }\n\n                    // Create enum\n                    this.#objects!.setObject(\n                        `enum.${enumName}.${addTo}`,\n                        {\n                            common: {\n                                name: addTo,\n                                members: [objId],\n                            },\n                            from: `system.adapter.${this.namespace}`,\n                            ts: Date.now(),\n                            type: 'enum',\n                            native: {},\n                        },\n                        options,\n                        callback,\n                    );\n                }\n            });\n        }\n    }\n\n    // external signature\n    deleteStateFromEnum(\n        enumName: string,\n        parentDevice: string,\n        parentChannel: string,\n        stateName: string,\n        callback?: ioBroker.ErrorCallback,\n    ): void;\n    deleteStateFromEnum(\n        enumName: string,\n        parentDevice: string,\n        parentChannel: string,\n        stateName: string,\n        options: unknown,\n        callback?: ioBroker.ErrorCallback,\n    ): void;\n    deleteStateFromEnum(\n        enumName: unknown,\n        parentDevice: unknown,\n        parentChannel: unknown,\n        stateName: unknown,\n        options: unknown,\n        callback?: unknown,\n    ): any {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        Validator.assertString(enumName, 'enumName');\n        Validator.assertString(parentDevice, 'parentDevice');\n        Validator.assertString(parentChannel, 'parentChannel');\n        Validator.assertString(stateName, 'stateName');\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n        Validator.assertOptionalCallback(callback, 'callback');\n\n        return this._deleteStateFromEnum({ enumName, parentDevice, parentChannel, stateName, options, callback });\n    }\n\n    private _deleteStateFromEnum(_options: InternalDeleteStateFromEnumOptions): Promise<void> | void {\n        const { options, callback } = _options;\n        let { enumName, parentDevice, parentChannel, stateName } = _options;\n\n        if (!this.#objects) {\n            this._logger.info(\n                `${this.namespaceLog} deleteStateFromEnum not processed because Objects database not connected`,\n            );\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        if (parentDevice) {\n            if (this._namespaceRegExp.test(parentDevice)) {\n                parentDevice = parentDevice.substring(this.namespace.length + 1);\n            }\n\n            parentDevice = parentDevice.replace(FORBIDDEN_CHARS, '_').replace(/\\./g, '_');\n        }\n\n        if (parentChannel) {\n            if (this._namespaceRegExp.test(parentChannel)) {\n                parentChannel = parentChannel.substring(this.namespace.length + 1);\n            }\n            if (parentDevice && parentChannel.substring(0, parentDevice.length) === parentDevice) {\n                parentChannel = parentChannel.substring(parentDevice.length + 1);\n            }\n\n            parentChannel = parentChannel.replace(FORBIDDEN_CHARS, '_').replace(/\\./g, '_');\n        }\n\n        if (this._namespaceRegExp.test(stateName)) {\n            stateName = stateName.substring(this.namespace.length + 1);\n        }\n        if (parentDevice && stateName.substring(0, parentDevice.length) === parentDevice) {\n            stateName = stateName.substring(parentDevice.length + 1);\n        }\n        if (parentChannel && stateName.substring(0, parentChannel.length) === parentChannel) {\n            stateName = stateName.substring(parentChannel.length + 1);\n        }\n        stateName = stateName.replace(FORBIDDEN_CHARS, '_').replace(/\\./g, '_');\n\n        const objId = this._utils.fixId(\n            {\n                device: parentDevice,\n                channel: parentChannel,\n                state: stateName,\n            },\n            false /*, 'state'*/,\n        );\n\n        if (enumName) {\n            enumName = `enum.${enumName}.`;\n        } else {\n            enumName = 'enum.';\n        }\n\n        this.#objects.getObjectView(\n            'system',\n            'enum',\n            {\n                startkey: enumName,\n                endkey: `${enumName}\\u9999`,\n            },\n            options,\n            async (err, res) => {\n                if (err || !res) {\n                    return tools.maybeCallbackWithError(callback, err);\n                }\n\n                for (const row of res.rows) {\n                    try {\n                        const obj = await this.#objects!.getObjectAsync(row.id);\n                        if (obj && obj.common && obj.common.members) {\n                            const pos = obj.common.members.indexOf(objId);\n                            if (pos !== -1) {\n                                obj.common.members.splice(pos, 1);\n                                obj.from = `system.adapter.${this.namespace}`;\n                                obj.user = options?.user || SYSTEM_ADMIN_USER;\n                                obj.ts = Date.now();\n                                await this.#objects!.setObjectAsync(obj._id, obj);\n                            }\n                        }\n                    } catch (e) {\n                        return tools.maybeCallbackWithError(callback, e);\n                    }\n                }\n                return tools.maybeCallback(callback);\n            },\n        );\n    }\n    // external signature\n    chmodFile(\n        adapter: string | null,\n        path: string,\n        options: { mode: number | string } | Record<string, any>,\n        callback: ioBroker.ChownFileCallback,\n    ): void;\n\n    chmodFile(adapter: string | null, path: string, callback: ioBroker.ChownFileCallback): void;\n\n    /**\n     * Change file access rights\n     *\n     * This function updates the file access rights\n     * ```js\n     *      adapter.chmodFile('vis-2.0', '/main/vis-views.json', {mode: 0x644}, function (err, processed) {\n     *        if (err) adapter.log.error('Cannot read file: ' + err);\n     *        adapter.log.info('New files: ' + JSON.stringify(processed));\n     *      });\n     * ```\n     *\n     * @param _adapter adapter name. If the adapter name is null, so the name (not instance) of the current adapter will be taken.\n     * @param path path to file without adapter name. E.g., If you want to update \"/vis-2.0/main/*\", here must be \"/main/*\" and _adapter must be equal to \"vis-2.0\".\n     * @param options data with mode\n     * @param callback return result\n     *        ```js\n     *            function (err, processedFiles) {\n     *                list of processed files with new groups\n     *            }\n     *        ```\n     */\n    chmodFile(_adapter: unknown, path: unknown, options: unknown, callback?: unknown): any {\n        if (_adapter === null) {\n            _adapter = this.name;\n        }\n\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n        if (!this.#objects) {\n            this._logger.info(`${this.namespaceLog} chmodFile not processed because Objects database not connected`);\n            return tools.maybeCallbackWithError(callback as any, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        this.#objects.chmodFile(_adapter as any, path as any, options as any, callback as any);\n    }\n\n    chownFile(\n        _adapter: string,\n        path: string,\n        options: unknown,\n        callback: (err?: Error | null, processedFiles?: any) => void,\n    ): void;\n\n    chownFile(_adapter: string, path: string, callback: (err?: Error | null, processedFiles?: any) => void): void;\n\n    /**\n     * Change a file owner\n     *\n     * This function updates the file owner and ownerGroup\n     * ```js\n     *      adapter.chownFile('vis-2.0', '/main/vis-views.json', {owner: 'newOwner', ownerGroup: 'newgroup'}, function (err, processed) {\n     *        if (err) adapter.log.error('Cannot read file: ' + err);\n     *        adapter.log.info('New files: ' + JSON.stringify(processed));\n     *      });\n     * ```\n     *\n     * @param _adapter adapter name. If the adapter name is null, so the name (not instance) of the current adapter will be taken.\n     * @param path path to file without adapter name. E.g., If you want to update \"/vis-2.0/main/*\", here must be \"/main/*\" and _adapter must be equal to \"vis-2.0\".\n     * @param options data with owner and ownerGroup\n     * @param callback return result\n     *        ```js\n     *            function (err, processedFiles) {\n     *                list of processed files with new groups\n     *            }\n     *        ```\n     */\n    chownFile(_adapter: unknown, path: unknown, options: unknown, callback?: unknown): any {\n        if (_adapter === null) {\n            _adapter = this.name;\n        }\n\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n        if (!this.#objects) {\n            this._logger.info(`${this.namespaceLog} chownFile not processed because Objects database not connected`);\n            return tools.maybeCallbackWithError(callback as any, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        this.#objects.chownFile(_adapter as string, path as string, options as any, callback as any);\n    }\n\n    // external signatures\n    readDir(adapterName: string | null, path: string, callback: ioBroker.ReadDirCallback): void;\n    readDir(adapterName: string | null, path: string, options: unknown, callback: ioBroker.ReadDirCallback): void;\n\n    /**\n     * Read directory from DB.\n     *\n     * This function reads the content of directory from DB for given adapter and path.\n     * If getEnum called with no enum specified, all enums will be returned:\n     * ```js\n     *      adapter.readDir('vis-2.0', '/main/', function (err, filesOrDirs) {\n     *        // All enums\n     *        if (err) adapter.log.error('Cannot read directory: ' + err);\n     *        if (filesOrDirs) {\n     *           for (var f = 0; f < filesOrDirs.length; f++) {\n     *              adapter.log.debug('Directory main has the following files and dirs: ' + filesOrDirs[f].file + '[dir - ' + filesOrDirs[f].isDir + ']');\n     *           }\n     *       }\n     *      });\n     * ```\n     *\n     * @param _adapter adapter name. If the adapter name is null, so the name (not instance) of the current adapter will be taken.\n     * @param path path to directory without adapter name. E.g., If you want to read \"/vis-2.0/main/views.json\", here must be \"/main/views.json\" and _adapter must be equal to \"vis-2.0\".\n     * @param options optional user context\n     * @param callback return result\n     *        ```js\n     *            function (err, filesOrDirs) {\n     *                // filesOrDirs is array with elements like\n     *                // {\n     *                //      file:       'views.json,\n     *                //      stats:      node.js stats object like https://nodejs.org/api/fs.html#fs_class_fs_stats ,\n     *                //      isDir:      true/false,\n     *                //      acl:        access control list object,\n     *                //      modifiedAt: time when modified,\n     *                //      createdAt:  time when created\n     *                // }\n     *            }\n     *        ```\n     */\n    readDir(_adapter: unknown, path: unknown, options: unknown, callback?: unknown): any {\n        if (_adapter === null) {\n            _adapter = this.name;\n        }\n\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        Validator.assertCallback(callback, 'callback');\n        Validator.assertString(_adapter, '_adapter');\n        Validator.assertString(path, 'path');\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n\n        if (!this.#objects) {\n            this._logger.info(`${this.namespaceLog} readDir not processed because Objects database not connected`);\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        this.#objects.readDir(_adapter, path, options, callback);\n    }\n\n    // public signature\n    unlink(adapterName: string | null, path: string, callback: ioBroker.ErrnoCallback): void;\n    unlink(adapterName: string | null, path: string, options: unknown, callback: ioBroker.ErrnoCallback): void;\n    unlink(_adapter: unknown, name: unknown, options: unknown, callback?: unknown): any {\n        if (_adapter === null) {\n            _adapter = this.name;\n        }\n\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        Validator.assertOptionalCallback(callback, 'callback');\n        Validator.assertString(_adapter, '_adapter');\n        Validator.assertString(name, 'name');\n        if (options !== undefined && options !== null) {\n            Validator.assertObject(options, 'options');\n        }\n\n        if (!this.#objects) {\n            this._logger.info(`${this.namespaceLog} unlink not processed because Objects database not connected`);\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        this.#objects.unlink(_adapter, name, options, callback);\n    }\n\n    // external signatures\n    rename(adapterName: string | null, oldName: string, newName: string, callback: ioBroker.ErrnoCallback): void;\n    rename(\n        adapterName: string | null,\n        oldName: string,\n        newName: string,\n        options: unknown,\n        callback: ioBroker.ErrnoCallback,\n    ): void;\n\n    rename(_adapter: unknown, oldName: unknown, newName: unknown, options: unknown, callback?: unknown): any {\n        if (_adapter === null) {\n            _adapter = this.name;\n        }\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        Validator.assertOptionalCallback(callback, 'callback');\n        Validator.assertString(oldName, 'oldName');\n        Validator.assertString(newName, 'newName');\n        Validator.assertString(_adapter, '_adapter');\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n\n        if (!this.#objects) {\n            this._logger.info(`${this.namespaceLog} rename not processed because Objects database not connected`);\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        this.#objects.rename(_adapter, oldName, newName, options, callback);\n    }\n\n    mkdir(adapterName: string | null, path: string, callback: ioBroker.ErrnoCallback): void;\n    mkdir(adapterName: string | null, path: string, options: unknown, callback: ioBroker.ErrnoCallback): void;\n    mkdir(_adapter: unknown, dirname: unknown, options: unknown, callback?: unknown): any {\n        if (_adapter === null) {\n            _adapter = this.name;\n        }\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        Validator.assertOptionalCallback(callback, 'callback');\n        Validator.assertString(_adapter, '_adapter');\n        Validator.assertString(dirname, 'dirname');\n        if (options !== undefined && options !== null) {\n            Validator.assertObject(options, 'options');\n        }\n\n        if (!this.#objects) {\n            this._logger.info(`${this.namespaceLog} mkdir not processed because Objects database not connected`);\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        this.#objects.mkdir(_adapter, dirname, options, callback);\n    }\n\n    readFile(adapterName: string | null, path: string, callback: ioBroker.ReadFileCallback): void;\n    readFile(adapterName: string | null, path: string, options: unknown, callback: ioBroker.ReadFileCallback): void;\n\n    /**\n     * Read file from DB.\n     *\n     * This function reads the content of one file from DB for given adapter and file name.\n     * ```js\n     *      adapter.readFile('vis-2.0', '/main/vis-views.json', function (err, data) {\n     *        // All enums\n     *        if (err) adapter.log.error('Cannot read file: ' + err);\n     *        adapter.log.info('Content of file is: ' + data);\n     *      });\n     * ```\n     *\n     * @param _adapter adapter name. If the adapter name is null, so the name (not instance) of the current adapter will be taken.\n     * @param filename path to file without adapter name. E.g., If you want to read \"/vis-2.0/main/views.json\", here must be \"/main/views.json\" and _adapter must be equal to \"vis-2.0\".\n     * @param options optional user context\n     * @param callback return result\n     *        ```js\n     *            function (err, data) {\n     *                // data is utf8 or binary Buffer depends on the file extension.\n     *            }\n     *        ```\n     */\n    readFile(_adapter: unknown, filename: unknown, options: unknown, callback?: unknown): any {\n        if (_adapter === null) {\n            _adapter = this.name;\n        }\n\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        Validator.assertString(_adapter, '_adapter');\n        Validator.assertString(filename, 'filename');\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n        Validator.assertCallback(callback, 'callback');\n\n        if (!this.#objects) {\n            this._logger.info(`${this.namespaceLog} readFile not processed because Objects database not connected`);\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        this.#objects.readFile(_adapter, filename, options, callback);\n    }\n\n    // external signatures\n    writeFile(adapterName: string | null, path: string, data: Buffer | string, callback: ioBroker.ErrnoCallback): void;\n    writeFile(\n        adapterName: string | null,\n        path: string,\n        data: Buffer | string,\n        options: unknown,\n        callback: ioBroker.ErrnoCallback,\n    ): void;\n\n    /**\n     * Write file to DB.\n     *\n     * This function writes the content of one file into DB for given adapter and file name.\n     * ```js\n     *      adapter.writeFile('vis-2.0', '/main/vis-views.json', data, function (err) {\n     *        err && adapter.log.error('Cannot write file: ' + err);\n     *      });\n     * ```\n     *\n     * @param _adapter adapter name. If the adapter name is null, so the name (not instance) of the current adapter will be taken.\n     * @param filename path to file without adapter name. E.g., If you want to read \"/vis-2.0/main/views.json\", here must be \"/main/views.json\" and _adapter must be equal to \"vis-2.0\".\n     * @param data data as UTF8 string or buffer depends on the file extension.\n     * @param options optional user context\n     * @param callback return result\n     *        ```js\n     *            function (err) {\n     *\n     *            }\n     *        ```\n     */\n    writeFile(_adapter: unknown, filename: unknown, data: unknown, options: unknown, callback?: unknown): MaybePromise {\n        if (_adapter === null) {\n            _adapter = this.name;\n        }\n\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        Validator.assertString(_adapter, '_adapter');\n        Validator.assertString(filename, 'filename');\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n        Validator.assertOptionalCallback(callback, 'callback');\n        if (typeof data !== 'string') {\n            Validator.assertBuffer(data, 'data');\n        }\n\n        if (!this.#objects) {\n            this._logger.info(`${this.namespaceLog} writeFile not processed because Objects database not connected`);\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        return this.#objects.writeFile(_adapter, filename, data, options, callback);\n    }\n\n    fileExists(adapterName: string | null, path: string): Promise<boolean>;\n    fileExists(adapterName: string | null, path: string, callback?: ioBroker.GenericCallback<boolean>): void;\n    fileExists(\n        adapterName: string | null,\n        path: string,\n        options: unknown,\n        callback: ioBroker.GenericCallback<boolean>,\n    ): void;\n\n    /**\n     * Checks if file exists in DB.\n     *\n     * @param _adapter adapter name\n     * @param filename path to file without adapter name. E.g., If you want to check \"/vis-2.0/main/views.json\", here must be \"/main/views.json\" and _adapter must be equal to \"vis-2.0\".\n     * @param options optional user context\n     * @param callback cb function if none provided, a promise is returned\n     */\n    async fileExists(\n        _adapter: unknown,\n        filename: unknown,\n        options?: unknown,\n        callback?: unknown,\n    ): Promise<boolean | void> {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        Validator.assertOptionalCallback(callback, 'callback');\n        Validator.assertString(_adapter, '_adapter');\n        Validator.assertString(filename, 'filename');\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n\n        if (!this.#objects) {\n            this._logger.info(`${this.namespaceLog} fileExists not processed because Objects database not connected`);\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        try {\n            const exists = await this.#objects.fileExists(_adapter, filename, options);\n            return tools.maybeCallbackWithError(callback, null, exists);\n        } catch (e) {\n            return tools.maybeCallbackWithError(callback, e);\n        }\n    }\n\n    // external signatures\n    formatValue(value: number | string, format?: string): string;\n    formatValue(value: number | string, decimals: number, format?: string): string;\n    formatValue(value: unknown, decimals: unknown, _format?: unknown): any {\n        if (typeof decimals !== 'number') {\n            _format = decimals;\n            decimals = 2;\n        }\n\n        const format =\n            // @ts-expect-error fix later\n            !_format || _format.length !== 2\n                ? this.isFloatComma === undefined\n                    ? '.,'\n                    : this.isFloatComma\n                      ? '.,'\n                      : ',.'\n                : _format;\n\n        if (typeof value !== 'number') {\n            // @ts-expect-error fix later\n            value = parseFloat(value);\n        }\n        // @ts-expect-error fix later\n        return isNaN(value)\n            ? ''\n            : // @ts-expect-error fix later\n              value\n                  .toFixed(decimals)\n                  // @ts-expect-error fix later\n                  .replace(format[0], format[1])\n                  // @ts-expect-error fix later\n                  .replace(/\\B(?=(\\d{3})+(?!\\d))/g, format[0]);\n    }\n\n    // external signature\n    formatDate(dateObj: string | Date | number, format?: string): string;\n    formatDate(dateObj: string | Date | number, isDuration: boolean | string, format?: string): string;\n\n    formatDate(dateObj: unknown, isDuration: unknown, _format?: unknown): any {\n        if ((typeof isDuration === 'string' && isDuration.toLowerCase() === 'duration') || isDuration === true) {\n            isDuration = true;\n        }\n        if (typeof isDuration !== 'boolean') {\n            _format = isDuration;\n            isDuration = false;\n        }\n\n        if (!dateObj) {\n            return '';\n        }\n\n        Validator.assertBoolean(isDuration, 'isDuration');\n        if (_format !== undefined) {\n            Validator.assertString(_format, 'format');\n        }\n\n        return this._formatDate({ dateObj: dateObj as any, isDuration, _format });\n    }\n\n    private _formatDate(_options: InternalFormatDateOptions): string {\n        const { _format, dateObj: _dateObj } = _options;\n        let { isDuration } = _options;\n\n        let dateObj: Date;\n\n        if (typeof _dateObj === 'string') {\n            dateObj = new Date(_dateObj);\n        }\n\n        if (typeof _dateObj !== 'object') {\n            const j = typeof _dateObj === 'number' ? _dateObj : parseInt(_dateObj, 10);\n            if (j === _dateObj) {\n                // may this is interval\n                if (j < 946681200) {\n                    isDuration = true;\n                    dateObj = new Date(_dateObj);\n                } else {\n                    // if less 2000.01.01 00:00:00\n                    dateObj = j < 946681200000 ? new Date(j * 1_000) : new Date(j);\n                }\n            } else {\n                dateObj = new Date(_dateObj);\n            }\n        } else {\n            dateObj = _dateObj;\n        }\n        const format = _format || this.dateFormat || 'DD.MM.YYYY';\n\n        if (isDuration) {\n            dateObj.setMilliseconds(dateObj.getMilliseconds() + dateObj.getTimezoneOffset() * 60 * 1_000);\n        }\n\n        const validFormatChars = 'YJ\u0413M\u041CDT\u0414hS\u0447m\u043Cs\u0441';\n        let s = '';\n        let result = '';\n\n        const put = (s: string): string => {\n            let v: number | string = '';\n            switch (s) {\n                case 'YYYY':\n                case 'JJJJ':\n                case '\u0413\u0413\u0413\u0413':\n                case 'YY':\n                case 'JJ':\n                case '\u0413\u0413':\n                    v = dateObj.getFullYear();\n                    if (s.length === 2) {\n                        v %= 100;\n                    }\n                    if (v <= 9) {\n                        v = `0${v}`;\n                    }\n                    break;\n                case 'MM':\n                case 'M':\n                case '\u041C\u041C':\n                case '\u041C':\n                    v = dateObj.getMonth() + 1;\n                    if (v < 10 && s.length === 2) {\n                        v = `0${v}`;\n                    }\n                    break;\n                case 'DD':\n                case 'TT':\n                case 'D':\n                case 'T':\n                case '\u0414\u0414':\n                case '\u0414':\n                    v = dateObj.getDate();\n                    if (v < 10 && s.length === 2) {\n                        v = `0${v}`;\n                    }\n                    break;\n                case 'hh':\n                case 'SS':\n                case 'h':\n                case 'S':\n                case '\u0447\u0447':\n                case '\u0447':\n                    v = dateObj.getHours();\n                    if (v < 10 && s.length === 2) {\n                        v = `0${v}`;\n                    }\n                    break;\n                case 'mm':\n                case 'm':\n                case '\u043C\u043C':\n                case '\u043C':\n                    v = dateObj.getMinutes();\n                    if (v < 10 && s.length === 2) {\n                        v = `0${v}`;\n                    }\n                    break;\n                case 'ss':\n                case 's':\n                case 'cc':\n                case 'c':\n                    v = dateObj.getSeconds();\n                    if (v < 10 && s.length === 2) {\n                        v = `0${v}`;\n                    }\n                    v = v.toString();\n                    break;\n                case 'sss':\n                case '\u0441\u0441\u0441':\n                    v = dateObj.getMilliseconds();\n                    if (v < 10) {\n                        v = `00${v}`;\n                    } else if (v < 100) {\n                        v = `0${v}`;\n                    }\n                    v = v.toString();\n            }\n            return (result += v);\n        };\n\n        for (let i = 0; i < format.length; i++) {\n            if (validFormatChars.includes(format[i])) {\n                s += format[i];\n            } else {\n                put(s);\n                s = '';\n                result += format[i];\n            }\n        }\n        put(s);\n        return result;\n    }\n\n    sendTo(\n        instanceName: string,\n        message: any,\n        callback?: ioBroker.MessageCallback | ioBroker.MessageCallbackInfo,\n    ): void;\n    sendTo(\n        instanceName: string,\n        command: string,\n        message: any,\n        callback?: ioBroker.MessageCallback | ioBroker.MessageCallbackInfo,\n        options?: SendToOptions,\n    ): void;\n\n    /**\n     * Send message to other adapter instance or all instances of adapter.\n     *\n     * This function sends a message to specific instance or all instances of some specific adapter.\n     * If no instance given (e.g. \"pushover\"), the callback argument will be ignored. Because normally many responses will come.\n     *\n     * @param instanceName name of the instance where the message must be sent to. E.g. \"pushover.0\" or \"system.adapter.pushover.0\".\n     * @param command command name, like \"send\", \"browse\", \"list\". Command is depend on target adapter implementation.\n     * @param message object that will be given as argument for request\n     * @param callback optional return result\n     *        ```js\n     *            function (result) {\n     *              // result is target adapter specific and can vary from adapter to adapter\n     *              if (!result) adapter.log.error('No response received');\n     *            }\n     *        ```\n     * @param options optional options to define a timeout. This allows to get an error callback if no answer received in time (only if target is specific instance)\n     */\n    sendTo(instanceName: unknown, command: unknown, message: unknown, callback?: unknown, options?: unknown): any {\n        if (typeof message === 'function' && typeof callback === 'undefined') {\n            callback = message;\n            message = undefined;\n        }\n        if (typeof message === 'undefined') {\n            message = command;\n            command = 'send';\n        }\n\n        Validator.assertString(instanceName, 'instanceName');\n        Validator.assertString(command, 'command');\n\n        if (!tools.isObject(callback)) {\n            Validator.assertOptionalCallback(callback, 'callback');\n        }\n\n        if (options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n\n        return this._sendTo({\n            instanceName,\n            command,\n            message,\n            options,\n            callback: callback as ioBroker.MessageCallbackInfo | ioBroker.MessageCallback,\n        });\n    }\n\n    /**\n     * Async version of sendTo\n     * As we have a special case (first arg can be error or result, we need to promisify manually)\n     *\n     * @param instanceName name of the instance where the message must be sent to. E.g. \"pushover.0\" or \"system.adapter.pushover.0\".\n     * @param command command name, like \"send\", \"browse\", \"list\". Command is depend on target adapter implementation.\n     * @param message object that will be given as argument for request\n     * @param options optional options to define a timeout. This allows to get an error callback if no answer received in time (only if target is specific instance)\n     */\n    sendToAsync(instanceName: unknown, command: unknown, message?: unknown, options?: unknown): any {\n        return new Promise((resolve, reject) => {\n            const callback: ioBroker.MessageCallback = resOrError => {\n                if (resOrError instanceof Error) {\n                    reject(resOrError);\n                }\n\n                resolve(resOrError);\n            };\n\n            // validation takes place inside sendTo so skip here\n            this.sendTo(\n                instanceName as string,\n                command as string,\n                message as string,\n                callback,\n                options as SendToOptions,\n            );\n        });\n    }\n\n    private async _sendTo(_options: InternalSendToOptions): Promise<void> {\n        const { command, message, callback, options } = _options;\n        let { instanceName } = _options;\n\n        const obj: ioBroker.SendableMessage = {\n            command,\n            message,\n            from: `system.adapter.${this.namespace}`,\n        };\n\n        if (!instanceName) {\n            // @ts-expect-error TODO it could also be the cb object\n            return tools.maybeCallbackWithError(callback, 'No instanceName provided or not a string');\n        }\n\n        if (!instanceName.startsWith('system.adapter.')) {\n            instanceName = `system.adapter.${instanceName}`;\n        }\n\n        if (!this.#states) {\n            // if states is no longer existing, we do not need to unsubscribe\n            this._logger.info(`${this.namespaceLog} sendTo not processed because States database not connected`);\n            // @ts-expect-error TODO it could also be the cb object\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        if (typeof message !== 'object') {\n            this._logger.silly(\n                `${this.namespaceLog} sendTo \"${command}\" to ${instanceName} from system.adapter.${this.namespace}: ${message}`,\n            );\n        } else {\n            this._logger.silly(\n                `${this.namespaceLog} sendTo \"${command}\" to ${instanceName} from system.adapter.${this.namespace}`,\n            );\n        }\n\n        // If not specific instance\n        if (!instanceName.match(/\\.[0-9]+$/)) {\n            if (!this.#objects) {\n                this._logger.info(`${this.namespaceLog} sendTo not processed because Objects database not connected`);\n                // @ts-expect-error TODO it could also be the cb object\n                return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n            }\n\n            try {\n                // Send it to all instances of adapter\n                const res = await this.#objects.getObjectView('system', 'instance', {\n                    startkey: `${instanceName}.`,\n                    endkey: `${instanceName}.\\u9999`,\n                });\n\n                if (res) {\n                    for (const row of res.rows) {\n                        try {\n                            await this.#states.pushMessage(row.id, obj);\n                        } catch (e) {\n                            // @ts-expect-error TODO it could also be the cb object\n                            return tools.maybeCallbackWithError(callback, e);\n                        }\n                    }\n                }\n            } catch {\n                //ignore\n            }\n        } else {\n            if (callback) {\n                if (typeof callback === 'function') {\n                    // force subscribe even no messagebox enabled\n                    if (!isMessageboxSupported(this.common!) && !this.mboxSubscribed) {\n                        this.mboxSubscribed = true;\n                        this.#states.subscribeMessage(`system.adapter.${this.namespace}`);\n                    }\n\n                    obj.callback = {\n                        message,\n                        id: this._callbackId++,\n                        ack: false,\n                        time: Date.now(),\n                    };\n                    if (this._callbackId >= 0xffffffff) {\n                        this._callbackId = 1;\n                    }\n\n                    const callbackId = obj.callback.id;\n\n                    let timer: undefined | NodeJS.Timeout;\n\n                    if (options?.timeout) {\n                        timer = setTimeout(() => {\n                            const callbackObj = this.messageCallbacks.get(callbackId);\n\n                            if (callbackObj) {\n                                callbackObj.cb(new Error('Timeout exceeded'));\n                                this.messageCallbacks.delete(callbackId);\n                            }\n                        }, options.timeout);\n                    }\n\n                    this.messageCallbacks.set(callbackId, { cb: callback, time: Date.now(), timer });\n\n                    // delete too old callbacks IDs\n                    const now = Date.now();\n                    for (const [_id, cb] of this.messageCallbacks) {\n                        if (now - cb.time > 3_600_000) {\n                            this.messageCallbacks.delete(_id);\n                        }\n                    }\n                } else {\n                    // callback is an object\n                    obj.callback = callback;\n                    obj.callback.ack = true;\n                }\n            }\n\n            try {\n                await this.#states.pushMessage(instanceName, obj);\n            } catch (e) {\n                // @ts-expect-error TODO it could also be the cb object\n                return tools.maybeCallbackWithError(callback, e);\n            }\n        }\n    }\n\n    sendToHost(\n        hostName: string | null,\n        message: any,\n        callback?: ioBroker.MessageCallback | ioBroker.MessageCallbackInfo,\n    ): void;\n    sendToHost(\n        hostName: string | null,\n        command: string,\n        message: any,\n        callback?: ioBroker.MessageCallback | ioBroker.MessageCallbackInfo,\n    ): void;\n\n    /**\n     * Send message to specific host or to all hosts.\n     *\n     * This function sends a message to specific host or all hosts.\n     * If no host name given (e.g. null), the callback argument will be ignored. Because normally many responses will come.\n     *\n     * @param hostName name of the host where the message must be sent to. E.g. \"myPC\" or \"system.host.myPC\". If argument is null, the message will be sent to all hosts.\n     * @param command command name. One of: \"cmdExec\", \"getRepository\", \"getInstalled\", \"getVersion\", \"getDiagData\", \"getLocationOnDisk\", \"getDevList\", \"getLogs\", \"delLogs\", \"readDirAsZip\", \"writeDirAsZip\", \"readObjectsAsZip\", \"writeObjectsAsZip\", \"checkLogging\". Commands can be checked in controller.js (function processMessage)\n     * @param message object that will be given as argument for request\n     * @param callback optional return result\n     *        ```js\n     *            function (result) {\n     *              // result is target adapter specific and can vary from command to command\n     *              if (!result) adapter.log.error('No response received');\n     *            }\n     *        ```\n     */\n    sendToHost(hostName: unknown, command: unknown, message: unknown, callback?: unknown): any {\n        if (typeof message === 'undefined') {\n            message = command;\n            command = 'send';\n        }\n\n        if (hostName !== null) {\n            Validator.assertString(hostName, 'hostName');\n        }\n\n        Validator.assertString(command, 'command');\n\n        if (!tools.isObject(callback)) {\n            Validator.assertOptionalCallback(callback, 'callback');\n        }\n\n        return this._sendToHost({\n            hostName,\n            command,\n            message,\n            callback: callback as ioBroker.MessageCallback | ioBroker.MessageCallbackInfo,\n        });\n    }\n\n    private async _sendToHost(_options: InternalSendToHostOptions): Promise<void> {\n        const { command, message, callback } = _options;\n        let { hostName } = _options;\n        const obj: Partial<ioBroker.Message> = { command, message, from: `system.adapter.${this.namespace}` };\n\n        if (!this.#states) {\n            // if states is no longer existing, we do not need to unsubscribe\n            this._logger.info(`${this.namespaceLog} sendToHost not processed because States database not connected`);\n            // @ts-expect-error TODO it could also be the cb object\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        if (hostName && !hostName.startsWith('system.host.')) {\n            hostName = `system.host.${hostName}`;\n        }\n\n        if (!hostName) {\n            if (!this.#objects) {\n                this._logger.info(\n                    `${this.namespaceLog} sendToHost not processed because Objects database not connected`,\n                );\n                // @ts-expect-error TODO it could also be the cb object\n                return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n            }\n\n            // Send to all hosts\n            this.#objects.getObjectList(\n                {\n                    startkey: 'system.host.',\n                    endkey: `system.host.\\u9999`,\n                },\n                null,\n                async (err, res) => {\n                    if (!this.#states) {\n                        // if states is no longer existing, we do not need to unsubscribe\n                        return;\n                    }\n                    if (!err && res?.rows.length) {\n                        for (const row of res.rows) {\n                            const parts: string[] = row.id.split('.');\n                            // ignore system.host.name.alive and so on\n                            if (parts.length === 3) {\n                                try {\n                                    await this.#states.pushMessage(row.id, obj as any);\n                                } catch (e) {\n                                    // @ts-expect-error TODO it could also be the cb object\n                                    return tools.maybeCallbackWithError(callback, e);\n                                }\n                            }\n                        }\n                    }\n                },\n            );\n        } else {\n            if (callback) {\n                if (typeof callback === 'function') {\n                    // force subscribe even no messagebox enabled\n                    if (!isMessageboxSupported(this.common!) && !this.mboxSubscribed) {\n                        this.mboxSubscribed = true;\n                        this.#states.subscribeMessage(`system.adapter.${this.namespace}`);\n                    }\n\n                    obj.callback = {\n                        message,\n                        id: this._callbackId++,\n                        ack: false,\n                        time: Date.now(),\n                    };\n                    if (this._callbackId >= 0xffffffff) {\n                        this._callbackId = 1;\n                    }\n\n                    this.messageCallbacks.set(obj.callback.id, { cb: callback, time: Date.now() });\n                } else {\n                    // callback is an object\n                    obj.callback = callback;\n                    obj.callback.ack = true;\n                }\n            }\n\n            try {\n                await this.#states.pushMessage(hostName, obj as any);\n            } catch (e) {\n                // @ts-expect-error TODO it could also be the cb object\n                return tools.maybeCallbackWithError(callback, e);\n            }\n        }\n    }\n\n    sendToUI(options: SendToUserInterfaceClientOptions): Promise<void>;\n\n    /**\n     * Send a message to an active UI Client\n     *\n     * @param options clientId and data options\n     */\n    sendToUI(options: AllPropsUnknown<SendToUserInterfaceClientOptions>): Promise<void> {\n        if (!this.#states) {\n            throw new Error(tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        const { clientId, data } = options;\n\n        if (clientId === undefined) {\n            return this.uiMessagingController.sendToAllClients({\n                data,\n                states: this.#states,\n            });\n        }\n\n        Validator.assertString(clientId, 'clientId');\n\n        return this.uiMessagingController.sendToClient({\n            clientId,\n            data,\n            states: this.#states,\n        });\n    }\n\n    registerNotification<Scope extends keyof ioBroker.NotificationScopes>(\n        scope: Scope,\n        category: ioBroker.NotificationScopes[Scope] | null,\n        message: string,\n        options?: NotificationOptions,\n    ): Promise<void>;\n\n    /**\n     * Send notification with given scope and category to host of this adapter\n     *\n     * @param scope - scope to be addressed\n     * @param category - to be addressed, if a null message will be checked by regex of given scope\n     * @param message - message to be stored/checked\n     * @param options - Additional options for the notification, currently `contextData` is supported\n     */\n    async registerNotification(scope: unknown, category: unknown, message: unknown, options?: unknown): Promise<void> {\n        if (!this.#states) {\n            // if states is no longer existing, we do not need to set\n            this._logger.info(\n                `${this.namespaceLog} registerNotification not processed because States database not connected`,\n            );\n            throw new Error(tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        Validator.assertString(scope, 'scope');\n        if (category !== null) {\n            Validator.assertString(category, 'category');\n        }\n        Validator.assertString(message, 'message');\n\n        if (options !== undefined) {\n            Validator.assertObject<NotificationOptions>(options, 'options');\n        }\n\n        const obj = {\n            command: 'addNotification',\n            message: {\n                scope,\n                category,\n                message,\n                instance: this.namespace,\n                contextData: options?.contextData,\n            },\n            from: `system.adapter.${this.namespace}`,\n        };\n\n        await this.#states.pushMessage(`system.host.${this.host}`, obj as any);\n    }\n\n    // external signatures\n    setState<T extends ioBroker.SetStateCallback | undefined>(\n        id: string | ioBroker.IdObject,\n        state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState,\n        callback?: T,\n    ): T extends unknown ? ioBroker.SetStatePromise : void;\n    setState<T extends ioBroker.SetStateCallback | undefined>(\n        id: string | ioBroker.IdObject,\n        state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState,\n        ack: boolean,\n        callback?: T,\n    ): T extends unknown ? ioBroker.SetStatePromise : void;\n    setState<T extends ioBroker.SetStateCallback | undefined>(\n        id: string | ioBroker.IdObject,\n        state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState,\n        options?: Partial<GetUserGroupsOptions> | null,\n        callback?: T,\n    ): T extends unknown ? ioBroker.SetStatePromise : void;\n    setState<T extends ioBroker.SetStateCallback | undefined>(\n        id: string | ioBroker.IdObject,\n        state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState,\n        ack: boolean,\n        options?: Partial<GetUserGroupsOptions> | null,\n        callback?: T,\n    ): T extends unknown ? ioBroker.SetStatePromise : void;\n\n    /**\n     * Writes value into states DB.\n     *\n     * This function can write values into states DB for this adapter.\n     * Only Ids that belong to this adapter can be modified. So the function automatically adds \"adapter.X.\" to ID.\n     * ack, options and callback are optional\n     *\n     * @param id object ID of the state.\n     * @param state simple value or object with attributes.\n     *  If state is object and ack exists too as function argument, function argument has priority.\n     *  ```js\n     *      {\n     *          val:    value,\n     *          ack:    true|false,       // default - false; is command(false) or status(true)\n     *          ts:     timestampMS,      // default - now\n     *          q:      qualityAsNumber,  // default - 0 (ok)\n     *          from:   origin,           // default - this adapter\n     *          c:      comment,          // default - empty\n     *          expire: expireInSeconds   // default - 0\n     *          lc:     timestampMS       // default - automatic calculation\n     *      }\n     *  ```\n     * @param ack optional is command(false) or status(true)\n     * @param options optional user context\n     * @param callback optional return error and id\n     *        ```js\n     *            function (err, id) {\n     *              if (err) adapter.log.error('Cannot set value for \"' + id + '\": ' + err);\n     *            }\n     *        ```\n     */\n    setState(\n        id: unknown,\n        state: unknown,\n        ack: unknown,\n        options?: unknown,\n        callback?: unknown,\n    ): Promise<void | string> | void {\n        if (typeof state === 'object' && typeof ack !== 'boolean') {\n            callback = options;\n            options = ack;\n            ack = undefined;\n        }\n        if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n\n        if (typeof ack === 'function') {\n            callback = ack;\n            ack = undefined;\n        }\n\n        if (!tools.isObject(id)) {\n            // it can be id object or string\n            Validator.assertString(id, 'id');\n        }\n\n        if (ack !== undefined) {\n            Validator.assertBoolean(ack, 'ack');\n        }\n\n        Validator.assertOptionalCallback(callback, 'callback');\n\n        if (options !== undefined && options !== null) {\n            Validator.assertObject(options, 'options');\n        }\n\n        return this._setState({ id, state: state as ioBroker.SettableState, ack, options, callback });\n    }\n\n    private async _setState(_options: InternalSetStateOptions): Promise<void | string> {\n        const { state, ack, options, callback } = _options;\n        const { id } = _options;\n\n        if (!this.#states) {\n            // if states is no longer existing, we do not need to set\n            this._logger.info(`${this.namespaceLog} setState not processed because States database not connected`);\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n        if (!this.#objects) {\n            this._logger.info(`${this.namespaceLog} setState not processed because Objects database not connected`);\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        try {\n            this._utils.validateId(id, false, null);\n        } catch (e) {\n            return tools.maybeCallbackWithError(callback, e);\n        }\n\n        const fixedId = this._utils.fixId(id, false);\n        let stateObj: ioBroker.SettableState;\n\n        if (tools.isObject(state)) {\n            // Verify that the passed state object is valid\n            try {\n                this._utils.validateSetStateObjectArgument(state);\n                stateObj = state;\n            } catch (e) {\n                return tools.maybeCallbackWithError(callback, e);\n            }\n        } else {\n            // wrap non-object values in a state object\n            // @ts-expect-error fix later\n            stateObj = state !== undefined ? { val: state } : {};\n        }\n\n        if (stateObj.val === undefined && !Object.keys(stateObj).length) {\n            // undefined is not allowed as state.val -> return\n            return tools.maybeCallbackWithError(callback, 'undefined is not a valid state value');\n        }\n\n        if (ack !== undefined) {\n            stateObj.ack = ack;\n        }\n\n        // if state.from provided, we use it else, we set default property\n        stateObj.from =\n            typeof stateObj.from === 'string' && stateObj.from !== ''\n                ? stateObj.from\n                : `system.adapter.${this.namespace}`;\n        stateObj.user = options?.user || SYSTEM_ADMIN_USER;\n\n        let permCheckRequired = false;\n        if (options?.user && options.user !== SYSTEM_ADMIN_USER) {\n            permCheckRequired = true;\n        }\n\n        let obj: ioBroker.StateObject | null | undefined;\n        try {\n            if (permCheckRequired) {\n                obj = (await this._checkStates(fixedId, options || {}, 'setState')).objs[0];\n            } else {\n                obj = (await this.#objects.getObject(fixedId, options)) as ioBroker.StateObject | null | undefined;\n            }\n        } catch (e) {\n            return tools.maybeCallbackWithError(callback, e);\n        }\n\n        if (!this.#objects) {\n            // if objects is no longer existing, we do not need to unsubscribe\n            this._logger.info(\n                `${this.namespaceLog} setForeignState not processed because Objects database not connected`,\n            );\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        if (this.performStrictObjectChecks) {\n            // validate that object exists, read-only logic ok, type ok, etc. won't throw now\n            await this._utils.performStrictObjectCheck(fixedId, stateObj);\n        }\n\n        if (fixedId.startsWith(ALIAS_STARTS_WITH)) {\n            // write alias\n            if (obj?.common?.alias?.id) {\n                // id can be string or can have attribute write\n                const aliasId = tools.isObject(obj.common.alias.id) ? obj.common.alias.id.write : obj.common.alias.id;\n\n                // validate here because we use objects/states db directly\n                try {\n                    this._utils.validateId(aliasId, true, null);\n                } catch (e) {\n                    this._logger.warn(`${this.namespaceLog} Error validating alias id of ${fixedId}: ${e.message}`);\n                    return tools.maybeCallbackWithError(\n                        callback,\n                        `Error validating alias id of ${fixedId}: ${e.message}`,\n                    );\n                }\n\n                // check the rights\n                let targetObj;\n                try {\n                    if (permCheckRequired) {\n                        targetObj = (await this._checkStates(aliasId, options || {}, 'setState')).objs[0];\n                    } else {\n                        targetObj = (await this.#objects.getObject(aliasId, options)) as\n                            | ioBroker.StateObject\n                            | null\n                            | undefined;\n                    }\n                } catch (e) {\n                    return tools.maybeCallbackWithError(callback, e);\n                }\n\n                if (!this.#states) {\n                    // if states is no longer existing, we do not need to unsubscribe\n                    this._logger.info(\n                        `${this.namespaceLog} setForeignState not processed because States database not connected`,\n                    );\n                    return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n                }\n\n                // write target state\n                this.outputCount++;\n                try {\n                    const res = await this.#states.setState(\n                        aliasId,\n                        tools.formatAliasValue({\n                            sourceCommon: obj?.common,\n                            targetCommon: targetObj?.common,\n                            state: stateObj as ioBroker.State,\n                            logger: this._logger,\n                            logNamespace: this.namespaceLog,\n                            sourceId: obj?._id,\n                            targetId: targetObj?._id,\n                        }),\n                    );\n\n                    return tools.maybeCallbackWithError(callback, null, res);\n                } catch (e) {\n                    return tools.maybeCallbackWithError(callback, e);\n                }\n            } else {\n                this._logger.warn(`${this.namespaceLog} Alias ${fixedId} has no target 2`);\n                return tools.maybeCallbackWithError(callback, `Alias ${fixedId} has no target`);\n            }\n        } else {\n            if (!this.#states) {\n                // if states is no longer existing, we do not need to unsubscribe\n                this._logger.info(\n                    `${this.namespaceLog} setForeignState not processed because States database not connected`,\n                );\n                return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n            }\n\n            this.outputCount++;\n            try {\n                const res = await this.#states.setState(fixedId, stateObj);\n                return tools.maybeCallbackWithError(callback, null, res);\n            } catch (e) {\n                return tools.maybeCallbackWithError(callback, e);\n            }\n        }\n    }\n\n    // Cache will be cleared if user or group changes. Important! only if subscribed.\n    private async _getUserGroups(options: GetUserGroupsOptions): Promise<GetUserGroupsOptions> {\n        if (this.users[options.user]) {\n            options.groups = this.users[options.user].groups;\n            options.acl = this.users[options.user].acl;\n            return options;\n        }\n        options.groups = [];\n        let userAcl: ioBroker.UserObject | null | undefined;\n        try {\n            userAcl = await this.getForeignObjectAsync(options.user, null);\n        } catch {\n            // ignore\n        }\n\n        if (!userAcl) {\n            // User does not exists\n            this._logger.error(`${this.namespaceLog} unknown user \"${options.user}\"`);\n            return options;\n        }\n        let groups;\n        try {\n            groups = await this.getForeignObjectsAsync('*', 'group', null, null);\n        } catch {\n            // ignore\n        }\n\n        // aggregate all groups permissions, where this user is\n        if (groups) {\n            for (const group of Object.values(groups)) {\n                if (group.common.members.includes(options.user)) {\n                    options.groups.push(group._id);\n                }\n            }\n        }\n\n        // read all groups for this user\n        this.users[options.user] = {\n            groups: options.groups,\n            // @ts-expect-error TODO: UserCommon has no acl\n            acl: userAcl.common?.acl || {},\n        };\n        await this._getGroups(options.groups);\n        // combine all rights\n        const user = this.users[options.user];\n        for (const gName of options.groups) {\n            if (!this.groups[gName].common?.acl) {\n                continue;\n            }\n            const group = this.groups[gName];\n\n            if (group.common?.acl?.file) {\n                if (!user.acl || !user.acl.file) {\n                    user.acl = user.acl || {};\n                    user.acl.file = user.acl.file || {};\n\n                    user.acl.file.create = group.common.acl.file.create;\n                    user.acl.file.read = group.common.acl.file.read;\n                    user.acl.file.write = group.common.acl.file.write;\n                    user.acl.file.delete = group.common.acl.file.delete;\n                    user.acl.file.list = group.common.acl.file.list;\n                } else {\n                    user.acl.file.create = user.acl.file.create || group.common.acl.file.create;\n                    user.acl.file.read = user.acl.file.read || group.common.acl.file.read;\n                    user.acl.file.write = user.acl.file.write || group.common.acl.file.write;\n                    user.acl.file.delete = user.acl.file.delete || group.common.acl.file.delete;\n                    user.acl.file.list = user.acl.file.list || group.common.acl.file.list;\n                }\n            }\n\n            if (group.common?.acl?.object) {\n                if (!user.acl || !user.acl.object) {\n                    user.acl = user.acl || {};\n                    user.acl.object = user.acl.object || {};\n\n                    user.acl.object.create = group.common.acl.object.create;\n                    user.acl.object.read = group.common.acl.object.read;\n                    user.acl.object.write = group.common.acl.object.write;\n                    user.acl.object.delete = group.common.acl.object.delete;\n                    user.acl.object.list = group.common.acl.object.list;\n                } else {\n                    user.acl.object.create = user.acl.object.create || group.common.acl.object.create;\n                    user.acl.object.read = user.acl.object.read || group.common.acl.object.read;\n                    user.acl.object.write = user.acl.object.write || group.common.acl.object.write;\n                    user.acl.object.delete = user.acl.object.delete || group.common.acl.object.delete;\n                    user.acl.object.list = user.acl.object.list || group.common.acl.object.list;\n                }\n            }\n\n            if (group.common?.acl?.users) {\n                if (!user.acl || !user.acl.users) {\n                    user.acl = user.acl || {};\n                    user.acl.users = user.acl.users || {};\n\n                    user.acl.users.create = group.common.acl.users.create;\n                    user.acl.users.read = group.common.acl.users.read;\n                    user.acl.users.write = group.common.acl.users.write;\n                    user.acl.users.delete = group.common.acl.users.delete;\n                    user.acl.users.list = group.common.acl.users.list;\n                } else {\n                    user.acl.users.create = user.acl.users.create || group.common.acl.users.create;\n                    user.acl.users.read = user.acl.users.read || group.common.acl.users.read;\n                    user.acl.users.write = user.acl.users.write || group.common.acl.users.write;\n                    user.acl.users.delete = user.acl.users.delete || group.common.acl.users.delete;\n                    user.acl.users.list = user.acl.users.list || group.common.acl.users.list;\n                }\n            }\n            if (group.common?.acl?.state) {\n                if (!user.acl || !user.acl.state) {\n                    user.acl = user.acl || {};\n                    user.acl.state = user.acl.state || {};\n\n                    user.acl.state.create = group.common.acl.state.create;\n                    user.acl.state.read = group.common.acl.state.read;\n                    user.acl.state.write = group.common.acl.state.write;\n                    user.acl.state.delete = group.common.acl.state.delete;\n                    user.acl.state.list = group.common.acl.state.list;\n                } else {\n                    user.acl.state.create = user.acl.state.create || group.common.acl.state.create;\n                    user.acl.state.read = user.acl.state.read || group.common.acl.state.read;\n                    user.acl.state.write = user.acl.state.write || group.common.acl.state.write;\n                    user.acl.state.delete = user.acl.state.delete || group.common.acl.state.delete;\n                    user.acl.state.list = user.acl.state.list || group.common.acl.state.list;\n                }\n            }\n        }\n        options.acl = user.acl;\n        return options;\n    }\n\n    private _checkState(obj: ioBroker.StateObject, options: Record<string, any>, command: CheckStateCommand): boolean {\n        const limitToOwnerRights = options.limitToOwnerRights === true;\n        if (obj?.acl) {\n            obj.acl.state = obj.acl.state || obj.acl.object;\n\n            if (obj.acl.state) {\n                // If user is owner\n                if (options.user === obj.acl.owner) {\n                    if (command === 'setState' || command === 'delState') {\n                        if (command === 'delState' && !options.acl.state.delete) {\n                            this._logger.warn(\n                                `${this.namespaceLog} Permission error for user \"${options.user} on \"${obj._id}\": ${command}`,\n                            );\n                            return false;\n                        } else if (command === 'setState' && !options.acl.state.write) {\n                            this._logger.warn(\n                                `${this.namespaceLog} Permission error for user \"${options.user} on \"${obj._id}\": ${command}`,\n                            );\n                            return false;\n                        } else if (!(obj.acl.state & ACCESS_USER_WRITE)) {\n                            this._logger.warn(\n                                `${this.namespaceLog} Permission error for user \"${options.user} on \"${obj._id}\": ${command}`,\n                            );\n                            return false;\n                        }\n                    } else if (command === 'getState') {\n                        if (!(obj.acl.state & ACCESS_USER_READ) || !options.acl.state.read) {\n                            this._logger.warn(\n                                `${this.namespaceLog} Permission error for user \"${options.user} on \"${obj._id}\": ${command}`,\n                            );\n                            return false;\n                        }\n                    } else {\n                        this._logger.warn(\n                            `${this.namespaceLog} Called unknown command on \"${obj._id}\": ${command as any}`,\n                        );\n                    }\n                } else if (options.groups.includes(obj.acl.ownerGroup) && !limitToOwnerRights) {\n                    if (command === 'setState' || command === 'delState') {\n                        if (command === 'delState' && !options.acl.state.delete) {\n                            this._logger.warn(\n                                `${this.namespaceLog} Permission error for user \"${options.user} on \"${obj._id}\": ${command}`,\n                            );\n                            return false;\n                        } else if (command === 'setState' && !options.acl.state.write) {\n                            this._logger.warn(\n                                `${this.namespaceLog} Permission error for user \"${options.user} on \"${obj._id}\": ${command}`,\n                            );\n                            return false;\n                        } else if (!(obj.acl.state & ACCESS_GROUP_WRITE)) {\n                            this._logger.warn(\n                                `${this.namespaceLog} Permission error for user \"${options.user} on \"${obj._id}\": ${command}`,\n                            );\n                            return false;\n                        }\n                    } else if (command === 'getState') {\n                        if (!(obj.acl.state & ACCESS_GROUP_READ) || !options.acl.state.read) {\n                            this._logger.warn(\n                                `${this.namespaceLog} Permission error for user \"${options.user} on \"${obj._id}\": ${command}`,\n                            );\n                            return false;\n                        }\n                    } else {\n                        this._logger.warn(\n                            `${this.namespaceLog} Called unknown command on \"${obj._id}\": ${command as any}`,\n                        );\n                    }\n                } else if (!limitToOwnerRights) {\n                    if (command === 'setState' || command === 'delState') {\n                        if (command === 'delState' && !options.acl.state.delete) {\n                            this._logger.warn(\n                                `${this.namespaceLog} Permission error for user \"${options.user} on \"${obj._id}\": ${command}`,\n                            );\n                            return false;\n                        } else if (command === 'setState' && !options.acl.state.write) {\n                            this._logger.warn(\n                                `${this.namespaceLog} Permission error for user \"${options.user} on \"${obj._id}\": ${command}`,\n                            );\n                            return false;\n                        } else if (!(obj.acl.state & ACCESS_EVERY_WRITE)) {\n                            this._logger.warn(\n                                `${this.namespaceLog} Permission error for user \"${options.user}\" on \"${obj._id}\": ${command}`,\n                            );\n                            return false;\n                        }\n                    } else if (command === 'getState') {\n                        if (!(obj.acl.state & ACCESS_EVERY_READ) || !options.acl.state.read) {\n                            this._logger.warn(\n                                `${this.namespaceLog} Permission error for user \"${options.user}\"on \"${obj._id}\" : ${command}`,\n                            );\n                            return false;\n                        }\n                    } else {\n                        this._logger.warn(\n                            `${this.namespaceLog} Called unknown command on \"${obj._id}\": ${command as any}`,\n                        );\n                        return false;\n                    }\n                } else {\n                    this._logger.warn(`${this.namespaceLog} Permissions limited to Owner rights on \"${obj._id}\"`);\n                    return false;\n                }\n            } else if (limitToOwnerRights) {\n                this._logger.warn(`${this.namespaceLog} Permissions limited to Owner rights on \"${obj._id}\"`);\n                return false;\n            }\n        } else if (limitToOwnerRights) {\n            this._logger.warn(`${this.namespaceLog} Permissions limited to Owner rights on \"${obj._id}\"`);\n            return false;\n        }\n\n        return true;\n    }\n\n    private async _checkStates(\n        ids: string | string[],\n        options: Partial<GetUserGroupsOptions>,\n        command: CheckStateCommand,\n    ): Promise<CheckStatesResult> {\n        if (!options.groups) {\n            options = await this._getUserGroups(options as GetUserGroupsOptions);\n        }\n\n        if (!Array.isArray(ids)) {\n            ids = [ids];\n        }\n\n        if (options._objects) {\n            if (!ids.length) {\n                return { ids, objs: [] };\n            }\n\n            const objs: ioBroker.StateObject[] = [];\n\n            for (const obj of options._objects) {\n                if (obj && this._checkState(obj, options, command)) {\n                    objs.push(obj);\n                }\n            }\n\n            return { ids, objs };\n        }\n        const objs: ioBroker.StateObject[] = [];\n\n        for (const id of ids) {\n            let originalChecked: boolean | undefined;\n\n            if (options.checked !== undefined) {\n                originalChecked = options.checked;\n            }\n\n            options.checked = true;\n\n            if (!this.#objects) {\n                this._logger.info(\n                    `${this.namespaceLog} checkStates not processed because Objects database not connected`,\n                );\n\n                throw new Error(tools.ERRORS.ERROR_DB_CLOSED);\n            }\n\n            const obj = (await this.#objects.getObject(id, options)) as ioBroker.StateObject;\n\n            objs.push(obj);\n\n            if (originalChecked !== undefined) {\n                options.checked = originalChecked;\n            } else {\n                options.checked = undefined;\n            }\n\n            if (!this._checkState(obj, options, command)) {\n                throw new Error(ERROR_PERMISSION);\n            }\n        }\n\n        return { ids, objs };\n    }\n\n    private async _getGroups(ids: string[]): Promise<void> {\n        for (const id of ids) {\n            let obj;\n            try {\n                obj = (await this.getForeignObjectAsync(id)) as ioBroker.GroupObject;\n            } catch {\n                // ignore\n            }\n            if (this.groups[id] === undefined) {\n                this.groups[id] = obj || {};\n            }\n        }\n    }\n\n    private async _setStateChangedHelper(id: string, state: ioBroker.SettableState): Promise<SetStateChangedResult> {\n        if (!this.#objects) {\n            this._logger.info(\n                `${this.namespaceLog} setStateChanged not processed because Objects database not connected`,\n            );\n\n            throw new Error(tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        if (id.startsWith(ALIAS_STARTS_WITH)) {\n            let obj;\n            let err;\n            try {\n                obj = await this.#objects.getObject(id);\n            } catch (e) {\n                err = e;\n            }\n            if (obj?.common?.alias?.id) {\n                // id can be string or can have attribute write\n                const aliasId = tools.isObject(obj.common.alias.id) ? obj.common.alias.id.write : obj.common.alias.id;\n                return this._setStateChangedHelper(aliasId, state);\n            }\n            this._logger.warn(`${this.namespaceLog} ${err ? err.message : `Alias ${id} has no target 1`}`);\n            throw new Error(err ? err.message : `Alias ${id} has no target`);\n        } else {\n            const oldState = await this.getForeignStateAsync(id, null);\n\n            let differ = false;\n            if (!oldState) {\n                differ = true;\n            } else if (state.val !== oldState.val) {\n                differ = true;\n            } else if (state.ack !== undefined && state.ack !== oldState.ack) {\n                differ = true;\n            } else if (state.q !== undefined && state.q !== oldState.q) {\n                differ = true;\n            } else if (state.ts !== undefined && state.ts !== oldState.ts) {\n                differ = true;\n            } else if (state.c !== undefined && state.c !== oldState.c) {\n                // if comment changed\n                differ = true;\n            } else if (state.expire !== undefined && state.expire !== oldState.expire) {\n                differ = true;\n            } else if (state.from !== undefined && state.from !== oldState.from) {\n                differ = true;\n            } else if (state.user !== undefined && state.user !== oldState.user) {\n                differ = true;\n            }\n\n            if (differ) {\n                if (this.performStrictObjectChecks) {\n                    // validate that object exists, read-only logic ok, type ok, etc. won't throw now\n                    await this._utils.performStrictObjectCheck(id, state);\n                }\n                this.outputCount++;\n                await this.#states!.setState(id, state);\n                return { id, notChanged: false };\n            }\n            return { id, notChanged: true };\n        }\n    }\n\n    setStateChanged(\n        id: string,\n        state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState,\n        callback?: ioBroker.SetStateChangedCallback,\n    ): void;\n    setStateChanged(\n        id: string,\n        state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState,\n        ack: boolean,\n        callback?: ioBroker.SetStateChangedCallback,\n    ): void;\n    setStateChanged(\n        id: string,\n        state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState,\n        options: unknown,\n        callback?: ioBroker.SetStateChangedCallback,\n    ): void;\n    setStateChanged(\n        id: string,\n        state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState,\n        ack: boolean,\n        options: unknown,\n        callback?: ioBroker.SetStateChangedCallback,\n    ): void;\n\n    /**\n     * Writes value into states DB only if the value really changed.\n     *\n     * This function can write values into states DB for this adapter.\n     * Only Ids that belong to this adapter can be modified. So the function automatically adds \"adapter.X.\" to ID.\n     * ack, options and callback are optional\n     *\n     * @param id object ID of the state.\n     * @param state simple value or object with attribues.\n     * @param ack optional is command(false) or status(true)\n     * @param options optional user context\n     * @param callback optional return error, id and notChanged\n     *        ```js\n     *            function (err, id, notChanged) {\n     *              if (err) adapter.log.error('Cannot set value for \"' + id + '\": ' + err);\n     *              if (!notChanged) adapter.log.debug('Value was changed');\n     *            }\n     *        ```\n     */\n    setStateChanged(id: unknown, state: unknown, ack: unknown, options?: unknown, callback?: unknown): any {\n        if (typeof state === 'object' && typeof ack !== 'boolean') {\n            callback = options;\n            options = ack;\n            ack = undefined;\n        }\n        if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n\n        if (typeof ack === 'function') {\n            callback = ack;\n            ack = undefined;\n        }\n\n        if (!tools.isObject(id)) {\n            // it can be id object or string\n            Validator.assertString(id, 'id');\n        }\n\n        if (ack !== undefined) {\n            Validator.assertBoolean(ack, 'ack');\n        }\n\n        Validator.assertOptionalCallback(callback, 'callback');\n\n        if (options !== undefined && options !== null) {\n            Validator.assertObject(options, 'options');\n        }\n\n        return this._setStateChanged({ id, state: state as ioBroker.SettableState, ack, options, callback });\n    }\n\n    private async _setStateChanged(_options: InternalSetStateChangedOptions): Promise<void> {\n        const { id, ack, options, callback, state } = _options;\n        if (!this.#states) {\n            // if states is no longer existing, we do not need to unsubscribe\n            this._logger.info(\n                `${this.namespaceLog} setStateChanged not processed because States database not connected`,\n            );\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        try {\n            this._utils.validateId(id, false, null);\n        } catch (e) {\n            return tools.maybeCallbackWithError(callback, e);\n        }\n\n        const fixedId = this._utils.fixId(id, false);\n\n        let stateObj: ioBroker.SettableState;\n\n        if (tools.isObject(state)) {\n            // Verify that the passed state object is valid\n            try {\n                this._utils.validateSetStateObjectArgument(state);\n            } catch (e) {\n                return tools.maybeCallbackWithError(callback, e);\n            }\n            stateObj = state;\n        } else {\n            // wrap non-object values in a state object\n            // @ts-expect-error fix later\n            stateObj = state !== undefined ? { val: state } : {};\n        }\n\n        if (stateObj.val === undefined && !Object.keys(stateObj).length) {\n            // undefined is not allowed as state.val -> return\n            return tools.maybeCallbackWithError(callback, 'undefined is not a valid state value');\n        }\n\n        if (ack !== undefined) {\n            stateObj.ack = ack;\n        }\n\n        // if state.from provided, we use it else, we set default property\n        stateObj.from =\n            typeof stateObj.from === 'string' && stateObj.from !== ''\n                ? stateObj.from\n                : `system.adapter.${this.namespace}`;\n        if (options?.user && options.user !== SYSTEM_ADMIN_USER) {\n            try {\n                await this._checkStates(fixedId, options, 'setState');\n            } catch (e) {\n                return tools.maybeCallbackWithError(callback, e);\n            }\n\n            const res = await this._setStateChangedHelper(fixedId, stateObj);\n            // @ts-expect-error todo fix it\n            return tools.maybeCallbackWithError(callback, null, res.id, res.notChanged);\n        }\n        const res = await this._setStateChangedHelper(fixedId, stateObj);\n        // @ts-expect-error todo fix it\n        return tools.maybeCallbackWithError(callback, null, res.id, res.notChanged);\n    }\n\n    setForeignState(\n        id: string,\n        state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState,\n        callback?: ioBroker.SetStateCallback,\n    ): void;\n    setForeignState(\n        id: string,\n        state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState,\n        ack: boolean,\n        callback?: ioBroker.SetStateCallback,\n    ): void;\n    setForeignState(\n        id: string,\n        state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState,\n        options: unknown,\n        callback?: ioBroker.SetStateCallback,\n    ): void;\n    setForeignState(\n        id: string,\n        state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState,\n        ack: boolean,\n        options: unknown,\n        callback?: ioBroker.SetStateCallback,\n    ): void;\n\n    /**\n     * Writes value into states DB for any instance.\n     *\n     * This function can write values into states DB for all instances and system states too.\n     * ack, options and callback are optional\n     *\n     * @param id object ID of the state.\n     * @param state simple value or object with attribues.\n     *  If state is object, so the ack will be ignored and must be included into object.\n     *  ```js\n     *      {\n     *          val:    value,\n     *          ack:    true|false,       // default - false; is command(false) or status(true)\n     *          ts:     timestampMS,      // default - now\n     *          q:      qualityAsNumber,  // default - 0 (ok)\n     *          from:   origin,           // default - this adapter\n     *          c:      comment,          // default - empty\n     *          expire: expireInSeconds   // default - 0\n     *          lc:     timestampMS       // default - automatic calculation\n     *      }\n     *  ```\n     * @param ack optional is command(false) or status(true)\n     * @param options optional user context\n     * @param callback optional return error and id\n     *        ```js\n     *            function (err, id) {\n     *              if (err) adapter.log.error('Cannot set value for \"' + id + '\": ' + err);\n     *            }\n     *        ```\n     */\n    async setForeignState(id: any, state: any, ack: any, options?: any, callback?: any): Promise<any> {\n        if (typeof state === 'object' && typeof ack !== 'boolean') {\n            callback = options;\n            options = ack;\n            ack = undefined;\n        }\n\n        if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n\n        if (typeof ack === 'function') {\n            callback = ack;\n            ack = undefined;\n        }\n\n        if (!this.#states) {\n            // if states is no longer existing, we do not need to unsubscribe\n            this._logger.info(\n                `${this.namespaceLog} setForeignState not processed because States database not connected`,\n            );\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        if (!this.#objects) {\n            this._logger.info(\n                `${this.namespaceLog} setForeignState not processed because Objects database not connected`,\n            );\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        try {\n            this._utils.validateId(id, true, null);\n        } catch (e) {\n            return tools.maybeCallbackWithError(callback, e);\n        }\n\n        if (tools.isObject(state)) {\n            // Verify that the passed state object is valid\n            try {\n                this._utils.validateSetStateObjectArgument(state);\n            } catch (e) {\n                return tools.maybeCallbackWithError(callback, e);\n            }\n        } else {\n            // wrap non-object values in a state object\n            state = state !== undefined ? { val: state } : {};\n        }\n\n        if (state.val === undefined && !Object.keys(state).length) {\n            // undefined is not allowed as state.val -> return\n            this._logger.info(`${this.namespaceLog} undefined is not a valid state value for id \"${id}\"`);\n            // TODO: reactivate line below + test in in next controller version (02.05.2021)\n            // return tools.maybeCallbackWithError(callback, 'undefined is not a valid state value');\n        }\n\n        if (ack !== undefined) {\n            state.ack = ack;\n        }\n\n        // if state.from provided, we use it else, we set default property\n        state.from =\n            typeof state.from === 'string' && state.from !== '' ? state.from : `system.adapter.${this.namespace}`;\n        state.user = options?.user || SYSTEM_ADMIN_USER;\n\n        if (!id || typeof id !== 'string') {\n            const warn = id ? `ID can be only string and not \"${typeof id}\"` : `Empty ID: ${JSON.stringify(state)}`;\n            this._logger.warn(`${this.namespaceLog} ${warn}`);\n            return tools.maybeCallbackWithError(callback, warn);\n        }\n\n        id = this.fixForbiddenCharsInId(id);\n\n        if (options?.user && options.user !== SYSTEM_ADMIN_USER) {\n            let obj: ioBroker.StateObject;\n            try {\n                obj = (await this._checkStates(id, options, 'setState')).objs[0];\n            } catch (e) {\n                return tools.maybeCallbackWithError(callback, e);\n            }\n            if (!this.#states) {\n                // if states is no longer existing, we do not need to unsubscribe\n                this._logger.info(\n                    `${this.namespaceLog} setForeignState not processed because States database not connected`,\n                );\n                return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n            }\n\n            if (this.performStrictObjectChecks) {\n                // validate that object exists, read-only logic ok, type ok, etc. won't throw now\n                await this._utils.performStrictObjectCheck(id, state);\n            }\n\n            if (id.startsWith(ALIAS_STARTS_WITH)) {\n                // write alias\n                if (obj?.common?.alias?.id) {\n                    // id can be string or can have attribute write\n                    const aliasId = tools.isObject(obj.common.alias.id)\n                        ? obj.common.alias.id.write\n                        : obj.common.alias.id;\n\n                    // validate here because we use objects/states db directly\n                    try {\n                        this._utils.validateId(aliasId, true, null);\n                    } catch (e) {\n                        this._logger.warn(`${this.namespaceLog} Error validating alias id of ${id}: ${e.message}`);\n                        return tools.maybeCallbackWithError(\n                            callback,\n                            `Error validating alias id of ${id}: ${e.message}`,\n                        );\n                    }\n\n                    let targetObj;\n                    // we ignore permissions on the target object and thus get it as admin user\n                    try {\n                        targetObj = await this.#objects.getObject(aliasId, {\n                            ...options,\n                            user: SYSTEM_ADMIN_USER,\n                        });\n                    } catch (e) {\n                        return tools.maybeCallbackWithError(callback, e);\n                    }\n                    if (!this.#states) {\n                        // if states is no longer existing, we do not need to unsubscribe\n                        this._logger.info(\n                            `${this.namespaceLog} setForeignState not processed because States database not connected`,\n                        );\n                        return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n                    }\n\n                    this.outputCount++;\n                    this.#states.setState(\n                        aliasId,\n                        tools.formatAliasValue({\n                            sourceCommon: obj?.common,\n                            targetCommon: targetObj && (targetObj.common as any),\n                            state,\n                            logger: this._logger,\n                            logNamespace: this.namespaceLog,\n                            sourceId: obj?._id,\n                            targetId: targetObj?._id,\n                        }),\n                        callback,\n                    );\n                } else {\n                    this._logger.warn(`${this.namespaceLog} Alias ${id} has no target 3`);\n                    return tools.maybeCallbackWithError(callback, `Alias ${id} has no target`);\n                }\n            } else {\n                if (!this.#states) {\n                    // if states is no longer existing, we do not need to unsubscribe\n                    this._logger.info(\n                        `${this.namespaceLog} setForeignState not processed because States database not connected`,\n                    );\n                    return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n                }\n\n                this.outputCount++;\n                this.#states.setState(id, state, callback);\n            }\n        } else {\n            // write alias\n            if (id.startsWith(ALIAS_STARTS_WITH)) {\n                if (!this.#objects) {\n                    this._logger.info(\n                        `${this.namespaceLog} setForeignState not processed because Objects database not connected`,\n                    );\n                    return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n                }\n\n                // read alias id\n                const obj = (await this.#objects.getObjectAsync(id, options)) as ioBroker.StateObject;\n\n                if (obj?.common?.alias?.id) {\n                    // alias id can be a string or can have id.write\n                    const targetId = tools.isObject(obj.common.alias.id)\n                        ? obj.common.alias.id.write\n                        : obj.common.alias.id;\n\n                    // validate here because we use objects/states db directly\n                    try {\n                        this._utils.validateId(targetId, true, null);\n                    } catch (e) {\n                        this._logger.warn(`${this.namespaceLog} Error validating alias id of ${id}: ${e.message}`);\n                        return tools.maybeCallbackWithError(\n                            callback,\n                            `Error validating alias id of ${id}: ${e.message}`,\n                        );\n                    }\n\n                    if (!this.#objects) {\n                        // if objects is no longer existing, we do not need to unsubscribe\n                        this._logger.info(\n                            `${this.namespaceLog} setForeignState not processed because Objects database not connected`,\n                        );\n                        return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n                    }\n\n                    // read object for formatting - we ignore permissions on the target object and thus get it as admin user\n                    const targetObj = await this.#objects.getObject(targetId, {\n                        ...options,\n                        user: SYSTEM_ADMIN_USER,\n                    });\n\n                    if (!this.#states) {\n                        // if states is no longer existing, we do not need to unsubscribe\n                        this._logger.info(\n                            `${this.namespaceLog} setForeignState not processed because States database not connected`,\n                        );\n                        return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n                    }\n\n                    this.outputCount++;\n                    this.#states.setState(\n                        targetId,\n                        tools.formatAliasValue({\n                            sourceCommon: obj.common,\n                            targetCommon: targetObj?.common as ioBroker.StateCommon | undefined,\n                            state,\n                            logger: this._logger,\n                            logNamespace: this.namespaceLog,\n                            sourceId: obj._id,\n                            targetId: targetObj?._id,\n                        }),\n                        callback,\n                    );\n                } else {\n                    this._logger.warn(`${this.namespaceLog} Alias ${id} has no target 4`);\n                    return tools.maybeCallbackWithError(callback, `Alias ${id} has no target`);\n                }\n            } else {\n                if (this.performStrictObjectChecks) {\n                    if (!this.#objects) {\n                        // if objects is no longer existing, we do not need to unsubscribe\n                        this._logger.info(\n                            `${this.namespaceLog} setForeignState not processed because Objects database not connected`,\n                        );\n                        return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n                    }\n\n                    // validate that object exists, read-only logic ok, type ok, etc. won't throw now\n                    await this._utils.performStrictObjectCheck(id, state);\n                }\n                if (!this.#states) {\n                    // if states is no longer existing, we do not need to unsubscribe\n                    this._logger.info(\n                        `${this.namespaceLog} setForeignState not processed because States database not connected`,\n                    );\n                    return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n                }\n\n                this.outputCount++;\n                this.#states.setState(id, state, callback);\n            }\n        }\n    }\n\n    setForeignStateChanged(\n        id: string,\n        state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState,\n        callback?: ioBroker.SetStateChangedCallback,\n    ): void;\n    setForeignStateChanged(\n        id: string,\n        state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState,\n        ack: boolean,\n        callback?: ioBroker.SetStateChangedCallback,\n    ): void;\n    setForeignStateChanged(\n        id: string,\n        state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState,\n        options: unknown,\n        callback?: ioBroker.SetStateChangedCallback,\n    ): void;\n    setForeignStateChanged(\n        id: string,\n        state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState,\n        ack: boolean,\n        options: unknown,\n        callback?: ioBroker.SetStateChangedCallback,\n    ): void;\n\n    /**\n     * Writes value into states DB for any instance, but only if state changed.\n     *\n     * This function can write values into states DB for all instances and system states too.\n     * ack, options and callback are optional\n     *\n     * @param id object ID of the state.\n     * @param state simple value or object with attribues.\n     *  If state is object and ack exists too as function argument, function argument has priority.\n     *  ```js\n     *      {\n     *          val:    value,\n     *          ack:    true|false,       // default - false; is command(false) or status(true)\n     *          ts:     timestampMS,      // default - now\n     *          q:      qualityAsNumber,  // default - 0 (ok)\n     *          from:   origin,           // default - this adapter\n     *          c:      comment,          // default - empty\n     *          expire: expireInSeconds   // default - 0\n     *          lc:     timestampMS       // default - automatic calculation\n     *      }\n     *  ```\n     * @param ack optional is command(false) or status(true)\n     * @param options optional user context\n     * @param callback optional return error and id\n     *        ```js\n     *            function (err, id) {\n     *              if (err) adapter.log.error('Cannot set value for \"' + id + '\": ' + err);\n     *            }\n     *        ```\n     */\n    async setForeignStateChanged(\n        id: any,\n        state: any,\n        ack: any,\n        options?: any,\n        callback?: any,\n    ): Promise<void | [id: string, changed: boolean]> {\n        if (typeof state === 'object' && typeof ack !== 'boolean') {\n            callback = options;\n            options = ack;\n            ack = undefined;\n        }\n\n        if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n\n        if (typeof ack === 'function') {\n            callback = ack;\n            ack = undefined;\n        }\n\n        if (!this.#states) {\n            // if states is no longer existing, we do not need to unsubscribe\n            this._logger.info(\n                `${this.namespaceLog} setForeignStateChanged not processed because States database not connected`,\n            );\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        try {\n            this._utils.validateId(id, true, null);\n        } catch (e) {\n            return tools.maybeCallbackWithError(callback, e);\n        }\n\n        if (tools.isObject(state)) {\n            // Verify that the passed state object is valid\n            try {\n                this._utils.validateSetStateObjectArgument(state);\n            } catch (e) {\n                return tools.maybeCallbackWithError(callback, e);\n            }\n        } else {\n            // wrap non-object values in a state object\n            state = state !== undefined ? { val: state } : {};\n        }\n\n        if (state.val === undefined && !Object.keys(state).length) {\n            // undefined is not allowed as state.val -> return\n            this._logger.info(`${this.namespaceLog} undefined is not a valid state value for id \"${id}\"`);\n            // TODO: reactivate line below + test in in next controller version (02.05.2021)\n            // return tools.maybeCallbackWithError(callback, 'undefined is not a valid state value');\n        }\n\n        if (ack !== undefined) {\n            state.ack = ack;\n        }\n\n        // if state.from provided, we use it else, we set default property\n        state.from =\n            typeof state.from === 'string' && state.from !== '' ? state.from : `system.adapter.${this.namespace}`;\n        state.user = options?.user || SYSTEM_ADMIN_USER;\n\n        id = this.fixForbiddenCharsInId(id);\n\n        if (options?.user && options.user !== SYSTEM_ADMIN_USER) {\n            try {\n                await this._checkStates(id, options, 'setState');\n            } catch (e) {\n                return tools.maybeCallbackWithError(callback, e);\n            }\n\n            const res = await this._setStateChangedHelper(id, state);\n            return tools.maybeCallbackWithError(callback, null, res.id, res.notChanged);\n        }\n        const res = await this._setStateChangedHelper(id, state);\n        return tools.maybeCallbackWithError(callback, null, res.id, res.notChanged);\n    }\n\n    getState(id: string, callback: ioBroker.GetStateCallback): void;\n    getState(id: string, options: unknown, callback: ioBroker.GetStateCallback): void;\n\n    /**\n     * Read value from states DB.\n     *\n     * This function can read values from states DB for this adapter.\n     * Only Ids that belong to this adapter can be read. So the function automatically adds \"adapter.X.\" to ID.\n     *\n     * @param id object ID of the state.\n     * @param options optional user context\n     * @param callback return result\n     *        ```js\n     *            function (err, state) {\n     *              if (err) adapter.log.error('Cannot read value: ' + err);\n     *            }\n     *        ```\n     *\n     *        See possible attributes of the state in @setState explanation\n     */\n    getState(id: unknown, options: any, callback?: any): ioBroker.GetStatePromise {\n        // we use any types here, because validation takes place in foreign method\n        // get state does the same as getForeignState but fixes the id first\n\n        if (!tools.isObject(id)) {\n            Validator.assertString(id, 'id');\n        }\n        const fixedId = this._utils.fixId(id, false);\n        return this.getForeignState(fixedId, options, callback);\n    }\n\n    getForeignState(id: string, callback: ioBroker.GetStateCallback): ioBroker.GetStatePromise;\n    getForeignState(id: string, options: unknown, callback: ioBroker.GetStateCallback): ioBroker.GetStatePromise;\n\n    /**\n     * Read value from states DB for any instance and system state.\n     *\n     * This function can read values from states DB for all instances and adapters. It expects the full path of object ID.\n     *\n     * @param id object ID of the state.\n     * @param options optional user context\n     * @param callback return result\n     *        ```js\n     *            function (err, state) {\n     *              if (err) adapter.log.error('Cannot read value: ' + err);\n     *            }\n     *        ```\n     *\n     *        See possible attributes of the state in @setState explanation\n     */\n    getForeignState(\n        id: unknown,\n        options: unknown,\n        callback?: unknown,\n    ): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.GetStateCallback> | void> {\n        if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n\n        Validator.assertString(id, 'id');\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n        Validator.assertOptionalCallback(callback, 'callback');\n\n        return this._getForeignState({ id, options, callback });\n    }\n\n    private async _getForeignState(\n        _options: InternalGetStateOptions,\n    ): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.GetStateCallback> | void> {\n        const { id, options, callback } = _options;\n\n        if (!this.#states) {\n            // if states is no longer existing, we do not need to unsubscribe\n            this._logger.info(\n                `${this.namespaceLog} getForeignState not processed because States database not connected`,\n            );\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        if (!this.#objects) {\n            this._logger.info(\n                `${this.namespaceLog} getForeignState not processed because Objects database not connected`,\n            );\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        try {\n            this._utils.validateId(id, true, options);\n        } catch (e) {\n            return tools.maybeCallbackWithError(callback, e);\n        }\n\n        let permCheckRequired = false;\n        if (options?.user && options.user !== SYSTEM_ADMIN_USER) {\n            permCheckRequired = true;\n        }\n\n        let obj: ioBroker.StateObject | null | undefined;\n        try {\n            if (permCheckRequired) {\n                obj = (await this._checkStates(id, options || {}, 'getState')).objs[0];\n            } else {\n                obj = (await this.#objects.getObject(id, options)) as ioBroker.StateObject | null | undefined;\n            }\n        } catch (e) {\n            return tools.maybeCallbackWithError(callback, e);\n        }\n\n        if (id.startsWith(ALIAS_STARTS_WITH)) {\n            if (obj?.common?.alias?.id) {\n                // id can be string or can have attribute id.read\n                const aliasId = tools.isObject(obj.common.alias.id) ? obj.common.alias.id.read : obj.common.alias.id;\n\n                // validate here because we use objects/states db directly\n                try {\n                    this._utils.validateId(aliasId, true, null);\n                } catch (e) {\n                    this._logger.warn(`${this.namespaceLog} Error validating alias id of ${id}: ${e.message}`);\n                    return tools.maybeCallbackWithError(callback, `Error validating alias id of ${id}: ${e.message}`);\n                }\n\n                if (aliasId) {\n                    let sourceObj;\n                    try {\n                        // we ignore permissions on the source object and thus get it as admin user\n                        sourceObj = (await this.#objects.getObject(aliasId, {\n                            ...options,\n                            user: SYSTEM_ADMIN_USER,\n                        })) as ioBroker.StateObject | null | undefined;\n                    } catch (e) {\n                        return tools.maybeCallbackWithError(callback, e);\n                    }\n\n                    let state: ioBroker.State | undefined | null;\n                    if (this.oStates && this.oStates[aliasId]) {\n                        state = deepClone(this.oStates[aliasId]);\n                    } else {\n                        this.inputCount++;\n                        try {\n                            state = await this.#states.getState(aliasId);\n                        } catch (e) {\n                            return tools.maybeCallbackWithError(callback, e);\n                        }\n                    }\n\n                    return tools.maybeCallbackWithError(\n                        callback,\n                        null,\n                        tools.formatAliasValue({\n                            sourceCommon: sourceObj?.common,\n                            targetCommon: obj.common,\n                            state,\n                            logger: this._logger,\n                            logNamespace: this.namespaceLog,\n                            sourceId: sourceObj?._id,\n                            targetId: obj._id,\n                        }),\n                    );\n                }\n            } else {\n                // alias object non-existing or points to nowhere -> handle it like a non-existing state\n                return tools.maybeCallbackWithError(callback, null, null);\n            }\n        } else {\n            if (this.oStates && this.oStates[id]) {\n                return tools.maybeCallbackWithError(callback, null, this.oStates[id]);\n            }\n            return this.#states.getState(id, callback);\n        }\n    }\n\n    // find out default history instance\n    private async _getDefaultHistory(): Promise<void> {\n        if (!this.defaultHistory) {\n            // read default history instance from system.config\n            let data;\n            try {\n                data = await this.getForeignObjectAsync('system.config', null);\n            } catch {\n                // ignore\n            }\n\n            if (data?.common) {\n                this.defaultHistory = data.common.defaultHistory;\n            }\n            if (data?.native) {\n                this._systemSecret = data.native.secret;\n            }\n\n            // if no default history set\n            if (!this.defaultHistory) {\n                let _obj;\n                // read all adapters\n                try {\n                    _obj = await this.#objects!.getObjectViewAsync('system', 'instance', {\n                        startkey: 'system.adapter.',\n                        endkey: 'system.adapter.\\u9999',\n                    });\n                } catch {\n                    // ignore\n                }\n\n                if (_obj?.rows) {\n                    for (const row of _obj.rows) {\n                        if (row.value?.common && row.value.common.type === 'storage') {\n                            this.defaultHistory = row.id.substring('system.adapter.'.length);\n                            break;\n                        }\n                    }\n                }\n                if (!this.defaultHistory) {\n                    this.defaultHistory = 'history.0';\n                }\n            }\n        }\n    }\n\n    getHistory(id: string, options: ioBroker.GetHistoryOptions, callback: ioBroker.GetHistoryCallback): void;\n    getHistory(id: string, callback: ioBroker.GetHistoryCallback): void;\n\n    /**\n     * Read historian data for states of any instance or system state.\n     *\n     * This function can read values from history adapters like: history, sql, influxdb. It expects the full path of object ID.\n     * Normally only foreign history has interest, so there is no getHistory and getForeignHistory\n     *\n     * Possible options:\n     *\n     *  - instance - (optional) name of instance, where to read the historian data, e.g. 'history.0', 'sql.1'. By default, will be taken from system settings.\n     *  - start - (optional) time in ms - Date.now()', by default is (now - 1 week)\n     *  - end - (optional) time in ms - Date.now()', by default is (now + 5000 seconds)\n     *  - step - (optional) used in aggregate (m4, max, min, average, total) step in ms of intervals\n     *  - count - number of values if aggregate is 'onchange' or number of intervals if other aggregate method. Count will be ignored if step is set.\n     *  - from - if from field should be included in answer\n     *  - ack - if ack field should be included in answer\n     *  - q - if q field should be included in answer\n     *  - addId - if id field should be included in answer\n     *  - limit - do not return more entries than limit\n     *  - ignoreNull - if null values should be included (false), replaced by last not null value (true) or replaced with 0 (0)\n     *  - sessionId - (optional) identifier of request, will be returned back in the answer\n     *  - aggregate - aggregate method:\n     *      - minmax - used special algorithm. Splice the whole time range in small intervals and find for every interval max, min, start and end values.\n     *      - max - Splice the whole time range in small intervals and find for every interval max value and use it for this interval (nulls will be ignored).\n     *      - min - Same as max, but take minimal value.\n     *      - average - Same as max, but take average value.\n     *      - total - Same as max, but calculate total value.\n     *      - count - Same as max, but calculate number of values (nulls will be calculated).\n     *      - none - No aggregation at all. Only raw values in the given period.\n     *\n     * @param id object ID of the state.\n     * @param options see function description\n     * @param callback return result\n     *        ```js\n     *            function (error, result, step, sessionId) {\n     *              if (error) adapter.log.error('Cannot read value: ' + err);\n     *            }\n     *        ```\n     *\n     *        See possible attributes of the state in @setState explanation\n     */\n    getHistory(id: unknown, options: unknown, callback?: unknown): any {\n        if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n\n        Validator.assertString(id, 'id');\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n        Validator.assertCallback(callback, 'callback');\n\n        return this._getHistory({ id, options, callback });\n    }\n\n    // Checked implementation\n    private async _getHistory(_options: InternalGetHistoryOptions): Promise<void> {\n        const { id, callback } = _options;\n        let { options } = _options;\n\n        try {\n            this._utils.validateId(id, true, null);\n        } catch (e) {\n            // @ts-expect-error\n            return tools.maybeCallbackWithError(callback, e);\n        }\n\n        options = options || {};\n        options.end = options.end || Date.now() + 5000000;\n        if (!options.count && !options.start) {\n            options.start = options.start || Date.now() - 604800000; // - 1 week\n        }\n\n        if (!options.instance) {\n            if (!this.defaultHistory) {\n                // read default history instance from system.config\n                await this._getDefaultHistory();\n                return this.getHistory(id, options, callback);\n            }\n            options.instance = this.defaultHistory;\n        }\n\n        this.sendTo(options.instance || 'history.0', 'getHistory', { id: id, options: options }, res => {\n            // @ts-expect-error\n            tools.maybeCallbackWithError(callback, res.error, res.result, res.step, res.sessionId);\n        });\n    }\n\n    idToDCS(id: string): {\n        device: string;\n        channel: string;\n        state: string;\n    } | null;\n\n    /**\n     * Convert ID into object with device's, channel's and state's name.\n     *\n     * Convert \"adapter.instance.D.C.S\" in object `{device: D, channel: C, state: S}`\n     * Convert ID to `{device: D, channel: C, state: S}`\n     *\n     * @param id short or long string of ID like \"stateID\" or \"adapterName.0.stateID\".\n     * @returns parsed ID as an object\n     */\n    idToDCS(id: unknown): {\n        device: string;\n        channel: string;\n        state: string;\n    } | null {\n        if (!id) {\n            return null;\n        }\n\n        Validator.assertString(id, 'id');\n\n        const parts = id.split('.');\n        if (`${parts[0]}.${parts[1]}` !== this.namespace) {\n            this._logger.warn(`${this.namespaceLog} Try to decode id not from this adapter`);\n            return null;\n        }\n        return { device: parts[2], channel: parts[3], state: parts[4] };\n    }\n\n    // external signature\n    delState(id: string, callback?: ioBroker.ErrorCallback): void;\n    delState(id: string, options: unknown, callback?: ioBroker.ErrorCallback): void;\n\n    /**\n     * Deletes a state of this instance.\n     * The object will NOT be deleted. If you want to delete it too, use @delObject instead.\n     *\n     * It is not required to provice the adapter namespace, because it will automatically be added.\n     * E.g. to delete \"adapterName.X.myObject\", only \"myObject\" is required as ID.\n     *\n     * No error is returned if state does not exist.\n     *\n     * @param id exactly object ID (without namespace)\n     * @param options optional user context\n     * @param callback return result\n     *        ```js\n     *            function (err) {\n     *              if (err) adapter.log.error('Cannot delete object: ' + err);\n     *            }\n     *        ```\n     */\n    delState(id: unknown, options: unknown, callback?: unknown): any {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        Validator.assertString(id, 'id');\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n        Validator.assertOptionalCallback(callback, 'callback');\n\n        return this._delState({ id, options, callback });\n    }\n\n    private _delState(_options: InternalDelStateOptions): Promise<void> | void {\n        const { options, callback } = _options;\n        let { id } = _options;\n\n        try {\n            this._utils.validateId(id, false, null);\n        } catch (e) {\n            return tools.maybeCallbackWithError(callback, e);\n        }\n\n        // delState does the same as delForeignState, but fixes the ID first\n        id = this._utils.fixId(id);\n        return this.delForeignState(id, options, callback);\n    }\n\n    // external signature\n    delForeignState(id: string, callback?: ioBroker.ErrorCallback): void;\n    delForeignState(id: string, options: unknown, callback?: ioBroker.ErrorCallback): void;\n\n    /**\n     * Deletes a state of any adapter.\n     * The object is NOT deleted. If you want to delete it too, use @delForeignObject instead.\n     *\n     * No error is returned if state does not exist.\n     *\n     * @param id long string for ID like \"adapterName.0.stateID\".\n     * @param options optional argument to describe the user context\n     * @param callback return result\n     * ```js\n     * function (err) {}\n     * ```\n     */\n    delForeignState(id: unknown, options: unknown, callback?: unknown): any {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        Validator.assertString(id, 'id');\n        Validator.assertOptionalCallback(callback, 'callback');\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n\n        return this._delForeignState({ id, options, callback });\n    }\n\n    private async _delForeignState(_options: InternalDelStateOptions): Promise<void> {\n        const { id, options, callback } = _options;\n\n        if (!this.#states) {\n            // if states is no longer existing, we do not need to unsubscribe\n            this._logger.info(\n                `${this.namespaceLog} delForeignState not processed because States database not connected`,\n            );\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        try {\n            this._utils.validateId(id, true, options);\n        } catch (e) {\n            return tools.maybeCallbackWithError(callback, e);\n        }\n\n        if (options?.user && options.user !== SYSTEM_ADMIN_USER) {\n            try {\n                await this._checkStates(id, options, 'delState');\n            } catch (e) {\n                return tools.maybeCallbackWithError(callback, e);\n            }\n        }\n        this.#states.delState(id, callback);\n    }\n\n    // external signature\n    getStates(pattern: Pattern, callback: ioBroker.GetStatesCallback): void;\n    getStates(pattern: Pattern, options: unknown, callback: ioBroker.GetStatesCallback): void;\n\n    /**\n     * Read all states of this adapter, that pass the pattern\n     *\n     * Allows to read all states of current adapter according to pattern. To read all states of current adapter use:\n     * ```js\n     *     adapter.getStates('*', function (err, states) {\n     *         for (var id in states) {\n     *              adapter.log.debug('\"' + id + '\" = \"' + states[id].val);\n     *         }\n     *     });\n     * ```\n     *\n     * @param pattern string in form 'adapter.0.*' or like this. It can be an array of IDs too.\n     * @param options optional argument to describe the user context\n     * @param callback return result\n     * ```js\n     * function (err, states) {}, where states is an object like {\"ID1\": {\"val\": 1, \"ack\": true}, \"ID2\": {\"val\": 2, \"ack\": false}, ...}\n     * ```\n     */\n    getStates(pattern: unknown, options: any, callback?: any): any {\n        // we use any types here, because validation takes place in foreign method\n        if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n\n        Validator.assertPattern(pattern, 'pattern');\n\n        const fixedPattern = Array.isArray(pattern) ? pattern : this._utils.fixId(pattern, true);\n\n        this.getForeignStates(fixedPattern, options, callback);\n    }\n\n    private async _processStatesSecondary(\n        keys: string[],\n        targetObjs: (ioBroker.StateObject | null)[] | null,\n        srcObjs: (ioBroker.StateObject | null)[] | null,\n    ): Promise<ioBroker.GetStatesPromise> {\n        const arr = await this.#states!.getStates(keys);\n\n        const result: Record<string, Partial<ioBroker.State> | null> = {};\n\n        for (let i = 0; i < keys.length; i++) {\n            const obj = targetObjs && targetObjs[i];\n\n            if (obj?.common?.alias && srcObjs) {\n                const srcObj = srcObjs[i];\n\n                if (srcObj) {\n                    result[obj._id] =\n                        tools.formatAliasValue({\n                            sourceCommon: srcObj.common,\n                            targetCommon: obj.common,\n                            state: arr[i] || null,\n                            logger: this._logger,\n                            logNamespace: this.namespaceLog,\n                            sourceId: srcObj._id,\n                            targetId: obj._id,\n                        }) || null;\n                } else {\n                    result[obj._id || keys[i]] = arr[i] || null;\n                }\n            } else {\n                result[obj?._id || keys[i]] = arr[i] || null;\n            }\n        }\n\n        // @ts-expect-error adapt the return type?\n        return result;\n    }\n\n    /**\n     * Ensures, that object information is read, and the alias id is mapped to the source id if an alias is contained in the getStates call\n     * The adaption of the actual values is then performed in _processStatesSecondary, to apply alias conversion methods\n     *\n     * @param keys all ids of the getStates call\n     * @param targetObjs the target objects (e.g. alias objects or the actual objects)\n     */\n    private async _processStates(keys: string[], targetObjs: ioBroker.StateObject[]): ioBroker.GetStatesPromise {\n        const aliasIndexes: number[] = [];\n        const aliasIds: string[] = [];\n        /** Target objects with null placeholders for non-alias keys */\n        const fullTargetObjs: (ioBroker.StateObject | null)[] = new Array(keys.length).fill(null);\n\n        keys.forEach((id, idx) => {\n            if (id.startsWith(ALIAS_STARTS_WITH)) {\n                aliasIndexes.push(idx);\n                aliasIds.push(id);\n            }\n        });\n\n        // if any ID from aliases found\n        if (aliasIds.length) {\n            // make a copy of original array\n            keys = [...keys];\n\n            if (!targetObjs) {\n                // read aliases objects to get information of source objects\n                targetObjs = (await this._getObjectsByArray(aliasIds)) as ioBroker.StateObject[];\n            } else {\n                // we are only interested in keeping alias target objects\n                targetObjs = targetObjs.filter((_val, idx) => aliasIndexes.includes(idx));\n            }\n\n            // replace alias ids with targets\n            for (let i = 0; i < aliasIds.length; i++) {\n                const obj = targetObjs[i];\n                const aliasIdx = aliasIndexes[i];\n                fullTargetObjs[aliasIdx] = obj;\n\n                if (obj?.common?.alias) {\n                    // alias id can be string or can have attribute read (this is used by getStates -> so read is important)\n                    keys[aliasIdx] =\n                        tools.isObject(obj.common.alias.id) && 'read' in obj.common.alias.id\n                            ? obj.common.alias.id.read\n                            : obj.common.alias.id;\n                }\n            }\n\n            // srcObjs and targetObjs could be merged\n            const srcObjs = (await this._getObjectsByArray(keys)) as (ioBroker.StateObject | null)[];\n\n            return this._processStatesSecondary(keys, fullTargetObjs, srcObjs);\n        }\n        return this._processStatesSecondary(keys, null, null);\n    }\n\n    getForeignStates(pattern: Pattern, callback: ioBroker.GetStatesCallback): void;\n    getForeignStates(pattern: Pattern, options: unknown, callback: ioBroker.GetStatesCallback): void;\n\n    /**\n     * Read all states of all adapters (and system states), that pass the pattern\n     *\n     * Allows to read all states of current adapter according to pattern. To read all states of current adapter use:\n     * ```js\n     *     adapter.getStates('*', function (err, states) {\n     *         for (var id in states) {\n     *              adapter.log.debug('\"' + id + '\" = \"' + states[id].val);\n     *         }\n     *     });\n     * ```\n     *\n     * @param pattern string in form 'adapter.0.*' or like this. It can be an array of IDs too.\n     * @param options optional argument to describe the user context\n     * @param callback return result\n     * ```js\n     * function (err, states) {}, where states is an object like {\"ID1\": {\"val\": 1, \"ack\": true}, \"ID2\": {\"val\": 2, \"ack\": false}, ...}\n     * ```\n     */\n    getForeignStates(pattern: unknown, options: unknown, callback?: unknown): any {\n        if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n        if (typeof pattern === 'function') {\n            callback = pattern;\n            pattern = '*';\n        }\n\n        Validator.assertPattern(pattern, 'pattern');\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n        Validator.assertCallback(callback, 'callback');\n\n        return this._getForeignStates({ pattern, options: options || {}, callback });\n    }\n\n    private async _getForeignStates(_options: InternalGetStatesOptions): Promise<void> {\n        const { options, pattern, callback } = _options;\n\n        if (!this.#states) {\n            // if states is no longer existing, we do not need to unsubscribe\n            this._logger.info(\n                `${this.namespaceLog} getForeignStates not processed because States database not connected`,\n            );\n\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        if (!this.#objects) {\n            // if states is no longer existing, we do not need to unsubscribe\n            this._logger.info(\n                `${this.namespaceLog} getForeignStates not processed because Objects database not connected`,\n            );\n\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        // if pattern is array\n        if (Array.isArray(pattern)) {\n            if (options.user && options.user !== SYSTEM_ADMIN_USER) {\n                try {\n                    const { objs, ids } = await this._checkStates(pattern, options, 'getState');\n                    const res = await this._processStates(ids, objs);\n                    return tools.maybeCallbackWithError(callback, null, res);\n                } catch (e) {\n                    return tools.maybeCallbackWithError(callback, e);\n                }\n            } else {\n                const res = await this._processStates(pattern, options?._objects);\n                return tools.maybeCallbackWithError(callback, null, res);\n            }\n        } else {\n            // read first the keys for pattern\n            let params = {};\n            if (pattern && pattern !== '*') {\n                params = {\n                    startkey: pattern.replace(/\\*/g, ''),\n                    endkey: pattern.replace(/\\*/g, '\\u9999'),\n                };\n            }\n\n            let originalChecked: boolean | undefined;\n            if (options.checked !== undefined) {\n                originalChecked = options.checked;\n            }\n            options.checked = true;\n\n            // in special maintenance mode, just returns all states. Aliases are not supported in this mode\n            if (options.user === SYSTEM_ADMIN_USER && options.maintenance) {\n                try {\n                    const keys = await this.#states.getKeys(pattern);\n                    const res = await this._processStatesSecondary(keys || [], null, null);\n                    return tools.maybeCallbackWithError(callback, null, res);\n                } catch (e) {\n                    return tools.maybeCallbackWithError(callback, e);\n                }\n            }\n\n            try {\n                const res = await this.#objects.getObjectView('system', 'state', params, options);\n                if (originalChecked !== undefined) {\n                    options.checked = originalChecked;\n                } else {\n                    options.checked = undefined;\n                }\n\n                if (!res) {\n                    return tools.maybeCallbackWithError(callback, null, {});\n                }\n                const keys = [];\n                const objs = [];\n\n                // filter out\n                let regEx;\n                // process patterns like \"*.someValue\". The patterns \"someValue.*\" will be processed by getObjectView\n                try {\n                    if (pattern !== '*' && pattern[pattern.length - 1] !== '*') {\n                        regEx = new RegExp(tools.pattern2RegEx(pattern));\n                    }\n                    for (const row of res.rows) {\n                        const id = row.id;\n                        if (id && (!regEx || regEx.test(id))) {\n                            keys.push(id);\n                            objs.push(row.value);\n                        }\n                    }\n                } catch (e) {\n                    return tools.maybeCallbackWithError(callback, e);\n                }\n\n                options._objects = objs;\n                this.getForeignStates(keys, options, callback);\n            } catch (e) {\n                return tools.maybeCallbackWithError(callback, e);\n            }\n        }\n    }\n\n    /**\n     * Add subscription for given alias, if it is not a state it will be ignored\n     *\n     * @param aliasObj the alias object\n     * @param pattern pattern to subscribe for\n     */\n    private async _addAliasSubscribe(aliasObj: ioBroker.AnyObject, pattern: string): Promise<void> {\n        if (aliasObj.type !== 'state') {\n            // no state types do not need to be subscribed\n            return;\n        }\n\n        if (!aliasObj.common?.alias?.id) {\n            // if state and no id given\n            this._logger.warn(`${this.namespaceLog} Alias ${aliasObj._id} has no target 5`);\n            throw new Error(`Alias ${aliasObj._id} has no target`);\n        }\n\n        // id can be string or can have attribute read\n        const sourceId = tools.isObject(aliasObj.common.alias.id)\n            ? aliasObj.common.alias.id.read\n            : aliasObj.common.alias.id;\n\n        // validate here because we use objects/states db directly\n        try {\n            this._utils.validateId(sourceId, true, null);\n        } catch (e) {\n            throw new Error(`Error validating alias id of ${aliasObj._id}: ${e.message}`);\n        }\n\n        const targetEntry = {\n            alias: deepClone(aliasObj.common.alias),\n            id: aliasObj._id,\n            pattern,\n            type: aliasObj.common.type,\n            max: aliasObj.common.max,\n            min: aliasObj.common.min,\n            unit: aliasObj.common.unit,\n        };\n\n        let aliasDetails: AliasDetails;\n\n        if (!this.aliases.has(sourceId)) {\n            aliasDetails = { targets: [] };\n            // add the alias before doing anything async, so if a delete comes in between we can detect it\n            this.aliases.set(sourceId, aliasDetails);\n        } else {\n            aliasDetails = this.aliases.get(sourceId)!;\n        }\n\n        if (!aliasDetails.source) {\n            await this.#states!.subscribe(sourceId);\n            // we ignore permissions on the source object and thus get it as admin user\n            const sourceObj = await this.#objects!.getObject(sourceId, { user: SYSTEM_ADMIN_USER });\n\n            // if we have a common and the alias has not been removed in-between\n            if (sourceObj?.common && this.aliases.has(sourceObj._id)) {\n                aliasDetails.source = {\n                    min: sourceObj.common.min,\n                    max: sourceObj.common.max,\n                    type: sourceObj.common.type,\n                    unit: sourceObj.common.unit,\n                };\n            }\n        }\n\n        // add the alias target after we have ensured that we have the source set\n        aliasDetails.targets.push(targetEntry);\n    }\n\n    /**\n     * Remove an alias subscribe\n     *\n     * @param sourceId id of the source object\n     * @param aliasObjOrIdx the alias target or the index of the targets array\n     */\n    private async _removeAliasSubscribe(sourceId: string, aliasObjOrIdx: number | AliasTargetEntry): Promise<void> {\n        if (!this.aliases.has(sourceId)) {\n            return;\n        }\n\n        const alias = this.aliases.get(sourceId)!;\n\n        // remove from targets array\n        const pos = typeof aliasObjOrIdx === 'number' ? aliasObjOrIdx : alias.targets.indexOf(aliasObjOrIdx);\n\n        if (pos !== -1) {\n            alias.targets.splice(pos, 1);\n\n            // unsubscribe if no more aliases exists\n            if (!alias.targets.length) {\n                this.aliases.delete(sourceId);\n                await this.#states!.unsubscribe(sourceId);\n            }\n        }\n    }\n\n    subscribeForeignStates(pattern: Pattern, callback?: ioBroker.ErrorCallback): void;\n    subscribeForeignStates(pattern: Pattern, options: unknown, callback?: ioBroker.ErrorCallback): void;\n\n    /**\n     * Subscribe for changes on all states of all adapters (and system states), that pass the pattern\n     *\n     * Allows to Subscribe on changes all states of all instances according to pattern. E.g. to read all states of 'adapterName.X' instance use:\n     * ```js\n     *     adapter.subscribeForeignStates('adapterName.X.*');\n     * ```\n     *\n     * @param pattern string in form 'adapter.0.*' or like this. It can be an array of IDs too.\n     * @param options optional argument to describe the user context\n     * @param callback return result ```function (err) {}```\n     */\n    subscribeForeignStates(pattern: unknown, options: unknown, callback?: unknown): any {\n        pattern = pattern || '*';\n\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        Validator.assertOptionalCallback(callback, 'callback');\n\n        if (pattern instanceof RegExp) {\n            return tools.maybeCallbackWithError(\n                callback,\n                `Regexp is not supported for \"subscribeForeignStates\", received \"${pattern.toString()}\"`,\n            );\n        }\n\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n        Validator.assertPattern(pattern, 'pattern');\n\n        return this._subscribeForeignStates({ pattern, options, callback });\n    }\n\n    private async _subscribeForeignStates(_options: InternalSubscribeOptions): Promise<void> {\n        const { pattern, options, callback } = _options;\n\n        // Todo check rights for options\n        await this._autoSubscribeOn();\n\n        if (!this.#states) {\n            // if states is no longer existing, we do not need to unsubscribe\n            this._logger.info(\n                `${this.namespaceLog} subscribeForeignStates not processed because States database not connected`,\n            );\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n        if (!this.#objects) {\n            this._logger.info(\n                `${this.namespaceLog} subscribeForeignStates not processed because Objects database not connected`,\n            );\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        // compare if this pattern for one of auto-subscribe adapters\n        for (const autoSubEntry of this.autoSubscribe) {\n            if (typeof pattern === 'string' && (pattern === '*' || pattern.startsWith(`${autoSubEntry}.`))) {\n                // put this pattern into adapter list\n                let state;\n                try {\n                    state = await this.#states.getState(`system.adapter.${autoSubEntry}.subscribes`);\n                } catch {\n                    // ignore\n                }\n                state = state || { val: '{}' };\n                state.val = state.val || '{}';\n                let subs;\n                try {\n                    subs = JSON.parse(state.val as any);\n                } catch {\n                    this._logger.error(`${this.namespaceLog} Cannot parse subscribes for \"${autoSubEntry}.subscribes\"`);\n                }\n\n                // validate that correct structure read from state.val\n                if (!tools.isObject(subs)) {\n                    subs = {};\n                }\n\n                if (!tools.isObject(subs[pattern])) {\n                    subs[pattern] = {};\n                }\n\n                if (typeof subs[pattern][this.namespace] !== 'number') {\n                    subs[pattern][this.namespace] = 0;\n                }\n\n                subs[pattern][this.namespace]++;\n                this.outputCount++;\n                this.#states.setState(`system.adapter.${autoSubEntry}.subscribes`, JSON.stringify(subs));\n            }\n        }\n\n        if (Array.isArray(pattern)) {\n            // get all aliases\n            const aliasesIds = pattern\n                .map(id => (id.startsWith(ALIAS_STARTS_WITH) ? id : null))\n                .filter(id => id) as string[];\n\n            // get all non aliases\n            const nonAliasesIds = pattern\n                .map(id => (!id.startsWith(ALIAS_STARTS_WITH) ? id : null))\n                .filter(id => id) as string[];\n\n            for (const aliasPattern of pattern) {\n                if (\n                    (aliasPattern.startsWith(ALIAS_STARTS_WITH) || aliasPattern.includes('*')) &&\n                    !this.aliasPatterns.has(aliasPattern)\n                ) {\n                    // it's a new alias conform pattern to store\n                    this.aliasPatterns.add(aliasPattern);\n                }\n            }\n\n            const promises = [];\n\n            if (aliasesIds.length) {\n                if (!this._aliasObjectsSubscribed) {\n                    this._aliasObjectsSubscribed = true;\n                    this.#objects.subscribe(`${ALIAS_STARTS_WITH}*`);\n                }\n\n                const aliasObjs = await this._getObjectsByArray(aliasesIds, options);\n\n                for (const aliasObj of aliasObjs) {\n                    if (aliasObj) {\n                        promises.push(this._addAliasSubscribe(aliasObj, aliasObj._id));\n                    }\n                }\n            }\n\n            if (nonAliasesIds.length) {\n                for (const id of nonAliasesIds) {\n                    promises.push(new Promise(resolve => this.#states!.subscribeUser(id, resolve)));\n                }\n            }\n\n            try {\n                await Promise.all(promises);\n            } catch (e) {\n                this._logger.error(`${this.namespaceLog} Error on \"subscribeForeignStates\": ${e.message}`);\n            }\n            return tools.maybeCallback(callback);\n        } else if (pattern.includes('*')) {\n            if (pattern === '*' || pattern.startsWith(ALIAS_STARTS_WITH)) {\n                if (!this._aliasObjectsSubscribed) {\n                    this._aliasObjectsSubscribed = true;\n                    this.#objects.subscribe(`${ALIAS_STARTS_WITH}*`);\n                }\n\n                // read all aliases\n                try {\n                    // @ts-expect-error adjust types\n                    const objs = await this.getForeignObjectsAsync(pattern, null, null, options);\n                    const promises = [];\n                    if (!this.aliasPatterns.has(pattern)) {\n                        // it's a new pattern to store\n                        this.aliasPatterns.add(pattern);\n                    }\n\n                    for (const id of Object.keys(objs)) {\n                        // If alias\n                        if (id.startsWith(ALIAS_STARTS_WITH)) {\n                            const aliasObj = objs[id];\n                            promises.push(this._addAliasSubscribe(aliasObj, pattern));\n                        }\n                    }\n\n                    try {\n                        await Promise.all(promises);\n                    } catch (e) {\n                        this._logger.error(`${this.namespaceLog} Error on \"subscribeForeignStates\": ${e.message}`);\n                    }\n\n                    if (!this.#states) {\n                        // if states is no longer existing, we do not need to unsubscribe\n                        this._logger.info(\n                            `${this.namespaceLog} subscribeForeignStates not processed because States database not connected`,\n                        );\n                        return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n                    }\n\n                    if (promises.length && pattern !== '*') {\n                        return tools.maybeCallback(callback);\n                    }\n                    // no alias objects found or pattern *\n                    this.#states.subscribeUser(pattern, callback);\n                } catch (e) {\n                    this._logger.warn(`${this.namespaceLog} Cannot subscribe to ${pattern}: ${e.message}`);\n                    return tools.maybeCallbackWithError(callback, e);\n                }\n            } else {\n                this.#states.subscribeUser(pattern, callback);\n            }\n        } else if (pattern.startsWith(ALIAS_STARTS_WITH)) {\n            if (!this._aliasObjectsSubscribed) {\n                this._aliasObjectsSubscribed = true;\n                this.#objects.subscribe(`${ALIAS_STARTS_WITH}*`);\n            }\n\n            // just read one alias Object\n            try {\n                const aliasObj = await this.#objects.getObject(pattern, options);\n                if (aliasObj) {\n                    await this._addAliasSubscribe(aliasObj, pattern);\n                    return tools.maybeCallback(callback);\n                }\n                return tools.maybeCallback(callback);\n            } catch (e) {\n                this._logger.warn(`${this.namespaceLog} cannot subscribe on alias \"${pattern}\": ${e.message}`);\n            }\n        } else {\n            this.#states.subscribeUser(pattern, callback);\n        }\n    }\n\n    unsubscribeForeignStates(pattern: string | string[], callback?: ioBroker.ErrorCallback): void;\n    unsubscribeForeignStates(pattern: string | string[], options: unknown, callback?: ioBroker.ErrorCallback): void;\n\n    /**\n     * Unsubscribe for changes for given pattern\n     *\n     * This function allows to unsubscribe from changes. The pattern must be equal to requested one.\n     * ```js\n     *     adapter.subscribeForeignStates('adapterName.X.*');\n     *     adapter.unsubscribeForeignStates('adapterName.X.abc*'); // This will not work\n     *     adapter.unsubscribeForeignStates('adapterName.X.*'); // Valid unsubscribe\n     * ```\n     *\n     * @param pattern string in form 'adapter.0.*'. Must be the same as subscribe.\n     * @param options optional argument to describe the user context\n     * @param callback return result\n     * ```js\n     * function (err) {}\n     * ```\n     */\n    unsubscribeForeignStates(pattern: unknown, options: unknown, callback?: unknown): any {\n        pattern = pattern || '*';\n\n        // Todo check rights for options\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        Validator.assertOptionalCallback(callback, 'callback');\n\n        if (pattern instanceof RegExp) {\n            return tools.maybeCallbackWithError(\n                callback,\n                `Regexp is not supported for \"unsubscribeForeignStates\", received \"${pattern.toString()}\"`,\n            );\n        }\n\n        Validator.assertPattern(pattern, 'pattern');\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n\n        return this._unsubscribeForeignStates({ pattern, options, callback });\n    }\n\n    private async _unsubscribeForeignStates(_options: InternalSubscribeOptions): Promise<void> {\n        const { pattern, callback } = _options;\n\n        if (!this.#states) {\n            // if states is no longer existing, we do not need to unsubscribe\n            this._logger.info(\n                `${this.namespaceLog} unsubscrubeForeignStates not processed because States database not connected`,\n            );\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        if (this.autoSubscribe && typeof pattern === 'string') {\n            for (const autoSub of this.autoSubscribe) {\n                if (pattern === '*' || pattern.substring(0, autoSub.length + 1) === `${autoSub}.`) {\n                    // remove this pattern from adapter list\n                    let state;\n                    try {\n                        state = await this.#states.getState(`system.adapter.${autoSub}.subscribes`);\n                    } catch {\n                        // ignore\n                    }\n                    if (!state || !state.val) {\n                        continue;\n                    }\n                    let subs;\n                    try {\n                        subs = JSON.parse(state.val as any);\n                    } catch {\n                        this._logger.error(`${this.namespaceLog} Cannot parse subscribes for \"${autoSub}.subscribes\"`);\n                        continue;\n                    }\n\n                    if (\n                        !tools.isObject(subs) ||\n                        !tools.isObject(subs[pattern]) ||\n                        subs[pattern][this.namespace] === undefined\n                    ) {\n                        // check subs is a valid object, because it comes from state.val\n                        continue;\n                    }\n\n                    if (typeof subs[pattern][this.namespace] === 'number') {\n                        subs[pattern][this.namespace]--;\n                        if (subs[pattern][this.namespace] <= 0) {\n                            delete subs[pattern][this.namespace];\n                        }\n                    } else {\n                        // corrupted info, we can only delete\n                        delete subs[pattern][this.namespace];\n                    }\n\n                    // if no other subs are there\n                    if (!Object.keys(subs[pattern]).length) {\n                        delete subs[pattern];\n                    }\n                    this.outputCount++;\n                    this.#states.setState(`system.adapter.${autoSub}.subscribes`, JSON.stringify(subs));\n                }\n            }\n        }\n\n        let aliasPattern;\n        const promises = [];\n\n        if (Array.isArray(pattern)) {\n            // process every entry as single unsubscribe\n            for (const _pattern of pattern) {\n                promises.push(this.unsubscribeForeignStatesAsync(_pattern));\n            }\n        } else if (pattern.includes('*') || pattern.startsWith(ALIAS_STARTS_WITH)) {\n            if (pattern === '*' || pattern.startsWith(ALIAS_STARTS_WITH)) {\n                aliasPattern = pattern; // check all aliases\n                if (pattern === '*') {\n                    promises.push(this.#states.unsubscribeUser(pattern));\n                }\n            } else {\n                promises.push(this.#states.unsubscribeUser(pattern));\n            }\n        } else {\n            promises.push(this.#states.unsubscribeUser(pattern));\n        }\n\n        if (aliasPattern) {\n            // if pattern known, remove it from alias patterns to not subscribe to further matching aliases\n            this.aliasPatterns.delete(aliasPattern);\n\n            for (const [sourceId, alias] of this.aliases) {\n                for (let i = alias.targets.length - 1; i >= 0; i--) {\n                    if (alias.targets[i].pattern === aliasPattern) {\n                        promises.push(this._removeAliasSubscribe(sourceId, i));\n                    }\n                }\n            }\n        }\n\n        await Promise.all(promises);\n        // if no alias subscribed any longer, remove subscription\n        if (!this.aliases.size && this._aliasObjectsSubscribed) {\n            this._aliasObjectsSubscribed = false;\n            this.#objects!.unsubscribe(`${ALIAS_STARTS_WITH}*`);\n        }\n        return tools.maybeCallback(callback);\n    }\n\n    subscribeStates(pattern: Pattern, callback?: ioBroker.ErrorCallback): void;\n    subscribeStates(pattern: Pattern, options: unknown, callback?: ioBroker.ErrorCallback): void;\n\n    /**\n     * Subscribe for changes on all states of this instance, that pass the pattern\n     *\n     * Allows to Subscribe on changes all states of current adapter according to pattern. To read all states of current adapter use:\n     * ```js\n     *     adapter.subscribeStates('*'); // subscribe for all states of this adapter\n     * ```\n     *\n     * @param pattern string in form 'adapter.0.*' or like this. Only string allowed\n     * @param options optional argument to describe the user context\n     * @param callback optional callback\n     */\n    subscribeStates(pattern: unknown, options: unknown, callback?: unknown): any {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        Validator.assertPattern(pattern, 'pattern');\n        Validator.assertOptionalCallback(callback, 'callback');\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n\n        return this._subscribeForeignStates({\n            pattern: Array.isArray(pattern) ? pattern : this._utils.fixId(pattern, true),\n            options,\n            callback,\n        });\n    }\n\n    unsubscribeStates(pattern: Pattern, callback?: ioBroker.ErrorCallback): void;\n    unsubscribeStates(pattern: Pattern, options: unknown, callback?: ioBroker.ErrorCallback): void;\n\n    /**\n     * Unsubscribe for changes for given pattern for own states.\n     *\n     * This function allows to unsubscribe from changes. The pattern must be equal to requested one.\n     *\n     * ```js\n     *     adapter.unsubscribeStates('abc*'); // This will not work\n     *     adapter.unsubscribeStates('*');    // Valid unsubscribe\n     * ```\n     *\n     * @param pattern string in form 'adapter.0.*'. Must be the same as subscribe.\n     * @param options optional argument to describe the user context\n     * @param callback optional callback\n     */\n    unsubscribeStates(pattern: unknown, options: unknown, callback?: unknown): any {\n        if (typeof options === 'function') {\n            callback = options;\n            options = null;\n        }\n\n        Validator.assertPattern(pattern, 'pattern');\n        Validator.assertOptionalCallback(callback, 'callback');\n        if (options !== null && options !== undefined) {\n            Validator.assertObject(options, 'options');\n        }\n\n        return this._unsubscribeForeignStates({\n            pattern: Array.isArray(pattern) ? pattern : this._utils.fixId(pattern, true),\n            options,\n            callback,\n        });\n    }\n\n    getPluginInstance(name: string): ioBroker.Plugin | null;\n\n    /**\n     * Return plugin instance\n     *\n     * @param name name of the plugin to return\n     * @returns plugin instance or null if not existent or not isActive\n     */\n    getPluginInstance(name: unknown): ioBroker.Plugin | null {\n        if (!this.pluginHandler) {\n            return null;\n        }\n\n        Validator.assertString(name, 'name');\n\n        return this.pluginHandler.getPluginInstance(name);\n    }\n\n    getPluginConfig(name: string): Record<string, any> | null;\n\n    /**\n     * Return plugin configuration\n     *\n     * @param name name of the plugin to return\n     * @returns plugin configuration or null if not existent or not isActive\n     */\n    getPluginConfig(name: unknown): Record<string, any> | null {\n        if (!this.pluginHandler) {\n            return null;\n        }\n\n        Validator.assertString(name, 'name');\n        return this.pluginHandler.getPluginConfig(name);\n    }\n\n    private async _autoSubscribeOn(): Promise<void> {\n        if (!this.autoSubscribe && this.#objects) {\n            try {\n                // collect all\n                const res = await this.#objects.getObjectViewAsync('system', 'instance', {\n                    startkey: 'system.adapter.',\n                    endkey: 'system.adapter.\\u9999',\n                });\n\n                this.autoSubscribe = [];\n                for (const row of res.rows) {\n                    if (row.value?.common.subscribable) {\n                        const _id = row.id.substring(15); // cut system.adapter.\n                        if (!this.autoSubscribe.includes(_id)) {\n                            this.autoSubscribe.push(_id);\n                        }\n                    }\n                }\n\n                // because of autoSubscribe\n                await this.#objects.subscribeAsync('system.adapter.*');\n            } catch {\n                // ignore\n            }\n        }\n    }\n\n    getSuitableLicenses(all?: boolean, adapterName?: string): Promise<any[]>;\n\n    /**\n     * This method returns the list of license that can be used by this adapter\n     *\n     * @param all if return the licenses, that used by other instances (true) or only for this instance (false)\n     * @param adapterName Return licenses for specific adapter\n     * @returns list of suitable licenses\n     */\n    async getSuitableLicenses(all?: boolean, adapterName?: string): Promise<SuitableLicense[]> {\n        const licenses: SuitableLicense[] = [];\n        try {\n            const obj = await this.getForeignObjectAsync('system.licenses');\n            const uuidObj = await this.getForeignObjectAsync('system.meta.uuid');\n            if (!uuidObj?.native?.uuid) {\n                this._logger.warn(`${this.namespaceLog} No UUID found!`);\n                return licenses;\n            }\n\n            const uuid: string = uuidObj.native.uuid;\n\n            if (obj?.native?.licenses?.length) {\n                const now = Date.now();\n                const cert = fs.readFileSync(path.join(thisDir, '..', '..', 'cert', 'cloudCert.crt'));\n                let adapterObj: ioBroker.AdapterObject | null | undefined;\n                if (adapterName) {\n                    try {\n                        adapterObj = await this.getForeignObjectAsync(`system.adapter.${adapterName}`);\n                    } catch {\n                        // ignore\n                    }\n                }\n\n                const version = semver.major(adapterObj?.common?.version || this.pack!.version);\n\n                for (const license of obj.native.licenses as Omit<SuitableLicense, 'decoded'>[]) {\n                    try {\n                        const decoded: any = jwt.verify(license.json, cert);\n                        if (\n                            decoded.name &&\n                            (!decoded.valid_till ||\n                                decoded.valid_till === '0000-00-00 00:00:00' ||\n                                new Date(decoded.valid_till).getTime() > now)\n                        ) {\n                            if (\n                                decoded.name.startsWith(`iobroker.${adapterName || this.name}`) &&\n                                (all || !license.usedBy || license.usedBy === this.namespace)\n                            ) {\n                                // Licenses for version ranges 0.x and 1.x are handled identically and are valid for both version ranges.\n                                // If license is for adapter with version 0 or 1\n                                if (\n                                    decoded.version === '&lt;2' ||\n                                    decoded.version === '<2' ||\n                                    decoded.version === '<1' ||\n                                    decoded.version === '<=1'\n                                ) {\n                                    // check the current adapter major version\n                                    if (version !== 0 && version !== 1) {\n                                        // exception if vis-1 has UUID, so it is valid for vis-2\n                                        const exception =\n                                            decoded.name === 'iobroker.vis' && version === 2 && decoded.uuid;\n\n                                        if (!exception) {\n                                            continue;\n                                        }\n                                    }\n                                } else if (decoded.version && decoded.version !== version) {\n                                    // Licenses for adapter versions >=2 need to match to the adapter major version,\n                                    // which means that a new major version requires new licenses if it would be \"included\"\n                                    //  in the last purchase\n\n                                    // decoded.version could be only '<2' or direct version, like \"2\", \"3\" and so on\n                                    continue;\n                                }\n                                if (decoded.uuid && decoded.uuid !== uuid) {\n                                    // License is not for this server\n                                    continue;\n                                }\n\n                                // remove free license if commercial license found\n                                if (decoded.invoice !== 'free') {\n                                    const pos = licenses.findIndex(item => item.invoice === 'free');\n                                    if (pos !== -1) {\n                                        licenses.splice(pos, 1);\n                                    }\n                                }\n\n                                licenses.push({ ...license, decoded });\n                            }\n                        }\n                    } catch (e) {\n                        this._logger.error(\n                            `${this.namespaceLog} Cannot decode license \"${license.product}\": ${e.message}`,\n                        );\n                    }\n                }\n            }\n        } catch {\n            // ignore\n        }\n\n        licenses.sort((a, b) => {\n            const aInvoice = a.decoded.invoice !== 'free';\n            const bInvoice = b.decoded.invoice !== 'free';\n            if (aInvoice === bInvoice) {\n                return 0;\n            } else if (aInvoice) {\n                return -1;\n            } else if (bInvoice) {\n                return 1;\n            }\n\n            return 0;\n        });\n\n        return licenses;\n    }\n\n    /**\n     * Add given id to log redirect list\n     *\n     * @param isActive if id should be added or removed\n     * @param id the id to add\n     */\n    private logRedirect(isActive: boolean, id: string): void {\n        // ignore itself\n        if (id === `system.adapter.${this.namespace}`) {\n            return;\n        }\n\n        if (isActive) {\n            if (!this.logList.has(id)) {\n                this.logList.add(id);\n            }\n        } else {\n            this.logList.delete(id);\n        }\n    }\n\n    private _reportStatus(): void {\n        if (!this.#states) {\n            return;\n        }\n\n        /** Time after which states regularly set by the status report expire in seconds */\n        const reportStatusExpirySec = Math.floor(this._config.system.statisticsInterval / 1_000) + 10;\n\n        const id = `system.adapter.${this.namespace}`;\n        this.#states.setState(`${id}.alive`, {\n            val: true,\n            ack: true,\n            expire: reportStatusExpirySec,\n            from: id,\n        });\n        this.outputCount++;\n        if (this.connected) {\n            this.#states.setState(`${id}.connected`, {\n                val: true,\n                ack: true,\n                expire: reportStatusExpirySec,\n                from: id,\n            });\n            this.outputCount++;\n        }\n        if (!this.startedInCompactMode) {\n            // pidUsage([pid,pid,...], function (err, stats) {\n            // => {\n            //   cpu: 10.0,            // percentage (from 0 to 100*vcore)\n            //   memory: 357306368,    // bytes\n            //   ppid: 312,            // PPID\n            //   pid: 727,             // PID\n            //   ctime: 867000,        // ms user + system time\n            //   elapsed: 6650000,     // ms since the start of the process\n            //   timestamp: 864000000  // ms since epoch\n            // }\n            pidUsage(process.pid, (err, stats) => {\n                // sometimes adapter is stopped, but this is still running\n                if (!err && this && this.#states && this.#states.setState && stats) {\n                    this.#states.setState(`${id}.cpu`, {\n                        ack: true,\n                        from: id,\n                        val: Math.round(100 * stats.cpu) / 100,\n                        expire: reportStatusExpirySec,\n                    });\n                    this.#states.setState(`${id}.cputime`, {\n                        ack: true,\n                        from: id,\n                        val: stats.ctime / 1_000,\n                        expire: reportStatusExpirySec,\n                    });\n                    this.outputCount += 2;\n                }\n            });\n            try {\n                //RSS is the resident set size, the portion of the process's memory held in RAM (as opposed to the swap space or the part held in the filesystem).\n                const mem = process.memoryUsage();\n                this.#states.setState(`${id}.memRss`, {\n                    val: parseFloat(\n                        (mem.rss / 1048576) /* 1MB */\n                            .toFixed(2),\n                    ),\n                    ack: true,\n                    from: id,\n                    expire: reportStatusExpirySec,\n                });\n                this.#states.setState(`${id}.memHeapTotal`, {\n                    val: parseFloat(\n                        (mem.heapTotal / 1048576) /* 1MB */\n                            .toFixed(2),\n                    ),\n                    ack: true,\n                    from: id,\n                    expire: reportStatusExpirySec,\n                });\n                this.#states.setState(`${id}.memHeapUsed`, {\n                    val: parseFloat(\n                        (mem.heapUsed / 1048576) /* 1MB */\n                            .toFixed(2),\n                    ),\n                    ack: true,\n                    from: id,\n                    expire: reportStatusExpirySec,\n                });\n            } catch (e) {\n                this._logger.warn(`${this.namespaceLog} Could not query used process memory: ${e.message}`);\n            }\n            this.outputCount += 3;\n            if (this.eventLoopLags.length) {\n                const eventLoopLag = Math.ceil(this.eventLoopLags.reduce((a, b) => a + b) / this.eventLoopLags.length);\n                this.#states.setState(`${id}.eventLoopLag`, {\n                    val: eventLoopLag,\n                    ack: true,\n                    from: id,\n                    expire: reportStatusExpirySec,\n                }); // average of measured values\n                this.eventLoopLags = [];\n                this.outputCount++;\n            }\n        }\n        this.outputCount += 3;\n        this.#states.setState(`${id}.uptime`, {\n            val: parseInt(process.uptime().toFixed(), 10),\n            ack: true,\n            from: id,\n            expire: reportStatusExpirySec,\n        });\n        this.#states.setState(`${id}.inputCount`, {\n            val: this.inputCount,\n            ack: true,\n            from: id,\n            expire: reportStatusExpirySec,\n        });\n        this.#states.setState(`${id}.outputCount`, {\n            val: this.outputCount,\n            ack: true,\n            from: id,\n            expire: reportStatusExpirySec,\n        });\n        this.inputCount = 0;\n        this.outputCount = 0;\n    }\n\n    // debug function to find error with stop logging\n    private _checkLogging(): void {\n        let logs: null | string[] = [];\n        // LogList\n        logs.push(`Actual Loglist - ${JSON.stringify(Array.from(this.logList))}`);\n\n        if (!this.#states) {\n            // if adapterState was destroyed, we can not continue\n            return;\n        }\n\n        // Read current state of all log subscribers\n        this.#states.getKeys(`${SYSTEM_ADAPTER_PREFIX}*.logging`, (err, keys) => {\n            if (keys?.length) {\n                if (!this.#states) {\n                    // if adapterState was destroyed, we can not continue\n                    return;\n                }\n\n                this.#states.getStates(keys, (err, obj) => {\n                    if (obj) {\n                        for (let i = 0; i < keys.length; i++) {\n                            const objPart = obj[i];\n                            // We can JSON.parse, but index is 16x faster\n                            if (objPart) {\n                                const id = keys[i].substring(0, keys[i].length - '.logging'.length);\n                                if (\n                                    (typeof objPart === 'string' &&\n                                        // @ts-expect-error recheck code-wise this should not be possible to have a string\n                                        (objPart.includes('\"val\":true') || objPart.includes('\"val\":\"true\"'))) ||\n                                    (typeof objPart === 'object' && (objPart.val === true || objPart.val === 'true'))\n                                ) {\n                                    logs!.push(`Subscriber - ${id} ENABLED`);\n                                } else {\n                                    if (logs) {\n                                        logs.push(`Subscriber - ${id} (disabled)`);\n                                    } else {\n                                        this._logger.error(\n                                            `${this.namespaceLog} LOGINFO: Subscriber - ${id} (disabled)`,\n                                        );\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    if (logs) {\n                        for (let m = 0; m < logs.length; m++) {\n                            this._logger.error(`${this.namespaceLog} LOGINFO: ${logs[m]}`);\n                        }\n                        logs = null;\n                    }\n                });\n            }\n        });\n    }\n\n    /**\n     * Initialize the logging logic\n     */\n    private async _initLogging(): Promise<void> {\n        if (!this.#states) {\n            // if adapterState was destroyed, we can not continue\n            return;\n        }\n\n        // temporary log buffer\n        let messages: null | any[] = [];\n\n        // If some message from logger\n        // find our notifier transport\n        // @ts-expect-error\n        const ts = this._logger.transports.find(t => t.name === 'NT');\n        // @ts-expect-error\n        ts.on('logged', info => {\n            info.from = this.namespace;\n            // emit to itself\n            if (this._options.logTransporter && this.logRequired && !this._stopInProgress) {\n                this.emit('log', info);\n            }\n\n            if (!this.logList.size) {\n                // if log buffer still active\n                if (messages && !this._options.logTransporter) {\n                    messages.push(info);\n\n                    // do not let messages grow without limit\n                    if (messages.length > this._config.states.maxQueue) {\n                        messages.splice(0, messages.length - this._config.states.maxQueue);\n                    }\n                }\n            } else if (this.#states?.pushLog) {\n                // Send to all adapter, that required logs\n                for (const instanceId of this.logList) {\n                    this.#states.pushLog(instanceId, info);\n                }\n            }\n        });\n\n        const keys = await this.#states.getKeys(`${SYSTEM_ADAPTER_PREFIX}*.logging`);\n        if (keys?.length) {\n            if (!this.#states) {\n                // if adapterState was destroyed, we can not continue\n                return;\n            }\n\n            const obj = await this.#states.getStates(keys);\n            if (obj) {\n                for (let i = 0; i < keys.length; i++) {\n                    const objPart = obj[i];\n                    // We can JSON.parse, but index is 16x faster\n                    if (!objPart) {\n                        continue;\n                    }\n                    const id = keys[i].substring(0, keys[i].length - '.logging'.length);\n\n                    if (typeof objPart === 'object' && (objPart.val === true || objPart.val === 'true')) {\n                        this.logRedirect(true, id);\n                    }\n                }\n                if (this.logList.size && messages?.length && this.#states) {\n                    for (const message of messages) {\n                        for (const instanceId of this.logList) {\n                            this.#states.pushLog(instanceId, message);\n                        }\n                    }\n                }\n            }\n            // clear log buffer\n            messages = null;\n        } else {\n            // disable log buffer\n            messages = null;\n        }\n\n        this._options.logTransporter = this._options.logTransporter || this.ioPack.common.logTransporter;\n\n        if (this._options.logTransporter) {\n            this.requireLog = async (isActive, options) => {\n                if (!this.#states) {\n                    return;\n                }\n\n                if (this.logRequired !== isActive) {\n                    this.logRequired = isActive; // remember state\n                    if (!isActive) {\n                        if (this.logOffTimer) {\n                            clearTimeout(this.logOffTimer);\n                        }\n                        // disable log receiving after 10 seconds\n                        this.logOffTimer = setTimeout(async () => {\n                            this.logOffTimer = null;\n                            this._logger.silly(`${this.namespaceLog} Change log subscriber state: FALSE`);\n                            this.outputCount++;\n                            if (this.#states) {\n                                try {\n                                    await this.setForeignStateAsync(\n                                        `system.adapter.${this.namespace}.logging`,\n                                        {\n                                            val: false,\n                                            ack: true,\n                                            from: `system.adapter.${this.namespace}`,\n                                        },\n                                        options,\n                                    );\n                                } catch (e) {\n                                    this._logger.warn(\n                                        `${this.namespaceLog} Could not change log subscriber state to \"false\": ${e.message}`,\n                                    );\n                                }\n                            }\n                        }, 10_000);\n                    } else {\n                        if (this.logOffTimer) {\n                            clearTimeout(this.logOffTimer);\n                            this.logOffTimer = null;\n                        } else {\n                            this._logger.silly(`${this.namespaceLog} Change log subscriber state: true`);\n                            this.outputCount++;\n                            try {\n                                await this.setForeignStateAsync(\n                                    `system.adapter.${this.namespace}.logging`,\n                                    {\n                                        val: true,\n                                        ack: true,\n                                        from: `system.adapter.${this.namespace}`,\n                                    },\n                                    options,\n                                );\n                            } catch (e) {\n                                this._logger.warn(\n                                    `${this.namespaceLog} Could not change log subscriber state to \"true\": ${e.message}`,\n                                );\n                            }\n                        }\n                    }\n                }\n            };\n\n            this.processLog = msg => {\n                if (msg && !this._stopInProgress) {\n                    this.emit('log', msg);\n                }\n            };\n\n            this.#states.subscribeLog(`system.adapter.${this.namespace}`);\n        } else {\n            this.requireLog = isActive => {\n                if (isActive) {\n                    this._logger.warn(\n                        `${this.namespaceLog} requireLog is not supported by this adapter! Please set common.logTransporter to true`,\n                    );\n                }\n            };\n        }\n    }\n\n    // initStates is called from initAdapter\n    private _initStates(cb: () => void): void {\n        this._logger.silly(`${this.namespaceLog} objectDB connected`);\n\n        this._config.states.maxQueue = this._config.states.maxQueue || 1_000;\n\n        this._initializeTimeout = setTimeout(() => {\n            this._initializeTimeout = null;\n            if (this._config.isInstall) {\n                this._logger.warn(`${this.namespaceLog} no connection to states DB. Terminating.`);\n                this.terminate(EXIT_CODES.NO_ERROR);\n            } else {\n                this._logger.warn(`${this.namespaceLog} slow connection to states DB. Still waiting ...`);\n            }\n        }, this._config.states.connectTimeout || 2_000);\n\n        if (!this.States) {\n            this._logger.warn(`${this.namespaceLog} States DB constructor has not been initialized`);\n            this.terminate(EXIT_CODES.NO_ERROR);\n        }\n\n        // Internal object, but some special adapters want to access it anyway.\n        this.#states = new this.States({\n            namespace: this.namespaceLog,\n            connection: this._config.states,\n            connected: async () => {\n                if (!this.#states) {\n                    return;\n                }\n\n                this._logger.silly(`${this.namespaceLog} statesDB connected`);\n                this.statesConnectedTime = Date.now();\n\n                if (this._initializeTimeout) {\n                    clearTimeout(this._initializeTimeout);\n                    this._initializeTimeout = null;\n                }\n\n                if (!this._config.isInstall) {\n                    // Subscribe for process exit signal\n                    this.#states.subscribe(`system.adapter.${this.namespace}.sigKill`);\n\n                    // Subscribe for loglevel\n                    this.#states.subscribe(`system.adapter.${this.namespace}.logLevel`);\n                }\n                if (this._options.subscribable) {\n                    // subscribe on if other instance wants to have states of this adapter\n                    this.#states.subscribe(`system.adapter.${this.namespace}.subscribes`);\n\n                    // read actual autosubscribe requests\n                    let state;\n                    try {\n                        state = await this.#states.getStateAsync(`system.adapter.${this.namespace}.subscribes`);\n                    } catch {\n                        // ignore\n                    }\n                    if (!state?.val) {\n                        this.patterns = {};\n                    } else {\n                        try {\n                            this.patterns = JSON.parse(state.val as string);\n                            Object.keys(this.patterns!).forEach(\n                                p => (this.patterns![p].regex = tools.pattern2RegEx(p)),\n                            );\n                        } catch {\n                            this.patterns = {};\n                        }\n                    }\n                    return tools.maybeCallback(cb);\n                }\n                return tools.maybeCallback(cb);\n            },\n            logger: this._logger,\n            change: async (id, stateOrMessage) => {\n                this.inputCount++;\n                // for simplicity reasons we exclude Message for now TODO\n                const state = stateOrMessage as ioBroker.State | null;\n\n                if (!id || typeof id !== 'string') {\n                    this._logger.warn(`${this.namespaceLog} Invalid id on system state change: ${JSON.stringify(id)}`);\n                    return;\n                }\n\n                if (\n                    id === `system.adapter.${this.namespace}.sigKill` &&\n                    state &&\n                    state.ts > this.statesConnectedTime! &&\n                    state.from &&\n                    state.from.startsWith('system.host.')\n                ) {\n                    const sigKillVal = parseInt(state.val as any);\n                    if (!isNaN(sigKillVal)) {\n                        if (this.startedInCompactMode || sigKillVal === -1) {\n                            this._logger.info(\n                                `${this.namespaceLog} Got terminate signal ${\n                                    sigKillVal === -1 ? 'TERMINATE_YOURSELF' : ` TERMINATE ${sigKillVal}`\n                                }`,\n                            );\n                        } else {\n                            this._logger.warn(\n                                `${this.namespaceLog} Got terminate signal. Checking desired PID: ${sigKillVal} vs own PID ${process.pid}`,\n                            );\n                        }\n                        // by deletion of state, stop this instance\n                        if (sigKillVal !== process.pid && !this._config.forceIfDisabled) {\n                            this._stop({\n                                isPause: false,\n                                isScheduled: false,\n                                exitCode: EXIT_CODES.ADAPTER_REQUESTED_TERMINATION,\n                                updateAliveState: false,\n                            });\n                            setTimeout(() => this.terminate(EXIT_CODES.ADAPTER_REQUESTED_TERMINATION), 4000);\n                        }\n                    }\n                }\n\n                if (id === `system.adapter.${this.namespace}.logLevel`) {\n                    if (this._config && this._config.log && state && !state.ack) {\n                        let currentLevel = this._config.log.level;\n                        if (\n                            state.val &&\n                            state.val !== currentLevel &&\n                            ['silly', 'debug', 'info', 'warn', 'error'].includes(state.val as string)\n                        ) {\n                            this.overwriteLogLevel = true;\n                            this._config.log.level = state.val;\n                            for (const transport in this._logger.transports) {\n                                if (!Object.prototype.hasOwnProperty.call(this._logger.transports, transport)) {\n                                    continue;\n                                }\n                                // set the loglevel on transport only if no loglevel was pinned in log config\n                                // @ts-expect-error it is our own modification\n                                if (!this._logger.transports[transport]._defaultConfigLoglevel) {\n                                    this._logger.transports[transport].level = state.val as string;\n                                }\n                            }\n                            this._logger.info(\n                                `${this.namespaceLog} Loglevel changed from \"${currentLevel}\" to \"${state.val}\"`,\n                            );\n                            currentLevel = state.val;\n                        } else if (state.val && state.val !== currentLevel) {\n                            this._logger.info(`${this.namespaceLog} Got invalid loglevel \"${state.val}\", ignoring`);\n                        }\n                        this.outputCount++;\n                        this.#states &&\n                            this.#states.setState(`system.adapter.${this.namespace}.logLevel`, {\n                                val: currentLevel,\n                                ack: true,\n                                from: `system.adapter.${this.namespace}`,\n                            });\n                    }\n                }\n\n                // todo remove it as an error with log will be found\n                if (id === `system.adapter.${this.namespace}.checkLogging`) {\n                    this._checkLogging();\n                }\n\n                // someone subscribes or unsubscribes from adapter\n                if (this._options.subscribable && id === `system.adapter.${this.namespace}.subscribes`) {\n                    let subs: Record<string, any>;\n                    try {\n                        subs = JSON.parse((state && (state.val as string)) || '{}');\n                        Object.keys(subs).forEach(p => (subs[p].regex = tools.pattern2RegEx(p)));\n                    } catch {\n                        subs = {};\n                    }\n\n                    this.patterns = subs;\n                    if (!this._stopInProgress) {\n                        if (typeof this._options.subscribesChange === 'function') {\n                            this._options.subscribesChange(subs);\n                        } else {\n                            this.emit('subscribesChange', subs);\n                        }\n                    }\n                }\n\n                // If someone want to have log messages\n                if (id.startsWith(SYSTEM_ADAPTER_PREFIX) && id.endsWith('.logging')) {\n                    const instance = id.substring(0, id.length - '.logging'.length);\n\n                    this._logger.silly(`${this.namespaceLog} ${instance}: logging ${state ? state.val : false}`);\n                    this.logRedirect(state ? !!state.val : false, instance);\n                } else if (id === `log.system.adapter.${this.namespace}`) {\n                    this._options.logTransporter && this.processLog && this.processLog(state);\n                } else if (id === `messagebox.system.adapter.${this.namespace}` && state) {\n                    // If this is messagebox\n                    const obj = state as unknown as ioBroker.Message;\n\n                    if (obj) {\n                        let callbackObj: MessageCallbackObject | undefined;\n\n                        if (obj.callback?.id) {\n                            callbackObj = this.messageCallbacks.get(obj.callback.id);\n                        }\n\n                        // If callback stored for this request\n                        if (obj.callback?.ack && obj.callback.id && callbackObj) {\n                            // Call callback function\n                            if (typeof callbackObj.cb === 'function') {\n                                callbackObj.cb(obj.message);\n\n                                if (callbackObj.timer) {\n                                    clearTimeout(callbackObj.timer);\n                                }\n\n                                this.messageCallbacks.delete(obj.callback.id);\n                            }\n                            // delete too old callbacks IDs, like garbage collector\n                            const now = Date.now();\n                            for (const [_id, callback] of this.messageCallbacks) {\n                                if (now - callback.time > 3_600_000) {\n                                    this.messageCallbacks.delete(_id);\n                                }\n                            }\n                        } else if (!this._stopInProgress) {\n                            if (obj.command === 'clientSubscribe') {\n                                const res = await this.uiMessagingController.registerClientSubscribeByMessage(obj);\n                                this.sendTo(obj.from, obj.command, res, obj.callback);\n                                return;\n                            }\n\n                            if (obj.command === 'clientUnsubscribe' || obj.command === 'clientSubscribeError') {\n                                return this.uiMessagingController.removeClientSubscribeByMessage(\n                                    obj as UserInterfaceClientRemoveMessage,\n                                );\n                            }\n\n                            if (this._options.message) {\n                                // Else inform about a new message the adapter\n                                this._options.message(obj);\n                            }\n                            this.emit('message', obj);\n                        }\n                    }\n                } else if (id.startsWith(`system.adapter.${this.namespace}.plugins.`) && id.endsWith('.enabled')) {\n                    if (!state || state.ack) {\n                        return;\n                    }\n                    const pluginStatesIndex = `system.adapter.${this.namespace}.plugins.`.length;\n                    let nameEndIndex: number | undefined = id.indexOf('.', pluginStatesIndex + 1);\n                    if (nameEndIndex === -1) {\n                        nameEndIndex = undefined;\n                    }\n                    const pluginName = id.substring(pluginStatesIndex, nameEndIndex);\n\n                    if (!this.pluginHandler?.pluginExists(pluginName)) {\n                        return;\n                    }\n\n                    if (this.pluginHandler.isPluginActive(pluginName) !== state.val) {\n                        if (state.val) {\n                            if (!this.pluginHandler.isPluginInstantiated(pluginName)) {\n                                this.pluginHandler.instantiatePlugin(\n                                    pluginName,\n                                    this.pluginHandler.getPluginConfig(pluginName) || {},\n                                    thisDir,\n                                );\n                                this.pluginHandler.setDatabaseForPlugin(pluginName, this.#objects, this.#states);\n                                this.pluginHandler.initPlugin(pluginName, this.adapterConfig || {});\n                            }\n                        } else {\n                            if (!this.pluginHandler.destroy(pluginName)) {\n                                this._logger.info(\n                                    `${this.namespaceLog} Plugin ${pluginName} could not be disabled. Please restart adapter to disable it.`,\n                                );\n                            }\n                        }\n                    }\n                } else if (!this._stopInProgress && this.adapterReady && this.aliases.has(id)) {\n                    // If adapter is ready and for this ID exist some alias links\n                    const alias = this.aliases.get(id)!;\n                    /** Prevent multiple publishes if multiple pattern contain this alias id */\n                    const uniqueTargets = new Set<string>();\n\n                    for (const target of alias.targets) {\n                        const targetId = target.id;\n                        if (uniqueTargets.has(targetId)) {\n                            continue;\n                        }\n\n                        uniqueTargets.add(targetId);\n\n                        const source = alias.source;\n\n                        const aState = state\n                            ? tools.formatAliasValue({\n                                  sourceCommon: source,\n                                  targetCommon: target,\n                                  state: deepClone(state),\n                                  logger: this._logger,\n                                  logNamespace: this.namespaceLog,\n                                  sourceId: id,\n                                  targetId,\n                              })\n                            : null;\n\n                        if (aState || !state) {\n                            if (typeof this._options.stateChange === 'function') {\n                                this._options.stateChange(targetId, aState);\n                            } else {\n                                // emit 'stateChange' event instantly\n                                setImmediate(() => this.emit('stateChange', targetId, aState));\n                            }\n                        }\n                    }\n                }\n            },\n            changeUser: (id, state) => {\n                this.inputCount++;\n\n                if (!id || typeof id !== 'string') {\n                    this._logger.warn(`${this.namespaceLog} Invalid id on state change: ${JSON.stringify(id)}`);\n                    return;\n                }\n\n                if (this.adapterReady) {\n                    if (this.oStates) {\n                        if (!state) {\n                            delete this.oStates[id];\n                        } else {\n                            this.oStates[id] = state;\n                        }\n                    }\n\n                    if (!this._stopInProgress) {\n                        if (typeof this._options.stateChange === 'function') {\n                            setImmediate(() => this._options.stateChange!(id, state));\n                        } else {\n                            // emit 'stateChange' event instantly\n                            setImmediate(() => this.emit('stateChange', id, state));\n                        }\n                    }\n                }\n            },\n            disconnected: () => {\n                this.connected = false;\n                !this.terminated &&\n                    setTimeout(() => {\n                        if (this.connected) {\n                            return;\n                        } // If reconnected in the meantime, do not terminate\n                        this._logger.warn(`${this.namespaceLog} Cannot connect/reconnect to states DB. Terminating`);\n                        this.terminate(EXIT_CODES.NO_ERROR);\n                    }, 5000);\n            },\n        });\n    }\n\n    private _initObjects(cb: () => void): void {\n        this._initializeTimeout = setTimeout(() => {\n            this._initializeTimeout = null;\n            if (this._config.isInstall) {\n                this._logger.warn(`${this.namespaceLog} no connection to objects DB. Terminating`);\n                this.terminate(EXIT_CODES.NO_ERROR);\n            } else {\n                this._logger.warn(`${this.namespaceLog} slow connection to objects DB. Still waiting ...`);\n            }\n        }, this._config.objects.connectTimeout * 2); // Because we do not connect only anymore, give it a bit more time\n\n        if (!this.Objects) {\n            this._logger.warn(`${this.namespaceLog} Objects DB constructor has not been initialized`);\n            this.terminate(EXIT_CODES.NO_ERROR);\n        }\n\n        this.#objects = new this.Objects({\n            namespace: this.namespaceLog,\n            connection: this._config.objects,\n            logger: this._logger,\n            connected: async () => {\n                this.connected = true;\n                if (this._initializeTimeout) {\n                    clearTimeout(this._initializeTimeout);\n                    this._initializeTimeout = null;\n                }\n\n                if (!this.#objects) {\n                    return;\n                }\n\n                // subscribe to user changes\n                this.#objects.subscribe('system.user.*');\n\n                // get all enums and register for enum changes\n                this.enums = await tools.getAllEnums(this.#objects);\n                this.#objects.subscribe('enum.*');\n\n                // Read dateformat if using of formatDate is announced\n                if (this._options.useFormatDate) {\n                    this.#objects.getObject('system.config', (err, data) => {\n                        if (data?.common) {\n                            this.dateFormat = data.common.dateFormat;\n                            this.isFloatComma = data.common.isFloatComma;\n                            this.language = data.common.language;\n                            this.longitude = data.common.longitude;\n                            this.latitude = data.common.latitude;\n                            this.defaultHistory = data.common.defaultHistory;\n                        }\n                        if (data?.native) {\n                            this._systemSecret = data.native.secret;\n                        }\n                        return tools.maybeCallback(cb);\n                    });\n                } else {\n                    return tools.maybeCallback(cb);\n                }\n            },\n            disconnected: () => {\n                this.connected = false;\n                !this.terminated &&\n                    setTimeout(() => {\n                        if (this.connected) {\n                            return;\n                        } // If reconnected in the meantime, do not terminate\n\n                        this._logger.warn(`${this.namespaceLog} Cannot connect/reconnect to objects DB. Terminating`);\n                        this.terminate(EXIT_CODES.NO_ERROR);\n                    }, 4000);\n            },\n            change: async (id, obj) => {\n                // System level object changes (and alias objects)\n                if (!id) {\n                    this._logger.error(`${this.namespaceLog} change ID is empty: ${JSON.stringify(obj)}`);\n                    return;\n                }\n\n                // If desired, that adapter must be terminated\n                if (id === `system.adapter.${this.namespace}` && obj?.common?.enabled === false) {\n                    this._logger.info(`${this.namespaceLog} Adapter is disabled => stop`);\n                    this._stop();\n                    setTimeout(() => this.terminate(EXIT_CODES.NO_ERROR), 4_000);\n                    return;\n                }\n\n                // update language, dateFormat and comma\n                if (\n                    id === 'system.config' &&\n                    obj?.common &&\n                    (this._options.useFormatDate || this.defaultHistory !== undefined)\n                ) {\n                    this.dateFormat = obj.common.dateFormat;\n                    this.isFloatComma = obj.common.isFloatComma;\n                    this.language = obj.common.language;\n                    this.longitude = obj.common.longitude;\n                    this.latitude = obj.common.latitude;\n                    this.defaultHistory = obj.common.defaultHistory;\n                }\n\n                // if alias\n                if (id.startsWith(ALIAS_STARTS_WITH)) {\n                    // if `this.aliases` is empty, or no target found, it's a new alias\n                    let isNewAlias = true;\n\n                    for (const [sourceId, alias] of this.aliases) {\n                        const targetAlias = alias.targets.find(entry => entry.id === id);\n\n                        // Find entry for this alias\n                        if (targetAlias) {\n                            isNewAlias = false;\n\n                            // new sourceId or same\n                            if (obj?.common?.alias?.id) {\n                                // check if id.read or id\n                                const newSourceId =\n                                    typeof obj.common.alias.id.read === 'string'\n                                        ? obj.common.alias.id.read\n                                        : obj.common.alias.id;\n\n                                // if linked ID changed\n                                if (newSourceId !== sourceId) {\n                                    await this._removeAliasSubscribe(sourceId, targetAlias);\n                                    try {\n                                        await this._addAliasSubscribe(obj, targetAlias.pattern);\n                                    } catch (e) {\n                                        this._logger.error(\n                                            `${this.namespaceLog} Could not add alias subscription: ${e.message}`,\n                                        );\n                                    }\n                                } else {\n                                    // update attributes\n                                    targetAlias.min = obj.common.min;\n                                    targetAlias.max = obj.common.max;\n                                    targetAlias.type = obj.common.type;\n                                    targetAlias.alias = deepClone(obj.common.alias);\n                                }\n                            } else {\n                                // link was deleted\n                                // remove from targets array\n                                await this._removeAliasSubscribe(sourceId, targetAlias);\n                            }\n                        }\n                    }\n\n                    // it's a new alias, we add it to our subscription\n                    if (isNewAlias && obj) {\n                        for (const aliasPattern of this.aliasPatterns) {\n                            // check if it's in our subs range, if so add it\n                            const testPattern =\n                                aliasPattern.slice(-1) === '*'\n                                    ? new RegExp(tools.pattern2RegEx(aliasPattern))\n                                    : aliasPattern;\n\n                            if (\n                                (typeof testPattern === 'string' && aliasPattern === id) ||\n                                (testPattern instanceof RegExp && testPattern.test(id))\n                            ) {\n                                try {\n                                    await this._addAliasSubscribe(obj, id);\n                                } catch (e) {\n                                    this._logger.warn(\n                                        `${this.namespaceLog} Could not add alias subscription: ${e.message}`,\n                                    );\n                                }\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                // process auto-subscribe adapters\n                if (id.startsWith('system.adapter.')) {\n                    if (obj?.common?.subscribable) {\n                        const _id = id.substring(15); // 'system.adapter.'.length\n                        if (obj.common.enabled) {\n                            if (!this.autoSubscribe.includes(_id)) {\n                                this.autoSubscribe.push(_id);\n                            }\n                        } else {\n                            const pos = this.autoSubscribe.indexOf(_id);\n                            if (pos !== -1) {\n                                this.autoSubscribe.splice(pos, 1);\n                            }\n                        }\n                    }\n                }\n\n                // Clear cache if got the message about change (Will work for admin and javascript - TODO: maybe always subscribe?)\n                if (id.startsWith('system.user.') || id.startsWith('system.group.')) {\n                    this.users = {};\n                    this.groups = {};\n                    this.usernames = {};\n                }\n\n                if (id.startsWith('enum.')) {\n                    if (!obj) {\n                        delete this.enums[id];\n                    } else if (obj.type === 'enum') {\n                        this.enums[id] = obj;\n                    }\n                }\n            },\n            changeUser: (id, obj) => {\n                // User level object changes\n                if (!id) {\n                    this._logger.error(`${this.namespaceLog} change ID is empty: ${JSON.stringify(obj)}`);\n                    return;\n                }\n\n                // remove protectedNative if not admin or own adapter\n                if (\n                    obj &&\n                    'protectedNative' in obj &&\n                    Array.isArray(obj.protectedNative) &&\n                    obj._id &&\n                    obj._id.startsWith('system.adapter.') &&\n                    obj.native &&\n                    !NO_PROTECT_ADAPTERS.includes(this.name) &&\n                    this.name !== obj._id.split('.')[2]\n                ) {\n                    for (const attr of obj.protectedNative) {\n                        delete obj.native[attr];\n                    }\n                }\n\n                if (this.adapterReady) {\n                    // update oObjects structure if desired\n                    if (this.oObjects) {\n                        if (obj) {\n                            this.oObjects[id] = obj;\n                        } else {\n                            delete this.oObjects[id];\n                        }\n                    }\n\n                    if (!this._stopInProgress) {\n                        typeof this._options.objectChange === 'function' &&\n                            // @ts-expect-error\n                            setImmediate(() => this._options.objectChange(id, obj));\n                        // emit 'objectChange' event instantly\n                        setImmediate(() => this.emit('objectChange', id, obj));\n                    }\n                }\n            },\n            changeFileUser: (id, fileName, size) => {\n                if (!id) {\n                    this._logger.error(`${this.namespaceLog} change file name is empty`);\n                    return;\n                }\n                if (this.adapterReady && !this._stopInProgress) {\n                    typeof this._options.fileChange === 'function' &&\n                        setImmediate(() => this._options.fileChange!(id, fileName, size));\n                    // emit 'fileChange' event instantly\n                    setImmediate(() => this.emit('fileChange', id, fileName, size));\n                }\n            },\n        });\n    }\n\n    /**\n     * Called if states and objects successfully initialized\n     */\n    private async _prepareInitAdapter(): Promise<void> {\n        if (this.terminated || !this.#objects || !this.#states) {\n            return;\n        }\n\n        if (this._options.instance !== undefined) {\n            return this._initAdapter(this._options);\n        }\n        const resAlive = await this.#states.getState(`system.adapter.${this.namespace}.alive`);\n        const killRes = await this.#states.getState(`system.adapter.${this.namespace}.sigKill`);\n\n        if (killRes?.val !== undefined) {\n            killRes.val = parseInt(killRes.val as any, 10);\n        }\n        if (!this._config.isInstall && this.startedInCompactMode && killRes && !killRes.ack && killRes.val === -1) {\n            this._logger.error(\n                `${this.namespaceLog} ${this.namespace} needs to be stopped because not correctly started in compact mode`,\n            );\n            this.terminate(EXIT_CODES.ADAPTER_REQUESTED_TERMINATION);\n        } else if (\n            !this._config.forceIfDisabled &&\n            !this._config.isInstall &&\n            !this.startedInCompactMode &&\n            killRes &&\n            killRes.from?.startsWith('system.host.') &&\n            killRes.ack &&\n            !isNaN(killRes.val as any) &&\n            killRes.val !== process.pid\n        ) {\n            this._logger.error(\n                `${this.namespaceLog} ${this.namespace} invalid process id scenario ${killRes.val} vs. own ID ${process.pid}. Stopping`,\n            );\n            this.terminate(EXIT_CODES.ADAPTER_REQUESTED_TERMINATION);\n        } else if (\n            !this._config.isInstall &&\n            resAlive &&\n            resAlive.val === true &&\n            resAlive.ack &&\n            !this._config.forceIfDisabled\n        ) {\n            this._logger.error(`${this.namespaceLog} ${this.namespace} already running`);\n            this.terminate(EXIT_CODES.ADAPTER_ALREADY_RUNNING);\n        } else {\n            let res: ioBroker.InstanceObject | null | undefined;\n            try {\n                res = await this.#objects.getObject(`system.adapter.${this.namespace}`);\n            } catch (e) {\n                this._logger.error(\n                    `${this.namespaceLog} ${this.namespace} Could not get instance object: ${e.message}`,\n                );\n            }\n\n            if (!res && !this._config.isInstall) {\n                this._logger.error(`${this.namespaceLog} ${this.namespace} invalid config`);\n                this.terminate(EXIT_CODES.INVALID_ADAPTER_CONFIG);\n            } else {\n                return this._initAdapter(res);\n            }\n        }\n    }\n\n    /**\n     * Initialize the adapter\n     *\n     * @param adapterConfig the AdapterOptions or the InstanceObject, is null/undefined if it is install process\n     */\n    private async _initAdapter(adapterConfig?: AdapterOptions | ioBroker.InstanceObject | null): Promise<void> {\n        await this._initLogging();\n\n        if (!this.pluginHandler) {\n            return;\n        }\n        this.pluginHandler.setDatabaseForPlugins(this.#objects, this.#states);\n        await this.pluginHandler.initPlugins(adapterConfig || {});\n        if (!this.#states || !this.#objects || this.terminated) {\n            // if adapterState was destroyed,we should not continue\n            return;\n        }\n\n        this.#states.subscribe(`system.adapter.${this.namespace}.plugins.*`);\n        if (this._options.instance === undefined) {\n            if (!adapterConfig || !('common' in adapterConfig) || !adapterConfig.common.enabled) {\n                if (adapterConfig && 'common' in adapterConfig && adapterConfig.common.enabled !== undefined) {\n                    !this._config.isInstall && this._logger.error(`${this.namespaceLog} adapter disabled`);\n                } else {\n                    !this._config.isInstall && this._logger.error(`${this.namespaceLog} no config found for adapter`);\n                }\n\n                if (!this._config.isInstall && (!process.argv || !this._config.forceIfDisabled)) {\n                    const id = `system.adapter.${this.namespace}`;\n                    this.outputCount += 2;\n                    this.#states.setState(`${id}.alive`, { val: true, ack: true, expire: 30, from: id });\n                    let done = false;\n                    this.#states.setState(\n                        `${id}.connected`,\n                        {\n                            val: true,\n                            ack: true,\n                            expire: 30,\n                            from: id,\n                        },\n                        () => {\n                            if (!done) {\n                                done = true;\n                                this.terminate(EXIT_CODES.NO_ADAPTER_CONFIG_FOUND);\n                            }\n                        },\n                    );\n                    setTimeout(() => {\n                        if (!done) {\n                            done = true;\n                            this.terminate(EXIT_CODES.NO_ADAPTER_CONFIG_FOUND);\n                        }\n                    }, 1_000);\n                    return;\n                }\n            }\n\n            if (!this._config.isInstall && (!adapterConfig || !('_id' in adapterConfig))) {\n                this._logger.error(`${this.namespaceLog} invalid config: no _id found`);\n                this.terminate(EXIT_CODES.INVALID_ADAPTER_ID);\n                return;\n            }\n\n            let name;\n            let instance;\n\n            if (!this._config.isInstall) {\n                // @ts-expect-error\n                const tmp = adapterConfig._id.match(/^system\\.adapter\\.([a-zA-Z0-9-_]+)\\.([0-9]+)$/);\n                if (!tmp) {\n                    this._logger.error(`${this.namespaceLog} invalid config`);\n                    this.terminate(EXIT_CODES.INVALID_ADAPTER_ID);\n                    return;\n                }\n                name = tmp[1];\n                instance = parseInt(tmp[2]) || 0;\n            } else {\n                name = this.name;\n                instance = 0;\n                adapterConfig = adapterConfig || {\n                    // @ts-expect-error protectedNative exists on instance objects\n                    common: { mode: 'once', name: name, protectedNative: [] },\n                    native: {},\n                };\n            }\n\n            // @ts-expect-error\n            if (adapterConfig.common.loglevel && !this.overwriteLogLevel) {\n                // set configured in DB log level\n                for (const trans of Object.values(this._logger.transports)) {\n                    // set the loglevel on transport only if no loglevel was pinned in log config\n                    // @ts-expect-error it is our own modification\n                    if (!trans._defaultConfigLoglevel) {\n                        // @ts-expect-error\n                        trans.level = adapterConfig.common.loglevel;\n                    }\n                }\n                // @ts-expect-error\n                this._config.log.level = adapterConfig.common.loglevel;\n            }\n\n            // @ts-expect-error\n            this.name = adapterConfig.common.name;\n            this.instance = instance;\n            this.namespace = `${name}.${instance}`;\n            this.namespaceLog = this.namespace + (this.startedInCompactMode ? ' (COMPACT)' : ` (${process.pid})`);\n            if (!this.startedInCompactMode) {\n                process.title = `io.${this.namespace}`;\n            }\n\n            // @ts-expect-error\n            this.config = adapterConfig.native;\n            // @ts-expect-error\n            this.host = adapterConfig.common.host;\n            // @ts-expect-error\n            this.common = adapterConfig.common;\n\n            if (\n                // @ts-expect-error\n                adapterConfig.common.mode === 'schedule' ||\n                // @ts-expect-error\n                adapterConfig.common.mode === 'once'\n            ) {\n                this.stop = params => this._stop({ ...params, isPause: true });\n            } else if (this.startedInCompactMode) {\n                this.stop = params => this._stop({ ...params, isPause: false });\n                this.kill = this.stop;\n            } else {\n                this.stop = params => this._stop({ ...params, isPause: false });\n            }\n\n            // Monitor logging state\n            this.#states.subscribe(`${SYSTEM_ADAPTER_PREFIX}*.logging`);\n\n            if (\n                typeof this._options.message === 'function' &&\n                // @ts-expect-error, we should infer correctly that this is an InstanceObject in this case\n                !isMessageboxSupported(adapterConfig.common)\n            ) {\n                this._logger.error(\n                    `${this.namespaceLog} : message handler implemented, but messagebox not enabled. Define common.messagebox in io-package.json for adapter or delete message handler.`,\n                );\n                // @ts-expect-error we should infer adapterConfig correctly\n            } else if (isMessageboxSupported(adapterConfig.common)) {\n                this.mboxSubscribed = true;\n                this.#states.subscribeMessage(`system.adapter.${this.namespace}`);\n            }\n        } else {\n            // @ts-expect-error\n            this.name = adapterConfig.name || this.name;\n            // @ts-expect-error\n            this.instance = adapterConfig.instance || 0;\n            this.namespace = `${this.name}.${this.instance!}`;\n            this.namespaceLog = this.namespace + (this.startedInCompactMode ? ' (COMPACT)' : ` (${process.pid})`);\n            // @ts-expect-error\n            this.config = adapterConfig.native || {};\n            // @ts-expect-error\n            this.common = adapterConfig.common || {};\n            this.host = this.common?.host || tools.getHostName() || os.hostname();\n        }\n\n        this.adapterConfig = adapterConfig;\n\n        this._utils = new Validator(\n            this.#objects,\n            this.#states,\n            this.namespaceLog,\n            this._logger,\n            this.namespace,\n            this._namespaceRegExp,\n        );\n\n        this.log = new Log(this.namespaceLog, this._config.log.level, this._logger);\n\n        await this._createInstancesObjects(adapterConfig as ioBroker.InstanceObject);\n\n        // auto oObjects\n        if (this._options.objects) {\n            this.oObjects = await this.getAdapterObjectsAsync();\n            await this.subscribeObjectsAsync('*');\n        }\n\n        // initialize the system secret\n        await this.getSystemSecret();\n\n        // Decrypt all attributes of encryptedNative\n        const promises = [];\n        // @ts-expect-error\n        if (Array.isArray(adapterConfig.encryptedNative)) {\n            // @ts-expect-error\n            for (const attr of adapterConfig.encryptedNative) {\n                // we can only decrypt strings\n                // @ts-expect-error\n                if (typeof this.config[attr] === 'string') {\n                    promises.push(\n                        this.getEncryptedConfig(attr)\n                            // @ts-expect-error\n                            .then(decryptedValue => (this.config[attr] = decryptedValue))\n                            .catch(e =>\n                                this._logger.error(\n                                    `${this.namespaceLog} Can not decrypt attribute ${attr}: ${e.message}`,\n                                ),\n                            ),\n                    );\n                }\n            }\n        } else {\n            // remove encrypted native from supported features, otherwise this can cause issues, if no adapter upload done with js-c v3+ yet\n            const idx = this.SUPPORTED_FEATURES.indexOf('ADAPTER_AUTO_DECRYPT_NATIVE');\n            if (idx !== -1) {\n                this.SUPPORTED_FEATURES.splice(idx, 1);\n            }\n        }\n\n        // Wait till all attributes decrypted\n        await Promise.all(promises);\n\n        if (!this.#states) {\n            // if this.adapterStates was destroyed, we should not continue\n            return;\n        }\n\n        this.outputCount++;\n        // set current loglevel\n        this.#states.setState(`system.adapter.${this.namespace}.logLevel`, {\n            val: this._config.log.level,\n            ack: true,\n            from: `system.adapter.${this.namespace}`,\n        });\n\n        if (this._options.instance === undefined) {\n            this.version = this.pack?.version\n                ? this.pack.version\n                : this.ioPack?.common\n                  ? this.ioPack.common.version\n                  : 'unknown';\n            // display if it's a non-official version - only if installedFrom is explicitly given and differs it's not npm\n            // display if it's a non-official version - only if installedFrom is explicitly given and differs it's not npm\n            const isNpmVersion = isInstalledFromNpm({\n                adapterName: this.name,\n                installedFrom: this.ioPack.common.installedFrom,\n            });\n\n            this._logger.info(\n                `${this.namespaceLog} starting. Version ${this.version} ${\n                    !isNpmVersion ? `(non-npm: ${this.ioPack.common.installedFrom}) ` : ''\n                }in ${this.adapterDir}, node: ${process.version}, js-controller: ${controllerVersion}`,\n            );\n            this._config.system = this._config.system || {};\n            this._config.system.statisticsInterval = parseInt(this._config.system.statisticsInterval, 10) || 15_000;\n            if (!this._config.isInstall) {\n                this._reportInterval = setInterval(() => this._reportStatus(), this._config.system.statisticsInterval);\n                this._reportStatus();\n                const id = `system.adapter.${this.namespace}`;\n                this.#states.setState(`${id}.compactMode`, {\n                    ack: true,\n                    from: id,\n                    val: !!this.startedInCompactMode,\n                });\n\n                this.outputCount++;\n\n                if (this.startedInCompactMode) {\n                    this.#states.setState(`${id}.cpu`, { ack: true, from: id, val: 0 });\n                    this.#states.setState(`${id}.cputime`, { ack: true, from: id, val: 0 });\n                    this.#states.setState(`${id}.memRss`, { val: 0, ack: true, from: id });\n                    this.#states.setState(`${id}.memHeapTotal`, { val: 0, ack: true, from: id });\n                    this.#states.setState(`${id}.memHeapUsed`, { val: 0, ack: true, from: id });\n                    this.#states.setState(`${id}.eventLoopLag`, { val: 0, ack: true, from: id });\n                    this.outputCount += 6;\n                } else {\n                    tools.measureEventLoopLag(1_000, lag => {\n                        if (lag) {\n                            this.eventLoopLags.push(lag);\n                        }\n                    });\n                }\n            }\n        }\n\n        if (adapterConfig && 'common' in adapterConfig && adapterConfig.common.restartSchedule) {\n            try {\n                this._schedule = await import('node-schedule');\n            } catch {\n                this._logger.error(`${this.namespaceLog} Cannot load node-schedule. Scheduled restart is disabled`);\n            }\n            if (this._schedule) {\n                this._logger.debug(`${this.namespaceLog} Schedule restart: ${adapterConfig.common.restartSchedule}`);\n                this._restartScheduleJob = this._schedule.scheduleJob(adapterConfig.common.restartSchedule, () => {\n                    this._logger.info(`${this.namespaceLog} Scheduled restart.`);\n                    this._stop({ isPause: false, isScheduled: true });\n                });\n            }\n        }\n\n        // auto oStates\n        if (this._options.states) {\n            this.getStates('*', null, (err, _states) => {\n                if (this._stopInProgress) {\n                    return;\n                }\n\n                this.oStates = _states;\n                this.subscribeStates('*');\n\n                if (this._firstConnection) {\n                    this._firstConnection = false;\n                    this._callReadyHandler();\n                }\n\n                this.adapterReady = true;\n            });\n        } else if (!this._stopInProgress) {\n            this._callReadyHandler();\n            this.adapterReady = true;\n        }\n    }\n\n    /**\n     * Calls the ready handler, if it is an install run it calls the install handler instead\n     */\n    private _callReadyHandler(): void {\n        if (\n            this._config.isInstall &&\n            (typeof this._options.install === 'function' || this.listeners('install').length)\n        ) {\n            if (typeof this._options.install === 'function') {\n                this._options.install();\n            }\n            this.emit('install');\n        } else {\n            if (typeof this._options.ready === 'function') {\n                this._options.ready();\n            }\n            this.emit('ready');\n        }\n    }\n\n    private async _exceptionHandler(err: NodeJS.ErrnoException, isUnhandledRejection?: boolean): Promise<void> {\n        // If the adapter has a callback to listen for unhandled errors\n        // give it a chance to handle the error itself instead of restarting it\n        if (typeof this._options.error === 'function') {\n            try {\n                // if the error handler in the adapter returned exactly true,\n                // we expect the error to be handled and do nothing more\n                const wasHandled = this._options.error(err);\n                if (wasHandled === true) {\n                    return;\n                }\n            } catch (e) {\n                console.error(`Error in adapter error handler: ${e.message}`);\n            }\n        }\n\n        // catch it on Windows\n        if (this.getPortRunning && err?.message === 'listen EADDRINUSE') {\n            const { host, port, callback } = this.getPortRunning;\n            this._logger.warn(\n                `${this.namespaceLog} Port ${port}${host ? ` for host ${host}` : ''} is in use. Get next`,\n            );\n\n            setImmediate(() => this.getPort(port + 1, host, callback));\n            return;\n        }\n\n        if (isUnhandledRejection) {\n            this._logger.error(\n                `${this.namespaceLog} Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch().`,\n            );\n        }\n        this._logger.error(\n            `${this.namespaceLog} ${isUnhandledRejection ? 'unhandled promise rejection' : 'uncaught exception'}: ${\n                err ? err.message : err\n            }`,\n        );\n        if (err && err.stack) {\n            this._logger.error(`${this.namespaceLog} ${err.stack}`);\n        }\n\n        if (err) {\n            const message = err.code ? `Exception-Code: ${err.code}: ${err.message}` : err.message;\n            this._logger.error(`${this.namespaceLog} ${message}`);\n            try {\n                await this.registerNotification('system', null, message);\n            } catch {\n                // ignore\n            }\n        }\n\n        try {\n            this._stop({\n                isPause: false,\n                isScheduled: false,\n                exitCode: EXIT_CODES.UNCAUGHT_EXCEPTION,\n                updateAliveState: false,\n            });\n            setTimeout(() => this.terminate(EXIT_CODES.UNCAUGHT_EXCEPTION), 1_000);\n        } catch (e) {\n            this._logger.error(`${this.namespaceLog} exception by stop: ${e ? e.message : e}`);\n        }\n    }\n\n    private async _createInstancesObjects(instanceObj: ioBroker.InstanceObject): Promise<void> {\n        let objs: (IoPackageInstanceObject & { state?: unknown })[];\n\n        if (instanceObj?.common && !('onlyWWW' in instanceObj.common) && instanceObj.common.mode !== 'once') {\n            objs = tools.getInstanceIndicatorObjects(this.namespace);\n        } else {\n            objs = [];\n        }\n\n        if (instanceObj && 'instanceObjects' in instanceObj) {\n            for (const instObj of instanceObj.instanceObjects) {\n                const obj: IoPackageInstanceObject & { state?: unknown } = instObj;\n\n                const allowedTopLevelTypes: ioBroker.ObjectType[] = ['meta', 'device'];\n\n                // the object comes from non-checked io-package, so treat the id as unknown\n                if (\n                    !obj ||\n                    typeof (obj._id as unknown) !== 'string' ||\n                    (obj._id === '' && !allowedTopLevelTypes.includes(obj.type))\n                ) {\n                    this._logger.error(\n                        `${this.namespaceLog} ${this.namespace} invalid instance object: ${JSON.stringify(obj)}`,\n                    );\n                    continue;\n                }\n\n                if (!obj._id.startsWith(this.namespace)) {\n                    // instanceObjects are normally defined without namespace prefix\n                    obj._id = obj._id === '' ? this.namespace : `${this.namespace}.${obj._id}`;\n                }\n\n                if (obj.common?.name) {\n                    const commonName = obj.common.name;\n                    // if name has many languages\n                    if (tools.isObject(commonName)) {\n                        for (const [lang, value] of Object.entries(commonName)) {\n                            commonName[lang as ioBroker.Languages] = value.replace(\n                                '%INSTANCE%',\n                                this.instance!.toString(),\n                            );\n                        }\n                    } else {\n                        obj.common.name = commonName.replace('%INSTANCE%', this.instance!.toString());\n                    }\n\n                    if ('desc' in obj.common) {\n                        const commonDesc = obj.common.desc;\n\n                        // if description has many languages\n                        if (tools.isObject(commonDesc)) {\n                            for (const [lang, value] of Object.entries(commonDesc)) {\n                                commonDesc[lang as ioBroker.Languages] = value.replace(\n                                    '%INSTANCE%',\n                                    this.instance!.toString(),\n                                );\n                            }\n                        } else if (commonDesc) {\n                            obj.common.desc = commonDesc.replace('%INSTANCE%', this.instance!.toString());\n                        }\n                    }\n\n                    if (obj.type === 'state' && obj.common.def !== undefined) {\n                        // default value given - if obj non-existing we have to set it\n                        try {\n                            const checkObj = await this.#objects!.objectExists(obj._id);\n                            if (!checkObj) {\n                                obj.state = obj.common.def;\n                            }\n                        } catch (e) {\n                            this._logger.warn(\n                                `${this.namespaceLog} Did not add default (${obj.common.def}) value on creation of ${obj._id}: ${e.message}`,\n                            );\n                        }\n                    }\n                }\n\n                objs.push(obj);\n            }\n        }\n\n        // create logging object for log-transporter instances\n        if (instanceObj?.common?.logTransporter) {\n            // create system.adapter.ADAPTERNAME.instance.logger\n            objs.push({\n                _id: `system.adapter.${this.namespace}.logging`,\n                common: {\n                    type: 'boolean',\n                    name: 'Logging for instance activated',\n                    role: 'indicator.state',\n                    write: false,\n                    read: true,\n                    def: false,\n                },\n                type: 'state',\n                native: {},\n            });\n        }\n\n        return new Promise(resolve => {\n            this._extendObjects(objs, resolve);\n        });\n    }\n\n    private async _extendObjects(tasks: Record<string, any>, callback: () => void): Promise<void> {\n        if (!tasks || !tasks.length) {\n            return tools.maybeCallback(callback);\n        }\n        const task = tasks.shift();\n        const state = task.state;\n        if (state !== undefined) {\n            delete task.state;\n        }\n\n        try {\n            tools.validateGeneralObjectProperties(task, true);\n        } catch (e) {\n            this._logger.error(`${this.namespaceLog} Object ${task._id} is invalid: ${e.message}`);\n            return tools.maybeCallbackWithError(callback, e);\n        }\n\n        if (!this.#objects) {\n            this._logger.info(\n                `${this.namespaceLog} extendObjects not processed because Objects database not connected.`,\n            );\n            return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        // preserve attributes on instance creation\n        const options = { preserve: { common: ['name'], native: true } };\n\n        try {\n            await this.extendForeignObjectAsync(task._id, task, options);\n        } catch {\n            // ignore\n        }\n\n        if (state !== undefined) {\n            if (!this.#states) {\n                this._logger.info(\n                    `${this.namespaceLog} extendObjects not processed because States database not connected.`,\n                );\n                return tools.maybeCallbackWithError(callback, tools.ERRORS.ERROR_DB_CLOSED);\n            }\n            this.outputCount++;\n            this.#states.setState(\n                task._id,\n                {\n                    val: state,\n                    from: `system.adapter.${this.namespace}`,\n                    ack: true,\n                },\n                () => setImmediate(() => this._extendObjects(tasks, callback)),\n            );\n        } else {\n            setImmediate(() => this._extendObjects(tasks, callback));\n        }\n    }\n\n    /**\n     * Replaces forbidden chars in an id if present\n     * Additionally logs a warning\n     *\n     * @param id the id which will be replaced\n     */\n    private fixForbiddenCharsInId(id: string): string {\n        const mId = id.replace(FORBIDDEN_CHARS, '_');\n        if (mId !== id) {\n            this._logger.warn(`${this.namespaceLog} Used invalid characters: ${id} changed to ${mId}`);\n        }\n\n        return mId;\n    }\n\n    /**\n     * This method reports deprecations via Sentry (controller own instance) and can only be used internally\n     *\n     * @param options information about version to remove feature and the log message\n     */\n    private async reportDeprecation(options: InternalReportDeprecationOption): Promise<void> {\n        if (!this.#states) {\n            throw new Error(tools.ERRORS.ERROR_DB_CLOSED);\n        }\n\n        const { version, deprecationMessage } = options;\n\n        const additionalMsg = version\n            ? `This will throw an error up from js-controller version ${version}! `\n            : 'Please report to the developer.';\n\n        this._logger.warn(`${this.namespaceLog} ${deprecationMessage} ${additionalMsg}`);\n\n        if (this.reportedDeprecations.has(deprecationMessage)) {\n            return;\n        }\n\n        this.reportedDeprecations.add(deprecationMessage);\n\n        const obj = {\n            command: 'sendToSentry',\n            message: {\n                extraInfo: {\n                    deprecationMessage,\n                    adapter: this.name,\n                    version: this.version,\n                },\n                message: `Deprecation ${this.name}`,\n                level: 'info',\n            },\n            from: `system.adapter.${this.namespace}`,\n        };\n\n        await this.#states.pushMessage(`system.host.${this.host}`, obj as any);\n    }\n\n    /**\n     * Initialize the plugin handler for this adapter\n     */\n    private _initPluginHandler(): void {\n        const pluginSettings: PluginHandlerSettings = {\n            scope: 'adapter',\n            namespace: `system.adapter.${this.namespace}`,\n            logNamespace: this.namespaceLog,\n            // @ts-expect-error\n            log: this._logger,\n            iobrokerConfig: this._config,\n            // @ts-expect-error\n            parentPackage: this.pack,\n            controllerVersion,\n        };\n\n        this.pluginHandler = new PluginHandler(pluginSettings);\n        try {\n            this.pluginHandler.addPlugins(this.ioPack.common.plugins || {}, [this.adapterDir, thisDir]); // first resolve from adapter directory, else from js-controller\n        } catch (e) {\n            this._logger.error(`Could not add plugins: ${e.message}`);\n        }\n    }\n\n    /**\n     * Initializes the adapter\n     */\n    private async _init(): Promise<void> {\n        /**\n         * Initiates the databases\n         */\n        const _initDBs = (): void => {\n            this._initObjects(() => {\n                if (this.inited) {\n                    this._logger.warn(`${this.namespaceLog} Reconnection to DB.`);\n                    return;\n                }\n\n                this.inited = true;\n                this._initStates(() => this._prepareInitAdapter());\n            });\n        };\n\n        if (fs.existsSync(`${this.adapterDir}/package.json`)) {\n            this.pack = fs.readJSONSync(`${this.adapterDir}/package.json`);\n        } else {\n            this._logger.info(`${this.namespaceLog} Non npm module. No package.json`);\n        }\n\n        // If required system configuration. Store it in systemConfig attribute\n        if (this._options.systemConfig) {\n            this.systemConfig = this._config;\n            // Workaround for an admin 5 issue which could lead to deleting the dataDir folder\n            // TODO: remove it as soon as all adapters are fixed which use systemConfig.dataDir\n            if (!Object.prototype.hasOwnProperty.call(this.systemConfig, 'dataDir')) {\n                this.systemConfig.dataDir = tools.getDefaultDataDir();\n            }\n        }\n\n        if (this._config.states && this._config.states.type) {\n            try {\n                this.States = (await import(`@iobroker/db-states-${this._config.states.type}`)).Client;\n            } catch (e) {\n                throw new Error(`Unknown states type: ${this._config.states.type}: ${e.message}`);\n            }\n        } else {\n            this.States = await getStatesConstructor();\n        }\n\n        if (this._config.objects && this._config.objects.type) {\n            try {\n                this.Objects = (await import(`@iobroker/db-objects-${this._config.objects.type}`)).Client;\n            } catch (e) {\n                throw new Error(`Unknown objects type: ${this._config.objects.type}: ${e.message}`);\n            }\n        } else {\n            this.Objects = await getObjectsConstructor();\n        }\n\n        const ifaces = os.networkInterfaces();\n        const ipArr = [];\n        for (const iface of Object.values(ifaces)) {\n            if (iface) {\n                iface.forEach(details => !details.internal && ipArr.push(details.address));\n            }\n        }\n\n        this.namespaceLog = this.namespace + (this.startedInCompactMode ? ' (COMPACT)' : ` (${process.pid})`);\n\n        // Can be later deleted if no more appears TODO: check\n        this.inited = false;\n\n        process.once('SIGINT', () => this._stop());\n        process.once('SIGTERM', () => this._stop());\n        // And the exit event shuts down the child.\n        process.once('exit', () => this._stop());\n\n        process.on('uncaughtException', err => this._exceptionHandler(err));\n        process.on('unhandledRejection', err => this._exceptionHandler(err as any, true));\n\n        this._initPluginHandler();\n        // finally init\n        _initDBs();\n    }\n}\n\n/**\n * Polyfill to allow calling without `new`\n */\nexport const Adapter = new Proxy(AdapterClass, {\n    apply(target, thisArg, argArray) {\n        // @ts-expect-error fix later on if necessary\n        return new target(...argArray);\n    },\n});\n", "export const __import_meta_url =\n  typeof document === 'undefined' ? new (require('url'.replace('', '')).URL)('file:' + __filename).href :\n    (document.currentScript && document.currentScript.src || new URL('main.js', document.baseURI).href)\n"],
  "mappings": "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",
  "names": ["import_constants", "packJson", "fs", "yargs", "net", "err", "obj", "extend", "path", "s", "objs", "res", "deepClone", "semver", "jwt", "pidUsage", "os"]
}
