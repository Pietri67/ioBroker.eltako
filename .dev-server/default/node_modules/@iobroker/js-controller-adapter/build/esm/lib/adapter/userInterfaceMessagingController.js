export class UserInterfaceMessagingController {
    /** The adapter using this messaging controller */
    adapter;
    /** Callback to call if successfully subscribed */
    unsubscribeCallback;
    /** Callback to call if successfully unsubscribed */
    subscribeCallback;
    /** All currently registered client handlers */
    handlers = new Map();
    /** Collection of current heartbeat timers */
    heartbeatTimers = new Map();
    constructor(options) {
        const { adapter, unsubscribeCallback, subscribeCallback } = options;
        this.adapter = adapter;
        this.unsubscribeCallback = unsubscribeCallback;
        this.subscribeCallback = subscribeCallback;
    }
    /**
     * Send a message to the given clientId
     *
     * @param options Data, states and client information
     */
    sendToClient(options) {
        const { states, clientId, data } = options;
        if (!this.handlers.has(clientId)) {
            throw new Error(`Client "${clientId}" is not registered`);
        }
        const handler = this.handlers.get(clientId);
        return states.pushMessage(handler.from, {
            command: 'im',
            message: { m: handler.type, s: handler.sid, d: data },
            from: `system.adapter.${this.adapter.namespace}`,
        });
    }
    /**
     * Send a message to all active clients
     *
     * @param options Data and states options
     */
    async sendToAllClients(options) {
        const { states, data } = options;
        for (const clientId of Object.keys(this.handlers)) {
            await this.sendToClient({ clientId, data, states });
        }
    }
    /**
     * Register subscription from new client
     *
     * @param msg The subscribe message
     */
    async registerClientSubscribeByMessage(msg) {
        if (!this.subscribeCallback) {
            return;
        }
        const handler = this.extractHandlerFromMessage(msg);
        const clientId = this.handlerToId(handler);
        if (this.heartbeatTimers.has(clientId)) {
            this.heartbeatTimers.get(clientId).timer.refresh();
            return;
        }
        const resOrAwaitable = this.subscribeCallback({ clientId, message: msg });
        let res;
        if (resOrAwaitable instanceof Promise) {
            res = await resOrAwaitable;
        }
        else {
            res = resOrAwaitable;
        }
        if (!res.accepted) {
            return res;
        }
        this.handlers.set(clientId, handler);
        if (res.heartbeat) {
            const timer = setTimeout(() => this.heartbeatExpired(clientId), res.heartbeat);
            this.heartbeatTimers.set(clientId, { heartbeat: res.heartbeat, timer });
        }
        return res;
    }
    /**
     * Remove a client subscription, issued by message
     * It contains an array of types which should be unsubscribed
     *
     * @param msg The unsubscribe message
     */
    removeClientSubscribeByMessage(msg) {
        const handler = this.extractHandlerFromMessage(msg);
        const reason = msg.command === 'clientSubscribeError' ? msg.command : msg.message.reason;
        const types = msg.message.type;
        for (const type of types) {
            const clientId = this.handlerToId({ ...handler, type });
            if (this.heartbeatTimers.has(clientId)) {
                const timer = this.heartbeatTimers.get(clientId);
                clearTimeout(timer.timer);
                this.heartbeatTimers.delete(clientId);
            }
            if (!this.handlers.has(clientId)) {
                return;
            }
            this.handlers.delete(clientId);
            if (this.unsubscribeCallback) {
                this.unsubscribeCallback({ clientId, message: msg, reason });
            }
        }
    }
    /**
     * Convert handler to id
     *
     * @param handler the client handler to creat the id for
     */
    handlerToId(handler) {
        const { sid, type, from } = handler;
        return `${sid}-${from}-${type}`;
    }
    /**
     * Extract the client handler from a given message
     *
     * @param msg the subscribe or unsubscribe message
     */
    extractHandlerFromMessage(msg) {
        return { sid: msg.message.sid, from: msg.from, type: msg.message.type };
    }
    /**
     * Handle expired heartbeat
     *
     * @param clientId the id of the expired client
     */
    heartbeatExpired(clientId) {
        this.handlers.delete(clientId);
        this.heartbeatTimers.delete(clientId);
        if (this.unsubscribeCallback) {
            this.unsubscribeCallback({ clientId, reason: 'timeout' });
        }
    }
}
//# sourceMappingURL=userInterfaceMessagingController.js.map