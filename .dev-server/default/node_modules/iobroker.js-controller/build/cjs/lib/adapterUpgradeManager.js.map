{
  "version": 3,
  "sources": ["../../../src/lib/adapterUpgradeManager.ts"],
  "sourcesContent": ["import { tools } from '@iobroker/js-controller-common';\nimport http from 'node:http';\nimport https from 'node:https';\nimport type { Client as ObjectsClient } from '@iobroker/db-objects-redis';\nimport type { Client as StatesClient } from '@iobroker/db-states-redis';\nimport { setTimeout as wait } from 'node:timers/promises';\nimport type { Logger } from 'winston';\nimport { Upgrade, type ProcessExitCallback } from '@iobroker/js-controller-cli';\nimport type { Socket } from 'node:net';\nimport type { Duplex } from 'node:stream';\n\ninterface Certificates {\n    /** Public certificate */\n    certPublic: string;\n    /** Private certificate */\n    certPrivate: string;\n}\n\ninterface InsecureWebServerParameters {\n    /** if https should be used for the webserver */\n    useHttps: false;\n    /** port of the web server */\n    port: number;\n}\n\ntype SecureWebServerParameters = Omit<InsecureWebServerParameters, 'useHttps'> & {\n    useHttps: true;\n    certPrivateName: string;\n    certPublicName: string;\n};\ntype WebServerParameters = InsecureWebServerParameters | SecureWebServerParameters;\n\nexport type AdapterUpgradeManagerOptions = {\n    /** Version of adapter to upgrade too */\n    version: string;\n    /** Name of the adapter to upgrade */\n    adapterName: string;\n    /** The objects DB client */\n    objects: ObjectsClient;\n    /** The states DB client */\n    states: StatesClient;\n    /** A logger instance */\n    logger: Logger;\n} & WebServerParameters;\n\ninterface GetCertificatesParams {\n    /** Name of the public certificate */\n    certPublicName: string;\n    /** Name of the private certificate */\n    certPrivateName: string;\n}\n\ninterface ServerResponse {\n    /** If the update is still running */\n    running: boolean;\n    stderr: string[];\n    stdout: string[];\n    /** if installation process succeeded */\n    success?: boolean;\n}\n\nexport class AdapterUpgradeManager {\n    /** Wait ms until adapter is stopped */\n    private readonly STOP_TIMEOUT_MS = 3_000;\n    /** Wait ms for delivery of final response */\n    private readonly SHUTDOWN_TIMEOUT = 10_000;\n    /** Name of the adapter to upgrade */\n    private readonly adapterName: string;\n    /** Desired adapter version */\n    private readonly version: string;\n    /** Response send by webserver */\n    private readonly response: ServerResponse = {\n        running: true,\n        stderr: [],\n        stdout: [],\n    };\n    /** Used to stop the stop shutdown timeout */\n    private shutdownAbortController?: AbortController;\n    /** Logger to log to file and other transports */\n    private readonly logger: Logger;\n\n    /** The server used for communicating upgrade status */\n    private server?: https.Server | http.Server;\n    /** All socket connections of the webserver */\n    private sockets = new Set<Socket | Duplex>();\n    /** Name of the host for logging purposes */\n    private readonly hostname = tools.getHostName();\n    /** The objects DB client */\n    private readonly objects: ObjectsClient;\n    /** The states DB client */\n    private readonly states: StatesClient;\n    /** List of instances which have been stopped */\n    private stoppedInstances: string[] = [];\n    /** If webserver should be started with https */\n    private readonly useHttps: boolean;\n    /** Public certificate name if https is desired */\n    private readonly certPublicName?: string;\n    /** Private certificate name if https is desired */\n    private readonly certPrivateName?: string;\n    /** Port where the webserver should be running */\n    private readonly port: number;\n\n    constructor(options: AdapterUpgradeManagerOptions) {\n        this.adapterName = options.adapterName;\n        this.version = options.version;\n        this.logger = options.logger;\n        this.objects = options.objects;\n        this.states = options.states;\n        this.useHttps = options.useHttps;\n        this.port = options.port;\n\n        if (options.useHttps) {\n            this.certPublicName = options.certPublicName;\n            this.certPrivateName = options.certPrivateName;\n        }\n    }\n\n    /**\n     * Stops the adapter and returns ids of stopped instances\n     */\n    async stopAdapter(): Promise<void> {\n        this.stoppedInstances = await this.getAllEnabledInstances();\n        await this.enableInstances(this.stoppedInstances, false);\n        await wait(this.STOP_TIMEOUT_MS);\n    }\n\n    /**\n     * Start all instances which were enabled before the upgrade\n     */\n    async startAdapter(): Promise<void> {\n        await this.enableInstances(this.stoppedInstances, true);\n    }\n\n    /**\n     * Start or stop given instances\n     *\n     * @param instances id of instances which will be stopped\n     * @param enabled if enable or disable instances\n     */\n    async enableInstances(instances: string[], enabled: boolean): Promise<void> {\n        const ts = Date.now();\n        for (const instance of instances) {\n            const updatedObj = {\n                common: {\n                    enabled,\n                },\n                from: `system.host.${this.hostname}`,\n                ts,\n            } as Partial<ioBroker.InstanceObject>;\n\n            await this.objects.extendObjectAsync(instance, updatedObj);\n        }\n    }\n\n    /**\n     * Install given version of adapter\n     */\n    async performUpgrade(): Promise<void> {\n        const processExitHandler: ProcessExitCallback = exitCode => {\n            this.log(`Upgrade process exited with code: ${exitCode}`, true);\n        };\n\n        const upgrade = new Upgrade({\n            objects: this.objects,\n            processExit: processExitHandler,\n            states: this.states,\n            params: {},\n        });\n\n        try {\n            await upgrade.upgradeAdapter(undefined, `${this.adapterName}@${this.version}`, true, true, false);\n            this.response.success = true;\n            this.log(`Successfully upgraded ${this.adapterName} to version ${this.version}`);\n        } catch (e) {\n            this.log(e.message, true);\n            this.response.success = false;\n        }\n\n        await this.setFinished();\n    }\n\n    /**\n     * Starts the web server for admin communication either secure or insecure\n     */\n    async startWebServer(): Promise<void> {\n        if (this.useHttps && this.certPublicName && this.certPrivateName) {\n            await this.startSecureWebServer({\n                certPublicName: this.certPublicName,\n                certPrivateName: this.certPrivateName,\n                port: this.port,\n                useHttps: true,\n            });\n        } else {\n            this.startInsecureWebServer({ port: this.port, useHttps: false });\n        }\n    }\n\n    /**\n     * Shuts down the server, restarts the adapter\n     */\n    shutdownServer(): void {\n        if (this.shutdownAbortController) {\n            this.shutdownAbortController.abort();\n        }\n\n        if (!this.server) {\n            return;\n        }\n\n        this.destroySockets();\n\n        this.server.close(async () => {\n            await this.startAdapter();\n            this.log('Successfully started adapter');\n        });\n    }\n\n    /**\n     * Destroy all sockets, to prevent requests from keeping server alive\n     */\n    destroySockets(): void {\n        for (const socket of this.sockets) {\n            socket.destroy();\n            this.sockets.delete(socket);\n        }\n    }\n\n    /**\n     * This function is called when the webserver receives a message\n     *\n     * @param req received message\n     * @param res server response\n     */\n    webServerCallback(req: http.IncomingMessage, res: http.ServerResponse): void {\n        res.writeHead(200);\n        res.end(JSON.stringify(this.response));\n\n        if (!this.response.running) {\n            this.log('Final information delivered');\n            this.shutdownServer();\n        }\n    }\n\n    /**\n     * Get all instances of the adapter\n     */\n    async getAllEnabledInstances(): Promise<string[]> {\n        const res = await this.objects.getObjectListAsync({\n            startkey: `system.adapter.${this.adapterName}.`,\n            endkey: `system.adapter.${this.adapterName}.\\u9999`,\n        });\n\n        let enabledInstances: string[] = [];\n\n        enabledInstances = res.rows\n            .filter(row => row.value.common.enabled && this.hostname === row.value.common.host)\n            .map(row => row.value._id);\n\n        return enabledInstances;\n    }\n\n    /**\n     * Log via logger and provide the logs for the server too\n     *\n     * @param message the message which will be logged\n     * @param error if it is an error\n     */\n    log(message: string, error = false): void {\n        if (error) {\n            this.logger.error(`host.${this.hostname} ${message}`);\n            this.response.stderr.push(message);\n            return;\n        }\n\n        this.logger.info(`host.${this.hostname} [WEBSERVER_UPGRADE] (${this.adapterName}) ${message}`);\n        this.response.stdout.push(message);\n    }\n\n    /**\n     * Start an insecure web server for admin communication\n     *\n     * @param params Web server configuration\n     */\n    startInsecureWebServer(params: InsecureWebServerParameters): void {\n        const { port } = params;\n\n        this.server = http.createServer((req, res) => {\n            this.webServerCallback(req, res);\n        });\n\n        this.monitorSockets(this.server);\n\n        this.server.listen(port, () => {\n            this.log(`Server is running on http://localhost:${port}`);\n        });\n    }\n\n    /**\n     * Start a secure web server for admin communication\n     *\n     * @param params Web server configuration\n     */\n    async startSecureWebServer(params: SecureWebServerParameters): Promise<void> {\n        const { port, certPublicName, certPrivateName } = params;\n\n        const { certPublic, certPrivate } = await this.getCertificates({ certPublicName, certPrivateName });\n\n        this.server = https.createServer({ key: certPrivate, cert: certPublic }, (req, res) => {\n            this.webServerCallback(req, res);\n        });\n\n        this.monitorSockets(this.server);\n\n        this.server.listen(port, () => {\n            this.log(`Server is running on http://localhost:${port}`);\n        });\n    }\n\n    /**\n     * Keep track of all existing sockets\n     *\n     * @param server the webserver\n     */\n    monitorSockets(server: http.Server | https.Server): void {\n        server.on('connection', socket => {\n            this.sockets.add(socket);\n\n            server.once('close', () => {\n                this.sockets.delete(socket);\n            });\n        });\n    }\n\n    /**\n     * Get certificates from the DB\n     *\n     * @param params certificate information\n     */\n    async getCertificates(params: GetCertificatesParams): Promise<Certificates> {\n        const { certPublicName, certPrivateName } = params;\n\n        const obj = await this.objects.getObjectAsync('system.certificates');\n\n        if (!obj) {\n            throw new Error('No certificates found');\n        }\n\n        const certs = obj.native.certificates;\n\n        return { certPrivate: certs[certPrivateName], certPublic: certs[certPublicName] };\n    }\n\n    /**\n     * Tells the upgrade manager, that server can be shut down on next response or on timeout\n     */\n    private async setFinished(): Promise<void> {\n        this.response.running = false;\n\n        await this.startShutdownTimeout();\n    }\n\n    /**\n     * Start a timeout which starts adapter and shuts down the server if expired\n     */\n    async startShutdownTimeout(): Promise<void> {\n        this.shutdownAbortController = new AbortController();\n        try {\n            await wait(this.SHUTDOWN_TIMEOUT, null, { signal: this.shutdownAbortController.signal });\n\n            this.log('Timeout expired, initializing shutdown');\n            this.shutdownServer();\n        } catch (e) {\n            if (e.code !== 'ABORT_ERR') {\n                this.log(e.message, true);\n            }\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": ["wait", "http", "https"]
}
