{
  "version": 3,
  "sources": ["../../src/main.ts", "../../../../node_modules/@alcalzone/esm2cjs/shims/import.meta.url/shim.js"],
  "sourcesContent": ["/// <reference types=\"@iobroker/types-dev\" />\nimport schedule from 'node-schedule';\nimport os from 'node:os';\nimport fs from 'fs-extra';\nimport path from 'node:path';\nimport cp, { spawn, exec } from 'node:child_process';\nimport semver from 'semver';\nimport restart from '@/lib/restart.js';\nimport pidUsage from 'pidusage';\nimport deepClone from 'deep-clone';\nimport { isDeepStrictEqual, inspect } from 'node:util';\nimport {\n    tools,\n    EXIT_CODES,\n    logger as toolsLogger,\n    isLocalObjectsDbServer,\n    isLocalStatesDbServer,\n    NotificationHandler,\n    getObjectsConstructor,\n    getStatesConstructor,\n    zipFiles,\n    getInstancesOrderedByStartPrio,\n    isInstalledFromNpm,\n} from '@iobroker/js-controller-common';\nimport {\n    SYSTEM_ADAPTER_PREFIX,\n    SYSTEM_CONFIG_ID,\n    SYSTEM_HOST_PREFIX,\n    SYSTEM_REPOSITORIES_ID,\n} from '@iobroker/js-controller-common-db/constants';\nimport { PluginHandler } from '@iobroker/plugin-base';\nimport type SentryPlugin from '@iobroker/plugin-sentry';\nimport { BlocklistManager } from '@/lib/blocklistManager.js';\nimport type { Client as ObjectsClient } from '@iobroker/db-objects-redis';\nimport type { Client as StatesClient } from '@iobroker/db-states-redis';\nimport { Upload, PacketManager, type UpgradePacket } from '@iobroker/js-controller-cli';\nimport decache from 'decache';\nimport cronParser from 'cron-parser';\nimport type { PluginHandlerSettings } from '@iobroker/plugin-base/types';\nimport type { GetDiskInfoResponse } from '@iobroker/js-controller-common-db/tools';\nimport { DEFAULT_DISK_WARNING_LEVEL, getCronExpression, getDiskWarningLevel } from '@/lib/utils.js';\nimport { AdapterAutoUpgradeManager } from '@/lib/adapterAutoUpgradeManager.js';\nimport {\n    getHostObject,\n    getDefaultNodeArgs,\n    type HostInfo,\n    isAdapterEsmModule,\n} from '@iobroker/js-controller-common-db/tools';\nimport type { UpgradeArguments } from '@/lib/upgradeManager.js';\nimport { AdapterUpgradeManager } from '@/lib/adapterUpgradeManager.js';\nimport { setTimeout as wait } from 'node:timers/promises';\nimport { getHostObjects } from '@/lib/objects.js';\nimport * as url from 'node:url';\nimport { createRequire } from 'node:module';\n// eslint-disable-next-line unicorn/prefer-module\nconst thisDir = url.fileURLToPath(new URL('.', import.meta.url || `file://${__filename}`));\n// eslint-disable-next-line unicorn/prefer-module\nconst require = createRequire(import.meta.url || `file://${__filename}`);\n\ntype DiagInfoType = 'extended' | 'normal' | 'no-city' | 'none';\ntype Dependencies = string[] | Record<string, string>[] | string | Record<string, string>;\n\ninterface GetLogFilesResult {\n    list: { fileName: string; size: number }[];\n}\ninterface UploadTask {\n    adapter: string;\n    msg?: ioBroker.SendableMessage;\n}\n\ninterface RebuildArgs {\n    module: string;\n    path: string;\n    version: string;\n}\n\ninterface InstallQueueEntry {\n    id: ioBroker.ObjectIDs.Instance;\n    rebuild?: boolean;\n    disabled?: boolean;\n    version?: string;\n    installedFrom?: string;\n    wakeUp?: boolean;\n    rebuildArgs?: RebuildArgs;\n    inProgress?: boolean;\n}\n\ninterface Process {\n    /** the process itself */\n    process?: cp.ChildProcess;\n    /** the config of the instance (mainly io-pack attributes) */\n    config: ioBroker.InstanceObject;\n    restartTimer?: NodeJS.Timeout;\n    restartExpected?: boolean;\n    downloadRetry?: number;\n    startedInCompactMode?: boolean;\n    needsRebuild?: boolean;\n    errors?: { ts: number; text: string }[];\n    rebuildCounter?: number;\n    rebuildArgs?: RebuildArgs;\n    startedAsCompactGroup?: boolean;\n    engine?: string;\n    lastCleanErrors?: number;\n    lastStart?: number;\n    /** Name of variable, that is subscribed automatically */\n    subscribe?: string;\n    stopping?: boolean;\n    crashCount?: number;\n    crashResetTimer?: NodeJS.Timeout;\n    schedule?: schedule.Job;\n}\n\ninterface CompactProcess extends Process {\n    /** instances in this compact group */\n    instances: ioBroker.ObjectIDs.Instance[];\n    /** the process itself */\n    process?: cp.ChildProcess;\n}\n\ninterface StopTimeoutObject {\n    timeout: NodeJS.Timeout | null;\n    callback?: (() => void) | null;\n}\n\ninterface RepoRequester {\n    /** requesting instance */\n    from: string;\n    callback: ioBroker.MessageCallbackInfo;\n}\n\ninterface SendResponseToOptions {\n    /** The message we want to respond to */\n    receivedMsg: ioBroker.SendableMessage;\n    /** The response payload */\n    payload: Record<string, unknown>;\n}\n\n/** Host information including host id and running version */\ntype HostInformation = ioBroker.HostCommon & { host: string; runningVersion: string };\n\nconst VIS_ADAPTERS = ['vis', 'vis-2'] as const;\nconst ioPackage = fs.readJSONSync(path.join(tools.getControllerDir(), 'io-package.json'));\nconst version = ioPackage.common.version;\n/** controller versions of multihost environments */\nconst controllerVersions: Record<string, string> = {};\n\nlet pluginHandler: InstanceType<typeof PluginHandler>;\nlet notificationHandler: NotificationHandler;\nlet blocklistManager: BlocklistManager;\nlet autoUpgradeManager: AdapterAutoUpgradeManager;\n/** array of instances which have requested repo update */\nlet requestedRepoUpdates: RepoRequester[] = [];\n\nlet upload: InstanceType<typeof Upload>; // will be used only once by upload of adapter\n\n/* Use require('loadavg-windows') to enjoy os.loadavg() on Windows OS.\n   Currently, Node.js on a Windows platform does not implement os.loadavg() functionality - it returns [0,0,0]\n   Expect first results after 1 min from application start (before 1 min runtime it will return [0,0,0])\n   Requiring it on other operating systems has NO influence.*/\nif (os.platform() === 'win32') {\n    require('loadavg-windows');\n}\n\ntools.ensureDNSOrder();\n\nlet Objects: typeof ObjectsClient;\nlet States: typeof StatesClient;\n\nlet logger: ReturnType<typeof toolsLogger>;\nlet isDaemon = false;\nlet callbackId = 1;\nconst callbacks: Record<string, { time: number; cb: (message: ioBroker.MessagePayload) => void }> = {};\nconst hostname = tools.getHostName();\nconst controllerDir = tools.getControllerDir();\nlet hostObjectPrefix: ioBroker.ObjectIDs.Host = `system.host.${hostname}`;\nlet hostLogPrefix = `host.${hostname}`;\nconst compactGroupObjectPrefix = '.compactgroup';\nconst logList: string[] = [];\nlet detectIpsCount = 0;\nlet objectsDisconnectTimeout: null | NodeJS.Timeout = null;\nlet statesDisconnectTimeout: null | NodeJS.Timeout = null;\nlet connected: null | boolean = null; // not false, because want to detect first connection\nlet lastDiskSizeCheck = 0;\nlet restartTimeout: null | NodeJS.Timeout = null;\nlet connectTimeout: null | NodeJS.Timeout = null;\nlet reportInterval: null | NodeJS.Timeout = null;\nlet primaryHostInterval: null | NodeJS.Timeout = null;\nlet isPrimary = false;\n/** If system reboot is required */\nlet isRebootRequired = false;\n\nconst PRIMARY_HOST_LOCK_TIME = 60_000;\nconst VENDOR_BOOTSTRAP_FILE = '/opt/iobroker/iob-vendor-secret.json';\nconst VENDOR_FILE = '/etc/iob-vendor.json';\n\nconst procs: Record<string, Process> = {};\nconst subscribe: Record<string, ioBroker.ObjectIDs.Instance[]> = {};\nconst stopTimeouts: Record<string, StopTimeoutObject> = {};\nlet states: StatesClient | null = null;\nlet objects: ObjectsClient | null = null;\nlet storeTimer: NodeJS.Timeout | null = null;\nlet mhTimer: NodeJS.Timeout | null = null;\nlet isStopping: null | number = null;\nlet allInstancesStopped = true;\nlet stopTimeout = 10_000;\nlet uncaughtExceptionCount = 0;\nlet installQueue: InstallQueueEntry[] = [];\nlet started = false;\nlet inputCount = 0;\nlet outputCount = 0;\nlet eventLoopLags: number[] = [];\nlet mhService: any = null; // multihost service\nconst uptimeStart = Date.now();\nlet compactGroupController = false;\nlet compactGroup: null | number = null;\nconst compactProcs: Record<string, CompactProcess> = {};\nconst scheduledInstances: Record<string, any> = {};\n/** If less than this disk space free in %, generate a warning */\nlet diskWarningLevel = DEFAULT_DISK_WARNING_LEVEL;\n\nlet updateIPsTimer: NodeJS.Timeout | null = null;\nlet lastDiagSend: null | number = null;\n\nconst config = getConfig();\n\n/**\n * Get the error text from an exit code\n *\n * @param code exit code\n */\nfunction getErrorText(code: number): string {\n    return EXIT_CODES[code];\n}\n\n/**\n * Get the config directly from fs - never cached\n */\nfunction getConfig(): ioBroker.IoBrokerJson | never {\n    const configFile = tools.getConfigFileName();\n    if (!fs.existsSync(configFile)) {\n        if (process.argv.indexOf('start') !== -1) {\n            isDaemon = true;\n            logger = toolsLogger('info', [tools.appName], true);\n        } else {\n            logger = toolsLogger('info', [tools.appName]);\n        }\n        logger.error(\n            `${hostLogPrefix} conf/${tools.appName.toLowerCase()}.json missing - call node ${tools.appName.toLowerCase()}.js setup`,\n        );\n        process.exit(EXIT_CODES.MISSING_CONFIG_JSON);\n    } else {\n        // TODO: adjust return type as soon as #2120 merged and we have the type\n        const _config = fs.readJSONSync(configFile);\n        if (!_config.states) {\n            _config.states = { type: 'jsonl' };\n        }\n        if (!_config.objects) {\n            _config.objects = { type: 'jsonl' };\n        }\n        if (!_config.system) {\n            _config.system = {};\n        }\n        return _config;\n    }\n}\n\n/**\n *\n * @param _config\n * @param secret\n */\nasync function _startMultihost(_config: ioBroker.IoBrokerJson, secret: string | false): Promise<void> {\n    const MHService = await import('./lib/multihostServer.js');\n    const cpus = os.cpus();\n    mhService = new MHService.MHServer(\n        hostname,\n        logger,\n        _config,\n        {\n            node: process.version,\n            arch: os.arch(),\n            model: cpus && cpus[0] && cpus[0].model ? cpus[0].model : 'unknown',\n            cpus: cpus ? cpus.length : 1,\n            mem: os.totalmem(),\n            ostype: os.type(),\n        },\n        tools.findIPs(),\n        secret,\n    );\n}\n\n/**\n * Starts or stops the multihost discovery server, depending on the config and temp information\n *\n * @param __config - the iobroker config object\n */\nasync function startMultihost(__config?: ioBroker.IoBrokerJson): Promise<boolean | void> {\n    if (compactGroupController) {\n        return;\n    }\n\n    if (mhTimer) {\n        clearTimeout(mhTimer);\n        mhTimer = null;\n    }\n\n    const _config = __config || getConfig();\n    if (_config.multihostService?.enabled) {\n        if (mhService) {\n            try {\n                mhService.close(() => {\n                    mhService = null;\n                    setImmediate(() => startMultihost(_config));\n                });\n                return;\n            } catch (e) {\n                logger.warn(`${hostLogPrefix} Cannot stop multihost discovery server: ${e.message}`);\n            }\n        }\n\n        const hasLocalObjectsServer = await isLocalObjectsDbServer(_config.objects.type, _config.objects.host, true);\n        const hasLocalStatesServer = await isLocalStatesDbServer(_config.states.type, _config.states.host, true);\n\n        if (!_config.objects.host || hasLocalObjectsServer) {\n            logger.warn(\n                `${hostLogPrefix} Multihost Master on this system is not possible, because IP address for objects is ${_config.objects.host}. Please allow remote connections to the server by adjusting the IP.`,\n            );\n            return false;\n        } else if (!_config.states.host || hasLocalStatesServer) {\n            logger.warn(\n                `${hostLogPrefix} Multihost Master on this system is not possible, because IP address for states is ${_config.states.host}. Please allow remote connections to the server by adjusting the IP.`,\n            );\n            return false;\n        }\n\n        if (_config.multihostService.secure) {\n            if (typeof _config.multihostService.password === 'string' && _config.multihostService.password.length) {\n                let obj: ioBroker.SystemConfigObject | null | undefined;\n                let errText;\n                try {\n                    obj = await objects!.getObject(SYSTEM_CONFIG_ID);\n                } catch (e) {\n                    // will log error below\n                    errText = e.message;\n                }\n\n                if (obj?.native?.secret) {\n                    if (!_config.multihostService.password.startsWith(`$/aes-192-cbc:`)) {\n                        // if old encryption was used, we need to decrypt in old fashion\n                        tools.decryptPhrase(obj.native.secret, _config.multihostService.password, secret =>\n                            _startMultihost(_config, secret!),\n                        );\n                    } else {\n                        try {\n                            // it can throw in edge cases #1474, we need further investigation\n                            const secret = tools.decrypt(obj.native.secret, _config.multihostService.password);\n                            _startMultihost(_config, secret);\n                        } catch (e) {\n                            logger.error(\n                                `${hostLogPrefix} Cannot decrypt password for multihost discovery server: ${e.message}`,\n                            );\n                        }\n                    }\n                } else {\n                    logger.error(\n                        `${hostLogPrefix} Cannot start multihost discovery server: no system.config found (err: ${errText})`,\n                    );\n                }\n            } else {\n                logger.error(\n                    `${hostLogPrefix} Cannot start multihost discovery server: secure mode was configured, but no secret was set. Please check the configuration!`,\n                );\n            }\n        } else {\n            _startMultihost(_config, false);\n        }\n\n        if (!_config.multihostService.persist) {\n            mhTimer = setTimeout(async () => {\n                if (mhService) {\n                    try {\n                        mhService.close();\n                        mhService = null;\n                        logger.info(\n                            `${hostLogPrefix} Multihost discovery server stopped after 15 minutes, because only temporarily activated`,\n                        );\n                        _config.multihostService.persist = false;\n                        _config.multihostService.enabled = false;\n                        const configFile = tools.getConfigFileName();\n                        await fs.writeFile(configFile, JSON.stringify(_config, null, 2));\n                    } catch (e) {\n                        logger.warn(`${hostLogPrefix} Cannot stop multihost discovery: ${e.message}`);\n                    }\n                }\n                mhTimer = null;\n            }, 15 * 60000);\n        }\n\n        return true;\n    } else if (mhService) {\n        try {\n            mhService.close();\n            mhService = null;\n        } catch (e) {\n            logger.warn(`${hostLogPrefix} Cannot stop multihost discovery: ${e.message}`);\n        }\n        return false;\n    }\n}\n\n/**\n * Starts cyclic update of IP interfaces.\n * At start every 30 seconds and after 5 minutes, every hour.\n * Because DHCP could change the IPs.\n */\nfunction startUpdateIPs(): void {\n    if (!updateIPsTimer) {\n        updateIPsTimer = setInterval(() => {\n            if (Date.now() - uptimeStart > 5 * 60_000) {\n                // 5 minutes at start check every 30 seconds because of DHCP\n                clearInterval(updateIPsTimer!);\n\n                updateIPsTimer = setInterval(() => setIPs(), 3_600_000); // update IPs every hour\n            }\n            setIPs();\n        }, 30_000);\n    }\n}\n\n// subscribe or unsubscribe loggers\n/**\n *\n * @param isActive\n * @param id\n * @param reason\n */\nfunction logRedirect(isActive: boolean, id: string, reason: string): void {\n    console.log(`================================== > LOG REDIRECT ${id} => ${isActive} [${reason}]`);\n    if (isActive) {\n        if (!logList.includes(id)) {\n            logList.push(id);\n        }\n    } else {\n        const pos = logList.indexOf(id);\n        if (pos !== -1) {\n            logList.splice(pos, 1);\n        }\n    }\n}\n\nfunction handleDisconnect(): void {\n    if (!connected || restartTimeout || isStopping) {\n        return;\n    }\n    if (statesDisconnectTimeout) {\n        clearTimeout(statesDisconnectTimeout);\n        statesDisconnectTimeout = null;\n    }\n    if (objectsDisconnectTimeout) {\n        clearTimeout(objectsDisconnectTimeout);\n        objectsDisconnectTimeout = null;\n    }\n\n    connected = false;\n    logger.warn(`${hostLogPrefix} Slave controller detected disconnection. Stop all instances.`);\n    if (compactGroupController) {\n        stop(true);\n    } else {\n        stop(true, () => {\n            restartTimeout = setTimeout(() => {\n                processMessage({ command: 'cmdExec', message: { data: '_restart' }, from: hostObjectPrefix });\n                setTimeout(() => process.exit(EXIT_CODES.JS_CONTROLLER_STOPPED), 1_000);\n            }, 10_000);\n        });\n    }\n}\n\n/**\n *\n * @param onConnect\n */\nfunction createStates(onConnect: () => void): void {\n    states = new States({\n        namespace: hostLogPrefix,\n        connection: config.states,\n        logger: logger,\n        hostname: hostname,\n        change: async (id, stateOrMessage) => {\n            if (!states || !objects) {\n                logger.error(`${hostLogPrefix} Could not handle state change of \"${id}\", because not connected`);\n                return;\n            }\n\n            inputCount++;\n            if (!id) {\n                return logger.error(`${hostLogPrefix} change event with no ID: ${JSON.stringify(stateOrMessage)}`);\n            }\n            // If some log transporter activated or deactivated\n            if (id.startsWith(SYSTEM_ADAPTER_PREFIX) && id.endsWith('.logging')) {\n                const state = stateOrMessage as ioBroker.State;\n                logRedirect(state ? (state.val as boolean) : false, id.substring(0, id.length - '.logging'.length), id);\n            } else if (!compactGroupController && id === `messagebox.${hostObjectPrefix}`) {\n                // If this is messagebox, only the main controller is handling the host messages\n                const obj = stateOrMessage as ioBroker.Message;\n                if (obj) {\n                    // If callback stored for this request\n                    if (obj.callback && obj.callback.ack && obj.callback.id && callbacks[`_${obj.callback.id}`]) {\n                        callbacks[`_${obj.callback.id}`].cb(obj.message);\n                        delete callbacks[`_${obj.callback.id}`];\n\n                        // delete too old callbacks IDs\n                        const now = Date.now();\n                        for (const _id of Object.keys(callbacks)) {\n                            if (now - callbacks[_id].time > 3_600_000) {\n                                delete callbacks[_id];\n                            }\n                        }\n                    } else {\n                        processMessage(obj);\n                    }\n                }\n            } else if (!compactGroupController && id.match(/^system.adapter.[^.]+\\.\\d+\\.alive$/)) {\n                const state = stateOrMessage as ioBroker.State;\n                // If this system.adapter.NAME.0.alive, only main controller is handling this\n                if (state && !state.ack) {\n                    const enabled = state.val;\n                    let obj: ioBroker.Object | null | undefined;\n\n                    try {\n                        obj = await objects.getObject(id.substring(0, id.length - 6 /*'.alive'.length*/));\n                    } catch (e) {\n                        logger.error(`${hostLogPrefix} Cannot read object: ${e.message}`);\n                    }\n\n                    if (obj?.common) {\n                        // IF adapter enabled => disable it\n                        if ((obj.common.enabled && !enabled) || (!obj.common.enabled && enabled)) {\n                            obj.common.enabled = !!enabled;\n                            logger.info(\n                                `${hostLogPrefix} instance \"${obj._id}\" ${\n                                    obj.common.enabled ? 'enabled' : 'disabled'\n                                } via .alive`,\n                            );\n                            obj.from = hostObjectPrefix;\n                            obj.ts = Date.now();\n                            try {\n                                await objects.setObject(obj._id, obj);\n                            } catch (e) {\n                                logger.error(`${hostLogPrefix} Cannot set object: ${e.message}`);\n                            }\n                        }\n                    }\n                }\n            } else if (subscribe[id]) {\n                const state = stateOrMessage as ioBroker.State;\n\n                for (const sub of subscribe[id]) {\n                    // wake up adapter\n                    if (procs[sub]) {\n                        console.log(`Wake up ${id} ${JSON.stringify(state)}`);\n                        startInstance(sub, true);\n                    } else {\n                        logger.warn(`${hostLogPrefix} controller Adapter subscribed on ${id} does not exist!`);\n                    }\n                }\n            } else if (id === `${hostObjectPrefix}.logLevel`) {\n                const state = stateOrMessage as ioBroker.State;\n\n                if (!config || !config.log || !state || state.ack) {\n                    return;\n                }\n                let currentLevel = config.log.level;\n                if (\n                    typeof state.val === 'string' &&\n                    state.val !== currentLevel &&\n                    ['silly', 'debug', 'info', 'warn', 'error'].includes(state.val)\n                ) {\n                    config.log.level = state.val;\n                    for (const transport in logger.transports) {\n                        if (\n                            logger.transports[transport].level === currentLevel &&\n                            // @ts-expect-error it's our custom property\n                            !logger.transports[transport]._defaultConfigLoglevel\n                        ) {\n                            logger.transports[transport].level = state.val;\n                        }\n                    }\n                    logger.info(`${hostLogPrefix} Loglevel changed from \"${currentLevel}\" to \"${state.val}\"`);\n                    currentLevel = state.val;\n                } else if (state.val && state.val !== currentLevel) {\n                    logger.info(`${hostLogPrefix} Got invalid loglevel \"${state.val}\", ignoring`);\n                }\n                await states.setState(`${hostObjectPrefix}.logLevel`, {\n                    val: currentLevel,\n                    ack: true,\n                    from: hostObjectPrefix,\n                });\n            } else if (id.startsWith(`${hostObjectPrefix}.plugins.`) && id.endsWith('.enabled')) {\n                const state = stateOrMessage as ioBroker.State;\n\n                if (!config || !config.log || !state || state.ack) {\n                    return;\n                }\n                const pluginStatesIndex = `${hostObjectPrefix}.plugins.`.length;\n                let nameEndIndex: number | undefined = id.indexOf('.', pluginStatesIndex + 1);\n                if (nameEndIndex === -1) {\n                    nameEndIndex = undefined;\n                }\n                const pluginName = id.substring(pluginStatesIndex, nameEndIndex);\n                if (!pluginHandler.pluginExists(pluginName)) {\n                    return;\n                }\n                if (pluginHandler.isPluginActive(pluginName) !== state.val) {\n                    if (state.val) {\n                        if (!pluginHandler.isPluginInstantiated(pluginName)) {\n                            pluginHandler.instantiatePlugin(\n                                pluginName,\n                                pluginHandler.getPluginConfig(pluginName)!,\n                                controllerDir,\n                            );\n                            pluginHandler.setDatabaseForPlugin(pluginName, objects, states);\n                            pluginHandler.initPlugin(pluginName, ioPackage);\n                        }\n                    } else {\n                        if (!pluginHandler.destroy(pluginName)) {\n                            logger.info(\n                                `${hostLogPrefix} Plugin ${pluginName} could not be disabled. Please restart ioBroker to disable it.`,\n                            );\n                        }\n                    }\n                }\n            } else if (\n                id === `${hostObjectPrefix}.diskWarning` &&\n                stateOrMessage &&\n                'ack' in stateOrMessage &&\n                !stateOrMessage.ack\n            ) {\n                const warningLevel = getDiskWarningLevel(stateOrMessage);\n                diskWarningLevel = warningLevel;\n                await states.setState(id, { val: warningLevel, ack: true });\n            }\n        },\n        connected: () => {\n            if (statesDisconnectTimeout) {\n                clearTimeout(statesDisconnectTimeout);\n                statesDisconnectTimeout = null;\n            }\n\n            initMessageQueue();\n            startAliveInterval();\n\n            initializeController();\n            onConnect && onConnect();\n        },\n        disconnected: () => {\n            if (restartTimeout) {\n                return;\n            }\n\n            statesDisconnectTimeout && clearTimeout(statesDisconnectTimeout);\n\n            statesDisconnectTimeout = setTimeout(\n                () => {\n                    statesDisconnectTimeout = null;\n                    handleDisconnect();\n                },\n                (config.states.connectTimeout || 2000) + (!compactGroupController ? 500 : 0),\n            );\n        },\n    });\n}\n\nasync function initializeController(): Promise<void> {\n    if (!states || !objects || connected) {\n        return;\n    }\n\n    logger.info(`${hostLogPrefix} connected to Objects and States`);\n\n    // initialize notificationHandler\n    const notificationSettings = {\n        states: states,\n        objects: objects,\n        log: logger,\n        logPrefix: hostLogPrefix,\n        host: hostname,\n    };\n\n    notificationHandler = new NotificationHandler(notificationSettings);\n\n    if (ioPackage.notifications) {\n        try {\n            await notificationHandler.addConfig(ioPackage.notifications);\n            logger.info(`${hostLogPrefix} added notifications configuration of host`);\n            // load setup of all adapters to class, to remember messages even of non-running hosts\n            await notificationHandler.getSetupOfAllAdaptersFromHost();\n        } catch (e) {\n            logger.error(`${hostLogPrefix} Could not add notifications config of this host: ${e.message}`);\n        }\n    }\n\n    autoUpgradeManager = new AdapterAutoUpgradeManager({ objects, states, logger, logPrefix: hostLogPrefix });\n    blocklistManager = new BlocklistManager({ objects });\n\n    checkSystemLocaleSupported();\n\n    if (connected === null) {\n        connected = true;\n        if (!isStopping) {\n            pluginHandler.setDatabaseForPlugins(objects, states);\n            await pluginHandler.initPlugins(ioPackage);\n            states.subscribe(`${hostObjectPrefix}.plugins.*`);\n\n            // Do not start if we're still stopping the instances\n            await checkHost();\n            startMultihost(config);\n            setMeta();\n            started = true;\n            getInstances();\n        }\n    } else {\n        connected = true;\n        started = true;\n\n        // Do not start if we're still stopping the instances\n        if (!isStopping) {\n            getInstances();\n        }\n    }\n}\n\n// create \"objects\" object\n/**\n *\n * @param onConnect\n */\nfunction createObjects(onConnect: () => void): void {\n    objects = new Objects({\n        namespace: hostLogPrefix,\n        connection: config.objects,\n        controller: true,\n        logger: logger,\n        hostname: hostname,\n        connected: async () => {\n            // stop disconnect timeout\n            if (objectsDisconnectTimeout) {\n                clearTimeout(objectsDisconnectTimeout);\n                objectsDisconnectTimeout = null;\n            }\n\n            // subscribe to primary host expiration\n            try {\n                await objects!.subscribePrimaryHost();\n            } catch (e) {\n                logger.error(`${hostLogPrefix} Cannot subscribe to primary host expiration: ${e.message}`);\n            }\n\n            if (!primaryHostInterval && !compactGroupController) {\n                primaryHostInterval = setInterval(checkPrimaryHost, PRIMARY_HOST_LOCK_TIME / 2);\n            }\n\n            // first execution now\n            checkPrimaryHost();\n\n            initializeController();\n            onConnect && onConnect();\n        },\n        disconnected: (/*error*/) => {\n            if (restartTimeout) {\n                return;\n            }\n            // on reconnection this will be determined anew\n            isPrimary = false;\n            objectsDisconnectTimeout && clearTimeout(objectsDisconnectTimeout);\n            objectsDisconnectTimeout = setTimeout(\n                () => {\n                    objectsDisconnectTimeout = null;\n                    handleDisconnect();\n                },\n                (config.objects.connectTimeout || 2000) + (!compactGroupController ? 500 : 0),\n            );\n            // give the main controller a bit longer, so that adapter and compact processes can exit before\n        },\n        change: async (_id, _obj) => {\n            if (!started || !_id.match(/^system\\.adapter\\.[a-zA-Z0-9-_]+\\.[0-9]+$/)) {\n                return;\n            }\n\n            const obj = _obj as ioBroker.InstanceObject | null;\n            const id = _id as ioBroker.ObjectIDs.Instance;\n\n            try {\n                logger.debug(`${hostLogPrefix} object change ${id} (from: ${obj ? obj.from : null})`);\n                // known adapter\n                const proc = procs[id];\n\n                if (proc) {\n                    // if adapter deleted\n                    if (!obj) {\n                        // deleted: also remove from an instance list of compactGroup\n                        if (\n                            !compactGroupController &&\n                            proc.config.common.compactGroup &&\n                            compactProcs[proc.config.common.compactGroup]?.instances?.includes(id as any)\n                        ) {\n                            compactProcs[proc.config.common.compactGroup].instances.splice(\n                                compactProcs[proc.config.common.compactGroup].instances.indexOf(id as any),\n                                1,\n                            );\n                        }\n\n                        // instance removed -> remove all notifications\n                        await notificationHandler.clearNotifications(null, null, id as any);\n                        proc.config.common.enabled = false;\n                        // @ts-expect-error check if we can handle it different\n                        proc.config.common.host = null;\n                        // @ts-expect-error it is only used in checkAndAddInstance, find a way without modifying the InstanceObject\n                        proc.config.deleted = true;\n                        logger.info(`${hostLogPrefix} object deleted ${id}`);\n                    } else {\n                        if (proc.config.common.enabled && !obj.common.enabled) {\n                            logger.info(`${hostLogPrefix} \"${id}\" disabled`);\n                        }\n                        if (!proc.config.common.enabled && obj.common.enabled) {\n                            logger.info(`${hostLogPrefix} \"${id}\" enabled`);\n                            proc.downloadRetry = 0;\n                        }\n\n                        // Check if compactgroup or compact mode changed\n                        if (\n                            !compactGroupController &&\n                            proc.config.common.compactGroup &&\n                            (proc.config.common.compactGroup !== obj.common.compactGroup ||\n                                proc.config.common.runAsCompactMode !== obj.common.runAsCompactMode) &&\n                            compactProcs[proc.config.common.compactGroup]?.instances?.includes(id as any)\n                        ) {\n                            compactProcs[proc.config.common.compactGroup].instances.splice(\n                                compactProcs[proc.config.common.compactGroup].instances.indexOf(id as any),\n                                1,\n                            );\n                        }\n                        proc.config = obj;\n                    }\n                    if (proc.process || proc.config.common.mode === 'schedule') {\n                        proc.restartExpected = true;\n                        await stopInstance(id, false);\n                        if (!procs[id]) {\n                            return;\n                        }\n                        const _ipArr = tools.findIPs();\n\n                        if (checkAndAddInstance(proc.config as any, _ipArr)) {\n                            if (\n                                proc.config.common.enabled &&\n                                (proc.config.common.mode !== 'extension' || !proc.config.native.webInstance)\n                            ) {\n                                if (proc.restartTimer) {\n                                    clearTimeout(proc.restartTimer);\n                                }\n                                const restartTimeout = (proc.config.common.stopTimeout || 500) + 2_500;\n                                proc.restartTimer = setTimeout(_id => startInstance(_id), restartTimeout, id);\n                            }\n                        } else {\n                            // moved: also remove from an instance list of compactGroup\n                            if (\n                                !compactGroupController &&\n                                proc.config.common.compactGroup &&\n                                compactProcs[proc.config.common.compactGroup]?.instances?.includes(id as any)\n                            ) {\n                                compactProcs[proc.config.common.compactGroup].instances.splice(\n                                    compactProcs[proc.config.common.compactGroup].instances.indexOf(id as any),\n                                    1,\n                                );\n                            }\n                            if (proc.restartTimer) {\n                                clearTimeout(proc.restartTimer);\n                                delete proc.restartTimer;\n                            }\n\n                            // instance moved -> remove all notifications, new host has to take care\n                            await notificationHandler.clearNotifications(null, null, id);\n\n                            delete procs[id];\n                        }\n                    } else if (installQueue.find(obj => obj.id === id)) {\n                        // ignore object changes when still in the installation queue\n                        logger.debug(\n                            `${hostLogPrefix} ignore object change because the adapter is still in installation/rebuild queue`,\n                        );\n                    } else {\n                        const _ipArr = tools.findIPs();\n                        if (proc.config && checkAndAddInstance(proc.config as any, _ipArr)) {\n                            if (\n                                proc.config.common.enabled &&\n                                (proc.config.common.mode !== 'extension' || !proc.config.native.webInstance)\n                            ) {\n                                startInstance(id);\n                            }\n                        } else {\n                            // moved: also remove from an instance list of compactGroup\n                            if (\n                                !compactGroupController &&\n                                proc.config.common.compactGroup &&\n                                compactProcs[proc.config.common.compactGroup]?.instances?.includes(id as any)\n                            ) {\n                                compactProcs[proc.config.common.compactGroup].instances.splice(\n                                    compactProcs[proc.config.common.compactGroup].instances.indexOf(id as any),\n                                    1,\n                                );\n                            }\n                            if (proc.restartTimer) {\n                                clearTimeout(proc.restartTimer);\n                                delete proc.restartTimer;\n                            }\n\n                            delete procs[id];\n                        }\n                    }\n                } else if (obj?.common) {\n                    const _ipArr = tools.findIPs();\n                    // new adapter\n                    if (!checkAndAddInstance(obj, _ipArr)) {\n                        return;\n                    }\n\n                    const proc = procs[id];\n                    if (\n                        proc.config.common.enabled &&\n                        (proc.config.common.mode !== 'extension' || !proc.config.native.webInstance)\n                    ) {\n                        // We should give a slight delay to allow a potentially former existing process on another host to exit\n                        const restartTimeout = (proc.config.common.stopTimeout || 500) + 2_500;\n                        proc.restartTimer = setTimeout(_id => startInstance(_id), restartTimeout, id);\n                    }\n                }\n            } catch (err) {\n                if (\n                    !compactGroupController ||\n                    (obj?.common?.runAsCompactMode && obj.common.compactGroup === compactGroup)\n                ) {\n                    logger.error(`${hostLogPrefix} cannot process: ${id}: ${err} / ${err.stack}`);\n                }\n            }\n        },\n        primaryHostLost: () => {\n            if (!isStopping) {\n                isPrimary = false;\n                logger.info('The primary host is no longer active. Checking responsibilities.');\n                checkPrimaryHost();\n            }\n        },\n    });\n}\n\nfunction startAliveInterval(): void {\n    config.system = config.system || {};\n    config.system.statisticsInterval = Math.round(config.system.statisticsInterval) || 15_000;\n    config.system.checkDiskInterval =\n        config.system.checkDiskInterval !== 0 ? Math.round(config.system.checkDiskInterval) || 300_000 : 0;\n    if (!compactGroupController) {\n        // Provide info to see for each host if compact is enabled or not and be able to use in Admin or such\n        states!.setState(`${hostObjectPrefix}.compactModeEnabled`, {\n            ack: true,\n            from: hostObjectPrefix,\n            val: config.system.compact || false,\n        });\n    }\n    reportInterval = setInterval(reportStatus, config.system.statisticsInterval);\n\n    reportStatus();\n    tools.measureEventLoopLag(1_000, lag => eventLoopLags.push(lag!));\n}\n\n/**\n * Check if the current redis Locale is supported, else register notification\n */\nasync function checkSystemLocaleSupported(): Promise<void> {\n    if (!objects) {\n        throw new Error('Objects database not connected');\n    }\n\n    const isSupported = await objects.isSystemLocaleSupported();\n\n    if (!isSupported) {\n        await notificationHandler.addMessage({\n            category: 'system',\n            scope: 'databaseErrors',\n            message:\n                'Your redis server is using an unsupported locale. This can lead to unexpected behavior of your ioBroker installation as well as data loss. ' +\n                'Please configure your Redis Server according to https://forum.iobroker.net/topic/52976/wichtiger-hinweis-f%C3%BCr-redis-installationen?_=1678099836122',\n            instance: `system.host.${hostname}`,\n        });\n    }\n}\n\n/**\n * Ensures that we take over primary host if no other is doing the job\n */\nasync function checkPrimaryHost(): Promise<void> {\n    // we cannot interact with db now because currently reconnecting\n    if (objectsDisconnectTimeout || compactGroupController) {\n        return;\n    }\n\n    // let our host value live PRIMARY_HOST_LOCK_TIME seconds, while it should be renewed lock time / 2\n    try {\n        if (!isPrimary) {\n            isPrimary = !!(await objects!.setPrimaryHost(PRIMARY_HOST_LOCK_TIME));\n        } else {\n            const lockExtended = !!(await objects!.extendPrimaryHostLock(PRIMARY_HOST_LOCK_TIME));\n            if (!lockExtended) {\n                // if we are host, a lock extension should always work, fallback to acquire lock\n                isPrimary = !!(await objects!.setPrimaryHost(PRIMARY_HOST_LOCK_TIME));\n            }\n        }\n    } catch (e) {\n        logger.error(`${hostLogPrefix} Could not execute primary host determination: ${e.message}`);\n    }\n}\n\nasync function reportStatus(): Promise<void> {\n    if (!states) {\n        return;\n    }\n    const id = hostObjectPrefix;\n    outputCount += 10;\n    states.setState(`${id}.alive`, {\n        val: true,\n        ack: true,\n        expire: Math.floor(config.system.statisticsInterval / 1_000) + 10,\n        from: id,\n    });\n\n    // provide infos about current process\n\n    // pidUsage([pid,pid,...], function (err, stats) {\n    // => {\n    //   cpu: 10.0,            // percentage (from 0 to 100*vcore)\n    //   memory: 357306368,    // bytes\n    //   ppid: 312,            // PPID\n    //   pid: 727,             // PID\n    //   ctime: 867000,        // ms user + system time\n    //   elapsed: 6650000,     // ms since the start of the process\n    //   timestamp: 864000000  // ms since epoch\n    // }\n    try {\n        pidUsage(process.pid, (err, stats) => {\n            // controller.s might be stopped, but this is still running\n            if (!err && states && states.setState && stats) {\n                states.setState(`${id}.cpu`, {\n                    ack: true,\n                    from: id,\n                    val: Math.round(100 * stats.cpu) / 100,\n                });\n                states.setState(`${id}.cputime`, { ack: true, from: id, val: stats.ctime / 1_000 });\n                outputCount += 2;\n            }\n        });\n    } catch (e) {\n        logger.error(`${hostLogPrefix} Cannot read pidUsage data : ${e.message}`);\n    }\n\n    try {\n        const mem = process.memoryUsage();\n        states.setState(`${id}.memRss`, {\n            val: Math.round(mem.rss / 10485.76 /* 1MB / 100 */) / 100,\n            ack: true,\n            from: id,\n        });\n        states.setState(`${id}.memHeapTotal`, {\n            val: Math.round(mem.heapTotal / 10485.76 /* 1MB / 100 */) / 100,\n            ack: true,\n            from: id,\n        });\n        states.setState(`${id}.memHeapUsed`, {\n            val: Math.round(mem.heapUsed / 10485.76 /* 1MB / 100 */) / 100,\n            ack: true,\n            from: id,\n        });\n    } catch (e) {\n        logger.error(`${hostLogPrefix} Cannot read memoryUsage data: ${e.message}`);\n    }\n\n    // provide machine infos\n    states.setState(`${id}.load`, { val: Math.round(os.loadavg()[0] * 100) / 100, ack: true, from: id });\n    states.setState(`${id}.uptime`, { val: Math.round(process.uptime()), ack: true, from: id });\n    states.setState(`${id}.mem`, { val: Math.round(100 - (os.freemem() / os.totalmem()) * 100), ack: true, from: id });\n    states.setState(`${id}.freemem`, { val: Math.round(os.freemem() / 1_048_576 /* 1MB */), ack: true, from: id });\n\n    if (fs.existsSync('/proc/meminfo')) {\n        try {\n            const text = fs.readFileSync('/proc/meminfo', 'utf8');\n            const m = text && text.match(/MemAvailable:\\s*(\\d+)/);\n            if (m && m[1]) {\n                states.setState(`${id}.memAvailable`, {\n                    val: Math.round(parseInt(m[1], 10) * 0.001024),\n                    ack: true,\n                    from: id,\n                });\n                outputCount++;\n            }\n        } catch (e) {\n            logger.error(`${hostLogPrefix} Cannot read /proc/meminfo: ${e.message}`);\n        }\n    }\n\n    if (config.system.checkDiskInterval && Date.now() - lastDiskSizeCheck >= config.system.checkDiskInterval) {\n        lastDiskSizeCheck = Date.now();\n        let info: GetDiskInfoResponse | null = null;\n\n        try {\n            info = await tools.getDiskInfo();\n        } catch (e) {\n            logger.error(`${hostLogPrefix} Cannot read disk size: ${e.message}`);\n        }\n\n        try {\n            if (info) {\n                const diskSize = Math.round((info['Disk size'] || 0) / (1024 * 1024));\n                const diskFree = Math.round((info['Disk free'] || 0) / (1024 * 1024));\n                const percentageFree = (diskFree / diskSize) * 100;\n                const isDiskWarningActive = percentageFree < diskWarningLevel;\n\n                if (isDiskWarningActive) {\n                    await notificationHandler.addMessage({\n                        scope: 'system',\n                        category: 'diskSpaceIssues',\n                        message: `Your system has only ${percentageFree.toFixed(2)} % of disk space left.`,\n                        instance: `system.host.${hostname}`,\n                    });\n                }\n\n                states.setState(`${id}.diskSize`, {\n                    val: diskSize,\n                    ack: true,\n                    from: id,\n                });\n                states.setState(`${id}.diskFree`, {\n                    val: diskFree,\n                    ack: true,\n                    from: id,\n                });\n\n                outputCount += 2;\n            }\n        } catch (e) {\n            logger.error(`${hostLogPrefix} Cannot read disk information: ${e.message}`);\n        }\n    }\n\n    // some statistics\n    states.setState(`${id}.inputCount`, { val: inputCount, ack: true, from: id });\n    states.setState(`${id}.outputCount`, { val: outputCount, ack: true, from: id });\n\n    if (eventLoopLags.length) {\n        const eventLoopLag = Math.ceil(eventLoopLags.reduce((a, b) => a + b) / eventLoopLags.length);\n        states.setState(`${id}.eventLoopLag`, { val: eventLoopLag, ack: true, from: id }); // average of measured values\n        eventLoopLags = [];\n    }\n\n    states.setState(`${id}.compactgroupProcesses`, { val: Object.keys(compactProcs).length, ack: true, from: id });\n    let realProcesses = 0;\n    let compactProcesses = 0;\n    Object.values(procs).forEach(proc => {\n        if (proc.process) {\n            if (proc.startedInCompactMode) {\n                compactProcesses++;\n            } else {\n                realProcesses++;\n            }\n        }\n    });\n    states.setState(`${id}.instancesAsProcess`, { val: realProcesses, ack: true, from: id });\n    states.setState(`${id}.instancesAsCompact`, { val: compactProcesses, ack: true, from: id });\n\n    inputCount = 0;\n    outputCount = 0;\n    if (!isStopping && compactGroupController && started && compactProcesses === 0 && realProcesses === 0) {\n        logger.info(`${hostLogPrefix} Compact group controller ${compactGroup} does not own any processes, stop`);\n        stop(false);\n    }\n}\n\n/**\n *\n * @param objs\n * @param oldHostname\n * @param newHostname\n */\nasync function changeHost(\n    objs: ioBroker.GetObjectViewItem<ioBroker.InstanceObject>[],\n    oldHostname: string,\n    newHostname: string,\n): Promise<void> {\n    for (const row of objs) {\n        if (row?.value?.common.host === oldHostname) {\n            const obj = row.value;\n            obj.common.host = newHostname;\n            logger.info(\n                `${hostLogPrefix} Reassign instance ${obj._id.substring(\n                    SYSTEM_ADAPTER_PREFIX.length,\n                )} from ${oldHostname} to ${newHostname}`,\n            );\n            obj.from = `system.host.${tools.getHostName()}`;\n            obj.ts = Date.now();\n\n            try {\n                await objects!.setObject(obj._id, obj);\n            } catch (e) {\n                logger.error(`Error changing host of ${obj._id}: ${e.message}`);\n            }\n        }\n    }\n}\n\n/**\n * Clean a single auto subscribe\n *\n * @param instance instance id without `system.adapter.` prefix\n * @param autoInstance instance id\n * @param callback\n */\nfunction cleanAutoSubscribe(instance: string, autoInstance: ioBroker.ObjectIDs.Instance, callback: () => void): void {\n    inputCount++;\n    states!.getState(`${autoInstance}.subscribes`, async (err, state) => {\n        if (!state || !state.val) {\n            return setImmediate(() => callback());\n        }\n        let subs;\n        try {\n            subs = JSON.parse(state.val as string);\n        } catch {\n            logger.error(`${hostLogPrefix} Cannot parse subscribes: ${state.val}`);\n            return setImmediate(() => callback());\n        }\n        let modified = false;\n        // look for all subscribes from this instance\n        for (const pattern of Object.keys(subs)) {\n            for (const id of Object.keys(subs[pattern])) {\n                if (id === instance) {\n                    modified = true;\n                    delete subs[pattern][id];\n                }\n            }\n\n            // check if the array is now empty\n            if (!Object.keys(subs[pattern]).length) {\n                modified = true;\n                delete subs[pattern];\n            }\n        }\n\n        if (modified) {\n            outputCount++;\n            await states!.setState(`${autoInstance}.subscribes`, subs);\n        }\n\n        setImmediate(() => callback());\n    });\n}\n\n/**\n *\n * @param instanceID\n * @param callback\n */\nfunction cleanAutoSubscribes(instanceID: ioBroker.ObjectIDs.Instance, callback: () => void): void {\n    const instance = instanceID.substring(15); // get name.0\n\n    // read all instances\n    objects!.getObjectView(\n        'system',\n        'instance',\n        { startkey: SYSTEM_ADAPTER_PREFIX, endkey: `${SYSTEM_ADAPTER_PREFIX}\\u9999` },\n        (err, res) => {\n            let count = 0;\n            if (res) {\n                for (const row of res.rows) {\n                    // remove this instance from autoSubscribe\n                    if (row.value?.common.subscribable) {\n                        count++;\n                        cleanAutoSubscribe(instance, row.id, () => !--count && callback && callback());\n                    }\n                }\n            }\n            !count && callback && callback();\n        },\n    );\n}\n\n/**\n *\n * @param objs\n */\nasync function delObjects(objs: ioBroker.GetObjectViewItem<ioBroker.AnyObject>[]): Promise<void> {\n    for (const row of objs) {\n        if (row?.id) {\n            logger.info(`${hostLogPrefix} Delete state \"${row.id}\"`);\n            try {\n                if (row.value && row.value.type === 'state') {\n                    await states!.delState(row.id);\n                    await objects!.delObject(row.id);\n                } else {\n                    await objects!.delObject(row.id);\n                }\n            } catch {\n                // ignore\n            }\n        }\n    }\n}\n\n/**\n * try to check host in objects\n * <p>\n * This function tries to find all hosts in the objects and if\n * only one host found and it is not actual host, change the\n * host name to new one.\n * <p>\n *\n */\nasync function checkHost(): Promise<void> {\n    const objectData = objects!.getStatus();\n    // only file master host controller needs to check/fix the host assignments from the instances\n    // for redis it is currently not possible to detect a single host system with a changed hostname for sure!\n    if (compactGroupController || !objectData.server) {\n        return;\n    }\n\n    let hostDoc;\n\n    try {\n        hostDoc = await objects!.getObjectViewAsync('system', 'host', {\n            startkey: 'system.host.',\n            endkey: 'system.host.\\u9999',\n        });\n    } catch {\n        // ignore\n    }\n\n    if (hostDoc?.rows.length === 1 && hostDoc?.rows[0].value.common.name !== hostname) {\n        const oldHostname = hostDoc.rows[0].value.common.name;\n        const oldId = hostDoc.rows[0].value._id;\n\n        let instanceDoc;\n\n        try {\n            // find out all instances and rewrite it to actual hostname\n            instanceDoc = await objects!.getObjectViewAsync('system', 'instance', {\n                startkey: SYSTEM_ADAPTER_PREFIX,\n                endkey: `${SYSTEM_ADAPTER_PREFIX}\\u9999`,\n            });\n        } catch (e) {\n            if (e.message.startsWith('Cannot find ')) {\n                return;\n            }\n        }\n\n        if (!instanceDoc?.rows || instanceDoc.rows.length === 0) {\n            logger.info(`${hostLogPrefix} no instances found`);\n            // no instances found\n            return;\n        }\n        // reassign all instances\n        await changeHost(instanceDoc.rows, oldHostname, hostname);\n        logger.info(`${hostLogPrefix} Delete host ${oldId}`);\n\n        try {\n            // delete host object\n            await objects!.delObjectAsync(oldId);\n        } catch {\n            // ignore\n        }\n\n        try {\n            // delete all hosts states\n            const newHostDoc = await objects!.getObjectViewAsync('system', 'state', {\n                startkey: `system.host.${oldHostname}.`,\n                endkey: `system.host.${oldHostname}.\\u9999`,\n                include_docs: true,\n            });\n\n            await delObjects(newHostDoc.rows);\n            return;\n        } catch {\n            // ignore\n        }\n    }\n}\n\n/**\n * Collects the dialog information, e.g., used by Admin \"System Settings\"\n *\n * @param type - type of required information\n */\nasync function collectDiagInfo(type: DiagInfoType): Promise<void | Record<string, any> | null> {\n    if (type !== 'extended' && type !== 'normal' && type !== 'no-city') {\n        return null;\n    }\n    let systemConfig;\n    let err;\n\n    try {\n        systemConfig = await objects!.getObject(SYSTEM_CONFIG_ID);\n    } catch (e) {\n        err = e;\n    }\n\n    if (err || !systemConfig?.common) {\n        logger.warn(\n            `System config object is corrupt, please run \"${tools.appNameLowerCase} setup first\". Error: ${err.message}`,\n        );\n        systemConfig = systemConfig || { common: {} };\n        systemConfig.common = systemConfig.common || {};\n    }\n\n    let obj;\n    try {\n        obj = await objects!.getObjectAsync('system.meta.uuid');\n    } catch {\n        // ignore obj is undefined\n    }\n\n    // create uuid\n    if (!obj) {\n        obj = { native: { uuid: 'not found' } };\n    }\n\n    let doc;\n    err = null;\n\n    try {\n        doc = await objects!.getObjectViewAsync('system', 'host', {\n            startkey: 'system.host.',\n            endkey: 'system.host.\\u9999',\n        });\n    } catch (e) {\n        err = e;\n    }\n\n    const { noCompactInstances, noInstances } = await _getNumberOfInstances();\n\n    // we need to show city and country at the beginning, so include it now and delete it later if not allowed.\n    const diag: Record<string, any> = {\n        uuid: obj.native.uuid,\n        language: systemConfig.common.language,\n        country: '',\n        city: '',\n        hosts: [],\n        node: process.version,\n        arch: os.arch(),\n        docker: tools.isDocker(),\n        adapters: {},\n        statesType: config.states.type, // redis or file\n        objectsType: config.objects.type, // redis or file\n        noInstances,\n        compactMode: config.system.compact,\n        noCompactInstances,\n    };\n\n    if (type === 'extended' || type === 'no-city') {\n        const cpus = os.cpus();\n        diag.country = 'country' in systemConfig.common ? systemConfig.common.country : 'unknown';\n        diag.model = cpus && cpus[0] && cpus[0].model ? cpus[0].model : 'unknown';\n        diag.cpus = cpus ? cpus.length : 1;\n        diag.mem = os.totalmem();\n        diag.ostype = os.type();\n        delete diag.city;\n    }\n    if (type === 'extended') {\n        diag.city = 'city' in systemConfig.common ? systemConfig.common.city : 'unknown';\n    } else if (type === 'normal') {\n        delete diag.city;\n        delete diag.country;\n    }\n\n    if (!err && doc?.rows.length) {\n        doc.rows.sort((a, b) => {\n            try {\n                return semver.lt(a.value.common.installedVersion ?? '0.0.0', b.value.common.installedVersion ?? '0.0.0')\n                    ? 1\n                    : 0;\n            } catch {\n                logger.error(\n                    `${hostLogPrefix} Invalid versions: ${a.value.common.installedVersion ?? '0.0.0'}[${\n                        a.value.common.name ?? 'unknown'\n                    }] or ${b.value.common.installedVersion ?? '0.0.0'}[${b.value.common.name ?? 'unknown'}]`,\n                );\n                return 0;\n            }\n        });\n\n        // Read installed versions of all hosts\n        for (const row of doc.rows) {\n            diag.hosts.push({\n                version: row.value.common.installedVersion,\n                platform: row.value.common.platform,\n                type: row.value.native.os.platform,\n            });\n        }\n    }\n\n    doc = null;\n    err = null;\n\n    try {\n        doc = await objects!.getObjectViewAsync('system', 'adapter', {\n            startkey: SYSTEM_ADAPTER_PREFIX,\n            endkey: `${SYSTEM_ADAPTER_PREFIX}\\u9999`,\n        });\n    } catch (e) {\n        err = e;\n    }\n\n    const foundVisAdapters = new Set<(typeof VIS_ADAPTERS)[number]>();\n\n    if (!err && doc?.rows.length) {\n        // Read installed versions of all adapters\n        for (const row of doc.rows) {\n            diag.adapters[row.value.common.name] = {\n                version: row.value.common.version,\n                platform: row.value.common.platform,\n                installedFrom: row.value.common.installedFrom,\n            };\n\n            if (VIS_ADAPTERS.includes(row.value.common.name as (typeof VIS_ADAPTERS)[number])) {\n                foundVisAdapters.add(row.value.common.name as (typeof VIS_ADAPTERS)[number]);\n            }\n        }\n    }\n    // read the number of vis data points\n    for (const visAdapter of foundVisAdapters) {\n        const { calcProjects } = await import('./lib/vis/states.js');\n\n        try {\n            const points = await calcProjects({ objects: objects!, instance: 0, visAdapter });\n            let total = null;\n            const tasks = [];\n\n            if (points?.length) {\n                for (const point of points) {\n                    if (point.id === `${visAdapter}.0.datapoints.total`) {\n                        total = point.val;\n                    }\n\n                    tasks.push({\n                        _id: point.id,\n                        type: 'state',\n                        native: {},\n                        common: {\n                            name: 'Datapoints count',\n                            role: 'state',\n                            type: 'number',\n                            read: true,\n                            write: false,\n                        },\n                        state: {\n                            val: point.val,\n                            ack: true,\n                        },\n                    });\n                }\n            }\n\n            if (total !== null) {\n                diag[visAdapter] = total;\n            }\n\n            await extendObjects(tasks);\n        } catch (e) {\n            logger.error(`${hostLogPrefix} cannot call visUtils: ${e.message}`);\n        }\n    }\n\n    return diag;\n}\n\n// check if some IPv4 address found. If not try in 30 seconds one more time (max 10 times)\n/**\n *\n * @param ipList\n */\nfunction setIPs(ipList?: string[]): void {\n    if (isStopping) {\n        return;\n    }\n    const _ipList = ipList || tools.findIPs();\n\n    // check if IPs detected (because of DHCP delay)\n    let found = false;\n    for (const entry of _ipList) {\n        if (entry === '127.0.0.1' || entry === '::1/128') {\n            continue;\n        }\n        found = true;\n        break;\n    }\n    // IPv4 address still not found, try again in 30 seconds\n    if (!found && detectIpsCount < 10) {\n        detectIpsCount++;\n        setTimeout(() => setIPs(), 30_000);\n    } else if (found) {\n        // IPv4 found => write to object\n        objects!.getObject(`system.host.${hostname}`, (err, oldObj) => {\n            const networkInterfaces = os.networkInterfaces();\n\n            if (\n                !err &&\n                oldObj &&\n                oldObj.common &&\n                oldObj.native &&\n                oldObj.native.hardware &&\n                (!isDeepStrictEqual(oldObj.native.hardware.networkInterfaces, networkInterfaces) ||\n                    !isDeepStrictEqual(oldObj.common.address, _ipList))\n            ) {\n                oldObj.common.address = _ipList;\n                oldObj.native.hardware.networkInterfaces = networkInterfaces;\n                oldObj.from = hostObjectPrefix;\n                oldObj.ts = Date.now();\n                objects!.setObject(\n                    oldObj._id,\n                    oldObj,\n                    err => err && logger.error(`${hostLogPrefix} Cannot write host object: ${err.message}`),\n                );\n            }\n\n            // update IP list periodically\n            startUpdateIPs();\n        });\n    } else {\n        logger.info(`${hostLogPrefix} No IPv4 address found after 5 minutes.`);\n    }\n}\n\n/**\n * Extends objects, optionally you can provide a state at each task (does not throw)\n *\n * @param tasks\n */\nasync function extendObjects(tasks: Record<string, any>[]): Promise<void> {\n    for (const task of tasks) {\n        const state = task.state;\n        if (state !== undefined) {\n            delete task.state;\n        }\n\n        try {\n            await objects!.extendObjectAsync(task._id, task);\n            // if extend throws we don't want to set corresponding state\n            if (state) {\n                await states!.setState(task._id, state);\n            }\n        } catch {\n            // ignore\n        }\n    }\n}\n\n/**\n * Create the host meta data like host objects and states\n */\nasync function setMeta(): Promise<void> {\n    const id = hostObjectPrefix;\n\n    const oldObj = await objects!.getObject(id);\n    let newObj: ioBroker.HostObject | ioBroker.FolderObject;\n    if (compactGroupController) {\n        newObj = {\n            _id: id,\n            type: 'folder',\n            common: {\n                name: hostname + compactGroupObjectPrefix + compactGroup,\n                cmd: `${process.argv[0]} ${`${process.execArgv.join(' ')} `.replace(\n                    /--inspect-brk=\\d+ /,\n                    '',\n                )}${process.argv.slice(1).join(' ')}`,\n                hostname: hostname,\n                address: tools.findIPs(),\n            },\n            native: {},\n        };\n    } else {\n        newObj = getHostObject(oldObj);\n    }\n\n    if (oldObj) {\n        // @ts-expect-error todo: can be removed?\n        delete oldObj.cmd;\n        delete oldObj.from;\n        delete oldObj.ts;\n        delete oldObj.acl;\n    }\n\n    if (!oldObj || !isDeepStrictEqual(newObj, oldObj)) {\n        newObj.from = hostObjectPrefix;\n        newObj.ts = Date.now();\n        try {\n            // @ts-expect-error TODO: for compact controller we are setting a folder object to a system.host.XY id\n            await objects!.setObject(id, newObj);\n            setIPs(newObj.common.address);\n        } catch (e) {\n            logger.error(`${hostLogPrefix} Cannot write host object: ${e.message}`);\n        }\n    } else {\n        setIPs(newObj.common.address);\n    }\n\n    config.system.checkDiskInterval =\n        config.system.checkDiskInterval !== 0 ? Math.round(config.system.checkDiskInterval) || 300_000 : 0;\n\n    const tasks = getHostObjects({\n        id,\n        hostname,\n        config,\n        isCompactGroupController: compactGroupController,\n    });\n\n    // delete obsolete states and create new ones\n    objects!.getObjectView(\n        'system',\n        'state',\n        { startkey: `${hostObjectPrefix}.`, endkey: `${hostObjectPrefix}.\\u9999`, include_docs: true },\n        async (err, doc) => {\n            if (err) {\n                logger &&\n                    logger.error(\n                        `${hostLogPrefix} Could not collect ${hostObjectPrefix} states to check for obsolete states: ${err.message}`,\n                    );\n            } else if (doc?.rows) {\n                // identify existing states for deletion, because they are not in the new tasks-list\n                let thishostStates = doc.rows;\n                if (!compactGroupController) {\n                    thishostStates = doc.rows.filter(\n                        out1 => !out1.id.includes(hostObjectPrefix + compactGroupObjectPrefix),\n                    );\n                }\n                const pluginStatesIndex = `${hostObjectPrefix}.plugins.`.length;\n                const notificationStatesIndex = `${hostObjectPrefix}.notifications.`.length;\n                const toDelete = thishostStates.filter(out1 => {\n                    const found = tasks.find(out2 => out1.id === out2._id);\n                    if (found === undefined) {\n                        if (out1.id.startsWith(`${hostObjectPrefix}.plugins.`)) {\n                            let nameEndIndex: number | undefined = out1.id.indexOf('.', pluginStatesIndex + 1);\n                            if (nameEndIndex === -1) {\n                                nameEndIndex = undefined;\n                            }\n                            return !pluginHandler.pluginExists(out1.id.substring(pluginStatesIndex, nameEndIndex));\n                        } else if (out1.id.startsWith(`${hostObjectPrefix}.notifications.`)) {\n                            // notification states are allowed to exist if their scope still exists\n                            return !notificationHandler.scopeExists(out1.id.substring(notificationStatesIndex));\n                        }\n                    }\n\n                    return found === undefined;\n                });\n\n                if (toDelete && toDelete.length > 0) {\n                    await delObjects(toDelete);\n                    logger && logger.info(`${hostLogPrefix} Some obsolete host states deleted.`);\n                }\n            }\n            await extendObjects(tasks);\n            // create UUID if not exist\n            if (!compactGroupController) {\n                const uuid = await tools.createUuid(objects);\n                uuid && logger && logger.info(`${hostLogPrefix} Created UUID: ${uuid}`);\n\n                if (fs.existsSync(VENDOR_BOOTSTRAP_FILE)) {\n                    logger &&\n                        logger.info(`${hostLogPrefix} Detected vendor file: ${fs.existsSync(VENDOR_BOOTSTRAP_FILE)}`);\n                    try {\n                        const startScript = fs.readJSONSync(VENDOR_BOOTSTRAP_FILE);\n\n                        if (startScript.password) {\n                            const { Vendor } = await import('@iobroker/js-controller-cli');\n                            const vendor = new Vendor({ objects: objects! });\n\n                            logger && logger.info(`${hostLogPrefix} Apply vendor file: ${VENDOR_FILE}`);\n                            try {\n                                await vendor.checkVendor(VENDOR_FILE, startScript.password, logger);\n                                logger && logger.info(`${hostLogPrefix} Vendor information synchronised.`);\n                                try {\n                                    if (fs.existsSync(VENDOR_BOOTSTRAP_FILE)) {\n                                        fs.unlinkSync(VENDOR_BOOTSTRAP_FILE);\n                                    }\n                                } catch (e) {\n                                    logger &&\n                                        logger.error(\n                                            `${hostLogPrefix} Cannot delete file ${VENDOR_BOOTSTRAP_FILE}: ${e.message}`,\n                                        );\n                                }\n                            } catch (e) {\n                                logger &&\n                                    logger.error(`${hostLogPrefix} Cannot update vendor information: ${e.message}`);\n                                try {\n                                    fs.existsSync(VENDOR_BOOTSTRAP_FILE) && fs.unlinkSync(VENDOR_BOOTSTRAP_FILE);\n                                } catch (e) {\n                                    logger &&\n                                        logger.error(\n                                            `${hostLogPrefix} Cannot delete file ${VENDOR_BOOTSTRAP_FILE}: ${e.message}`,\n                                        );\n                                }\n                            }\n                        }\n                    } catch (e) {\n                        logger && logger.error(`${hostLogPrefix} Cannot parse ${VENDOR_BOOTSTRAP_FILE}: ${e.message}`);\n                        try {\n                            fs.existsSync(VENDOR_BOOTSTRAP_FILE) && fs.unlinkSync(VENDOR_BOOTSTRAP_FILE);\n                        } catch (e) {\n                            logger &&\n                                logger.error(\n                                    `${hostLogPrefix} Cannot delete file ${VENDOR_BOOTSTRAP_FILE}: ${e.message}`,\n                                );\n                        }\n                    }\n                }\n            }\n        },\n    );\n}\n\n// Subscribe on message queue\nfunction initMessageQueue(): void {\n    states!.subscribeMessage(hostObjectPrefix);\n}\n\n/**\n * Send a message to another adapter instance\n *\n * @param objName - adapter name (hm-rpc) or id like system.host.rpi/system.adapter,hm-rpc\n * @param command\n * @param message\n * @param callback\n */\nasync function sendTo(\n    objName: string,\n    command: string,\n    message: ioBroker.MessagePayload,\n    callback?: ioBroker.ErrorCallback | ioBroker.MessageCallbackInfo,\n): Promise<void> {\n    if (!states) {\n        return;\n    }\n\n    if (message === undefined) {\n        message = command;\n        command = 'send';\n    }\n\n    const obj: ioBroker.SendableMessage = { command, message, from: hostObjectPrefix };\n\n    if (!objName.startsWith(SYSTEM_ADAPTER_PREFIX) && !objName.startsWith('system.host.')) {\n        objName = `${SYSTEM_ADAPTER_PREFIX}${objName}`;\n    }\n\n    if (callback) {\n        if (typeof callback === 'function') {\n            obj.callback = {\n                message: message,\n                id: callbackId++,\n                ack: false,\n                time: Date.now(),\n            };\n            if (callbackId > 0xffffffff) {\n                callbackId = 1;\n            }\n\n            callbacks[`_${obj.callback.id}`] = { cb: callback, time: Date.now() };\n        } else {\n            obj.callback = callback;\n            obj.callback.ack = true;\n        }\n    }\n    try {\n        await states.pushMessage(objName, obj);\n    } catch (e) {\n        // do not stringify the object, we had the issue with the invalid string length on serialization\n        logger.error(\n            `${hostLogPrefix} [sendTo] Could not push message \"${inspect(obj)}\" to \"${objName}\": ${e.message}`,\n        );\n        if (obj.callback && obj.callback.id) {\n            if (typeof callback === 'function') {\n                callback(e);\n            }\n            delete callbacks[`_${obj.callback.id}`];\n        }\n    }\n}\n\n/**\n * Get the version information from given host\n *\n * @param hostId host to get the version information from\n */\nasync function getVersionFromHost(hostId: ioBroker.ObjectIDs.Host): Promise<HostInformation | null> {\n    const state = await states!.getState(`${hostId}.alive`);\n    if (state?.val) {\n        return new Promise(resolve => {\n            let timeout: NodeJS.Timeout | null = setTimeout(() => {\n                timeout = null;\n                logger.warn(`${hostLogPrefix} too delayed answer for ${hostId}`);\n                resolve(null);\n            }, 5_000);\n\n            sendTo(hostId, 'getVersion', null, ioPack => {\n                if (timeout) {\n                    clearTimeout(timeout);\n                    timeout = null;\n                    // @ts-expect-error sendTo needs to be fixed, because in some cases there is no error and return value is in first arg\n                    resolve(ioPack);\n                }\n            });\n        });\n    }\n    logger.warn(`${hostLogPrefix} \"${hostId}\" is offline`);\n    return null;\n}\n\n/**\n * Upload given adapter\n *\n * @param task The upload task information containing name and an optional message\n */\nasync function uploadAdapter(task: UploadTask): Promise<void> {\n    if (!upload) {\n        upload = new Upload({\n            states: states!,\n            objects: objects!,\n        });\n    }\n\n    const msg = task.msg;\n\n    const logger = msg?.from\n        ? {\n              log: (text: string) =>\n                  // @ts-expect-error formally text is not allowed in Message, why not wrapped in message payload property?\n                  states!.pushMessage(msg.from, { command: 'log', text, from: `system.host.${hostname}` }),\n              warn: (text: string) =>\n                  // @ts-expect-error formally text is not allowed in Message, why not wrapped in message payload property?\n                  states!.pushMessage(msg.from, { command: 'warn', text, from: `system.host.${hostname}` }),\n              error: (text: string) =>\n                  // @ts-expect-error formally text is not allowed in Message, why not wrapped in message payload property?\n                  states!.pushMessage(msg.from, { command: 'error', text, from: `system.host.${hostname}` }),\n          }\n        : undefined;\n\n    await upload.uploadAdapter(task.adapter, true, true, '', logger);\n    await upload.upgradeAdapterObjects(task.adapter, undefined, logger);\n    await upload.uploadAdapter(task.adapter, false, true, '', logger);\n    // send response to requester\n    if (msg?.callback && msg.from) {\n        sendTo(msg.from, msg.command, { result: 'done' }, msg.callback);\n    }\n}\n\n/**\n * Process message to controller, like execute some script\n *\n * @param msg\n */\nasync function processMessage(msg: ioBroker.SendableMessage): Promise<null | void> {\n    // important: Do not forget to update the list of protected commands in iobroker.admin/lib/socket.js for \"socket.on('sendToHost'\"\n    // and iobroker.socketio/lib/socket.js\n\n    if (isStopping) {\n        logger.debug(`${hostLogPrefix} Ignoring incoming Host message because controller is stopping ${msg.command}`);\n        return;\n    }\n\n    logger.debug(`${hostLogPrefix} Incoming Host message ${msg.command}`);\n    switch (msg.command) {\n        case 'shell':\n            if (config.system?.allowShellCommands) {\n                logger.info(`${hostLogPrefix} ${tools.appName} execute shell command: ${msg.message}`);\n                exec(msg.message, { windowsHide: true }, (err, stdout, stderr) => {\n                    if (err) {\n                        return logger.error(`${hostLogPrefix} error: ${err.message}`);\n                    }\n\n                    logger.info(`${hostLogPrefix} stdout: ${stdout}`);\n                    logger.error(`${hostLogPrefix} stderr: ${stderr}`);\n                });\n            } else {\n                logger.warn(\n                    `${hostLogPrefix} ${tools.appName} cannot execute shell command \"${\n                        msg.message\n                    }\" because not enabled in ${tools.appName.toLowerCase()}.json file`,\n                );\n            }\n\n            break;\n\n        case 'cmdExec': {\n            const mainFile = path.join(tools.getControllerDir(), `${tools.appName.toLowerCase()}.js`);\n            const args = [...getDefaultNodeArgs(mainFile), mainFile];\n            if (!msg.message.data || typeof msg.message.data !== 'string') {\n                logger.warn(\n                    `${hostLogPrefix} ${\n                        tools.appName\n                    } Invalid cmdExec object. Expected key \"data\" with the command as string. Got as \"data\": ${JSON.stringify(\n                        msg.message.data,\n                    )}`,\n                );\n            } else {\n                const extraArgs = msg.message.data.split(' ');\n                args.push(...extraArgs);\n                logger.info(`${hostLogPrefix} ${tools.appName.toLowerCase()} ${extraArgs.join(' ')}`);\n\n                try {\n                    const child = spawn(process.execPath, args, { windowsHide: true });\n                    if (child.stdout) {\n                        child.stdout.on('data', data => {\n                            data = data.toString().replace(/\\n/g, '');\n                            logger.info(`${hostLogPrefix} ${tools.appName} ${data}`);\n                            msg.from && sendTo(msg.from, 'cmdStdout', { id: msg.message.id, data: data });\n                        });\n                    }\n\n                    if (child.stderr) {\n                        child.stderr.on('data', data => {\n                            data = data.toString().replace(/\\n/g, '');\n                            logger.error(`${hostLogPrefix} ${tools.appName} ${data}`);\n                            msg.from && sendTo(msg.from, 'cmdStderr', { id: msg.message.id, data: data });\n                        });\n                    }\n\n                    child.on('exit', exitCode => {\n                        logger.info(`${hostLogPrefix} ${tools.appName} exit ${exitCode}`);\n                        if (msg.from) {\n                            sendTo(msg.from, 'cmdExit', { id: msg.message.id, data: exitCode });\n                            // Sometimes finished command is lost, recent it\n                            setTimeout(\n                                () => sendTo(msg.from, 'cmdExit', { id: msg.message.id, data: exitCode }),\n                                1_000,\n                            );\n                        }\n                    });\n                } catch (e) {\n                    logger.error(`${hostLogPrefix} ${tools.appName} ${e.message}`);\n                    msg.from && sendTo(msg.from, 'cmdStderr', { id: msg.message.id, data: e.message });\n                }\n            }\n\n            break;\n        }\n\n        case 'getRepository':\n            if (msg.callback && msg.from) {\n                requestedRepoUpdates.push({ from: msg.from, callback: msg.callback });\n                if (requestedRepoUpdates.length > 1) {\n                    // someone has requested repo previous to us\n                    logger.debug(\n                        `${hostLogPrefix} Repository update already running, registered instance \"${msg.from}\"`,\n                    );\n                    return;\n                }\n\n                let systemConfig: ioBroker.SystemConfigObject | null | undefined;\n                try {\n                    systemConfig = await objects!.getObject(SYSTEM_CONFIG_ID);\n                } catch {\n                    // ignore\n                }\n\n                // Collect statistics (only if license has been confirmed - user agreed)\n                if (\n                    systemConfig?.common?.diag &&\n                    systemConfig.common.licenseConfirmed &&\n                    (!lastDiagSend || Date.now() - lastDiagSend > 30_000) // prevent sending of diagnostics by multiple admin instances\n                ) {\n                    lastDiagSend = Date.now();\n                    try {\n                        const obj = await collectDiagInfo(systemConfig.common.diag);\n                        // if the user selected 'none', we will have null here and do not want to send it\n                        if (obj) {\n                            // Ignore the response here and do not wait for a result to decrease the repo fetching as it used in admin GUI\n                            tools.sendDiagInfo(obj);\n                        }\n                    } catch (e) {\n                        logger.error(`${hostLogPrefix} cannot collect diagnostics: ${e.message}`);\n                    }\n                }\n\n                const globalRepo = {};\n\n                const systemRepos = await objects!.getObjectAsync(SYSTEM_REPOSITORIES_ID);\n                let changed = false;\n\n                // Check if repositories exist\n                if (systemRepos?.native?.repositories) {\n                    let forcedUpdate = false;\n                    if (tools.isObject(msg.message)) {\n                        forcedUpdate = msg.message.update;\n                        msg.message = msg.message.repo;\n                    }\n\n                    // @ts-expect-error todo it can be undefined handle the case\n                    let active = msg.message || systemConfig.common.activeRepo;\n\n                    if (!Array.isArray(active)) {\n                        active = [active];\n                    }\n\n                    for (const repoUrl of active) {\n                        const repo = systemRepos.native.repositories[repoUrl];\n                        if (repo) {\n                            if (typeof repo === 'string') {\n                                systemRepos.native.repositories[repoUrl] = {\n                                    link: repo,\n                                    json: null,\n                                };\n                                changed = true;\n                            }\n\n                            const currentRepo = systemRepos.native.repositories[repoUrl];\n\n                            // If repo is not yet loaded\n                            if (!currentRepo.json || forcedUpdate) {\n                                logger.info(\n                                    `${hostLogPrefix} Updating repository \"${repoUrl}\" under \"${currentRepo.link}\"`,\n                                );\n                                try {\n                                    if (\n                                        !currentRepo.json ||\n                                        !currentRepo.time ||\n                                        !currentRepo.hash ||\n                                        Date.now() - new Date(currentRepo.time).getTime() >= 30_000\n                                    ) {\n                                        const result = await tools.getRepositoryFileAsync(\n                                            currentRepo.link,\n                                            currentRepo.hash,\n                                            forcedUpdate,\n                                            currentRepo.json,\n                                        );\n\n                                        // If repo was really changed\n                                        if (result?.json && result.changed) {\n                                            changed = true;\n                                            currentRepo.json = result.json;\n                                            currentRepo.hash = result.hash || '';\n                                            currentRepo.time = new Date().toISOString();\n                                        }\n                                    }\n\n                                    // Make sure, that time is stored too to prevent the frequent access to repo server\n                                    if (!currentRepo.time) {\n                                        currentRepo.time = new Date().toISOString();\n                                        changed = true;\n                                    }\n                                } catch (e) {\n                                    logger.error(\n                                        `${hostLogPrefix} Error by updating repository \"${repoUrl}\" under \"${systemRepos.native.repositories[repoUrl].link}\": ${e.message}`,\n                                    );\n                                }\n                            }\n\n                            if (currentRepo.json) {\n                                Object.assign(globalRepo, currentRepo.json);\n                            }\n                        } else {\n                            logger.warn(`${hostLogPrefix} Requested repository \"${repoUrl}\" does not exist in config.`);\n                        }\n                    }\n\n                    if (changed || forcedUpdate) {\n                        try {\n                            // update timestamp so adapters like admin know when it was written the last time\n                            systemRepos.ts = Date.now();\n                            await objects!.setObject(SYSTEM_REPOSITORIES_ID, systemRepos);\n                        } catch (e) {\n                            logger.warn(`${hostLogPrefix} Repository object could not be updated: ${e.message}`);\n                        }\n                    }\n                }\n\n                for (const requester of requestedRepoUpdates) {\n                    sendTo(requester.from, msg.command, globalRepo, requester.callback);\n                }\n\n                requestedRepoUpdates = [];\n\n                try {\n                    await checkAvailableDockerUpdate();\n                } catch (e) {\n                    logger.warn(`${hostLogPrefix} Could not check for new Docker image: ${e.message}`);\n                }\n\n                try {\n                    await listUpdatableOsPackages();\n                } catch (e) {\n                    logger.warn(`${hostLogPrefix} Could not check for new OS updates: ${e.message}`);\n                }\n\n                await checkRebootRequired();\n                await disableBlocklistedInstances();\n\n                if (changed) {\n                    await autoUpgradeAdapters();\n                }\n            } else {\n                logger.error(\n                    `${hostLogPrefix} Invalid request ${\n                        msg.command\n                    }. \"callback\"(${!!msg.callback}) or \"from\"(${!!msg.from}) is null`,\n                );\n            }\n            break;\n\n        case 'getInstalled':\n            if (msg.callback && msg.from) {\n                // Get a list of all hosts\n                const doc = await objects!.getObjectViewAsync('system', 'host', {\n                    startkey: 'system.host.',\n                    endkey: 'system.host.\\u9999',\n                });\n\n                const installedInfo = tools.getInstalledInfo();\n                const hosts: Record<string, HostInformation> = {};\n\n                if (doc?.rows.length) {\n                    // Read installed versions of all hosts\n                    for (const row of doc.rows) {\n                        // If desired a local version, do not ask it, just answer\n                        if (row.id === hostObjectPrefix) {\n                            const ioPackCommon = deepClone(ioPackage.common);\n\n                            ioPackCommon.host = hostname;\n                            ioPackCommon.runningVersion = version;\n                            hosts[hostname] = ioPackCommon;\n                        } else {\n                            const ioPack = await getVersionFromHost(row.id);\n                            if (ioPack) {\n                                hosts[ioPack.host] = ioPack;\n                            }\n                        }\n                    }\n                }\n\n                sendTo(msg.from, msg.command, { ...installedInfo, hosts }, msg.callback);\n            } else {\n                logger.error(`${hostLogPrefix} Invalid request ${msg.command}. \"callback\" or \"from\" is null`);\n            }\n            break;\n\n        case 'getInstalledAdapter':\n            if (msg.callback && msg.from && msg.message) {\n                // read adapter file\n                const dir = tools.getAdapterDir(msg.message);\n                let _result = null;\n                if (fs.existsSync(`${dir}/io-package.json`)) {\n                    try {\n                        _result = fs.readJSONSync(`${dir}/io-package.json`);\n                    } catch {\n                        logger.error(`${hostLogPrefix} cannot read and parse \"${dir}/io-package.json\"`);\n                    }\n                }\n                sendTo(msg.from, msg.command, _result, msg.callback);\n            } else {\n                logger.error(`${hostLogPrefix} Invalid request ${msg.command}. \"callback\" or \"from\" is null`);\n            }\n            break;\n\n        case 'getVersion':\n            if (msg.callback && msg.from) {\n                const ioPackCommon: ioBroker.HostCommon & { host: string; runningVersion: string } = deepClone(\n                    ioPackage.common,\n                );\n                ioPackCommon.host = hostname;\n                ioPackCommon.runningVersion = version;\n                sendTo(msg.from, msg.command, ioPackCommon, msg.callback);\n            } else {\n                logger.error(`${hostLogPrefix} Invalid request ${msg.command}. \"callback\" or \"from\" is null`);\n            }\n            break;\n\n        case 'getDiagData':\n            if (msg.callback && msg.from) {\n                if (msg.message) {\n                    try {\n                        const obj = await collectDiagInfo(msg.message);\n                        sendTo(msg.from, msg.command, obj, msg.callback);\n                    } catch {\n                        sendTo(msg.from, msg.command, null, msg.callback);\n                    }\n                } else {\n                    sendTo(msg.from, msg.command, null, msg.callback);\n                }\n            } else {\n                logger.error(`${hostLogPrefix} Invalid request ${msg.command}. \"callback\" or \"from\" is null`);\n            }\n            break;\n\n        case 'getLocationOnDisk':\n            if (msg.callback && msg.from) {\n                sendTo(msg.from, msg.command, { path: controllerDir, platform: os.platform() }, msg.callback);\n            } else {\n                logger.error(`${hostLogPrefix} Invalid request ${msg.command}. \"callback\" or \"from\" is null`);\n            }\n            break;\n\n        case 'getDevList':\n            if (msg.callback && msg.from) {\n                if (os.platform() === 'linux') {\n                    const _args = ['/dev'];\n                    logger.info(`${hostLogPrefix} ls /dev`);\n                    const _child = spawn('ls', _args, { windowsHide: true });\n                    let result = '';\n                    if (_child.stdout) {\n                        _child.stdout.on('data', data => (result += data.toString()));\n                    }\n                    if (_child.stderr) {\n                        _child.stderr.on('data', data => logger.error(`${hostLogPrefix} ls ${data}`));\n                    }\n\n                    _child.on('exit', (/*exitCode*/) => {\n                        result = result.replace(/(\\r\\n|\\n|\\r|\\t)/gm, ' ');\n                        const parts = result.split(' ');\n                        const resList = [];\n                        for (let t = 0; t < parts.length; t++) {\n                            parts[t] = parts[t].trim();\n                            if (parts[t]) {\n                                resList.push(parts[t]);\n                            }\n                        }\n\n                        sendTo(msg.from, msg.command, resList, msg.callback);\n                    });\n                    break;\n                } else {\n                    sendTo(msg.from, msg.command, null, msg.callback);\n                }\n            } else {\n                logger.error(`${hostLogPrefix} Invalid request ${msg.command}. \"callback\" or \"from\" is null`);\n            }\n            break;\n\n        case 'getLogs':\n            if (msg.callback && msg.from) {\n                const lines = msg.message || 200;\n                let text = '';\n                // @ts-expect-error types not know this one\n                let logFile_ = logger.getFileName();\n\n                if (!fs.existsSync(logFile_)) {\n                    logFile_ = `${controllerDir}/../../log/${tools.appName}.log`;\n                }\n\n                if (fs.existsSync(logFile_)) {\n                    const stats = fs.statSync(logFile_);\n                    const start = stats.size > 150 * lines ? stats.size - 150 * lines : 0;\n\n                    fs.createReadStream(logFile_, {\n                        start,\n                        end: stats.size,\n                    })\n                        .on('data', chunk => (text += chunk.toString()))\n                        .on('end', () => {\n                            // done\n                            const lines = text.split('\\n');\n                            if (start) {\n                                lines.shift(); // remove first line of the file as it could be not full if starts not from 0\n                            }\n                            lines.push(stats.size.toString()); // place as last line the current size of log\n                            sendTo(msg.from, msg.command, lines, msg.callback);\n                        })\n                        .on('error', () =>\n                            // done\n                            sendTo(msg.from, msg.command, [stats.size], msg.callback),\n                        );\n                } else {\n                    sendTo(msg.from, msg.command, [0], msg.callback);\n                }\n            } else {\n                logger.error(`${hostLogPrefix} Invalid request ${msg.command}. \"callback\" or \"from\" is null`);\n            }\n            break;\n\n        case 'getLogFile':\n            if (msg.callback && msg.from && msg.message) {\n                const config = getConfig();\n                if (config && config.log && config.log.transport && config.log.transport[msg.message.transport]) {\n                    let filename = config.log.transport[msg.message.transport].filename || 'log/';\n                    const parts = filename.replace(/\\\\/g, '/').split('/');\n                    parts.pop();\n                    filename = parts.join('/');\n\n                    if (filename[0] !== '/' && !filename.match(/^\\W:/)) {\n                        const parts = ['..', '..', '..', '..'];\n                        do {\n                            parts.pop();\n                            const _filename = path.normalize(`${controllerDir}/${parts.join('/')}/`) + filename;\n                            if (fs.existsSync(_filename)) {\n                                filename = _filename;\n                                break;\n                            }\n                        } while (parts.length);\n                    }\n\n                    if (fs.existsSync(filename)) {\n                        try {\n                            const file = path.join(filename, msg.message.filename);\n                            const stat = fs.lstatSync(file);\n\n                            const data = fs.readFileSync(file);\n                            sendTo(\n                                msg.from,\n                                msg.command,\n                                { data, gz: msg.message.filename.toLowerCase().endsWith('.gz'), size: stat.size },\n                                msg.callback,\n                            );\n                        } catch (e) {\n                            sendTo(msg.from, msg.command, { error: `Cannot read file: ${e}` }, msg.callback);\n                        }\n                    } else {\n                        sendTo(msg.from, msg.command, { error: 'Cannot find file' }, msg.callback);\n                    }\n                } else {\n                    sendTo(msg.from, msg.command, { error: 'invalid config' }, msg.callback);\n                }\n            } else {\n                logger.error(`${hostLogPrefix} Invalid request ${msg.command}. \"callback\" or \"from\" is null`);\n            }\n            break;\n\n        case 'getLogFiles':\n            if (msg.callback && msg.from) {\n                const config = getConfig();\n                const result: GetLogFilesResult = { list: [] };\n                // detect file log\n                if (config && config.log && config.log.transport) {\n                    for (const transport in config.log.transport) {\n                        if (config.log.transport[transport] && config.log.transport[transport].type === 'file') {\n                            let filename = config.log.transport[transport].filename || 'log/';\n                            const parts = filename.replace(/\\\\/g, '/').split('/');\n                            parts.pop();\n                            filename = parts.join('/');\n\n                            if (filename[0] !== '/' && !filename.match(/^\\W:/)) {\n                                const parts = ['..', '..', '..', '..'];\n                                do {\n                                    parts.pop();\n                                    const _filename = path.normalize(`${controllerDir}/${parts.join('/')}/`) + filename;\n                                    if (fs.existsSync(_filename)) {\n                                        filename = _filename;\n                                        break;\n                                    }\n                                } while (parts.length);\n                            }\n\n                            try {\n                                if (fs.existsSync(filename)) {\n                                    const files = fs.readdirSync(filename);\n\n                                    for (const file of files) {\n                                        try {\n                                            if (!file.endsWith('-audit.json')) {\n                                                const stat = fs.lstatSync(path.join(filename, file));\n                                                if (!stat.isDirectory()) {\n                                                    result.list.push({\n                                                        fileName: `log/${hostname}/${transport}/${file}`,\n                                                        size: stat.size,\n                                                    });\n                                                }\n                                            }\n                                        } catch (e) {\n                                            logger.error(\n                                                `${hostLogPrefix} cannot check file: ${path.join(filename, file)} - ${\n                                                    e.message\n                                                }`,\n                                            );\n                                        }\n                                    }\n                                }\n                            } catch (e) {\n                                logger.error(`${hostLogPrefix} cannot check files: ${filename} - ${e.message}`);\n                            }\n                        }\n                    }\n                }\n\n                sendTo(msg.from, msg.command, result, msg.callback);\n            } else {\n                logger.error(`${hostLogPrefix} Invalid request ${msg.command}. \"callback\" or \"from\" is null`);\n            }\n            break;\n\n        case 'getHostInfo':\n            if (msg.callback && msg.from) {\n                // installed adapters\n                // available adapters\n                // node.js --version\n                // npm --version\n                // uptime\n                let hostInfo: HostInfo;\n                try {\n                    hostInfo = await tools.getHostInfo(objects);\n                } catch (e) {\n                    logger.error(`${hostLogPrefix} cannot get getHostInfo: ${e.message}`);\n                    return null;\n                }\n\n                // add information about running instances\n                let count = 0;\n                for (const proc of Object.values(procs)) {\n                    if (proc.process) {\n                        count++;\n                    }\n                }\n\n                let location = path.normalize(`${controllerDir}/../`);\n                if (path.basename(location) === 'node_modules') {\n                    location = path.normalize(`${controllerDir}/../../`);\n                }\n\n                const enrichedHostInfo = {\n                    ...hostInfo,\n                    'Active instances': count,\n                    location,\n                    Uptime: Math.round((Date.now() - uptimeStart) / 1_000),\n                };\n\n                sendTo(msg.from, msg.command, enrichedHostInfo, msg.callback);\n            } else {\n                logger.error(`${hostLogPrefix} Invalid request ${msg.command}. \"callback\" or \"from\" is null`);\n            }\n            break;\n\n        case 'getHostInfoShort':\n            if (msg.callback && msg.from) {\n                // same as getHostInfo, but faster because delivers less information\n                // node.js --version\n                // uptime\n                let location = path.normalize(`${controllerDir}/../`);\n                if (path.basename(location) === 'node_modules') {\n                    location = path.normalize(`${controllerDir}/../../`);\n                }\n\n                const cpus = os.cpus();\n                const dateObj = new Date();\n\n                const data: Record<string, any> = {\n                    Platform: os.platform(),\n                    os: process.platform,\n                    Architecture: os.arch(),\n                    CPUs: cpus.length,\n                    Speed: tools.isObject(cpus[0]) ? cpus[0].speed : undefined,\n                    Model: tools.isObject(cpus[0]) ? cpus[0].model : undefined,\n                    RAM: os.totalmem(),\n                    'System uptime': Math.round(os.uptime()),\n                    'Node.js': process.version,\n                    location,\n                    time: dateObj.getTime(), // give infos to compare the local times\n                    timeOffset: dateObj.getTimezoneOffset(),\n                };\n\n                if (data.Platform === 'win32') {\n                    data.Platform = 'Windows';\n                } else if (data.Platform === 'darwin') {\n                    data.Platform = 'OSX';\n                }\n\n                sendTo(msg.from, msg.command, data, msg.callback);\n            } else {\n                logger.error(`${hostLogPrefix} Invalid request ${msg.command}. \"callback\" or \"from\" is null`);\n            }\n            break;\n\n        case 'delLogs': {\n            // @ts-expect-error types not know this one\n            const logFile = logger.getFileName(); //controllerDir + '/log/' + tools.appName + '.log';\n            fs.existsSync(`${controllerDir}/log/${tools.appName}.log`) &&\n                fs.writeFileSync(`${controllerDir}/log/${tools.appName}.log`, '');\n            fs.existsSync(`${controllerDir}/../../log/${tools.appName}.log`) &&\n                fs.writeFileSync(`${controllerDir}/../../log/${tools.appName}.log`, '');\n            fs.existsSync(logFile) && fs.writeFileSync(logFile, '');\n\n            msg.callback && msg.from && sendTo(msg.from, msg.command, null, msg.callback);\n            break;\n        }\n\n        case 'readDirAsZip':\n            if (msg.callback && msg.from) {\n                zipFiles.readDirAsZip(\n                    objects!,\n                    msg.message.id,\n                    msg.message.name,\n                    msg.message.options,\n                    (err, base64) => {\n                        if (base64) {\n                            sendTo(msg.from, msg.command, { error: err, data: base64 }, msg.callback);\n                        } else {\n                            sendTo(msg.from, msg.command, { error: err }, msg.callback);\n                        }\n                    },\n                );\n            } else {\n                logger.error(`${hostLogPrefix} Invalid request ${msg.command}. \"callback\" or \"from\" is null`);\n            }\n            break;\n\n        case 'writeDirAsZip':\n            try {\n                await zipFiles.writeDirAsZip(\n                    objects!,\n                    msg.message.id,\n                    msg.message.name,\n                    Buffer.from(msg.message.data, 'base64'),\n                    msg.message.options,\n                );\n\n                msg.callback && msg.from && sendTo(msg.from, msg.command, {}, msg.callback);\n            } catch (e) {\n                logger.error(`${hostLogPrefix} Cannot write zip file as folder: ${e.message}`);\n                msg.callback && msg.from && sendTo(msg.from, msg.command, { error: e.message }, msg.callback);\n            }\n            break;\n\n        case 'readObjectsAsZip':\n            if (msg.callback && msg.from) {\n                let base64: string;\n                try {\n                    base64 = await zipFiles.readObjectsAsZip(\n                        objects!,\n                        msg.message.id,\n                        msg.message.adapter,\n                        msg.message.options,\n                    );\n                } catch (e) {\n                    sendTo(msg.from, msg.command, { error: e.message }, msg.callback);\n                    return;\n                }\n\n                // If client supports file via link\n                if (msg.message.link) {\n                    const buff = Buffer.from(base64, 'base64');\n                    if (msg.message.fileStorageNamespace) {\n                        try {\n                            await objects!.writeFileAsync(\n                                msg.message.fileStorageNamespace,\n                                `zip/${msg.message.link}`,\n                                buff,\n                            );\n                        } catch (e) {\n                            sendTo(msg.from, msg.command, { error: e.message }, msg.callback);\n                            return;\n                        }\n\n                        sendTo(\n                            msg.from,\n                            msg.command,\n                            `${msg.message.fileStorageNamespace}/zip/${msg.message.link}`,\n                            msg.callback,\n                        );\n                    } else {\n                        sendTo(\n                            msg.from,\n                            msg.command,\n                            {\n                                error: `Missing attribute \"fileStorageNamespace\" use e.g. \"admin.0\" to save ZIP in file as \"zip/${msg.message.link}\"`,\n                            },\n                            msg.callback,\n                        );\n                    }\n                } else {\n                    sendTo(msg.from, msg.command, { data: base64 }, msg.callback);\n                }\n            } else {\n                logger.error(`${hostLogPrefix} Invalid request ${msg.command}. \"callback\" or \"from\" is null`);\n            }\n            break;\n\n        case 'writeObjectsAsZip':\n            zipFiles.writeObjectsAsZip(\n                objects!,\n                msg.message.id,\n                msg.message.adapter,\n                Buffer.from(msg.message.data || '', 'base64'),\n                msg.message.options,\n                err => msg.callback && msg.from && sendTo(msg.from, msg.command, { error: err?.message }, msg.callback),\n            );\n            break;\n\n        case 'checkLogging':\n            (function () {\n                // TODO: temporary enough to remove now?\n                // this is temporary function to check the logging functionality\n                // Print all information into log\n                let logs: string[] = [];\n\n                // LogList\n                logs.push(`Actual Loglist - ${JSON.stringify(logList)}`);\n\n                // Read the current state of all log subscribers\n                states!.getKeys(`${SYSTEM_ADAPTER_PREFIX}*.logging`, (err, keys) => {\n                    if (keys?.length) {\n                        states!.getStates(keys, (err, objs) => {\n                            if (objs) {\n                                for (let i = 0; i < keys.length; i++) {\n                                    const obj = objs[i];\n                                    if (obj) {\n                                        const id = keys[i]\n                                            .substring(0, keys[i].length - '.logging'.length)\n                                            .replace(/^io\\./, '');\n\n                                        if (obj.val === true) {\n                                            logs.push(`Subscriber - ${id} ENABLED`);\n                                        } else {\n                                            logs.push(`Subscriber - ${id} (disabled)`);\n                                        }\n                                    }\n                                }\n                            }\n                            setTimeout(() => {\n                                for (const log of logs) {\n                                    logger.error(`${hostLogPrefix} LOGINFO: ${log}`);\n                                }\n                                logs = [];\n                            }, 3_000);\n                        });\n                    }\n                });\n\n                // Get a list of all active adapters and send them a message with command checkLogging\n                for (const _id of Object.keys(procs)) {\n                    if (procs[_id].process) {\n                        outputCount++;\n                        states!.setState(`${_id}.checkLogging`, { val: true, ack: false, from: hostObjectPrefix });\n                    }\n                }\n            })();\n            break;\n\n        case 'updateMultihost': {\n            const result = startMultihost();\n            if (msg.callback) {\n                sendTo(msg.from, msg.command, { result: result }, msg.callback);\n            }\n            break;\n        }\n\n        case 'upgradeController': {\n            if (!tools.isControllerUiUpgradeSupported()) {\n                if (msg.callback) {\n                    sendTo(msg.from, msg.command, { result: false }, msg.callback);\n                }\n                break;\n            }\n\n            const { version, adminInstance } = msg.message;\n\n            logger.info(`${hostLogPrefix} Controller will upgrade itself to version ${version}`);\n            await startUpgradeManager({\n                version,\n                adminInstance,\n                uid: process.getuid ? process.getuid() : 0,\n                gid: process.getgid ? process.getgid() : 0,\n            });\n\n            if (msg.callback) {\n                sendTo(msg.from, msg.command, { result: true }, msg.callback);\n            }\n            break;\n        }\n\n        case 'upgradeAdapterWithWebserver': {\n            const { version, adapterName, useHttps, port, certPrivateName, certPublicName } = msg.message;\n\n            const upgradeManager = new AdapterUpgradeManager({\n                logger,\n                adapterName,\n                version,\n                useHttps,\n                objects: objects!,\n                states: states!,\n                port,\n                certPrivateName,\n                certPublicName,\n            });\n\n            if (msg.callback) {\n                sendTo(msg.from, msg.command, { result: true }, msg.callback);\n            }\n\n            await upgradeManager.stopAdapter();\n            await upgradeManager.startWebServer();\n            await upgradeManager.performUpgrade();\n\n            break;\n        }\n\n        case 'getInterfaces':\n            if (msg.callback && msg.from) {\n                sendTo(msg.from, msg.command, { result: os.networkInterfaces() }, msg.callback);\n            } else {\n                logger.error(`${hostLogPrefix} Invalid request ${msg.command}. \"callback\" or \"from\" is null`);\n            }\n            break;\n\n        case 'upload': {\n            if (msg.message) {\n                uploadAdapter({ adapter: msg.message, msg });\n            } else {\n                logger.error(`${hostLogPrefix} No adapter name is specified for upload command from  ${msg.from}`);\n            }\n            break;\n        }\n\n        case 'rebuildAdapter':\n            if (!msg.message.id) {\n                if (msg.callback && msg.from) {\n                    sendTo(msg.from, msg.command, { error: 'Adapter to rebuild not provided.' }, msg.callback);\n                }\n            } else if (!installQueue.some(entry => entry.id === msg.message.id)) {\n                logger.info(\n                    `${hostLogPrefix} ${msg.message.id} will be rebuilt${\n                        msg.message.rebuildArgs ? ` (Args: ${JSON.stringify(msg.message.rebuildArgs)})` : ''\n                    }`,\n                );\n                const installObj: InstallQueueEntry = { id: msg.message.id, rebuild: true };\n                if (msg.message.rebuildArgs) {\n                    installObj.rebuildArgs = msg.message.rebuildArgs;\n                }\n\n                installQueue.push(installObj);\n                // start install queue if not started\n                installQueue.length === 1 && installAdapters();\n\n                if (msg.callback && msg.from) {\n                    sendTo(msg.from, msg.command, { result: 'ok' }, msg.callback);\n                }\n            } else {\n                logger.info(\n                    `${hostLogPrefix} ${msg.message.id} still in installQueue, rebuild will be done with install`,\n                );\n                if (msg.callback && msg.from) {\n                    sendTo(msg.from, msg.command, { result: 'pending' }, msg.callback);\n                }\n            }\n            break;\n\n        case 'readBaseSettings':\n            if (msg.callback && msg.from) {\n                const configFile = tools.getConfigFileName();\n                if (fs.existsSync(configFile)) {\n                    try {\n                        const config: ioBroker.IoBrokerJson = fs.readJsonSync(configFile);\n                        const stat = fs.lstatSync(configFile);\n                        sendTo(msg.from, msg.command, { config, isActive: uptimeStart > stat.mtimeMs }, msg.callback);\n                    } catch {\n                        const error = `Cannot parse file ${configFile}`;\n                        logger.error(`${hostLogPrefix} ${error}`);\n                        sendTo(msg.from, msg.command, { error }, msg.callback);\n                    }\n                } else {\n                    const error = `Cannot find file ${configFile}`;\n                    logger.error(`${hostLogPrefix} ${error}`);\n                    sendTo(msg.from, msg.command, { error }, msg.callback);\n                }\n            } else {\n                logger.error(\n                    `${hostLogPrefix} No adapter name is specified for readBaseSettings command from  ${msg.from}`,\n                );\n            }\n            break;\n\n        case 'writeBaseSettings': {\n            if (!msg.message) {\n                const error = `No data found on writeBaseSettings from \"${msg.from}\"`;\n                logger.error(`${hostLogPrefix} ${error}`);\n                return sendResponseTo({ receivedMsg: msg, payload: { error } });\n            }\n\n            const configFile = tools.getConfigFileName();\n\n            if (!fs.existsSync(configFile)) {\n                const error = `No config file exists on writeBaseSettings from \"${msg.from}\"`;\n                logger.error(`${hostLogPrefix} ${error}`);\n                return sendResponseTo({ receivedMsg: msg, payload: { error } });\n            }\n\n            let config: ioBroker.IoBrokerJson | undefined;\n            if (typeof msg.message === 'string') {\n                try {\n                    config = JSON.parse(msg.message);\n                } catch {\n                    return sendResponseTo({\n                        receivedMsg: msg,\n                        payload: { error: `Cannot parse data: \"${msg.message}\"` },\n                    });\n                }\n            } else {\n                config = msg.message;\n            }\n\n            if (!config) {\n                return sendResponseTo({ receivedMsg: msg, payload: { error: 'Empty config' } });\n            }\n\n            if (!config.system) {\n                return sendResponseTo({ receivedMsg: msg, payload: { error: 'Cannot find \"system\" in data' } });\n            }\n            if (!config.objects) {\n                return sendResponseTo({ receivedMsg: msg, payload: { error: 'Cannot find \"objects\" in data' } });\n            }\n            if (!config.states) {\n                return sendResponseTo({ receivedMsg: msg, payload: { error: 'Cannot find \"states\" in data' } });\n            }\n            if (!config.log) {\n                return sendResponseTo({ receivedMsg: msg, payload: { error: 'Cannot find \"log\" in data' } });\n            }\n\n            try {\n                fs.writeFileSync(configFile, JSON.stringify(config, null, 2));\n            } catch {\n                return sendResponseTo({ receivedMsg: msg, payload: { error: `Cannot write file ${configFile}` } });\n            }\n\n            return sendResponseTo({ receivedMsg: msg, payload: { result: 'ok' } });\n        }\n\n        case 'addNotification':\n            await notificationHandler.addMessage({\n                scope: msg.message.scope,\n                category: msg.message.category,\n                message: msg.message.message,\n                instance: msg.message.instance,\n                contextData: msg.message.contextData,\n            });\n\n            if (msg.callback && msg.from) {\n                sendTo(msg.from, msg.command, { result: 'ok' }, msg.callback);\n            }\n            break;\n\n        case 'clearNotifications':\n            await notificationHandler.clearNotifications(msg.message.scope, msg.message.category, msg.message.instance);\n            if (msg.callback && msg.from) {\n                sendTo(msg.from, msg.command, { result: 'ok' }, msg.callback);\n            }\n            break;\n\n        case 'getNotifications':\n            if (msg.callback && msg.from) {\n                const notificationsObj = notificationHandler.getFilteredInformation(\n                    msg.message.scope,\n                    msg.message.category,\n                    msg.message.instance,\n                );\n                sendTo(msg.from, msg.command, { result: notificationsObj }, msg.callback);\n            }\n            break;\n\n        // read licenses from iobroker.net\n        case 'updateLicenses': {\n            try {\n                const licenses = await tools.updateLicenses(\n                    objects,\n                    msg.message && msg.message.login,\n                    msg.message && msg.message.password,\n                );\n                logger.info(\n                    `${hostLogPrefix} Received ${licenses.length} licenses: \"${licenses\n                        .map(l => l.product)\n                        .join(', ')}\"`,\n                );\n                msg.callback && msg.from && sendTo(msg.from, msg.command, { result: licenses }, msg.callback);\n            } catch (e) {\n                logger.error(`${hostLogPrefix} Cannot read licenses: ${e.message}`);\n\n                msg.callback &&\n                    msg.from &&\n                    sendTo(msg.from, msg.command, { result: [], error: e.message }, msg.callback);\n            }\n            break;\n        }\n\n        case 'upgradeOsPackages': {\n            const { packages, restart: restartRequired } = msg.message;\n\n            try {\n                await upgradeOsPackages(packages);\n                sendTo(msg.from, msg.command, { success: true }, msg.callback);\n            } catch (e) {\n                sendTo(msg.from, msg.command, { error: e.message, success: false }, msg.callback);\n                return;\n            }\n\n            try {\n                await listUpdatableOsPackages();\n            } catch (e) {\n                logger.warn(`${hostLogPrefix} Could not check for new OS updates after upgrade: ${e.message}`);\n            }\n\n            if (restartRequired) {\n                logger.info(`${hostLogPrefix} Restart js-controller because desired after package upgrade`);\n                await wait(200);\n                restart(() => !isStopping && stop(false));\n            }\n            break;\n        }\n\n        case 'restartController': {\n            msg.callback && sendTo(msg.from, msg.command, '', msg.callback);\n            // let the answer be sent\n            await wait(200);\n            restart(() => !isStopping && stop(false));\n            break;\n        }\n\n        case 'sendToSentry': {\n            const message: string = msg.message.message;\n            const level: string = msg.message.level;\n            const extraInfo: Record<string, unknown> = msg.message.extraInfo;\n\n            const sentryObj = (\n                pluginHandler.getPluginInstance('sentry') as InstanceType<typeof SentryPlugin> | null\n            )?.getSentryObject();\n\n            if (!sentryObj) {\n                logger.debug(`${hostLogPrefix} Do not send message \"${message}\" to Sentry, because it is disabled`);\n                return;\n            }\n\n            sentryObj.withScope((scope: any) => {\n                scope.setLevel(level);\n                for (const [attr, val] of Object.entries(extraInfo)) {\n                    scope.setExtra(attr, val);\n                }\n\n                sentryObj.captureMessage(message, 'info');\n            });\n            break;\n        }\n    }\n}\n\n/**\n * Wrapper around sendTo for message responses\n *\n * @param options The received message and response payload\n */\nasync function sendResponseTo(options: SendResponseToOptions): Promise<void> {\n    const { receivedMsg, payload } = options;\n\n    if (receivedMsg.callback && receivedMsg.from) {\n        await sendTo(receivedMsg.from, receivedMsg.command, payload, receivedMsg.callback);\n    }\n}\n\n/**\n * Collect all instances on this host and call `initInstances`\n */\nasync function getInstances(): Promise<void> {\n    if (!objects) {\n        throw new Error('Objects database not connected');\n    }\n\n    const instances = await getInstancesOrderedByStartPrio(objects, logger, hostLogPrefix);\n\n    if (instances.length === 0) {\n        logger.info(`${hostLogPrefix} no instances found`);\n    } else {\n        const _ipArr = tools.findIPs();\n        if (!compactGroupController) {\n            logger.info(`${hostLogPrefix} ${instances.length} instance${instances.length === 1 ? '' : 's'} found`);\n        }\n        let count = 0;\n\n        // first mark all instances as disabled to detect disabled once\n        for (const proc of Object.values(procs)) {\n            if (proc.config?.common?.enabled) {\n                proc.config.common.enabled = false;\n            }\n        }\n\n        for (const instance of instances) {\n            // register all common fields that may not be deleted, like \"mobile\" or \"history\"\n            if (instance.common.preserveSettings) {\n                objects.addPreserveSettings(instance.common.preserveSettings);\n            }\n\n            // @ts-expect-error is mode web valid, it is not in schema\n            if (instance.common.mode === 'web' || instance.common.mode === 'none') {\n                if (instance.common.host === hostname) {\n                    const name = instance._id.split('.')[2];\n                    const adapterDir = tools.getAdapterDir(name);\n                    if (!fs.existsSync(adapterDir!)) {\n                        // @ts-expect-error check if we already need to add the config here\n                        procs[instance._id] = { downloadRetry: 0, config: { common: { enabled: false } } };\n                        installQueue.push({\n                            id: instance._id,\n                            disabled: true,\n                            version: instance.common.installedVersion || instance.common.version,\n                            installedFrom: instance.common.installedFrom,\n                        });\n                        // start install queue if not started\n                        installQueue.length === 1 && installAdapters();\n                    }\n                }\n                continue;\n            }\n\n            logger.debug(`${hostLogPrefix} check instance \"${instance._id}\" for host \"${instance.common.host}\"`);\n            console.log(`${hostLogPrefix} check instance \"${instance._id}\" for host \"${instance.common.host}\"`);\n\n            if (\n                checkAndAddInstance(instance, _ipArr) &&\n                instance.common.enabled &&\n                (instance.common.mode !== 'extension' || !instance.native.webInstance)\n            ) {\n                count++;\n            }\n        }\n\n        if (count > 0) {\n            logger.info(`${hostLogPrefix} starting ${count} instance${count > 1 ? 's' : ''}`);\n        } else {\n            logger.warn(`${hostLogPrefix} does not start any instances on this host`);\n        }\n    }\n\n    initInstances();\n}\n\n/**\n * Checks if an instance is relevant for this host to be considered or not\n *\n * @param instance Object of the instance\n * @param _ipArr IP-Array from this host\n * @returns true if instance needs to be handled by this host else false\n */\nfunction instanceRelevantForThisController(instance: ioBroker.InstanceObject, _ipArr: string[]): boolean {\n    // Normalize Compact group configuration\n    if (config.system.compact && instance.common.compact) {\n        if (instance.common.runAsCompactMode === undefined) {\n            instance.common.runAsCompactMode = false;\n        } // TODO repo logic!! -> someone can further specify this comment?\n        if (instance.common.compactGroup === undefined) {\n            instance.common.compactGroup = 1;\n        } // run in controller by default\n    }\n\n    if (compactGroupController) {\n        if (!config.system.compact || !instance.common.compact || !instance.common.runAsCompactMode) {\n            return false;\n        }\n        if (instance.common.runAsCompactMode && instance.common.compactGroup !== compactGroup) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * Check if an instance is handled by this host process and initialize internal data structures\n *\n * @param instance instance object\n * @param ipArr IP-Array from this host\n * @returns true if instance needs to be handled by this host (true) or not\n */\nfunction checkAndAddInstance(instance: ioBroker.InstanceObject, ipArr: string[]): boolean {\n    if (!ipArr.includes(instance.common.host) && instance.common.host && instance.common.host !== hostname) {\n        return false;\n    }\n    // @ts-expect-error todo who does this? legacy or still needed?\n    if (instance.deleted) {\n        return false;\n    }\n\n    // update host name to current host if host name is empty\n    if (!instance.common.host) {\n        instance.common.host = hostname;\n        objects!.setObject(instance._id, instance, err =>\n            err\n                ? logger.error(`${hostLogPrefix} Cannot update hostname for ${instance._id}: ${err.message}`)\n                : logger.info(`${hostLogPrefix} Set hostname ${hostname} for ${instance._id}`),\n        );\n    }\n\n    if (!instanceRelevantForThisController(instance, ipArr)) {\n        return false;\n    }\n\n    if (config.system.compact && instance.common.compact) {\n        if (instance.common.runAsCompactMode) {\n            // @ts-expect-error we need types if this can exist\n            compactProcs[instance.common.compactGroup] = compactProcs[instance.common.compactGroup] || {\n                instances: [],\n            };\n        }\n    }\n\n    if (compactGroupController) {\n        logger.debug(`${hostLogPrefix} instance ${instance._id} is managed by this controller`);\n    }\n    procs[instance._id] = procs[instance._id] || {};\n    if (!procs[instance._id].config) {\n        procs[instance._id].config = deepClone(instance);\n    }\n    return true;\n}\n\nfunction initInstances(): void {\n    let seconds = 0;\n    const interval = (config.system && config.system.instanceStartInterval) || 2_000;\n\n    // Start first admin\n    for (const [id, proc] of Object.entries(procs)) {\n        if (\n            proc.config.common.enabled &&\n            (proc.config.common.mode !== 'extension' || !proc.config.native.webInstance)\n        ) {\n            if (id.startsWith(`${SYSTEM_ADAPTER_PREFIX}admin`)) {\n                // do not process if still running. It will be started when old one will be finished\n                if (proc.process) {\n                    logger.info(`${hostLogPrefix} instance \"${id}\" was not started, because running.`);\n                    continue;\n                }\n                if (!installQueue.find(obj => obj.id === id)) {\n                    if (proc.restartTimer) {\n                        clearTimeout(proc.restartTimer);\n                    }\n                    // @ts-expect-error tell ts it is an instance id\n                    proc.restartTimer = setTimeout(_id => startInstance(_id), interval * seconds, id);\n\n                    seconds += 2; // 4-seconds pause between starts\n                }\n            }\n        } else if (procs[id].process) {\n            // stop instance if disabled\n            stopInstance(id, false);\n        }\n    }\n\n    for (const [id, proc] of Object.entries(procs)) {\n        if (\n            proc.config.common.enabled &&\n            (proc.config.common.mode !== 'extension' || !proc.config.native.webInstance)\n        ) {\n            if (!id.startsWith(`${SYSTEM_ADAPTER_PREFIX}admin`)) {\n                // Do not process if still running. It will be started when the old one is finished\n                if (proc.process) {\n                    logger.info(`${hostLogPrefix} instance \"${id}\" was not started, because already running.`);\n                    continue;\n                }\n\n                if (!installQueue.find(obj => obj.id === id)) {\n                    if (proc.restartTimer) {\n                        clearTimeout(proc.restartTimer);\n                    }\n                    // @ts-expect-error tell ts it is an instance id\n                    proc.restartTimer = setTimeout(_id => startInstance(_id), interval * seconds, id);\n\n                    if (!proc.config.common.onlyWWW) {\n                        seconds += 2; // 4 seconds pause between starts if not only www files\n                    }\n                }\n            }\n        } else {\n            const name = id.split('.')[2];\n            const adapterDir = tools.getAdapterDir(name);\n            if (!fs.existsSync(adapterDir!)) {\n                proc.downloadRetry = proc.downloadRetry || 0;\n                installQueue.push({\n                    // @ts-expect-error ts not knows that these are instance ids\n                    id: id,\n                    disabled: true,\n                    version: proc.config.common.installedVersion || proc.config.common.version,\n                    installedFrom: proc.config.common.installedFrom,\n                });\n                // start install queue if not started\n                installQueue.length === 1 && installAdapters();\n            }\n        }\n    }\n}\n\n/**\n * Checks if at least one of the instances of given name satisfies the version\n *\n * @param name - name of the dependency\n * @param version - version requirement, e.g. \">=3.3.0\"\n * @param instances - object of instances and their corresponding instance objects\n * @throws\n */\nfunction checkVersion(name: string, version: string, instances: Record<string, ioBroker.InstanceObject>): void {\n    let isFound = false;\n\n    if (name === 'js-controller') {\n        // Check only a version\n        if (version) {\n            if (!semver.satisfies(ioPackage.common.version, version, { includePrerelease: true })) {\n                throw new Error(\n                    `Invalid version of \"${name}\". Installed \"${ioPackage.common.version}\", required \"${version}\"`,\n                );\n            } else {\n                isFound = true;\n            }\n        } else {\n            isFound = true;\n        }\n    }\n\n    if (!isFound) {\n        // get all instances of this adapter\n        const filteredInst = Object.keys(instances).filter(\n            p => instances[p] && instances[p].common && instances[p].common.name === name,\n        );\n        for (const inst of filteredInst) {\n            if (version && !semver.satisfies(instances[inst].common.version, version, { includePrerelease: true })) {\n                throw new Error(\n                    `required adapter \"${name}\" has wrong version. Installed \"${instances[inst].common.version}\", required \"${version}\"!`,\n                );\n            }\n            isFound = true;\n        }\n    }\n\n    if (!isFound) {\n        throw new Error(`required adapter \"${name}\" not found!`);\n    }\n}\n\n/**\n * Checks if all dependencies of an adapter are satisfied\n *\n * @param id - instance id of the requiring instance (only used for logging)\n * @param deps - same host dependencies as defined in io-pack\n * @param globalDeps - global dependencies, as defined in io-pack\n */\nasync function checkVersions(id: string, deps?: Dependencies, globalDeps?: Dependencies): Promise<void> {\n    const res = await objects!.getObjectViewAsync('system', 'instance', {\n        startkey: SYSTEM_ADAPTER_PREFIX,\n        endkey: `${SYSTEM_ADAPTER_PREFIX}\\u9999`,\n    });\n    const instances: Record<string, ioBroker.InstanceObject> = {};\n    const globInstances: Record<string, ioBroker.InstanceObject> = {};\n\n    res.rows.forEach(item => {\n        if (!item.value._id) {\n            return;\n        }\n        globInstances[item.value._id] = item.value;\n    });\n\n    Object.keys(globInstances).forEach(id => {\n        if (globInstances[id]?.common && globInstances[id].common.host === hostname) {\n            instances[id] = globInstances[id];\n        }\n    });\n\n    // this ensures we have a real object with correct structure\n    deps = tools.parseDependencies(deps);\n    globalDeps = tools.parseDependencies(globalDeps);\n\n    // check local dependencies: required adapter must be installed on the same host\n    try {\n        for (const dep of Object.keys(deps)) {\n            checkVersion(dep, deps[dep], instances);\n        }\n    } catch (e) {\n        logger.debug(`${hostLogPrefix} ${id} [sameHostDependency]: ${JSON.stringify(deps)}`);\n        throw new Error(`Adapter dependency not fulfilled on \"${hostname}\": ${e.message}`);\n    }\n\n    // check global dependencies: required adapter must be NOT installed on the same host\n    try {\n        for (const gDep of Object.keys(globalDeps)) {\n            checkVersion(gDep, globalDeps[gDep], globInstances);\n        }\n    } catch (e) {\n        logger.debug(`${hostLogPrefix} ${id} [globalDependency]: ${JSON.stringify(globalDeps)}`);\n        throw new Error(`Adapter dependency not fulfilled on any host: ${e.message}`);\n    }\n}\n\n/**\n * Store process IDS to make possible kill them all by restart\n */\nfunction storePids(): void {\n    if (!storeTimer) {\n        storeTimer = setTimeout(() => {\n            storeTimer = null;\n            const pids = [];\n            for (const id of Object.keys(procs)) {\n                const proc = procs[id];\n\n                if (proc.process?.pid && !proc.startedAsCompactGroup) {\n                    pids.push(proc.process.pid);\n                }\n            }\n            for (const id of Object.keys(compactProcs)) {\n                const compactProc = compactProcs[id];\n\n                if (compactProc.process?.pid) {\n                    pids.push(compactProc.process.pid);\n                }\n            }\n            pids.push(process.pid);\n            try {\n                fs.writeFileSync(tools.getPidsFileName(), JSON.stringify(pids));\n            } catch (err) {\n                logger.error(\n                    `${hostLogPrefix} could not store process id list in ${tools.getPidsFileName()}! Please check permissions and user ownership of this file. Was ioBroker started as a different user? Please also check left over processes when stopping ioBroker!\\n${err}`,\n                );\n                logger.error(`${hostLogPrefix} Please consider running the installation fixer when on Linux.`);\n            }\n        }, 1_000);\n    }\n}\n\nfunction installAdapters(): void {\n    if (!installQueue.length) {\n        return;\n    }\n\n    const task = installQueue[0];\n    if (task.inProgress) {\n        return;\n    }\n    let name = task.id.split('.')[2];\n    if (task.version && !task.rebuild) {\n        name += `@${task.version}`;\n    }\n\n    const commandScope = task.rebuild ? 'rebuild' : 'install';\n    if (compactGroupController && !task.rebuild) {\n        logger.info(\n            `${hostLogPrefix} adapter ${name} is not installed, installation will be handled by main controller ... waiting `,\n        );\n        setImmediate(() => {\n            installQueue.shift();\n            installAdapters();\n        });\n        return;\n    }\n\n    const proc = procs[task.id];\n    proc.downloadRetry = proc.downloadRetry ?? 0;\n\n    if (proc?.downloadRetry < 4) {\n        proc.downloadRetry++;\n\n        if (task.rebuild) {\n            logger.warn(\n                `${hostLogPrefix} adapter \"${name}\" seems to be installed for a different version of Node.js. Trying to rebuild it... ${\n                    procs[task.id].rebuildCounter\n                } attempt`,\n            );\n        } else {\n            logger.warn(\n                `${hostLogPrefix} startInstance cannot find adapter \"${name}\". Try to install it... ${proc.downloadRetry} attempt`,\n            );\n        }\n\n        const mainFile = path.join(tools.getControllerDir(), `${tools.appName.toLowerCase()}.js`);\n        const installArgs = [];\n        const installOptions = { windowsHide: true };\n        if (!task.rebuild && task.installedFrom && proc.downloadRetry < 3) {\n            // two tries with installed location, afterward we try the normal npm version install\n            if (tools.isShortGithubUrl(task.installedFrom) || task.installedFrom.includes('://')) {\n                // Installing from URL supports raw http(s) and file URLs as well as the short GitHub URL format\n                installArgs.push('url');\n                installArgs.push(task.installedFrom);\n                installArgs.push(task.id.split('.')[2]); // adapter name\n            } else {\n                installArgs.push('install');\n                let installedFrom = task.installedFrom;\n                if (installedFrom.startsWith(`${tools.appName}.`)) {\n                    installedFrom = installedFrom.substring(tools.appName.length + 1);\n                }\n                installArgs.push(installedFrom);\n            }\n        } else {\n            installArgs.push(commandScope);\n            if (!task.rebuild) {\n                installArgs.push(name);\n            } else if (task.rebuildArgs) {\n                installArgs.push(`${task.rebuildArgs.module}@${task.rebuildArgs.version}`);\n                if (task.rebuildArgs.path) {\n                    installArgs.push('--path');\n                    installArgs.push(task.rebuildArgs.path);\n                }\n            }\n        }\n        logger.info(\n            `${hostLogPrefix} ${tools.appName.toLowerCase()} ${installArgs.join(' ')}${\n                task.rebuild\n                    ? ''\n                    : ` using ${proc.downloadRetry < 3 && task.installedFrom ? 'installedFrom' : 'installedVersion'}`\n            }`,\n        );\n\n        installArgs.unshift(...getDefaultNodeArgs(mainFile), mainFile);\n\n        try {\n            task.inProgress = true;\n            const child = spawn(process.execPath, installArgs, installOptions);\n            if (child.stdout) {\n                child.stdout.on('data', data => {\n                    data = data.toString().replace(/\\n/g, '');\n                    logger.info(`${hostLogPrefix} ${tools.appName} npm-${commandScope}: ${data}`);\n                });\n            }\n            if (child.stderr) {\n                child.stderr.on('data', data => {\n                    data = data.toString().replace(/\\n/g, '');\n                    logger.error(`${hostLogPrefix} ${tools.appName} npm-${commandScope}: ${data}`);\n                });\n            }\n\n            child.on('exit', exitCode => {\n                logger.info(`${hostLogPrefix} ${tools.appName} npm-${commandScope}: exit ${exitCode}`);\n                if (exitCode === EXIT_CODES.CANNOT_INSTALL_NPM_PACKET) {\n                    task.inProgress = false;\n                    // Move task to the end of the queue to try again (up to 3 times)\n                    installQueue.shift();\n                    installQueue.push(task);\n                } else {\n                    const finishTask = (task: InstallQueueEntry): void => {\n                        if (procs[task.id]) {\n                            procs[task.id].needsRebuild = false;\n                            if (!task.disabled) {\n                                if (!procs[task.id].config.common.enabled) {\n                                    logger.info(\n                                        `${hostLogPrefix} startInstance ${task.id}: instance is disabled but should be started, re-enabling it`,\n                                    );\n                                    states!.setState(`${task.id}.alive`, {\n                                        val: true,\n                                        ack: false,\n                                        from: hostObjectPrefix,\n                                    });\n                                } else if (task.rebuild) {\n                                    // on rebuild, we send a restart signal via object change to also reach compact group processes\n                                    objects!.extendObject(task.id, {});\n                                } else {\n                                    startInstance(task.id, task.wakeUp);\n                                }\n                            } else {\n                                logger.debug(\n                                    `${hostLogPrefix} ${tools.appName} ${commandScope} successful but the instance is disabled`,\n                                );\n                            }\n                        }\n                    };\n                    if (task.rebuild) {\n                        // This was a rebuild - find all tasks that required a rebuild and \"finish\" them (including the current one)\n                        // Since we rebuild globally now, they should all be done too.\n                        const rebuildTasks = installQueue.filter(t => t.rebuild);\n                        // Remove all rebuild tasks from the queue\n                        installQueue = installQueue.filter(t => !t.rebuild);\n                        rebuildTasks.forEach(t => finishTask(t));\n                    } else {\n                        installQueue.shift();\n                        finishTask(task);\n                    }\n                }\n\n                setTimeout(() => installAdapters(), 1_000);\n            });\n            child.on('error', err => {\n                logger.error(\n                    `${hostLogPrefix} Cannot execute \"${tools.getControllerDir()}/${tools.appName.toLowerCase()}.js ${commandScope} ${name}: ${\n                        err.message\n                    }`,\n                );\n                setTimeout(() => {\n                    installQueue.shift();\n                    installAdapters();\n                }, 1_000);\n            });\n        } catch (err) {\n            logger.error(\n                `${hostLogPrefix} Cannot execute \"${tools.getControllerDir()}/${tools.appName.toLowerCase()}.js ${commandScope} ${name}: ${err}`,\n            );\n            setTimeout(() => {\n                installQueue.shift();\n                installAdapters();\n            }, 1_000);\n        }\n    } else {\n        if (task.rebuild) {\n            logger.error(\n                `${hostLogPrefix} Cannot rebuild adapter \"${name}\". To retry it disable/enable the adapter or restart host. Also check the error messages in the log or execute \"npm install --production\" in adapter directory manually!`,\n            );\n        } else {\n            logger.error(\n                `${hostLogPrefix} Cannot download and install adapter \"${name}\". To retry it disable/enable the adapter or restart host. Also check the error messages in the log!`,\n            );\n        }\n        setTimeout(() => {\n            installQueue.shift();\n            installAdapters();\n        }, 500);\n    }\n}\n\n/**\n *\n * @param procObj\n * @param now\n * @param doOutput\n */\nfunction cleanErrors(procObj: Process, now: number | null, doOutput?: boolean): void {\n    if (!procObj || !procObj.errors || !procObj.errors.length || procObj.startedAsCompactGroup) {\n        return;\n    }\n\n    now = now || Date.now();\n\n    if (!doOutput && procObj.lastCleanErrors && now - procObj.lastCleanErrors < 1_000) {\n        return;\n    }\n\n    procObj.lastCleanErrors = now;\n\n    // output of errors into log\n    if (doOutput) {\n        for (let i = 0; i < procObj.errors.length; i++) {\n            if (procObj.errors[i] && now - procObj.errors[i].ts < 30000 && procObj.errors[i].text) {\n                const lines = procObj.errors[i].text\n                    .replace('\\x1B[31merror\\x1B[39m:', '')\n                    .replace('\\x1B[34mdebug\\x1B[39m:', 'debug:')\n                    .split('\\n');\n                for (let k = 0; k < lines.length; k++) {\n                    if (lines[k]) {\n                        logger.error(`${hostLogPrefix} Caught by controller[${i}]: ${lines[k]}`);\n                    }\n                }\n            }\n        }\n        procObj.errors = [];\n    } else {\n        // delete to old errors\n        for (let e = procObj.errors.length - 1; e >= 0; e--) {\n            if (now - procObj.errors[e].ts > 30000) {\n                procObj.errors.splice(0, e);\n                break;\n            }\n        }\n    }\n}\n\n/**\n * Start an instance of type schedule right now\n *\n * @param callback optional callback function\n */\nasync function startScheduledInstance(callback?: () => void): Promise<void> {\n    const idsToStart = Object.keys(scheduledInstances);\n    if (!idsToStart.length) {\n        callback && callback();\n        return;\n    }\n    let skipped = false;\n    const id = idsToStart[0];\n    const { adapterDir, fileNameFull, wakeUp } = scheduledInstances[idsToStart[0]];\n\n    const processNextScheduledInstance = (): void => {\n        let delay = (config.system && config.system.instanceStartInterval) || 2_000;\n        delay = skipped ? 0 : delay + 2_000;\n        setTimeout(() => {\n            delete scheduledInstances[id];\n            startScheduledInstance(callback);\n        }, delay); // 4 seconds pause\n    };\n\n    const proc = procs[id];\n\n    if (!proc) {\n        logger.error(`${hostLogPrefix} scheduleJob: Task deleted (${id})`);\n        skipped = true;\n        processNextScheduledInstance();\n        return;\n    }\n\n    const instance = proc.config;\n\n    // After sleep of PC all scheduled runs come together. There is no need to run it X times in one second. Just the last.\n    if (!proc.lastStart || Date.now() - proc.lastStart >= 2_000) {\n        // Remember the last run\n        proc.lastStart = Date.now();\n        if (!proc.process) {\n            // reset sigKill to 0 if it was set to another value from \"once run\"\n            await states!.setState(`${instance._id}.sigKill`, { val: 0, ack: false, from: hostObjectPrefix });\n\n            const args = [\n                '--instance',\n                instance._id.split('.').pop() || '0',\n                '--loglevel',\n                instance.common.loglevel || 'info',\n            ];\n            try {\n                proc.process = cp.fork(fileNameFull, args, {\n                    execArgv: tools.getDefaultNodeArgs(fileNameFull),\n                    // @ts-expect-error missing from types, but we already tested it is needed\n                    windowsHide: true,\n                    cwd: adapterDir,\n                });\n            } catch (err) {\n                logger.error(`${hostLogPrefix} instance ${id} could not be started: ${err.message}`);\n                delete proc.process;\n            }\n            if (proc.process) {\n                storePids();\n                const { pid } = proc.process;\n\n                const isNpm = isInstalledFromNpm({\n                    installedFrom: instance.common.installedFrom,\n                    adapterName: instance.common.name,\n                });\n\n                logger.info(\n                    `${hostLogPrefix} instance ${instance._id} in version \"${instance.common.version}\"${!isNpm ? ` (non-npm: ${instance.common.installedFrom})` : ''} started with pid ${proc.process.pid}`,\n                );\n\n                proc.process.on('exit', (code, signal) => {\n                    outputCount++;\n                    states!.setState(`${id}.alive`, { val: false, ack: true, from: hostObjectPrefix });\n                    if (signal) {\n                        logger.warn(`${hostLogPrefix} instance ${id} terminated due to ${signal}`);\n                    } else if (code === null) {\n                        logger.error(`${hostLogPrefix} instance ${id} terminated abnormally`);\n                    } else {\n                        const text = `${hostLogPrefix} instance ${id} having pid ${pid} terminated with code ${code} (${\n                            getErrorText(code) || ''\n                        })`;\n                        if (\n                            !code ||\n                            code === EXIT_CODES.ADAPTER_REQUESTED_TERMINATION ||\n                            code === EXIT_CODES.NO_ERROR\n                        ) {\n                            logger.info(text);\n                        } else {\n                            logger.error(text);\n                        }\n                    }\n\n                    if (proc.process) {\n                        delete proc.process;\n                    }\n                    storePids();\n                });\n            }\n\n            processNextScheduledInstance();\n            return;\n        }\n        !wakeUp &&\n            logger.warn(`${hostLogPrefix} instance ${instance._id} already running with pid ${proc.process.pid}`);\n        skipped = true;\n    } else {\n        logger.warn(\n            `${hostLogPrefix} instance ${instance._id} not started, because start has already been initialized less than 2 seconds ago`,\n        );\n        skipped = true;\n    }\n\n    processNextScheduledInstance();\n}\n\n/**\n * Start given instance\n *\n * @param id - id of instance, like 'system.adapter.hm-rpc.0'\n * @param wakeUp\n */\nasync function startInstance(id: ioBroker.ObjectIDs.Instance, wakeUp = false): Promise<void> {\n    if (isStopping || !connected || !objects) {\n        return;\n    }\n\n    const proc = procs[id];\n\n    if (!proc) {\n        logger.error(`${hostLogPrefix} startInstance ${id}: object not found!`);\n        return;\n    }\n\n    const instance = proc.config;\n    const name = id.split('.')[2];\n    let mode = instance.common.mode;\n\n    if (proc.restartTimer) {\n        clearTimeout(proc.restartTimer);\n        delete proc.restartTimer;\n    }\n\n    proc.restartExpected = false;\n\n    if (wakeUp) {\n        mode = 'daemon';\n    }\n\n    // Check if all required adapters installed and have a valid version\n    if (instance.common.dependencies || instance.common.globalDependencies) {\n        try {\n            await checkVersions(id, instance.common.dependencies, instance.common.globalDependencies);\n        } catch (e) {\n            logger.error(`${hostLogPrefix} startInstance ${id} ${e.message}`);\n            // Do not start this instance\n            return;\n        }\n    }\n\n    const adapterDir = tools.getAdapterDir(name);\n    if (adapterDir === null || !fs.existsSync(adapterDir)) {\n        proc.downloadRetry = proc.downloadRetry || 0;\n        logger.debug(`${hostLogPrefix} startInstance Queue ${id} for installation`);\n        installQueue.push({\n            id,\n            version: instance.common.installedVersion || instance.common.version,\n            installedFrom: instance.common.installedFrom,\n            wakeUp,\n        });\n        // start install queue if not started\n        if (installQueue.length === 1) {\n            installAdapters();\n        }\n        return;\n    }\n\n    const loglevel = instance.common.loglevel || 'info';\n    const instanceNo = instance._id.split('.').pop() || '0';\n    /** Args passed to the actual adapter code */\n    const args =\n        instance?._id && instance.common\n            ? ['--instance', instanceNo, '--loglevel', loglevel]\n            : ['--instance', '0', '--loglevel', 'info'];\n\n    /** Args passed to Node.js */\n    const execArgv: string[] = [];\n\n    // define memory limit for adapter\n    if (instance.common.memoryLimitMB && Math.round(instance.common.memoryLimitMB)) {\n        execArgv.push(`--max-old-space-size=${Math.round(instance.common.memoryLimitMB)}`);\n    }\n\n    if (Array.isArray(instance.common.nodeProcessParams) && instance.common.nodeProcessParams.length) {\n        execArgv.push(...instance.common.nodeProcessParams);\n\n        if (instance.common.compact) {\n            instance.common.compact = false;\n            logger.warn(\n                `${hostLogPrefix} Adapter ${instance.common.name} has \"compact=true\" as well as \"nodeProcessParams\" specified, this is not supported, please report to developer`,\n            );\n        }\n    }\n\n    try {\n        // check if the io-package content is uploaded to the database\n        const ioPack = fs.readJSONSync(path.join(adapterDir, 'io-package.json'));\n\n        if (ioPack.common.version !== instance.common.version) {\n            logger.warn(`${hostLogPrefix} Detected missing upload of adapter \"${name}\" - starting upload now.`);\n            await uploadAdapter({ adapter: name });\n            return;\n        }\n    } catch (e) {\n        logger.error(\n            `${hostLogPrefix} startInstance ${name}.${instanceNo}: Error while ensuring adapter is uploaded: ${e.message}`,\n        );\n    }\n\n    const isBlocked = await blocklistManager.isAdapterVersionBlocked({\n        version: instance.common.version,\n        adapterName: instance.common.name,\n    });\n\n    if (isBlocked) {\n        const message = `Do not start instance \"${id}\", because the version \"${instance.common.version}\" has been blocked by the developer`;\n        logger.error(`${hostLogPrefix} ${message}`);\n\n        await notificationHandler.addMessage({\n            scope: 'system',\n            category: 'blockedVersions',\n            message,\n            instance: SYSTEM_HOST_PREFIX + hostname,\n        });\n        return;\n    }\n\n    // Check if all required adapters installed and have a valid version\n    if (instance.common.dependencies || instance.common.globalDependencies) {\n        try {\n            await checkVersions(id, instance.common.dependencies, instance.common.globalDependencies);\n        } catch (e) {\n            logger.error(`${hostLogPrefix} startInstance ${id} ${e.message}`);\n            // Do not start this instance\n            return;\n        }\n    }\n\n    // workaround for old vis\n    if (instance.common.onlyWWW && name === 'vis') {\n        instance.common.onlyWWW = false;\n    }\n\n    // www-only adapters have no start file\n    if (instance.common.onlyWWW) {\n        logger.debug(`${hostLogPrefix} startInstance ${name}.${instanceNo} only WWW files. Nothing to start`);\n        return;\n    }\n\n    let adapterMainFile: string;\n    // Web extensions have a separate field for the main file. We don't need to search it in that case\n    if (instance.common.mode !== 'extension') {\n        try {\n            adapterMainFile = await tools.resolveAdapterMainFile(name);\n        } catch {\n            logger.error(`${hostLogPrefix} startInstance ${name}.${instanceNo}: cannot find start file!`);\n            return;\n        }\n    }\n\n    proc.downloadRetry = 0;\n\n    // read node.js engine requirements\n    try {\n        // read directly from disk and not via require to allow \"on the fly\" updates of adapters.\n        const packJSON = fs.readJSONSync(path.join(adapterDir, 'package.json'));\n        proc.engine = packJSON?.engines?.node;\n    } catch {\n        logger.error(\n            `${hostLogPrefix} startInstance ${name}.${instanceNo}: Cannot read and parse \"${adapterDir}/package.json\"`,\n        );\n    }\n\n    // check node.js version if defined in package.json\n    if (proc.engine) {\n        if (!semver.satisfies(process.version.replace(/^v/, ''), proc.engine)) {\n            logger.warn(\n                `${hostLogPrefix} startInstance ${name}.${instanceNo}: required Node.js version ${proc.engine}, actual version ${process.version}`,\n            );\n            // disable instance\n            const obj = await objects.getObject(id);\n            if (obj?.common?.enabled) {\n                obj.common.enabled = false;\n                await objects.setObject(obj._id, obj);\n                logger.warn(\n                    `${hostLogPrefix} startInstance ${name}.${instanceNo}: instance disabled because of Node.js version mismatch`,\n                );\n            }\n            return;\n        }\n    }\n\n    // check how much memory is left and log a warning error/if its critical\n    let availableMemMB;\n\n    if (fs.existsSync('/proc/meminfo')) {\n        // on linux we read mem available\n        try {\n            const text = fs.readFileSync('/proc/meminfo', 'utf8');\n            const m = text && text.match(/MemAvailable:\\s*(\\d+)/);\n            if (m && m[1]) {\n                availableMemMB = Math.round(parseInt(m[1], 10) * 0.001024); // convert to MB\n            }\n        } catch (err) {\n            logger.warn(`${hostLogPrefix} Cannot read /proc/meminfo: ${err}`);\n        }\n    } else {\n        // else just use freemem\n        availableMemMB = Math.round(os.freemem() / 1048576); // convert to MB\n    }\n\n    // default: if less than 100 MB log warning, less than 50 MB log error, but check config first\n    if (\n        availableMemMB !== undefined &&\n        availableMemMB < (typeof config.system.memLimitWarn === 'number' ? config.system.memLimitWarn : 100)\n    ) {\n        if (availableMemMB < (typeof config.system.memLimitError === 'number' ? config.system.memLimitError : 50)) {\n            logger.error(\n                `${hostLogPrefix} Your system has only ${availableMemMB} MB RAM left available and an additional adapter process is started. Please check your system, settings and active instances to prevent swapping and Out-Of-Memory situations!`,\n            );\n            logger.error(`${hostLogPrefix} In future versions, the adapter might not be started!`);\n        } else {\n            logger.warn(\n                `${hostLogPrefix} Your system has only ${availableMemMB} MB RAM left available and an additional adapter process is started. Please check your system, settings and active instances to prevent swapping and Out-Of-Memory situations!`,\n            );\n        }\n\n        // add it to notifications for popup\n        try {\n            await notificationHandler.addMessage({\n                scope: 'system',\n                category: 'memIssues',\n                message: `Your system has only ${availableMemMB} MB RAM left available and an additional adapter process is started. Please check your system, settings and active instances to prevent swapping and Out-Of-Memory situations!`,\n                instance: `system.host.${hostname}`,\n            });\n        } catch (e) {\n            logger.warn(`${hostLogPrefix} Could not add OOM notification: ${e.message}`);\n        }\n    }\n\n    proc.startedInCompactMode = false;\n    proc.startedAsCompactGroup = false;\n\n    if (proc.config?.notifications) {\n        try {\n            await notificationHandler.addConfig(proc.config.notifications);\n            logger.debug(`${hostLogPrefix} added notifications configuration of ${id}`);\n        } catch (e) {\n            logger.error(`${hostLogPrefix} Could not add notifications config of ${id}: ${e.message}`);\n        }\n    }\n\n    switch (mode) {\n        case 'once':\n        case 'daemon':\n            if (proc && !proc.process) {\n                allInstancesStopped = false;\n                if (proc.stopping) {\n                    delete proc.stopping;\n                }\n\n                logger.debug(\n                    `${hostLogPrefix} startInstance ${name}.${instanceNo} loglevel=${loglevel}, compact=${\n                        instance.common.compact && instance.common.runAsCompactMode\n                            ? `true (${instance.common.compactGroup})`\n                            : 'false'\n                    }`,\n                );\n                // Exit Handler for normal Adapters started as own processes\n                const exitHandler = (code: number, signal: string): void => {\n                    setInstanceOfflineStates(id);\n\n                    // if we have waiting kill timeouts from stopInstance clear them\n                    // and call callback because process ended now\n                    const stopTimeout = stopTimeouts[id];\n                    if (stopTimeout?.timeout) {\n                        clearTimeout(stopTimeout.timeout);\n                        stopTimeout.timeout = null;\n                        if (stopTimeout.callback && typeof stopTimeout.callback === 'function') {\n                            stopTimeout.callback();\n                            stopTimeout.callback = null;\n                        }\n                    }\n\n                    cleanAutoSubscribes(id, async () => {\n                        const proc = procs[id];\n                        if (proc?.config?.common.logTransporter) {\n                            outputCount++;\n                            console.log(\n                                `================================== > LOG REDIRECT ${id} => false [Process stopped]`,\n                            );\n                            states!.setState(`${id}.logging`, { val: false, ack: true, from: hostObjectPrefix });\n                        }\n\n                        // show stored errors\n                        cleanErrors(\n                            proc,\n                            null,\n                            code !== EXIT_CODES.START_IMMEDIATELY_AFTER_STOP &&\n                                code !== EXIT_CODES.ADAPTER_REQUESTED_TERMINATION,\n                        );\n\n                        if (mode !== 'once') {\n                            if (signal) {\n                                logger.warn(`${hostLogPrefix} instance ${id} terminated due to ${signal}`);\n                            } else if (code === null) {\n                                logger.error(`${hostLogPrefix} instance ${id} terminated abnormally`);\n                            }\n\n                            if (proc?.stopping || isStopping || wakeUp) {\n                                logger.info(\n                                    `${hostLogPrefix} instance ${id} terminated with code ${code} (${\n                                        getErrorText(code) || ''\n                                    })`,\n                                );\n\n                                if (proc) {\n                                    if (proc.stopping !== undefined) {\n                                        delete proc.stopping;\n                                    }\n\n                                    if (proc.process) {\n                                        delete proc.process;\n                                    }\n                                }\n\n                                if (isStopping) {\n                                    logger.silly(`${hostLogPrefix} Check Stopping ${id}`);\n                                    for (const proc of Object.values(procs)) {\n                                        if (proc.process) {\n                                            logger.silly(`${hostLogPrefix} ${proc.config.common.name} still running`);\n                                            return;\n                                        }\n                                    }\n                                    for (const [i, compactProc] of Object.entries(compactProcs)) {\n                                        if (compactProc.process) {\n                                            logger.silly(`${hostLogPrefix} Compact group ${i} still running`);\n                                            return;\n                                        }\n                                    }\n                                    logger.info(`${hostLogPrefix} All instances are stopped.`);\n                                    allInstancesStopped = true;\n                                }\n                                storePids();\n                                return;\n                            }\n                            if (code === EXIT_CODES.ADAPTER_REQUESTED_TERMINATION && proc?.restartExpected) {\n                                logger.info(`${hostLogPrefix} instance ${id} terminated for restart.`);\n                            } else if (code === EXIT_CODES.ADAPTER_REQUESTED_TERMINATION) {\n                                logger.info(\n                                    `${hostLogPrefix} instance ${id} terminated by request of the instance itself and will not be restarted, before user restarts it.`,\n                                );\n                            } else if (\n                                code === EXIT_CODES.START_IMMEDIATELY_AFTER_STOP &&\n                                proc?.config?.common.restartSchedule\n                            ) {\n                                logger.info(\n                                    `${hostLogPrefix} instance ${id} scheduled normal terminated and will be restarted on schedule.`,\n                                );\n                            } else if (code === EXIT_CODES.ADAPTER_REQUESTED_REBUILD && proc) {\n                                logger.info(\n                                    `${hostLogPrefix} instance ${id} requested a rebuild of its dependencies and will be restarted after that is done.`,\n                                );\n                                proc.needsRebuild = true;\n                            } else {\n                                const text = `${hostLogPrefix} instance ${id} terminated with code ${code} (${\n                                    getErrorText(code) || ''\n                                })`;\n                                if (\n                                    !code ||\n                                    code === EXIT_CODES.ADAPTER_REQUESTED_TERMINATION ||\n                                    code === EXIT_CODES.NO_ERROR ||\n                                    code === EXIT_CODES.START_IMMEDIATELY_AFTER_STOP\n                                ) {\n                                    logger.info(text);\n                                } else {\n                                    logger.error(text);\n                                }\n                            }\n                        }\n\n                        if (proc?.process) {\n                            delete proc.process;\n                        }\n\n                        if (proc?.needsRebuild) {\n                            proc.rebuildCounter = proc.rebuildCounter ?? 0;\n                            proc.rebuildCounter++;\n                            if (proc.rebuildCounter < 4) {\n                                logger.info(\n                                    `${hostLogPrefix} Adapter ${id} needs rebuild ${\n                                        proc.rebuildArgs ? `of ${proc.rebuildArgs.module} ` : ''\n                                    }and will be restarted afterwards.`,\n                                );\n                                const msg: Record<string, any> = {\n                                    command: 'rebuildAdapter',\n                                    message: { id: instance._id },\n                                };\n\n                                // if rebuild args are given, send them\n                                if (proc.rebuildArgs) {\n                                    msg.message.rebuildArgs = proc.rebuildArgs;\n                                    delete proc.rebuildArgs;\n                                }\n\n                                if (!compactGroupController) {\n                                    // execute directly\n                                    processMessage(msg as any);\n                                } else {\n                                    // send to the main controller to make sure only one npm process runs at a time\n                                    sendTo(`system.host.${hostname}`, 'rebuildAdapter', msg);\n                                }\n                            } else {\n                                logger.info(\n                                    `${hostLogPrefix} Rebuild for adapter ${id} not successful in 3 tries. Adapter will not be restarted again. Please execute \"npm install --production\" in adapter directory manually.`,\n                                );\n                            }\n                        } else {\n                            if (proc) {\n                                proc.rebuildCounter = 0;\n                            }\n                            if (\n                                code !== EXIT_CODES.ADAPTER_REQUESTED_TERMINATION &&\n                                !wakeUp &&\n                                connected &&\n                                !isStopping &&\n                                proc?.config?.common.enabled &&\n                                !proc.config.native.webInstance &&\n                                mode !== 'once'\n                            ) {\n                                if (code === EXIT_CODES.UNCAUGHT_EXCEPTION) {\n                                    // if it's an uncaught exception, detect restart loop\n                                    proc.crashCount = proc.crashCount ?? 0;\n                                    proc.crashCount++;\n                                    logger.debug(`${hostLogPrefix} Crash count of ${id}: ${proc.crashCount}`);\n\n                                    if (proc.crashResetTimer) {\n                                        logger.debug(\n                                            `${hostLogPrefix} Reset crash timer of ${id}, to be initialized anew`,\n                                        );\n                                        clearTimeout(proc.crashResetTimer);\n                                    }\n\n                                    // after 10 minutes without a crash, we reset the counter\n                                    logger.debug(`${hostLogPrefix} Initialize crash timer of ${id}`);\n                                    proc.crashResetTimer = setTimeout(() => {\n                                        logger.debug(\n                                            `${hostLogPrefix} Cleared crash counter of ${id}, because 10 minutes no crash`,\n                                        );\n                                        // check that process id still exists - could be moved to another host\n                                        if (proc) {\n                                            proc.crashCount = 0;\n                                        }\n                                    }, 1_000 * 600);\n                                } else {\n                                    // reset crash count and timer because non-crash exit\n                                    logger.debug(`${hostLogPrefix} Reset crash count of ${id}, because non-crash exit`);\n                                    proc.crashCount = 0;\n                                    if (proc.crashResetTimer) {\n                                        logger.debug(\n                                            `${hostLogPrefix} Cleared crash timer of ${id}, because non-crash exit`,\n                                        );\n                                        clearTimeout(proc.crashResetTimer);\n                                        delete proc.crashResetTimer;\n                                    }\n                                }\n\n                                logger.info(`${hostLogPrefix} Restart adapter ${id} because enabled`);\n\n                                const restartTimerExisting = !!proc.restartTimer;\n                                if (proc.restartTimer) {\n                                    clearTimeout(proc.restartTimer);\n                                }\n\n                                if (!proc.crashCount || proc.crashCount < 3) {\n                                    proc.restartTimer = setTimeout(\n                                        _id => startInstance(_id),\n                                        code === EXIT_CODES.START_IMMEDIATELY_AFTER_STOP\n                                            ? 1_000\n                                            : proc.config.common.restartSchedule || restartTimerExisting\n                                              ? 1_000\n                                              : 30_000,\n                                        id,\n                                    );\n                                    // 156 is special code that adapter wants itself to be restarted immediately\n                                } else {\n                                    // 3 crashes - do not restart anymore\n                                    logger.warn(\n                                        `${hostLogPrefix} Do not restart adapter ${id} because restart loop detected`,\n                                    );\n                                    await notificationHandler.addMessage({\n                                        scope: 'system',\n                                        category: 'restartLoop',\n                                        message: 'Restart loop detected',\n                                        instance: id,\n                                    });\n                                    proc.crashCount = 0;\n                                    if (proc.crashResetTimer) {\n                                        logger.debug(\n                                            `${hostLogPrefix} Cleared crash timer of ${id}, because adapter stopped`,\n                                        );\n                                        clearTimeout(proc.crashResetTimer);\n                                        delete proc.crashResetTimer;\n                                    }\n                                }\n                            } else {\n                                if (code === EXIT_CODES.ADAPTER_REQUESTED_TERMINATION && proc && proc.restartExpected) {\n                                    logger.info(`${hostLogPrefix} Adapter ${id} will be restarted automatically`);\n                                } else if (code === EXIT_CODES.ADAPTER_REQUESTED_TERMINATION) {\n                                    logger.info(\n                                        `${hostLogPrefix} Do not restart adapter ${id} because desired by instance`,\n                                    );\n                                } else if (mode !== 'once') {\n                                    logger.info(\n                                        `${hostLogPrefix} Do not restart adapter ${id} because disabled or deleted`,\n                                    );\n                                } else {\n                                    logger.info(\n                                        `${hostLogPrefix} instance ${id} terminated while should be started once`,\n                                    );\n                                }\n                            }\n                        }\n\n                        storePids();\n                    });\n                };\n\n                // Some parts of the Adapter start logic are async, so \"the finalization\" is put into this method\n                const handleAdapterProcessStart = (): void => {\n                    const proc = procs[id];\n\n                    if (!proc) {\n                        return;\n                    }\n\n                    if (!proc.process) {\n                        // We were not able or should not start as compact mode\n                        try {\n                            proc.process = cp.fork(adapterMainFile, args, {\n                                execArgv: [...tools.getDefaultNodeArgs(adapterMainFile), ...execArgv],\n                                stdio: ['ignore', 'ignore', 'pipe', 'ipc'],\n                                // @ts-expect-error missing from types, but we already tested it is needed\n                                windowsHide: true,\n                                cwd: adapterDir,\n                            });\n                        } catch (err) {\n                            logger.error(`${hostLogPrefix} instance ${instance._id} could not be started: ${err}`);\n                        }\n                    }\n\n                    if (!proc.startedInCompactMode && !proc.startedAsCompactGroup && proc.process) {\n                        states!.setState(`${id}.sigKill`, {\n                            val: proc.process.pid,\n                            ack: true,\n                            from: hostObjectPrefix,\n                        });\n                    }\n\n                    // catch error output\n                    if (!proc.startedInCompactMode && !proc.startedAsCompactGroup && proc.process?.stderr) {\n                        proc.process.stderr.on('data', data => {\n                            const proc = procs[id];\n\n                            if (!data || !proc || !tools.isObject(proc)) {\n                                return;\n                            }\n                            const text = data.toString();\n\n                            // show for debug\n                            console.error(text);\n                            if (\n                                text.includes('NODE_MODULE_VERSION') ||\n                                text.includes('npm rebuild') ||\n                                text.includes(\"Error: The module '\") ||\n                                text.includes('Could not locate the bindings file.') ||\n                                text.includes('Cannot find module')\n                            ) {\n                                // only try this at second rebuild\n                                if (proc.rebuildCounter === 1) {\n                                    proc.rebuildArgs = _determineRebuildArgsFromLog(text);\n                                }\n                                proc.needsRebuild = true;\n                            }\n                            proc.errors = proc.errors || [];\n                            const now = Date.now();\n                            proc.errors.push({ ts: now, text: text });\n                            // limit output to 300 messages\n                            if (proc.errors.length > 300) {\n                                proc.errors.splice(proc.errors.length - 300);\n                            }\n                            cleanErrors(proc, now);\n                        });\n                    }\n\n                    storePids();\n\n                    if (!proc.startedInCompactMode && !proc.startedAsCompactGroup && proc.process) {\n                        proc.process.on('exit', exitHandler);\n                    }\n\n                    if (\n                        !wakeUp &&\n                        proc?.process &&\n                        proc.config.common?.enabled &&\n                        (proc.config.common.mode !== 'extension' || !proc.config.native.webInstance) &&\n                        mode !== 'once'\n                    ) {\n                        if (proc.startedInCompactMode) {\n                            logger.info(`${hostLogPrefix} instance ${instance._id} started in COMPACT mode`);\n                        } else if (proc.startedAsCompactGroup) {\n                            logger.info(\n                                `${hostLogPrefix} instance ${instance._id} is handled by compact group controller pid ${proc.process.pid}`,\n                            );\n                        } else {\n                            const isNpm = isInstalledFromNpm({\n                                installedFrom: instance.common.installedFrom,\n                                adapterName: instance.common.name,\n                            });\n\n                            logger.info(\n                                `${hostLogPrefix} instance ${instance._id} in version \"${instance.common.version}\"${!isNpm ? ` (non-npm: ${instance.common.installedFrom})` : ''} started with pid ${proc.process.pid}`,\n                            );\n                        }\n                    }\n                };\n\n                // If system has compact mode enabled and adapter supports it and instance has it enabled\n                if (config.system.compact && instance.common.compact && instance.common.runAsCompactMode) {\n                    // compact group = 0 is executed by main js.controller, all others as own processes\n                    if (\n                        (!compactGroupController && instance.common.compactGroup === 0) ||\n                        (compactGroupController && instance.common.compactGroup !== 0)\n                    ) {\n                        try {\n                            // set to 0 to stop any pot. already running instances, especially broken compactModes\n                            await states!.setState(`${id}.sigKill`, { val: 0, ack: false, from: hostObjectPrefix });\n                        } catch {\n                            // ignore\n                        }\n\n                        const proc = procs[id];\n                        const _instance = instance?._id && instance.common ? instance._id.split('.').pop() || 0 : 0;\n                        const logLevel = instance?._id && instance.common ? instance.common.loglevel || 'info' : 'info';\n\n                        if (adapterMainFile!) {\n                            try {\n                                // @ts-expect-error commonjs module TODO: validate\n                                decache(adapterMainFile);\n\n                                // Prior to requiring the main file, make sure that the esbuild require hook was loaded\n                                // if this is a TypeScript adapter\n                                if (adapterMainFile.endsWith('.ts')) {\n                                    require('@alcalzone/esbuild-register');\n                                }\n\n                                const module = (await isAdapterEsmModule(name))\n                                    ? (await import(`${adapterMainFile}?update=${Date.now()}`)).default\n                                    : require(adapterMainFile);\n\n                                proc.process = {\n                                    // @ts-expect-error TODO type compact processes too\n                                    logic: module({\n                                        logLevel,\n                                        compactInstance: _instance,\n                                        compact: true,\n                                    }),\n                                };\n\n                                // @ts-expect-error todo add types for compact adapter procs\n                                proc.process.logic.on('exit', exitHandler);\n\n                                proc.startedInCompactMode = true;\n                            } catch (e) {\n                                logger.error(\n                                    `${hostLogPrefix} Cannot start ${name}.${_instance} in compact mode. Fallback to normal start: ${e.message}`,\n                                );\n                                logger.error(e.stackTrace);\n                                if (proc.process) {\n                                    delete proc.process;\n                                }\n\n                                // if started, let it end itself\n                                await states!.setState(`${id}.sigKill`, {\n                                    val: -1,\n                                    ack: false,\n                                    from: hostObjectPrefix,\n                                });\n                            }\n                        } else {\n                            logger.warn(\n                                `${hostLogPrefix} Cannot start ${name}.${_instance} in compact mode: Filename invalid`,\n                            );\n                        }\n\n                        if (proc.process && !proc.process.kill) {\n                            proc.process.kill = () => {\n                                states!.setState(`${id}.sigKill`, {\n                                    val: -1,\n                                    ack: false,\n                                    from: hostObjectPrefix,\n                                });\n\n                                return true;\n                            };\n                        }\n\n                        handleAdapterProcessStart();\n                    } else {\n                        const compactGroup = instance.common.compactGroup!;\n\n                        // a group controller for this group is not yet started, execute one\n                        compactProcs[compactGroup] = compactProcs[compactGroup] || {\n                            instances: [],\n                        };\n\n                        const compactProc = compactProcs[compactGroup];\n                        if (!compactProc.process) {\n                            /** Args passed to the actual adapter */\n                            const compactControllerArgs = [compactGroup.toString()];\n                            /** Args passed to Node.js */\n                            const execArgv: string[] = [];\n\n                            if (instance.common.memoryLimitMB && Math.round(instance.common.memoryLimitMB)) {\n                                execArgv.push(`--max-old-space-size=${Math.round(instance.common.memoryLimitMB)}`);\n                            }\n\n                            logger.info(\n                                `${hostLogPrefix} start controller for compactgroup ${instance.common.compactGroup}`,\n                            );\n\n                            try {\n                                compactProc.process = cp.fork(\n                                    path.join(thisDir, 'compactgroupController.js'),\n                                    compactControllerArgs,\n                                    {\n                                        execArgv,\n                                        stdio: ['ignore', 'ignore', 'pipe', 'ipc'],\n                                        // @ts-expect-error missing from types, but we already tested it is needed\n                                        windowsHide: true,\n                                    },\n                                );\n                            } catch (err) {\n                                delete compactProc.process;\n                                logger.info(\n                                    `${hostLogPrefix} controller for compactgroup ${instance.common.compactGroup} could not be started: ${err}`,\n                                );\n                            }\n\n                            if (compactProc.process) {\n                                if (compactProc.process.stderr) {\n                                    compactProc.process.stderr.on('data', data => {\n                                        const compactProc = compactProcs[compactGroup];\n                                        if (!data || !compactProc || typeof compactProc !== 'object') {\n                                            return;\n                                        }\n                                        const text = data.toString();\n                                        // show for debug\n                                        console.error(text);\n                                        compactProc.errors = compactProc.errors || [];\n                                        const now = Date.now();\n                                        compactProc.errors.push({ ts: now, text: text });\n                                        // limit output to 300 messages\n                                        if (compactProc.errors.length > 300) {\n                                            compactProc.errors.splice(compactProc.errors.length - 300);\n                                        }\n                                        cleanErrors(compactProc, now);\n                                    });\n                                }\n\n                                const currentCompactGroup = instance.common.compactGroup!;\n                                // Exit handler for compact groups\n                                const groupExitHandler = (code: number, signal: string): void => {\n                                    if (signal) {\n                                        logger.warn(\n                                            `${hostLogPrefix} compactgroup controller ${currentCompactGroup} terminated due to ${signal}`,\n                                        );\n                                    } else if (code !== null) {\n                                        logger.info(\n                                            `${hostLogPrefix} compactgroup controller ${currentCompactGroup} terminated with code ${code} (${\n                                                getErrorText(code) || ''\n                                            })`,\n                                        );\n                                    } else {\n                                        logger.info(\n                                            `${hostLogPrefix} compactgroup controller ${currentCompactGroup} terminated`,\n                                        );\n                                    }\n\n                                    if (\n                                        compactProcs[currentCompactGroup] &&\n                                        compactProcs[currentCompactGroup].process\n                                    ) {\n                                        delete compactProcs[currentCompactGroup].process;\n                                    }\n\n                                    /**\n                                     *\n                                     * @param instances\n                                     * @param callback\n                                     */\n                                    function markCompactInstancesAsStopped(\n                                        instances: ioBroker.ObjectIDs.Instance[],\n                                        callback: () => void,\n                                    ): void {\n                                        if (!instances.length) {\n                                            callback && callback();\n                                            return;\n                                        }\n\n                                        const id = instances.shift()!;\n                                        outputCount += 2;\n                                        states!.setState(`${id}.alive`, {\n                                            val: false,\n                                            ack: true,\n                                            from: hostObjectPrefix,\n                                        });\n                                        states!.setState(`${id}.connected`, {\n                                            val: false,\n                                            ack: true,\n                                            from: hostObjectPrefix,\n                                        });\n\n                                        cleanAutoSubscribes(id, () => {\n                                            const proc = procs[id];\n\n                                            if (proc?.stopping || isStopping) {\n                                                if (proc?.stopping !== undefined) {\n                                                    delete proc.stopping;\n                                                }\n                                            }\n\n                                            if (proc?.process) {\n                                                delete proc.process;\n                                            }\n\n                                            markCompactInstancesAsStopped(instances, callback);\n                                        });\n                                    }\n\n                                    // mark all instances that should be handled by this controller also as not running.\n                                    const killedInstances: ioBroker.ObjectIDs.Instance[] = [];\n                                    compactProcs[currentCompactGroup].instances.forEach(el => killedInstances.push(el));\n                                    markCompactInstancesAsStopped(killedInstances, () => {\n                                        // show stored errors\n                                        cleanErrors(compactProcs[currentCompactGroup], null, true);\n\n                                        if (isStopping) {\n                                            logger.silly(\n                                                `${hostLogPrefix} Check after group exit ${currentCompactGroup}`,\n                                            );\n                                            for (const proc of Object.values(procs)) {\n                                                if (proc.process) {\n                                                    logger.silly(\n                                                        `${hostLogPrefix} ${proc.config.common.name} still running`,\n                                                    );\n                                                    return;\n                                                }\n                                            }\n                                            for (const [i, compactProc] of Object.entries(compactProcs)) {\n                                                if (compactProc.process) {\n                                                    logger.silly(\n                                                        `${hostLogPrefix} Compact group ${i} still running (compact)`,\n                                                    );\n                                                    return;\n                                                }\n                                            }\n                                            logger.info(`${hostLogPrefix} All instances are stopped.`);\n                                            allInstancesStopped = true;\n\n                                            storePids();\n                                            return;\n                                        }\n\n                                        // Restart group controller because still instances assigned to him, done via startInstance\n                                        if (connected && compactProcs[currentCompactGroup].instances.length) {\n                                            logger.info(\n                                                `${hostLogPrefix} Restart compact group controller ${currentCompactGroup}`,\n                                            );\n                                            logger.debug(\n                                                `${hostLogPrefix} Instances: ${JSON.stringify(\n                                                    compactProcs[currentCompactGroup].instances,\n                                                )}`,\n                                            );\n\n                                            compactProcs[currentCompactGroup].instances.forEach(id => {\n                                                if (proc.restartTimer) {\n                                                    clearTimeout(proc.restartTimer);\n                                                }\n\n                                                // START_IMMEDIATELY_AFTER_STOP is a special code that adapter wants itself to be restarted immediately\n                                                proc.restartTimer = setTimeout(\n                                                    _id => startInstance(_id),\n                                                    code === EXIT_CODES.START_IMMEDIATELY_AFTER_STOP\n                                                        ? 1_000\n                                                        : procs[id].config.common.restartSchedule\n                                                          ? 1_000\n                                                          : 30_000,\n                                                    id,\n                                                );\n                                            });\n                                        } else {\n                                            logger.info(\n                                                `${hostLogPrefix} Do not restart compact group controller ${currentCompactGroup} because no instances assigned to him`,\n                                            );\n                                        }\n                                        storePids();\n                                    });\n                                };\n\n                                compactProcs[compactGroup].process!.on('exit', groupExitHandler);\n                            }\n                        }\n                        if (compactProcs[compactGroup].process) {\n                            if (!compactProcs[compactGroup].instances.includes(id)) {\n                                compactProcs[compactGroup].instances.push(id);\n                            }\n\n                            proc.process = compactProcs[compactGroup].process;\n                            proc.startedAsCompactGroup = true;\n                        }\n                        handleAdapterProcessStart();\n                    }\n                } else {\n                    try {\n                        // set to 0 to stop any pot. already running instances, especially broken compactModes\n                        await states!.setState(`${id}.sigKill`, {\n                            val: 0,\n                            ack: false,\n                            from: hostObjectPrefix,\n                        });\n                    } catch {\n                        // ignore\n                    }\n                    handleAdapterProcessStart();\n                }\n            } else {\n                if (!wakeUp && proc) {\n                    logger.warn(\n                        `${hostLogPrefix} instance ${instance._id} ${\n                            proc.stopping ? 'still' : 'already'\n                        } running with pid ${proc.process!.pid}`,\n                    );\n                }\n                if (proc.stopping) {\n                    delete proc.stopping;\n                }\n            }\n            break;\n\n        case 'schedule': {\n            if (compactGroupController) {\n                logger.debug(`${hostLogPrefix} ${instance._id} schedule is not started by compact group controller`);\n                break;\n            }\n            if (!instance.common.schedule) {\n                logger.error(`${hostLogPrefix} ${instance._id} schedule attribute missing`);\n                break;\n            }\n\n            // cancel current schedule\n            if (proc.schedule) {\n                proc.schedule.cancel();\n                logger.info(`${hostLogPrefix} instance canceled schedule ${instance._id}`);\n            }\n\n            try {\n                cronParser.parseExpression(instance.common.schedule);\n            } catch (e) {\n                logger.error(`${hostLogPrefix} Cannot schedule start of instance ${instance._id}: ${e.message}`);\n                break;\n            }\n\n            proc.schedule = schedule.scheduleJob(\n                getCronExpression({\n                    cronExpression: instance.common.schedule,\n                    connectionType: instance.common.connectionType,\n                }),\n                () => {\n                    // queue up, but only if not already queued\n                    scheduledInstances[id] = {\n                        fileNameFull: adapterMainFile,\n                        adapterDir,\n                        wakeUp,\n                    };\n                    Object.keys(scheduledInstances).length === 1 && startScheduledInstance();\n                },\n            );\n            logger.info(`${hostLogPrefix} instance scheduled ${instance._id} ${instance.common.schedule}`);\n            // Start one time adapter by start or if configuration changed\n            if (instance.common.allowInit) {\n                try {\n                    // @ts-expect-error if mode !== extension we have ensured it exists\n                    proc.process = cp.fork(adapterMainFile, args, {\n                        // @ts-expect-error if mode !== extension we have ensured it exists\n                        execArgv: [...tools.getDefaultNodeArgs(adapterMainFile), ...execArgv],\n                        // @ts-expect-error missing from types, but we already tested it is necessary\n                        windowsHide: true,\n                        cwd: adapterDir,\n                    });\n                } catch (e) {\n                    logger.info(`${hostLogPrefix} instance ${instance._id} could not be started: ${e.message}`);\n                }\n                if (proc.process) {\n                    storePids();\n                    const isNpm = isInstalledFromNpm({\n                        installedFrom: instance.common.installedFrom,\n                        adapterName: instance.common.name,\n                    });\n\n                    logger.info(\n                        `${hostLogPrefix} instance ${instance._id} in version \"${instance.common.version}\"${!isNpm ? ` (non-npm: ${instance.common.installedFrom})` : ''} started with pid ${proc.process.pid}`,\n                    );\n\n                    proc.process.on('exit', (code, signal) => {\n                        cleanAutoSubscribes(id, () => {\n                            const proc = procs[id];\n\n                            outputCount++;\n                            states!.setState(`${id}.alive`, { val: false, ack: true, from: hostObjectPrefix });\n                            if (signal) {\n                                logger.warn(`${hostLogPrefix} instance ${id} terminated due to ${signal}`);\n                            } else if (code === null) {\n                                logger.error(`${hostLogPrefix} instance ${id} terminated abnormally`);\n                            } else {\n                                const text = `${hostLogPrefix} instance ${id} terminated with code ${code} (${\n                                    getErrorText(code) || ''\n                                })`;\n                                if (\n                                    !code ||\n                                    code === EXIT_CODES.ADAPTER_REQUESTED_TERMINATION ||\n                                    code === EXIT_CODES.NO_ERROR\n                                ) {\n                                    logger.info(text);\n                                } else {\n                                    logger.error(text);\n                                }\n                            }\n                            if (proc) {\n                                delete proc.process;\n                            }\n\n                            storePids();\n                        });\n                    });\n                }\n            }\n\n            break;\n        }\n        case 'extension':\n            break;\n\n        default:\n            logger.error(`${hostLogPrefix} ${instance._id} has the invalid mode \"${mode}\"`);\n    }\n}\n\n/**\n * Sends kill signal via sigKill state or a kill after timeouts or if forced\n *\n * @param id instance id\n * @param force if forced we will kill the pid\n */\nasync function stopInstance(id: string, force: boolean): Promise<void> {\n    const proc = procs[id];\n\n    if (!proc) {\n        logger.warn(`${hostLogPrefix} stopInstance unknown instance ${id}`);\n        return;\n    }\n\n    logger.info(\n        `${hostLogPrefix} stopInstance ${id} (force=${force}, process=${procs[id].process ? 'true' : 'false'})`,\n    );\n\n    const instance = proc.config;\n    if (!instance?.common?.mode) {\n        if (proc.process) {\n            proc.stopping = true;\n            if (!proc.startedAsCompactGroup) {\n                try {\n                    proc.process.kill(); // call stop directly in adapter.js or call kill of a process\n                } catch (e) {\n                    logger.error(`${hostLogPrefix} Cannot stop ${id}: ${JSON.stringify(e)}`);\n                }\n            }\n            delete proc.process;\n        }\n\n        if (proc.schedule) {\n            proc.schedule.cancel();\n            delete proc.schedule;\n        }\n\n        if (proc.subscribe) {\n            // Remove this id from subscribed on this message\n            if (subscribe[proc.subscribe] && subscribe[proc.subscribe].includes(id as any)) {\n                subscribe[proc.subscribe].splice(subscribe[proc.subscribe].indexOf(id as any), 1);\n\n                // If no one subscribed\n                if (!subscribe[proc.subscribe].length) {\n                    // Delete item\n                    delete subscribe[proc.subscribe];\n\n                    // Unsubscribe\n                    if (proc.subscribe.startsWith('messagebox.')) {\n                        states!.unsubscribeMessage(proc.subscribe.substring('messagebox.'.length));\n                    } else {\n                        states!.unsubscribe(proc.subscribe);\n                    }\n                }\n            }\n        }\n        return;\n    }\n\n    const stopTimeout = stopTimeouts[id] || {};\n    stopTimeouts[id] = stopTimeout;\n    if (stopTimeout.timeout) {\n        clearTimeout(stopTimeout.timeout);\n        stopTimeout.timeout = null;\n    }\n\n    switch (instance.common.mode) {\n        case 'daemon':\n            if (!proc.process) {\n                if (proc.config?.common.enabled && !proc.startedAsCompactGroup) {\n                    !isStopping && logger.warn(`${hostLogPrefix} stopInstance ${instance._id} not running`);\n                }\n                return;\n            }\n            if (force && !proc.startedAsCompactGroup) {\n                logger.info(`${hostLogPrefix} stopInstance forced ${instance._id} killing pid ${proc.process.pid}`);\n                proc.stopping = true;\n                try {\n                    proc.process.kill('SIGKILL'); // call stop directly in adapter.js or call kill of a process\n                } catch (e) {\n                    logger.error(`${hostLogPrefix} Cannot stop ${id}: ${JSON.stringify(e)}`);\n                }\n                delete proc.process;\n            } else if (\n                (instance.common.messagebox && instance.common.supportStopInstance) ||\n                instance.common.supportedMessages?.stopInstance\n            ) {\n                // Send to adapter signal \"stopInstance\" because on some systems SIGTERM does not work\n                sendTo(instance._id, 'stopInstance', null, result => {\n                    const stopTimeout = stopTimeouts[id];\n                    if (stopTimeout?.timeout) {\n                        clearTimeout(stopTimeout.timeout);\n                        stopTimeout.timeout = null;\n                    }\n                    logger.info(\n                        `${hostLogPrefix} stopInstance self ${instance._id} killing pid ${\n                            proc.process ? proc.process.pid : 'undefined'\n                        }${result ? `: ${result}` : ''}`,\n                    );\n                    if (proc.process && !proc.startedAsCompactGroup) {\n                        proc.stopping = true;\n                        try {\n                            proc.process.kill('SIGKILL'); // call stop directly in adapter.js or call kill of a process\n                        } catch (e) {\n                            logger.error(`${hostLogPrefix} Cannot stop ${id}: ${JSON.stringify(e)}`);\n                        }\n                        delete proc.process;\n                    }\n\n                    if (typeof stopTimeout?.callback === 'function') {\n                        stopTimeout.callback();\n                        stopTimeout.callback = null;\n                    }\n                });\n\n                const supportStopInstanceVal: boolean | number | undefined =\n                    instance.common.supportStopInstance || instance.common.supportedMessages?.stopInstance;\n\n                const timeoutDuration = supportStopInstanceVal === true ? 1_000 : supportStopInstanceVal || 1_000;\n                return new Promise(resolve => {\n                    // If no response from adapter, kill it in 1 second\n                    stopTimeout.callback = resolve;\n                    stopTimeout.timeout = setTimeout(() => {\n                        const stopTimeout = stopTimeouts[id];\n                        const proc = procs[id];\n\n                        if (stopTimeout) {\n                            stopTimeout.timeout = null;\n                        }\n                        if (proc?.process && !proc.startedAsCompactGroup) {\n                            logger.info(\n                                `${hostLogPrefix} stopInstance timeout ${timeoutDuration} ${instance._id} killing pid ${proc.process.pid}`,\n                            );\n                            proc.stopping = true;\n                            try {\n                                proc.process.kill('SIGKILL'); // call stop directly in adapter.js or call kill of a process\n                            } catch (e) {\n                                logger.error(`${hostLogPrefix} Cannot stop ${id}: ${JSON.stringify(e)}`);\n                            }\n                            delete proc.process;\n                        } else if (!compactGroupController && proc?.process) {\n                            // was compact mode in another group\n                            delete proc.process; // we consider that the other group controller managed to stop it\n                        }\n                        if (stopTimeout && typeof stopTimeout.callback === 'function') {\n                            stopTimeout.callback();\n                            stopTimeout.callback = null;\n                        }\n                    }, timeoutDuration);\n                });\n            } else if (!proc.startedAsCompactGroup) {\n                let err;\n                try {\n                    // if started, let it end itself as first try\n                    await states!.setState(`${id}.sigKill`, { val: -1, ack: false, from: hostObjectPrefix });\n                } catch (e) {\n                    err = e;\n                }\n                // send kill signal\n                logger.info(`${hostLogPrefix} stopInstance ${instance._id} send kill signal`);\n                const proc = procs[id];\n                const stopTimeout = stopTimeouts[id];\n\n                if (!err) {\n                    if (proc) {\n                        proc.stopping = true;\n                    }\n                }\n                const timeoutDuration = instance.common.stopTimeout || 1_000;\n\n                return new Promise(resolve => {\n                    // If no response from adapter, kill it in 1 second\n                    stopTimeout.callback = resolve;\n                    stopTimeout.timeout = setTimeout(() => {\n                        const proc = procs[id];\n                        const stopTimeout = stopTimeouts[id];\n\n                        if (stopTimeout) {\n                            stopTimeout.timeout = null;\n                        }\n\n                        if (proc?.process && !proc.startedAsCompactGroup) {\n                            logger.info(\n                                `${hostLogPrefix} stopInstance timeout ${instance._id} killing pid ${proc.process.pid}`,\n                            );\n                            proc.stopping = true;\n                            try {\n                                proc.process.kill('SIGKILL');\n                            } catch (e) {\n                                logger.error(`${hostLogPrefix} Cannot stop ${id}: ${JSON.stringify(e)}`);\n                            }\n                            delete proc.process;\n                        }\n                        if (stopTimeout && typeof stopTimeout.callback === 'function') {\n                            stopTimeout.callback();\n                            stopTimeout.callback = null;\n                        }\n                    }, timeoutDuration);\n                });\n            } else {\n                if (proc) {\n                    delete proc.process;\n                }\n            }\n\n            break;\n\n        case 'schedule':\n            if (!proc.schedule) {\n                !isStopping && logger.debug(`${hostLogPrefix} stopInstance ${instance._id} not scheduled`);\n            } else {\n                proc.schedule.cancel();\n                delete proc.schedule;\n                if (scheduledInstances[id]) {\n                    delete scheduledInstances[id];\n                }\n                logger.info(`${hostLogPrefix} stopInstance canceled schedule ${instance._id}`);\n            }\n            break;\n\n        default:\n    }\n}\n\n/**\n *\n * @param forceStop\n * @param callback\n */\nfunction stopInstances(forceStop: boolean, callback?: ((wasForced?: boolean) => void) | null): void {\n    let maxTimeout: NodeJS.Timeout | null | undefined;\n    let waitTimeout: NodeJS.Timeout | null | undefined;\n\n    function waitForInstances(): void {\n        waitTimeout = null;\n        if (!allInstancesStopped) {\n            waitTimeout = setTimeout(waitForInstances, 200);\n        } else {\n            if (maxTimeout) {\n                clearTimeout(maxTimeout);\n            }\n            typeof callback === 'function' && callback();\n            callback = null;\n        }\n    }\n\n    try {\n        isStopping = isStopping || Date.now(); // Sometimes a process receives SIGTERM twice\n        const elapsed = Date.now() - isStopping;\n        logger.debug(\n            `${hostLogPrefix} stop isStopping=${elapsed} isDaemon=${isDaemon} allInstancesStopped=${allInstancesStopped}`,\n        );\n        if (elapsed >= stopTimeout) {\n            if (maxTimeout) {\n                clearTimeout(maxTimeout);\n            }\n            typeof callback === 'function' && callback(true);\n            callback = null;\n        }\n\n        for (const id of Object.keys(procs)) {\n            stopInstance(id, forceStop);\n        }\n        if (forceStop || isDaemon) {\n            // send instances SIGTERM, only needed if running in a background (isDaemon)\n            // or slave lost connection to master\n            for (const id of Object.keys(compactProcs)) {\n                const proc = compactProcs[id];\n\n                if (proc.process) {\n                    proc.process.kill();\n                }\n            }\n            if (forceStop) {\n                allInstancesStopped = true;\n            }\n        }\n\n        waitForInstances();\n    } catch (e) {\n        logger.error(`${hostLogPrefix} ${e.message}`);\n        if (maxTimeout) {\n            clearTimeout(maxTimeout);\n        }\n        if (waitTimeout) {\n            clearTimeout(waitTimeout);\n        }\n        typeof callback === 'function' && callback();\n        callback = null;\n    }\n\n    // force after Xs\n    maxTimeout = setTimeout(() => {\n        maxTimeout = null;\n        if (waitTimeout) {\n            clearTimeout(waitTimeout);\n        }\n        typeof callback === 'function' && callback(true);\n        callback = null;\n    }, stopTimeout);\n}\n\n/**\n * Stops the js-controller and all running adapter instances if no cb provided pids.txt is deleted and process exit will be called\n *\n * @param force kills instances under all circumstances\n * @param callback callback function\n */\nfunction stop(force?: boolean, callback?: () => void): void {\n    if (force === undefined) {\n        force = false;\n    }\n    if (mhService) {\n        mhService.close();\n        mhService = null;\n    }\n\n    if (primaryHostInterval) {\n        clearInterval(primaryHostInterval);\n        primaryHostInterval = null;\n    }\n\n    if (updateIPsTimer) {\n        clearInterval(updateIPsTimer);\n        updateIPsTimer = null;\n    }\n\n    if (reportInterval) {\n        clearInterval(reportInterval);\n        reportInterval = null;\n    }\n\n    if (isStopping) {\n        return;\n    }\n\n    stopInstances(force, async wasForced => {\n        pluginHandler.destroyAll();\n        notificationHandler && notificationHandler.storeNotifications();\n\n        try {\n            // if we are the host, we should now let someone else take over\n            if (isPrimary) {\n                await objects!.releasePrimaryHost();\n                isPrimary = false;\n            }\n        } catch {\n            // ignore\n        }\n\n        if (objects && objects.destroy) {\n            await objects.destroy();\n        }\n\n        if (!states || force) {\n            logger.info(\n                `${hostLogPrefix} ${\n                    wasForced ? 'force terminating' : 'terminated'\n                }. Could not reset alive status for instances`,\n            );\n            if (typeof callback === 'function') {\n                return void callback();\n            }\n            setTimeout(() => process.exit(EXIT_CODES.JS_CONTROLLER_STOPPED), 1_000);\n\n            return;\n        }\n        outputCount++;\n        try {\n            await states.setState(`${hostObjectPrefix}.alive`, { val: false, ack: true, from: hostObjectPrefix });\n            await states.setState(`${hostObjectPrefix}.pid`, { val: null, ack: true, from: hostObjectPrefix });\n        } catch {\n            // ignore\n        }\n        logger.info(`${hostLogPrefix} ${wasForced ? 'force terminating' : 'terminated'}`);\n        if (wasForced) {\n            for (const i of Object.keys(procs)) {\n                if (procs[i].process) {\n                    if (procs[i].config && procs[i].config.common && procs[i].config.common.name) {\n                        logger.info(`${hostLogPrefix} Adapter ${procs[i].config.common.name} still running`);\n                    }\n                }\n            }\n            for (const i of Object.keys(compactProcs)) {\n                if (compactProcs[i].process) {\n                    logger.info(`${hostLogPrefix} Compact group controller ${i} still running`);\n                }\n            }\n        }\n\n        if (states?.destroy) {\n            await states.destroy();\n        }\n\n        if (typeof callback === 'function') {\n            return void callback();\n        }\n        setTimeout(() => {\n            try {\n                // avoid pids been written after deletion\n                if (storeTimer) {\n                    clearTimeout(storeTimer);\n                }\n                // delete pids.txt\n                fs.unlinkSync(tools.getPidsFileName());\n            } catch (e) {\n                if (e.code !== 'ENOENT') {\n                    logger.error(`${hostLogPrefix} Could not delete ${tools.getPidsFileName()}: ${e}`);\n                }\n            }\n            process.exit(EXIT_CODES.JS_CONTROLLER_STOPPED);\n        }, 1_000);\n    });\n}\n\n/**\n * Initialize the controller\n *\n * @param compactGroupId the id of the compact group\n */\nexport async function init(compactGroupId?: number): Promise<void> {\n    let title = `${tools.appName}.js-controller`;\n\n    if (compactGroupId) {\n        compactGroupController = true;\n        compactGroup = compactGroupId;\n\n        hostObjectPrefix += compactGroupObjectPrefix + compactGroup;\n        hostLogPrefix += compactGroupObjectPrefix + compactGroup;\n        title += compactGroupObjectPrefix + compactGroup;\n\n        isDaemon = true;\n    } else {\n        stopTimeout += 5_000;\n    }\n\n    // If a bootstrap file detected, it must be deleted, but give time for a bootstrap process to use this file\n    if (fs.existsSync(VENDOR_BOOTSTRAP_FILE)) {\n        setTimeout(() => {\n            try {\n                if (fs.existsSync(VENDOR_BOOTSTRAP_FILE)) {\n                    fs.unlinkSync(VENDOR_BOOTSTRAP_FILE);\n                    logger && logger.info(`${hostLogPrefix} Deleted ${VENDOR_BOOTSTRAP_FILE}`);\n                }\n            } catch (e) {\n                logger && logger.error(`${hostLogPrefix} Cannot delete ${VENDOR_BOOTSTRAP_FILE}: ${e.message}`);\n            }\n        }, 30_000);\n    }\n\n    process.title = title;\n\n    // Get \"objects\" object\n    // If \"file\" and on the local machine\n    const hasLocalObjectsServer = await isLocalObjectsDbServer(config.objects.type, config.objects.host);\n    if (hasLocalObjectsServer && !compactGroupController) {\n        Objects = (await import(`@iobroker/db-objects-${config.objects.type}`)).Server;\n    } else {\n        Objects = await getObjectsConstructor();\n    }\n\n    const hasLocalStatesServer = await isLocalStatesDbServer(config.states.type, config.states.host);\n    // Get \"states\" object\n    if (hasLocalStatesServer && !compactGroupController) {\n        States = (await import(`@iobroker/db-states-${config.states.type}`)).Server;\n    } else {\n        States = await getStatesConstructor();\n    }\n\n    // Detect if outputs to console are forced. By default, they are disabled and redirected to log file\n    if (\n        config.log.noStdout &&\n        process.argv &&\n        (process.argv.indexOf('--console') !== -1 || process.argv.indexOf('--logs') !== -1)\n    ) {\n        config.log.noStdout = false;\n    }\n\n    // Detect if controller runs as a linux-daemon\n    if (process.argv.indexOf('start') !== -1 && !compactGroupController) {\n        isDaemon = true;\n        config.log.noStdout = true;\n    }\n\n    try {\n        logger = toolsLogger(config.log);\n    } catch (e) {\n        if (e.code === 'EACCES_LOG') {\n            // We could not access logging directory - e.g., because of restored backup\n            console.error(`Could not access logging directory \"${e.path}\", fallback to default`);\n\n            // read a fresh config to avoid overwriting e.g., noStdout\n            const _config = getConfig();\n            // persist the config to be fixed permanently\n            const configFile = tools.getConfigFileName();\n            const fixedLogPath = 'log/iobroker';\n            _config.log.transport.file1.filename = fixedLogPath;\n            fs.writeFileSync(configFile, JSON.stringify(_config, null, 2));\n\n            // fix this run\n            config.log.transport.file1.filename = fixedLogPath;\n            // @ts-expect-error TODO: correct way to apply config?\n            logger = toolsLogger.logger(config.log);\n\n            logger.warn(\n                `${hostLogPrefix} Your logging path \"${e.path}\" was invalid, it has been changed to \"${fixedLogPath}\"`,\n            );\n        } else {\n            // without logger multiple things will have undefined behavior, and probably more is wrong -> do not start\n            console.error(`Error initializing logger: ${e.stack}`);\n            process.exit(EXIT_CODES.UNKNOWN_ERROR);\n        }\n    }\n\n    if (!compactGroupController) {\n        // Delete all log files older than x days\n        // @ts-expect-error we have augmented winston instance with this method\n        logger.activateDateChecker(true, config.log.maxDays);\n    }\n\n    // find our notifier transport\n    // @ts-expect-error types do not seem to be perfect here\n    const ts = logger.transports.find(t => t.name === 'NT');\n    ts!.on('logged', info => {\n        info.from = hostLogPrefix;\n        for (const log of logList) {\n            states!.pushLog(log, info);\n        }\n    });\n\n    if (!compactGroupController) {\n        logger.info(\n            `${hostLogPrefix} ${tools.appName}.js-controller version ${version} ${ioPackage.common.name} starting`,\n        );\n        logger.info(`${hostLogPrefix} Copyright (c) 2014-2024 bluefox, 2014 hobbyquaker`);\n        logger.info(`${hostLogPrefix} hostname: ${hostname}, node: ${process.version}`);\n        logger.info(`${hostLogPrefix} ip addresses: ${tools.findIPs().join(' ')}`);\n\n        // create package.json for npm >= 3.x if not exists\n        const isInNodeModules = controllerDir\n            .toLowerCase()\n            .includes(`${path.sep}node_modules${path.sep}${title.toLowerCase()}`);\n\n        if (isInNodeModules && !tools.isDevServerInstallation()) {\n            try {\n                if (!fs.existsSync(`${controllerDir}/../../package.json`)) {\n                    fs.writeFileSync(\n                        `${controllerDir}/../../package.json`,\n                        JSON.stringify(\n                            {\n                                name: 'iobroker.core',\n                                version: '1.0.0',\n                                private: true,\n                            },\n                            null,\n                            2,\n                        ),\n                    );\n                } else {\n                    // npm3 requires version attribute\n                    const p = fs.readJSONSync(`${controllerDir}/../../package.json`);\n                    if (!p.version) {\n                        fs.writeFileSync(\n                            `${controllerDir}/../../package.json`,\n                            JSON.stringify(\n                                {\n                                    name: 'iobroker.core',\n                                    version: '1.0.0',\n                                    private: true,\n                                },\n                                null,\n                                2,\n                            ),\n                        );\n                    }\n                }\n            } catch (e) {\n                console.error(`Cannot create \"${controllerDir}/../../package.json\": ${e}`);\n            }\n        }\n    } else {\n        logger.info(\n            `${hostLogPrefix} ${tools.appName}.js-controller version ${version} ${ioPackage.common.name} starting`,\n        );\n    }\n\n    let packageJson;\n    try {\n        packageJson = fs.readJSONSync(`${controllerDir}/package.json`);\n    } catch {\n        logger.error(`${hostLogPrefix} Can not read js-controller package.json`);\n    }\n\n    if (packageJson?.engines?.node) {\n        let invalidVersion;\n        try {\n            invalidVersion = !semver.satisfies(process.version, packageJson.engines.node);\n        } catch {\n            // semver could also not support the node version or something else ... failsafe\n            invalidVersion = true;\n        }\n\n        if (invalidVersion) {\n            logger.error(\n                `${hostLogPrefix} ioBroker requires Node.js in version ${packageJson.engines.node}, you have ${process.version}`,\n            );\n            logger.error(\n                `${hostLogPrefix} Please upgrade your Node.js version. See https://forum.iobroker.net/topic/22867/how-to-node-js-f%C3%BCr-iobroker-richtig-updaten`,\n            );\n\n            console.error(\n                `ioBroker requires Node.js in version ${packageJson.engines.node}, you have ${process.version}`,\n            );\n            console.error(\n                'Please upgrade your Node.js version. See https://forum.iobroker.net/topic/22867/how-to-node-js-f%C3%BCr-iobroker-richtig-updaten',\n            );\n\n            process.exit(EXIT_CODES.INVALID_NODE_VERSION);\n        }\n    }\n\n    const pluginSettings: PluginHandlerSettings = {\n        scope: 'controller',\n        namespace: hostObjectPrefix,\n        logNamespace: hostLogPrefix,\n        log: logger as any,\n        iobrokerConfig: config,\n        parentPackage: packageJson,\n        controllerVersion: version,\n    };\n\n    pluginHandler = new PluginHandler(pluginSettings);\n    pluginHandler.addPlugins(ioPackage.common.plugins, controllerDir); // Plugins from io-package have priority over ...\n\n    try {\n        pluginHandler.addPlugins(config.plugins, controllerDir); // ... plugins from iobroker.json\n    } catch (e) {\n        logger.error(`${hostLogPrefix} Cannot load plugins ${JSON.stringify(config.plugins)}: ${e}`);\n        console.error(`Cannot load plugins ${JSON.stringify(config.plugins)}: ${e}`);\n    }\n\n    createObjects(async () => {\n        objects!.subscribe(`${SYSTEM_ADAPTER_PREFIX}*`);\n\n        // get the current host versions\n        try {\n            const hostView = await objects!.getObjectViewAsync('system', 'host');\n            for (const row of hostView.rows) {\n                if (row.value?.common?.installedVersion) {\n                    controllerVersions[row.id] = row.value.common.installedVersion;\n                }\n            }\n        } catch {\n            // ignore\n        }\n\n        // create the states object\n        createStates(async () => {\n            if (!states || !objects) {\n                throw new Error(`States or objects have not been initialized yet`);\n            }\n\n            if (connectTimeout) {\n                clearTimeout(connectTimeout);\n                connectTimeout = null;\n            }\n            // Subscribe for all logging objects\n            states.subscribe(`${SYSTEM_ADAPTER_PREFIX}*.logging`);\n\n            // Subscribe for all alive states\n            states.subscribe(`${SYSTEM_ADAPTER_PREFIX}*.alive`);\n            states.subscribe(`${hostObjectPrefix}.diskWarning`);\n            const diskWarningState = await states.getState(`${hostObjectPrefix}.diskWarning`);\n            if (diskWarningState) {\n                diskWarningLevel = getDiskWarningLevel(diskWarningState);\n            }\n\n            // set current Loglevel and subscribe for changes\n            states.setState(`${hostObjectPrefix}.logLevel`, {\n                val: config.log.level,\n                ack: true,\n                from: hostObjectPrefix,\n            });\n            states.subscribe(`${hostObjectPrefix}.logLevel`);\n\n            if (!compactGroupController) {\n                try {\n                    const nodeVersion = process.version.replace(/^v/, '');\n                    const prevNodeVersionState = await states.getStateAsync(`${hostObjectPrefix}.nodeVersion`);\n\n                    if (!prevNodeVersionState || prevNodeVersionState.val !== nodeVersion) {\n                        // detected a change in the nodejs version (or state non-existing - upgrade from below v4)\n                        logger.info(\n                            `${hostLogPrefix} Node.js version has changed from ${\n                                prevNodeVersionState ? prevNodeVersionState.val : 'unknown'\n                            } to ${nodeVersion}`,\n                        );\n                        if (os.platform() === 'linux' && process.env.IOB_NO_SETCAP !== 'true') {\n                            // ensure capabilities are set\n                            const capabilities = ['cap_net_admin', 'cap_net_bind_service', 'cap_net_raw'];\n                            await tools.setExecutableCapabilities(process.execPath, capabilities, true, true, true);\n                            logger.info(\n                                `${hostLogPrefix} Successfully updated capabilities \"${capabilities.join(', ')}\" for ${\n                                    process.execPath\n                                }`,\n                            );\n                        }\n                    }\n\n                    // set current node version\n                    await states.setState(`${hostObjectPrefix}.nodeVersion`, {\n                        val: nodeVersion,\n                        ack: true,\n                        from: hostObjectPrefix,\n                    });\n                } catch (e) {\n                    logger.warn(\n                        `${hostLogPrefix} Error while trying to update capabilities after detecting new Node.js version: ${e.message}`,\n                    );\n                }\n            }\n\n            let keys: string[] | undefined;\n\n            try {\n                // Read the current state of all log subscribers\n                keys = (await states.getKeys(`${SYSTEM_ADAPTER_PREFIX}*.logging`))!;\n            } catch {\n                // ignore\n            }\n\n            if (keys?.length) {\n                const oKeys = keys.map(id => id.replace(/\\.logging$/, ''));\n                let objs: ioBroker.AnyObject[];\n\n                try {\n                    objs = await objects.getObjects(oKeys);\n                } catch {\n                    return;\n                }\n\n                const toDelete = keys.filter((id, i) => !objs[i]);\n                keys = keys.filter((id, i) => objs[i]);\n\n                let statesArr: (ioBroker.State | null)[] | undefined;\n\n                try {\n                    statesArr = (await states.getStates(keys))!;\n                } catch {\n                    // ignore\n                }\n\n                if (statesArr) {\n                    for (let i = 0; i < keys.length; i++) {\n                        const state = statesArr[i];\n                        if (state?.val === true) {\n                            logRedirect(\n                                true,\n                                keys[i].substring(0, keys[i].length - '.logging'.length).replace(/^io\\./, ''),\n                                'starting',\n                            );\n                        }\n                    }\n                }\n\n                if (toDelete.length) {\n                    toDelete.forEach(id => {\n                        logger.warn(`${hostLogPrefix} logger ${id} was deleted`);\n                        states!.delState(id);\n                    });\n                }\n            }\n        });\n    });\n\n    connectTimeout = setTimeout(() => {\n        connectTimeout = null;\n        logger.error(`${hostLogPrefix} No connection to databases possible, restart`);\n        !compactGroupController &&\n            processMessage({ command: 'cmdExec', message: { data: '_restart' }, from: hostObjectPrefix });\n        setTimeout(() => process.exit(EXIT_CODES.JS_CONTROLLER_STOPPED), compactGroupController ? 0 : 1_000);\n    }, 30_000);\n\n    const exceptionHandler = (err: Error): void => {\n        if (compactGroupController) {\n            console.error(err.message);\n            if (err.stack) {\n                console.error(err.stack);\n            }\n            stop(false);\n            return;\n        }\n        console.error(err.message);\n        if (err.stack) {\n            console.error(err.stack);\n        }\n\n        // If by terminating one more exception => stop immediately to break the circle\n        if (uncaughtExceptionCount) {\n            console.error(err.message);\n            if (err.stack) {\n                console.error(err.stack);\n            }\n            process.exit(EXIT_CODES.UNCAUGHT_EXCEPTION);\n            return;\n        }\n        uncaughtExceptionCount++;\n        if (typeof err === 'object') {\n            // @ts-expect-error should be correct\n            if (err.errno === 'EADDRINUSE') {\n                logger.error(`${hostLogPrefix} Another instance is running or some application uses port!`);\n                logger.error(`${hostLogPrefix} uncaught exception: ${err.message}`);\n            } else {\n                logger.error(`${hostLogPrefix} uncaught exception: ${err.message}`);\n                logger.error(`${hostLogPrefix} ${err.stack}`);\n            }\n        } else {\n            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n            logger.error(`${hostLogPrefix} uncaught exception: ${err}`);\n            // @ts-expect-error todo: can this else clause even happen\n            logger.error(`${hostLogPrefix} ${err.stack}`);\n        }\n        stop(false);\n        // Restart itself\n        processMessage({ command: 'cmdExec', message: { data: '_restart' }, from: hostObjectPrefix });\n    };\n\n    process.on('SIGINT', () => {\n        logger.info(`${hostLogPrefix} received SIGINT`);\n        stop(false);\n    });\n\n    process.on('SIGTERM', () => {\n        logger.info(`${hostLogPrefix} received SIGTERM`);\n        stop(false);\n    });\n\n    process.on('uncaughtException', exceptionHandler);\n    process.on('unhandledRejection', exceptionHandler);\n}\n\n/**\n * Parses out the rebuild path, name and version from an error log\n *\n * @param text - log text\n */\nfunction _determineRebuildArgsFromLog(text: string): RebuildArgs | undefined {\n    let matches;\n    // Try to get a path for this case after a \u2192\n    if (text.includes('Could not locate the bindings file.')) {\n        matches = text.match(/\u2192 (.+)$/gm);\n        if (matches) {\n            matches.shift(); // we need to remove the first element from match\n        }\n    }\n\n    // else, extract a rebuild path the standard way - it is always\n    // between the only two single quotes\n    if (!matches) {\n        matches = text.match(/'.+'/g);\n    }\n\n    if (matches) {\n        // We only check the first path like entry\n        // remove the quotes\n        let rebuildPath = matches[0].replace(/'/g, '');\n        if (path.isAbsolute(rebuildPath)) {\n            // we have found a module which needs rebuild - we need to find the deepest pack.json\n            rebuildPath = path.dirname(rebuildPath);\n            const rootDir = path.parse(process.cwd()).root;\n\n            while (rebuildPath !== rootDir) {\n                const packPath = path.join(rebuildPath, 'package.json');\n                if (fs.pathExistsSync(packPath)) {\n                    try {\n                        const packJson = fs.readJsonSync(packPath);\n                        // step outside the module dir itself\n                        rebuildPath = path.join(rebuildPath, '..');\n\n                        return { path: rebuildPath, module: packJson.name, version: packJson.version };\n                    } catch (e) {\n                        logger.error(`${hostLogPrefix} Could not determine rebuild arguments: ${e.message}`);\n                        return;\n                    }\n                } else {\n                    rebuildPath = path.join(rebuildPath, '..');\n                }\n            }\n        }\n    }\n}\n\n/**\n * Returns number of instances and how many of them are compact instances if compact mode is enabled\n */\nasync function _getNumberOfInstances(): Promise<\n    { noCompactInstances: null; noInstances: null } | { noCompactInstances: number; noInstances: number }\n> {\n    try {\n        let noCompactInstances = 0;\n        const instancesView = await objects!.getObjectViewAsync('system', 'instance', {\n            startkey: SYSTEM_ADAPTER_PREFIX,\n            endkey: `${SYSTEM_ADAPTER_PREFIX}\\u9999`,\n        });\n\n        const noInstances = instancesView.rows.length;\n\n        if (config.system.compact) {\n            for (const row of instancesView.rows) {\n                const state = await states!.getStateAsync(`${row.id}.compactMode`);\n                if (state?.val) {\n                    noCompactInstances++;\n                }\n            }\n        }\n\n        return { noInstances, noCompactInstances };\n    } catch {\n        return { noInstances: null, noCompactInstances: null };\n    }\n}\n\n/**\n * Mark given adapter instance as offline on state level\n *\n * @param id id of the instance\n */\nasync function setInstanceOfflineStates(id: ioBroker.ObjectIDs.Instance): Promise<void> {\n    outputCount += 2;\n    await states!.setState(`${id}.alive`, { val: false, ack: true, from: hostObjectPrefix });\n    await states!.setState(`${id}.connected`, { val: false, ack: true, from: hostObjectPrefix });\n\n    const adapterInstance = id.substring(SYSTEM_ADAPTER_PREFIX.length);\n\n    const state = await states!.getState(`${adapterInstance}.info.connection`);\n\n    if (state?.val === true) {\n        outputCount++;\n        await states!.setState(adapterInstance, { val: false, ack: true, from: hostObjectPrefix });\n    }\n}\n\n/**\n * Check if a new Docker Image version is available\n */\nasync function checkAvailableDockerUpdate(): Promise<void> {\n    const dockerInfo = tools.getDockerInformation();\n\n    if (!dockerInfo.isOfficial || !states) {\n        return;\n    }\n\n    const { isNew, lastUpdated, version } = await tools.getNewestDockerImageVersion();\n\n    if (!isNew) {\n        return;\n    }\n\n    const dockerVersionStateId = `${hostObjectPrefix}.availableDockerBuild`;\n    const knownLastUpdated = (await states.getState(dockerVersionStateId))?.val;\n    await states.setState(dockerVersionStateId, { val: lastUpdated, ack: true });\n\n    if (knownLastUpdated === lastUpdated) {\n        return;\n    }\n\n    await notificationHandler.addMessage({\n        scope: 'system',\n        category: 'dockerUpdate',\n        message: `${version} (${lastUpdated})`,\n        instance: `system.host.${hostname}`,\n    });\n}\n\n/**\n * Check for updatable OS packages and register them as notification\n */\nasync function listUpdatableOsPackages(): Promise<void> {\n    if (tools.isDocker() || !states) {\n        return;\n    }\n\n    const packManager = new PacketManager();\n    await packManager.ready();\n\n    const packages = await packManager.listUpgradeablePackages();\n\n    const packageStateId = `${hostObjectPrefix}.osPackageUpdates`;\n    const packagesState = await states.getState(packageStateId);\n\n    await states.setState(packageStateId, { val: JSON.stringify(packages), ack: true });\n\n    if (!packages.length) {\n        await notificationHandler.clearNotifications('system', 'packageUpdates', `system.host.${hostname}`);\n        return;\n    }\n\n    const knownPackages: string[] = typeof packagesState?.val === 'string' ? JSON.parse(packagesState.val) : [];\n    const hasNewPackage = packages.some(pack => !knownPackages.includes(pack));\n\n    if (!hasNewPackage) {\n        return;\n    }\n\n    await notificationHandler.addMessage({\n        scope: 'system',\n        category: 'packageUpdates',\n        message: packages.join('\\n'),\n        instance: `system.host.${hostname}`,\n    });\n}\n\n/**\n * Upgrade given operating system packages\n *\n * @param packages package names and version information\n */\nasync function upgradeOsPackages(packages: UpgradePacket[]): Promise<void> {\n    const packManager = new PacketManager();\n    await packManager.ready();\n\n    await packManager.upgrade(packages);\n}\n\n/**\n * Start a detached process of the upgrade manager\n * Handles Docker installation accordingly\n *\n * @param options Arguments passed to the UpgradeManager process\n */\nasync function startUpgradeManager(options: UpgradeArguments): Promise<void> {\n    const { version, adminInstance, uid, gid } = options;\n    const upgradeProcessPath = require.resolve('./lib/upgradeManager');\n    let upgradeProcess: cp.ChildProcess;\n\n    const isSystemd = await tools.isIoBrokerInstalledAsSystemd();\n\n    if (isSystemd) {\n        upgradeProcess = spawn(\n            'sudo',\n            [\n                'systemd-run',\n                '--no-ask-password',\n                process.execPath,\n                upgradeProcessPath,\n                version,\n                adminInstance.toString(),\n                uid.toString(),\n                gid.toString(),\n            ],\n            {\n                detached: true,\n                stdio: 'ignore',\n            },\n        );\n    } else {\n        upgradeProcess = spawn(process.execPath, [upgradeProcessPath, version, adminInstance.toString()], {\n            detached: true,\n            stdio: 'ignore',\n        });\n    }\n\n    upgradeProcess.unref();\n}\n\n/**\n * Checks if a system reboot is required and generates a notification if this is the case\n */\nasync function checkRebootRequired(): Promise<void> {\n    if (process.platform !== 'linux' || isRebootRequired) {\n        return;\n    }\n\n    /** This file exists on most linux systems if a reboot is required */\n    const rebootRequiredPath = '/var/run/reboot-required';\n    /** This file contains a list of packages which require the reboot, separated by newline */\n    const packagesListPath = '/var/run/reboot-required.pkgs';\n\n    isRebootRequired = await fs.pathExists(rebootRequiredPath);\n\n    if (!isRebootRequired) {\n        return;\n    }\n\n    let message = 'At least one package update requires a system reboot';\n\n    try {\n        const content = await fs.readFile(packagesListPath, { encoding: 'utf-8' });\n        message = `The following package updates require a restart of the system: ${content.split('\\n').join(', ')}`;\n    } catch (e) {\n        if (e.code !== 'ENOENT') {\n            logger.error(`${hostLogPrefix} Could not read file \"${packagesListPath}\": ${e.message}`);\n        }\n    }\n\n    await notificationHandler.addMessage({\n        scope: 'system',\n        category: 'systemRebootRequired',\n        message,\n        instance: `system.host.${hostname}`,\n    });\n}\n\n/**\n * Upgrade all upgradeable adapters with respect to their auto upgrade policy\n */\nasync function autoUpgradeAdapters(): Promise<void> {\n    try {\n        if (!(await autoUpgradeManager.isAutoUpgradeEnabled())) {\n            logger.debug(`${hostLogPrefix} Automatic adapter upgrades are disabled for the current repository`);\n            return;\n        }\n\n        const { upgradedAdapters, failedAdapters } = await autoUpgradeManager.upgradeAdapters();\n\n        if (upgradedAdapters.length) {\n            await notificationHandler.addMessage({\n                scope: 'system',\n                category: 'automaticAdapterUpgradeSuccessful',\n                message: upgradedAdapters\n                    .map(entry => `${entry.name}: ${entry.oldVersion} -> ${entry.newVersion}`)\n                    .join('\\n'),\n                instance: `system.host.${hostname}`,\n            });\n        }\n\n        if (failedAdapters.length) {\n            await notificationHandler.addMessage({\n                scope: 'system',\n                category: 'automaticAdapterUpgradeFailed',\n                message: failedAdapters\n                    .map(entry => `${entry.name}: ${entry.oldVersion} -> ${entry.newVersion}`)\n                    .join('\\n'),\n                instance: `system.host.${hostname}`,\n            });\n        }\n    } catch (e) {\n        logger.error(`${hostLogPrefix} An error occurred while processing automatic adapter upgrades: ${e.message}`);\n    }\n}\n\n/**\n * Disables all blocklisted instances which are currently enabled and generates notifications\n */\nasync function disableBlocklistedInstances(): Promise<void> {\n    let newlyDisabledInstances: ioBroker.InstanceObject[];\n\n    try {\n        newlyDisabledInstances = await blocklistManager.disableAllBlocklistedInstances();\n    } catch (e) {\n        logger.error(`${hostLogPrefix} Could not check if blocklisted adapters need to be disabled: ${e.message}`);\n        return;\n    }\n\n    for (const disabledInstance of newlyDisabledInstances) {\n        const message = `Instance \"${disabledInstance._id}\" has been stopped and disabled because the version \"${disabledInstance.common.version}\" has been blocked by the developer`;\n        logger.error(`${hostLogPrefix} ${message}`);\n\n        await notificationHandler.addMessage({\n            scope: 'system',\n            category: 'blockedVersions',\n            message,\n            instance: SYSTEM_HOST_PREFIX + hostname,\n        });\n    }\n}\n\n// eslint-disable-next-line unicorn/prefer-module\nconst modulePath = url.fileURLToPath(import.meta.url || `file://${__filename}`);\nif (process.argv[1] === modulePath) {\n    init();\n}\n", "export const __import_meta_url =\n  typeof document === 'undefined' ? new (require('url'.replace('', '')).URL)('file:' + __filename).href :\n    (document.currentScript && document.currentScript.src || new URL('main.js', document.baseURI).href)\n"],
  "mappings": "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",
  "names": ["require", "fs", "path", "os", "toolsLogger", "restartTimeout", "_id", "obj", "proc", "pidUsage", "semver", "err", "e", "logger", "deepClone", "lines", "config", "parts", "version", "wait", "restart", "id", "task", "cp", "stopTimeout", "decache", "module", "compactGroup", "execArgv", "compactProc", "cronParser", "schedule"]
}
