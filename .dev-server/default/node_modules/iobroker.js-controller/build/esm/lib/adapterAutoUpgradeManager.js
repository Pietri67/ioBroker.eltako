import { Upgrade } from '@iobroker/js-controller-cli';
import semver from 'semver';
export class AdapterAutoUpgradeManager {
    objects;
    states;
    /** Mapping from semver range to range identifier */
    SEMVER_RANGE_MAPPING = {
        none: '',
        patch: '~',
        minor: '^',
        major: '>',
    };
    /** Prefix for log messages */
    logPrefix;
    /** Logger which needs to be prefixed */
    logger;
    constructor(options) {
        this.objects = options.objects;
        this.states = options.states;
        this.logger = options.logger;
        this.logPrefix = options.logPrefix;
    }
    /**
     * Checks if auto upgrade is enabled for the current configured repository
     */
    async isAutoUpgradeEnabled() {
        let sysConf;
        try {
            sysConf = await this.objects.getObjectAsync('system.config');
        }
        catch {
            // ignore
        }
        if (!sysConf?.common.activeRepo?.length || !sysConf.common.adapterAutoUpgrade) {
            return false;
        }
        const activeRepo = sysConf.common.activeRepo[0];
        return sysConf.common.adapterAutoUpgrade.repositories[activeRepo];
    }
    /**
     * Checks the current `system.repositories` object and checks if one needs to be performed according to the adapter configuration
     */
    async upgradeAdapters() {
        this.logger.info(`${this.logPrefix} Check for available automatic adapter upgrades`);
        const upgradedAdapters = [];
        const failedAdapters = [];
        const repoName = await this.getConfiguredRepositoryName();
        const repoInformation = await this.getRepository(repoName);
        const installedAdaptersConfig = await this.getAutoUpdateConfiguration();
        for (const adapterConfig of installedAdaptersConfig) {
            const repoAdapterInfo = repoInformation[adapterConfig.name];
            if (!repoAdapterInfo) {
                continue;
            }
            if (semver.gte(adapterConfig.version, repoAdapterInfo.version)) {
                continue;
            }
            if (semver.satisfies(repoAdapterInfo.version, `${this.SEMVER_RANGE_MAPPING[adapterConfig.upgradePolicy]}${adapterConfig.version}`, { includePrerelease: true })) {
                try {
                    await this.upgradeAdapter({ ...repoAdapterInfo, repoName });
                    upgradedAdapters.push({
                        name: repoAdapterInfo.name,
                        newVersion: repoAdapterInfo.version,
                        oldVersion: adapterConfig.version,
                    });
                    this.logger.info(`${this.logPrefix} Successfully upgraded adapter "${repoAdapterInfo.name}" to ${repoAdapterInfo.version}`);
                }
                catch (e) {
                    this.logger.error(`${this.logPrefix} Could not upgrade adapter "${repoAdapterInfo.name}" to ${repoAdapterInfo.version}: ${e.message}`);
                    failedAdapters.push({
                        name: repoAdapterInfo.name,
                        newVersion: repoAdapterInfo.version,
                        oldVersion: adapterConfig.version,
                    });
                }
            }
        }
        return { upgradedAdapters, failedAdapters };
    }
    /**
     * Upgrade specified adapter to given version
     *
     * @param options information of the adapter to install, e.g. version and name, sa well as active repo
     */
    async upgradeAdapter(options) {
        const { repoName, name, version } = options;
        this.logger.info(`${this.logPrefix} Upgrade adapter "${name}" to ${version}`);
        const upgrade = new Upgrade({
            objects: this.objects,
            states: this.states,
            params: {},
            processExit: () => undefined,
        });
        await upgrade.upgradeAdapter(repoName, `${name}@${version}`, false, true, false);
    }
    /**
     * Get the current active repository name
     */
    async getConfiguredRepositoryName() {
        const obj = await this.objects.getObjectAsync('system.config');
        if (!obj?.common?.activeRepo?.length) {
            throw new Error('Could not find an active repository');
        }
        return obj.common.activeRepo[0];
    }
    /**
     * Get the repository information for the given repository
     *
     * @param name Name of the repository
     */
    async getRepository(name) {
        const obj = await this.objects.getObjectAsync('system.repositories');
        const jsonContent = obj?.native?.repositories?.[name]?.json;
        if (!jsonContent) {
            throw new Error(`Could not get repository information for "${name}"`);
        }
        delete jsonContent._repoInfo;
        return jsonContent;
    }
    /**
     * Get the auto upgrade configuration of all adapters
     */
    async getAutoUpdateConfiguration() {
        const res = await this.objects.getObjectViewAsync('system', 'adapter', {
            startkey: 'system.adapter.',
            endkey: 'system.adapter.\u9999',
        });
        if (!res) {
            throw new Error('Did not get information about installed adapters');
        }
        const defaultPolicy = await this.getDefaultUpgradePolicy();
        return res.rows
            .filter(row => (defaultPolicy && defaultPolicy !== 'none') ||
            (row.value?.common.automaticUpgrade && row.value.common.automaticUpgrade !== 'none'))
            .map(row => {
            return {
                // ts can not infer, that we filtered out falsy row.value entries
                name: row.value.common.name,
                version: row.value.common.version,
                upgradePolicy: row.value.common.automaticUpgrade || defaultPolicy,
            };
        });
    }
    /**
     * Get the default upgrade policy from the system config
     */
    async getDefaultUpgradePolicy() {
        let sysConf;
        try {
            sysConf = await this.objects.getObjectAsync('system.config');
        }
        catch {
            // ignore
        }
        return sysConf?.common.adapterAutoUpgrade?.defaultPolicy;
    }
}
//# sourceMappingURL=adapterAutoUpgradeManager.js.map